# Custom scalars, also need to modify ./apollo/schema.ts @see https://www.graphql-scalars.dev/docs/quick-start
scalar BigInt
scalar DateTime
scalar JSON

type Query {
  # search by id or name, if not found return null
  author(id: ID, name: String): Author

  bullet(id: ID!): Bullet

  # search by id, symbol, or url, if id or symbol not found return nulll, if url not found will try to fetch and create a new note
  # notes(branchId: ID, symbol: String, url: String): Note

  # notesByAuthor(authorId: ID!): [Note!]!

  # need to modify the input (confirm the prisma)
  noteEmojis(noteId: ID!): [NoteEmoji!]!

  # latest note digests (what does this mean??)
  # noteDigests(afterCommitId: String): [NoteDigest!]!

  discuss(id: ID!): Discuss

  discussEmojis(discussId: ID!): [DiscussEmoji!]!

  discussPosts(discussId: ID!): [DiscussPost!]!

  discussPostEmojis(discussPostId: ID!): [DiscussPostEmoji!]!

  link(id: ID, url: String): Link

  me: User!

  myNoteEmojiLike(noteEmojiId: ID!): NoteEmojiLike

  myDiscussEmojiLike(discussEmojiId: ID!): DiscussEmojiLike

  myDiscussPostEmojiLike(discussPostEmojiId: ID!): DiscussPostEmojiLike

  myRates(symId: ID!): [Rate!]!

  # allow vote multiple times on the same poll
  myVotes(pollId: ID!): [Vote!]!

  poll(id: ID!): Poll

  searchAuthor(term: String!): [SearchHit!]!

  # fuzzy search discuss title by given term
  searchDiscuss(term: String!): [SearchHit!]!

  # fuzzy search symbol name, if 'type' not given, search both ticker & topic
  searchSymbol(term: String!, type: SymType): [SearchHit!]!

  rate(id: ID!): Rate

  # rates(authorId: ID!): [Rate!]!

  ratesByAuthor(authorId: ID!, symId: ID!): [Rate!]!

  ratesBySource(linkId: ID!): [Rate!]!

  #-----New-----
  # throws error if not found
  note(id: ID!): Note!

  # get noteDoc and throws error if not found
  noteDoc(id: ID!): NoteDoc!

  # get all notes for homepage
  noteDocsJustMerged: [NoteDoc!]!

  # get all candidate docs for verdict
  noteDocsToMerge: [NoteDoc!]!

  # get user's draft
  noteDraft(id: ID, symbol: String, url: String): NoteDraft

  # get all docs from note pull request records including candidates (like Github pr history)
  noteHistory(noteId: ID!, status: NoteDocStatus): [NoteDocEntry!]!

  # myNoteDocs(): [NoteDoc!]!

  # to know all latest commit docs
  myCommits: [Commit!]!

  # get user's all drafts for draft-sidebar
  # provide id and some necessary info for sidebar to display, avoid offering unnecessary info in one go
  myNoteDraftEntries: [NoteDraftEntry!]!

  # search note by sym or title
  searchNote(symbol: String, title: String): [Note!]!

  searchByDomain(domain: String!): [Note!]!

  searchByAuthor(name: String!): [Note!]!

  # -------------End--------------

  # 以 note symbol 找該 note 所有的 active hashtags
  # hashtags(symbol: String!): [Hashtag!]

  # myVotes(after: String): [Vote!]!
  # myCommentLikes(after: String): [CommentLike!]!
  # myBoardLikes(after: String): [BoardLike!]!
  # myBulletLikes(after: String): [BulletLike!]!
  # board(id: ID!): Board!
  # comments(boardId: ID!, afterId: ID): [Comment!]!

  # 以下note目前暫不考慮
  # selfnote(id: ID!): Selfnote
  # mynote(symbolName: String!): Selfnote

  # 專用於顯示
  # topComments(blockId: ID!, afterId: ID): [CommentWithReplies!]!

  # 所有的comments（含spot），幫助cache，僅含spotReplies
  # comments(noteId: ID!, afterId: ID): [Comment!]!

  # 用於filter comments的情形（例如：/q, /stage, ...)
  # commentsBySymbol(pageTitle: String!, symbol: String!, afterId: ID): [Comment!]!

  # 自動標註可能的topic, tickers
  # automark(text: String!): String!

  # ticks(symbolId: ID!, after: String): [Tick!]!

  # trendTopics: [String!]!
  # newTopics: [String!]!
  # newTickers: [String!]!

  # botPolls(symbolName: String): [Poll!]!
  # latestPolls(symbolId: ID, afterId: String): [Poll!]!
  # pollHints(symbols: [String], title: String): [Poll!]!
  # poll(id: ID!): Poll!

  # myPollLikes(afterId: ID): [PollLike!]!

  # latestPosts(symbolId: ID, afterId: String): [Post!]!
  # repliedPosts(parentId: ID!, afterId: String): [Post!]!
  # risingPosts(afterId: String): [Post!]!
  # trendPosts(afterId: String): [Post!]!

  # symbol(name: String!): Symbol!

  # post(id: ID!): Post!
  # event(id: ID!): Event!
  # ticker(id: ID, name: String): Ticker!

  # myPostLikes(after: String): [PostLike!]!
  # myCommentLikes(after: String): [CommentLike!]!

  # myComments(after: String): [ID!]!
  # myPosts(afterId: String): [Post!]!
  # myFollows: [Follow!]!
  # myCommits(after: String): [ID!]!
  # myCommitReviews(after: String): [CommitReview!]!
  # myWaitedCommitReviews: [CommitReview!]!

  # tagHints(term: String): [String!]!
  # tickerHints(term: String): [String!]!
  # eventHints(term: String): [String!]!

  # fetchPage(url: String!): Page!

  # myBets: [Bet!]!
  # myNotices: [Notice!]!
  # mySignals: [Signal]
  # groups: [Group]
  # myGroups: [Group]
  # groupPosts(groupId: ID): [Post]
}

type Mutation {
  createAuthor(data: AuthorInput!): Author!

  updateAuthor(id: ID!, data: AuthorInput!): Author!

  # optional noteId for connecting discuss with note
  createDiscuss(noteId: ID, data: DiscussInput!): Discuss!

  updateDiscuss(id: ID!, data: DiscussInput!): Discuss!

  # connectDiscussToNote(
  #   discussId: ID!
  #   noteId: ID!
  #   disconnect: Boolean
  # ): Boolean!

  # Either emoji-id or (discuss-id, code) is required
  upsertDiscussEmojiLike(
    liked: Boolean!
    emojiId: Int
    emojiCode: EmojiCode
    discussId: String
  ): [UpsertDiscussEmojiLikeResult!]!

  createDiscussPost(discussId: ID!, data: DiscussPostInput!): DiscussPost!

  updateDiscussPost(id: ID!, data: DiscussPostInput!): DiscussPost!

  upsertDiscussPostEmojiLike(
    liked: Boolean!
    emojiId: Int
    emojiCode: EmojiCode
    discussPostId: Int
  ): [UpsertDiscussPostEmojiLikeResult!]!

  upsertNoteEmojiLike(
    liked: Boolean!
    emojiId: Int
    emojiCode: EmojiCode
    noteId: String
  ): [UpsertNoteEmojiLikeResult!]!

  # if newSymbol is given, will also update note symbol
  # @throw validation error
  # updateNoteMeta(noteId: ID!, data: NoteMetaInput!, newSymbol: String): Note!

  createPoll(data: PollInput!): Poll!

  createRate(data: RateInput!): Rate!

  updateRate(id: ID!, data: RateInput!): Rate!

  # also used for merge verdict
  createVote(pollId: ID!, data: VoteInput!): Vote!

  # csrf token not support yet
  sessionLogin(idToken: String!, csrfToken: String): User!

  sessionLogout: Boolean!

  #-------- New -------------
  # not sure about the type of meta, which is for creating from existing note
  createNoteDraft(symbol: String!, draftInput: NoteDraftInput!): NoteDraft!

  createNoteDraftByLink(
    linkId: String!
    draftInput: NoteDraftInput!
  ): NoteDraft!

  # input not yet decided
  updateNoteDraft(id: ID!, data: NoteDraftInput!): NoteDraft!

  dropNoteDraft(id: ID!): NoteDraftDropResponse!

  # commit must be created first -> createCommit ->
  commitNoteDrafts(draftIds: [ID!]!): NoteDraftCommitResponse!
  #---------------End------------------

  # createComment(boardId: ID!, pollId: ID, data: CommentInput!): Comment!
  # createAuthorComment(boardId: ID!, pollId: ID, oauthorName: String!, data: CommentInput!): Comment!

  # createOauthorComment(boardId: ID!, data: CommentInput!)
  # updateComment(id: ID!, data: CommentInput!): Comment!

  # createBulletLike(bulletId: ID!, data: LikeInput!): BulletLikeResponse!
  # updateBulletLike(id: ID!, data: LikeInput!): BulletLikeResponse!

  # createCommentLike(commentId: ID!, data: LikeInput!): CommentLikeResponse!
  # updateCommentLike(id: ID!, data: LikeInput!): CommentLikeResponse!

  # createBoardLike(boardId: ID!, data: LikeInput!): BoardLikeResponse!
  # updateBoardLike(id: ID!, data: LikeInput!): BoardLikeResponse!

  # --- NEXT ---

  # createPoll(data: PollInput!): Poll!
  # createPollLike(pollId: ID!, data: LikeInput!): PollLikeResonse!
  # updatePollLike(id: ID!, data: LikeInput!): PollLikeResonse!

  # createVotePost(pollId: ID!, choiceId: ID!, data: PostInput!): Post!
  # createPost(data: PostInput!, pollId: ID): Post!
  # updatePost(id: ID!, data: PostInput!): Post!
  # createPostLike(postId: ID!, data: LikeInput!): PostLikeResonse!
  # updatePostLike(id: ID!, data: LikeInput!): PostLikeResonse!

  # 允許更新postVote？
  # updatePollVote(pollId: ID!, data: VoteInput!): PollVote!

  # createCommit(data: CommitInput!): Commit!
  # updateCommit(id: ID!, data: CommitInput!): Commit!
  # applyCommitReview(commitId: ID!): ApplyCommitReviewResult!
  # applyCommitReview(commitId: ID!): CommitReview!
  # updateCommitReview(id: ID!, data: CommitReviewInput!): CommitReview!

  # createFollow(symbolId: ID!, data: FollowInput!): Follow!
  # updateFollow(symbolId: ID!, data: FollowInput!): Follow!

  ### upcoming ###

  # uploadImg(): Img
  # createBet(): Bet
  # upsertBet(data: BetInput): Bet
  # createGroup(data: GroupInput): Group
  # updateGroup(data: GroupInput): Group
  # joinGroup(id: ID): Boolean
  # leaveGroup(id: ID): Boolean
  # inviteJoin(groupId: ID, criteria: String): Boolean
}

# type AuthPayload {
#   token: String!
#   user: User!
# }

type Author {
  id: ID!
  name: String!
  meta: AuthorMeta!
}

type AuthorMeta {
  type: AuthorType!
  job: String
  org: String
  sites: [AuthorMetaSite!]!
}

type AuthorMetaSite {
  name: String!
  url: String!
}

type Bullet {
  id: ID!
  # noteId: String!
  # createdAt: DateTime!
  # updatedAt: DateTime!
}

# type BulletNodeChange {
#   type: String!
#   cid: String!
#   toParentCid: String!
#   toIndex: Int
#   data: Bullet
# }

# type BulletTreeNode {
#   cid: String!
#   parentCid: String
#   index: Int
#   data: Bullet
#   # change?: 'move' // record change-event lively
#   children: BulletTreeNode
# }

type Discuss {
  id: ID!
  userId: String!
  status: DiscussStatus!
  meta: JSON! # TODO: define the content of meta
  title: String!
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
  count: DiscussCount!
}

type DiscussCount {
  id: ID!
  nPosts: Int!
}

type DiscussEmoji {
  id: ID!
  code: EmojiCode!
  count: DiscussEmojiCount!
}

type DiscussEmojiCount {
  id: ID!
  nUps: Int!
}

type DiscussEmojiLike {
  id: ID!
  discussEmojiId: Int!
  liked: Boolean!
  updatedAt: DateTime!
}

type DiscussPost {
  id: String!
  userId: String!
  status: DiscussPostStatus!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DiscussPostEmoji {
  id: ID!
  code: EmojiCode!
  count: DiscussPostEmojiCount!
}

type DiscussPostEmojiCount {
  id: ID!
  nUps: Int!
}

type DiscussPostEmojiLike {
  id: ID!
  discussPostEmojiId: Int!
  liked: Boolean!
  updatedAt: DateTime!
}

type NoteEmoji {
  id: ID!
  code: EmojiCode!
  count: NoteEmojiCount!
}

type NoteEmojiCount {
  id: ID!
  nUps: Int!
  nDowns: Int!
}

type NoteEmojiLike {
  id: ID!
  noteEmojiId: Int!
  liked: Boolean!
  updatedAt: DateTime!
}

# type NoteDigest {
#   commitId: String!
#   noteId: String!
#   noteMeta: NoteMeta! # includes title
#   fromNoteId: String
#   branchName: String!
#   sym: Sym!
#   subSyms: [Sym!]!
#   # title: String!
#   picks: [String!]!
#   # rates: [String!]!
#   updatedAt: DateTime!
# }

# -----------Remove-----------

# type NoteMeta {
#   author: String
#   # // description?: string
#   duplicates: [String!]
#   keywords: [String!]
#   # // lang?: string
#   publishedAt: String
#   redirect: String
#   # // template?: 'webpage' | 'ticker' | 'topic' | 'vs'
#   tickers: [String!]
#   title: String
#   url: String
# }

# type NoteState {
#   id: ID!
#   noteId: String!
#   userId: String!
#   commitId: String!
#   prevId: String
#   # body: NoteStateBody!
#   updatedAt: DateTime!
# }

# type DictEntryArray {
#   k: String!
#   v: String!
# }

# ------------End Remove------------

type Link {
  id: ID!
  url: String!
  authorId: String
  # scraped: Scraped!
}

type Scraped {
  authorName: String
  date: String
  description: String
  title: String
  keywords: [String!]
  tickers: [String!]
}

type Rate {
  id: ID!
  userId: String!
  authorId: String
  linkId: String
  symId: String!
  choice: RateChoice!
  # body: ShotBody
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RateBody {
  comment: String
  quote: String
}

type Sym {
  id: ID!
  type: SymType!
  symbol: String! # this is mutable
}

type Poll {
  id: ID!
  userId: String!
  # meta: PollMeta!
  # type: PollType!
  # status: PollStatus!
  choices: [String!]!
  # nVotes: [Int!]!
  count: PollCount!
  # title: String!
  # text: String
  # start: DateTime!
  # end: DateTime!
  # nDays: Int!
  # minVotes: Int!
  # nDaysJudge: Int!
  # minJudgments: Int!
  # count: PollCount!
  # posts: [Post!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PollCount {
  id: ID!
  nVotes: [Int!]!
  # nJudgements: [Int]
  # judgeStartedAt: DateTime
  # judgeEndedAt: DateTime
  # verdictValid: Boolean
  # verdictChoice: Int
  # updatedAt: DateTime!
  # failedMsg: String
}

type SearchHit {
  id: String!
  str: String!
}

type User {
  id: ID!
  email: String!
  # profileImage: String
  # trips: [Launch]!
}

type Vote {
  id: ID!
  pollId: String!
  choiceIdx: Int!
  # reward: Float
  # createdAt: DateTime!
  # updatedAt: DateTime!
}

type UpsertDiscussEmojiLikeResult {
  emoji: DiscussEmoji!
  like: DiscussEmojiLike!
}

type UpsertDiscussPostEmojiLikeResult {
  emoji: DiscussPostEmoji!
  like: DiscussPostEmojiLike!
}

type UpsertNoteEmojiLikeResult {
  emoji: NoteEmoji!
  like: NoteEmojiLike!
}

#-------New-------

type Note {
  id: ID!
  sym: Sym!
  link: Link
  meta: NoteDocMeta!
  doc: NoteDoc! # the latest merged NoteDoc, throw error if there is none (it's impossible to be null because first NoteDoc will auto-merge to the newly-built Note)
  updatedAt: DateTime!
}

type NoteDoc {
  id: ID!
  # noteId: String!
  commitId: String!
  fromDocId: String
  userId: String!
  status: NoteDocStatus!
  domain: String!
  meta: NoteDocMeta # not sure about this type
  content: NoteDocContent!
  updatedAt: DateTime!
}

type NoteDraft {
  id: ID!
  # noteId: String  # not using for creating a draft and not this field in db
  userId: String!
  commitId: String
  fromDocId: String
  domain: String
  symbol: String
  meta: NoteDocMeta # not sure about this type
  content: NoteDocContent!
  updatedAt: DateTime!
  status: NoteDraftStatus!
}

type NoteDraftEntry {
  id: ID!
}

# # similar design as NoteDocBody
# type DraftBody {
#   body: JSON!
# }

type NoteDraftDropResponse {
  response: String!
}

type NoteDraftCommitResponse {
  commitId: String!
  response: String!
}

# ----------------Modified---------------
# TODO: confirm using the structure specified in block-editor/src/interfaces.ts or not
type Block {
  uid: ID!
  str: String!
  parentUid: String
  docTitle: String
}

type BlockUid_DiscussId {
  blockUid: String!
  discussId: String!
  commitId: String
}

type NoteDocContent {
  discussIds: [BlockUid_DiscussId]!
  diff: JSON
  symbolIdDict: JSON
  blocks: [Block!]!
  # a symbol-noteId map, so later the cahnge of symbol name won't affect
}

type NoteDocMeta {
  duplicatedSymbols: [String] # store Sym.symbols refering to the same note (e.g $BA, [[Boeing]] both to Boeing)
  # blockUidAnddiscussIdsDict: [String] # store discussion ids
  keywords: [String] # note keywords
  redirectFroms: [String] # used when duplicate symbol exists
  redirectTo: String
  webpage: NoteDocMetaWebpage
}

type NoteDocMetaWebpage {
  authors: [String]
  title: String
  publishedAt: DateTime # when the webpage content publish at
  tickers: [String] # tickers mentioned in the webpage content
}

type NoteDocEntry {
  id: ID!
}

type Commit {
  id: String!
  userId: String!
  drafts: [NoteDraft!]!
  docs: [NoteDoc!]!
  updatedAt: DateTime!
}

# ------------------End-------------------

# type Branch {
#   id: ID!
#   name: String!
#   syms: [Sym]!
#   drafts: [NoteDraft]!
#   notes: [Note!]!
# }

# type PollMeta {
#   code: String
#   text: String
# }

# type CommentLike {
#   id: ID!
#   commentId: Int!
#   choice: LikeChoice!
#   createdAt: DateTime!
#   updatedAt: DateTime!
# }

# type CommentCount {
#   id: ID!
#   nViews: Int!
#   nUps: Int!
#   nDowns: Int!
# }

# type CommentLikeResponse {
#   like: CommentLike!
#   count: CommentCount!
# }

# type Comment {
#   id: ID!
#   userId: String!
#   oauthorName: String
#   status: CommentStatus!
#   content: String!

#   # 若是投票的會一起記錄
#   vote: Vote

#   count: CommentCount!
#   createdAt: DateTime!
#   updatedAt: DateTime!
# }

# type BoardLike {
#   id: ID!
#   boardId: Int!
#   choice: LikeChoice!
#   createdAt: DateTime!
#   updatedAt: DateTime!
# }

# type BoardCount {
#   id: ID!
#   nViews: Int!
#   nUps: Int!
#   nDowns: Int!
#   # nComments: Int!
# }

# type BoardLikeResponse {
#   like: BoardLike!
#   count: BoardCount!
# }

# type Board {
#  id: ID!
#  userId: String!
#  bulletId: Int
#  noteId: Int
#  status: BoardStatus!
#  hashtag: String!
#  meta: String! # json
#  content: String! # json
#  poll: Poll
#  count: BoardCount!
#  createdAt: DateTime!
#  updatedAt: DateTime!
# }

# ------ Inputs ------

input AuthorInput {
  name: String!
  type: AuthorType!
  job: String
  org: String
  sites: [AuthorMetaSiteInput!]!
}

input AuthorMetaSiteInput {
  name: String!
  url: String!
}

# ---------------Remove------------
# input NoteInput {
#   symbol: String!
#   # templateProps: NoteTemplatePropsInput
#   meta: NoteMetaInput
# }

# input NoteMetaInput {
#   author: String
#   # // description?: string
#   duplicates: [String!]
#   keywords: [String!]
#   # // lang?: string
#   publishedAt: String
#   redirect: String
#   # // template?: 'webpage' | 'ticker' | 'topic' | 'vs'
#   tickers: [String!]
#   title: String
#   # url: String
# }

# input NoteStateInput {
#   cid: String!
#   fromDocCid: String # for doc-index tree
#   noteInput: NoteInput # for creating note or update note-meta
#   noteId: String
#   prevStateId: String
#   changes: JSON!
#   value: JSON! # for comparing changes
# }
# -------------End Remove--------------

input DiscussInput {
  meta: JSON
  title: String!
  content: String
}

input DiscussPostInput {
  content: String!
}

input LikeInput {
  choice: LikeChoice!
}

input PollInput {
  # cat: PollCat!
  choices: [String!]!
}

input RateInput {
  choice: RateChoice!
  targetId: ID! # target note id
  authorId: ID # create author rate required
  linkId: ID # create author rate required
}

input VoteInput {
  choiceIdx: Int!
}

#------New-------
# id: ID!
#   noteId: String
#   userId: String!
#   commitId: String
#   fromDocId: String
#   meta: NoteDocMeta # not sure about this type
#   body: NoteDocContent!
#   updatedAt: DateTime!
#   status: DraftStatus!
input NoteDraftInput {
  # noteId: String   # not using for creating a draft and not this field in db
  fromDocId: String
  domain: String!
  meta: NoteDocMetaInput!
  content: NoteDocContentInput!
}

# similar to NoteDocMeta
input NoteDocMetaInput {
  duplicatedSymbols: [String]! # to store Sym.symbols refering to the same note (e.g $BA, [[Boeing]] both to Boeing)
  keywords: [String]! # note keywords
  redirectFroms: [String]! # used when duplicate symbol exists
  redirectTo: String
  # webpage: NoteDocMetaWebpageInput
}

# data extracted from the webpage
# input NoteDocMetaWebpageInput {
#   authors: [String]!
#   title: String
#   publishedAt: DateTime # when the webpage content publish at
#   tickers: [String]! # tickers mentioned in the webpage content
# }

input BlockUid_DiscussIdInput {
  blockUid: String!
  discussId: String!
  commitId: String
}

input NoteDocContentInput {
  discussIds: [BlockUid_DiscussIdInput]!
  diff: JSON
  symbolIdMap: JSON
  blocks: [BlockInput!]!
}

input BlockInput {
  uid: ID!
  str: String!
  parentUid: String
  docTitle: String
}

# -----------Modified--------------
input CommitInput {
  noteDraftInputs: [NoteDraftInput!]!
}
#---------------End-----------------

# input CommentInput {
#   content: String!
#   vote: VoteInput
# }

# input BoardInput {
#   hashtag: String!
#   meta: String!
#   content: String!
# }

# ------ NEXT ------

# type Tick {
#   id: ID!
#   symbolId: Int!
#   value: Float!
#   at: DateTime!
# }

# type PollJudgment {
#   id: ID!
#   pollId: Int!
#   choice: Int!
#   comment: Comment!
#   createdAt: DateTime!
#   updatedAt: DateTime!
# }

# input PollJudgmentInput {
#   choice: Int!
# }

# type Page {
#   id: ID!
#   # null if not existed
#   createdPostId: ID
#   # symbols: [String!]
#   suggestTitle: String
#   suggestTags: [String!]!
#   suggestEvents: [String!]!
#   suggestTickers: [String!]!
#   # null if not created
#   createdEvent: Symbol
# }

# type EventContent {
#   tags: [String!]!
#   tickers: [String!]!
#   events: [String!]!
#   equalEvents: [String!]!
# }

# type PostLink {
#   url: String!
# }

# type Follow {
#   id: ID!
#   # symbol: Symbol!
#   symbolId: Int!
#   followed: Boolean!
#   # createdAt: DateTime!
#   updatedAt: DateTime!
# }

# input FollowInput {
#   symbolId: ID!
#   followed: Boolean!
# }

enum AuthorType {
  ORG
  PERSON
}

enum NoteStatus {
  ACTIVE
  ARCHIVE
  REDIRECT
  REPORTED
  DUPLICATED
}

enum DiscussStatus {
  DRAFT
  ACTIVE
  LOCK
  DELETE
  ARCHIVE
  REPORTED
}

enum DiscussPostStatus {
  ACTIVE
  LOCK
  DELETE
  ARCHIVE
  REPORTED
}

enum EmojiCode {
  UP
  DOWN
  PIN
  REPORT
}

enum LikeChoice {
  UP
  # DOWN
  NEUTRAL
}

enum PollType {
  FIXED
  ADD
  ADD_BY_POST
}

enum PollStatus {
  OPEN
  JUDGE
  CLOSE_SUCCESS
  CLOSE_FAIL
}

enum PollFailReason {
  MIN_VOTES
  MIN_JUDGMENTS
  MAJOR_VERDICT
  VERDICT_AS_FAIL
  OTHER
}

enum RateChoice {
  LONG
  SHORT
  HOLD
}

enum SourceType {
  VIDEO
  POST
  AUTHOR
  OTHER
}

enum SymType {
  TICKER
  TOPIC
  URL
}

# enum BoardStatus {
#   ACTIVE
#   LOCK
#   DELETE
#   ARCHIVE
#   REPORTED
# }

# enum CommentStatus {
#   ACTIVE
#   LOCK
#   DELETE
#   ARCHIVE
#   REPORTED
# }

#-------New-------
enum NoteDraftStatus {
  EDIT
  COMMIT
  DROP
}

enum NoteDocStatus {
  CANDIDATE
  MERGE
  REJECT
}
