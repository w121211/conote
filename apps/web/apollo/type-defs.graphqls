# Custom scalars, also need to modify ./apollo/schema.ts @see https://www.graphql-scalars.dev/docs/quick-start
scalar BigInt
scalar DateTime
scalar JSON

type Query {
  # search by id or name, if not found return null
  # NEXT:
  author(id: ID, name: String): Author

  # notesByAuthor(authorId: ID!): [Note!]!

  discuss(id: ID!): Discuss

  discussEmojis(discussId: ID!): [DiscussEmoji!]!

  discussPosts(discussId: ID!): [DiscussPost!]!

  discussPostEmojis(discussPostId: ID!): [DiscussPostEmoji!]!

  link(id: ID, url: String): Link

  me: User!

  myNoteEmojiLike(noteEmojiId: ID!): NoteEmojiLike

  myDiscussEmojiLike(discussEmojiId: ID!): DiscussEmojiLike

  myDiscussPostEmojiLike(discussPostEmojiId: ID!): DiscussPostEmojiLike

  # NEXT:
  myRates(symId: ID!): [Rate!]!

  # allow vote multiple times on the same poll
  # NEXT: Priority, will be used for merge request
  myVotes(pollId: ID!): [Vote!]!

  # need to modify the input (confirm the prisma)
  noteEmojis(noteId: ID!): [NoteEmoji!]!

  # NEXT: Priority, same as Votes
  poll(id: ID!): Poll

  # NEXT:
  rate(id: ID!): Rate

  # NEXT:
  ratesByAuthor(authorId: ID!, symId: ID!): [Rate!]!

  # NEXT:
  ratesBySource(linkId: ID!): [Rate!]!

  # NEXT:
  searchAuthor(term: String!): [SearchHit!]!

  # fuzzy search discuss title by given term
  searchDiscuss(term: String!): [SearchHit!]!

  # fuzzy search symbol name, if 'type' not given, search both ticker & topic
  searchSymbol(term: String!, type: SymType): [SearchHit!]!

  #-----New-----

  # to know all latest commit docs
  myCommits: [Commit!]!

  # get user's all drafts for draft-sidebar
  # provide id and some necessary info for sidebar to display, avoid offering unnecessary info in one go
  myNoteDraftEntries: [NoteDraftEntry!]!

  # throws error if not found
  noteById(id: ID!): Note!

  noteByBranchSymbol(branch: String!, symbol: String!): Note

  # get noteDoc and throws error if not found
  noteDoc(id: ID!): NoteDoc!

  # get all notes with merged docs for homepage
  noteDocsJustMerged: [NoteDoc!]!

  # get all candidate docs for verdict
  noteDocsToMerge: [NoteDoc!]!

  # get user's draft
  noteDraft(id: ID, symbol: String, url: String): NoteDraft

  # get all docs from note pull request records including candidates (like Github pr history)
  noteHistory(noteId: ID!, status: NoteDocStatus): [NoteDocEntry!]!

  # search note by sym or title, using domain for filtering
  searchNote(symbol: String, title: String, domain: String): [Note!]!

  # -------------End--------------

  # 以 note symbol 找該 note 所有的 active hashtags
  # hashtags(symbol: String!): [Hashtag!]

  # myVotes(after: String): [Vote!]!
  # myCommentLikes(after: String): [CommentLike!]!
  # myBoardLikes(after: String): [BoardLike!]!
  # myBulletLikes(after: String): [BulletLike!]!
  # board(id: ID!): Board!
  # comments(boardId: ID!, afterId: ID): [Comment!]!

  # 以下note目前暫不考慮
  # selfnote(id: ID!): Selfnote
  # mynote(symbolName: String!): Selfnote

  # 專用於顯示
  # topComments(blockId: ID!, afterId: ID): [CommentWithReplies!]!

  # 所有的comments（含spot），幫助cache，僅含spotReplies
  # comments(noteId: ID!, afterId: ID): [Comment!]!

  # 用於filter comments的情形（例如：/q, /stage, ...)
  # commentsBySymbol(pageTitle: String!, symbol: String!, afterId: ID): [Comment!]!

  # 自動標註可能的topic, tickers
  # automark(text: String!): String!

  # ticks(symbolId: ID!, after: String): [Tick!]!

  # trendTopics: [String!]!
  # newTopics: [String!]!
  # newTickers: [String!]!

  # botPolls(symbolName: String): [Poll!]!
  # latestPolls(symbolId: ID, afterId: String): [Poll!]!
  # pollHints(symbols: [String], title: String): [Poll!]!
  # poll(id: ID!): Poll!

  # myPollLikes(afterId: ID): [PollLike!]!

  # latestPosts(symbolId: ID, afterId: String): [Post!]!
  # repliedPosts(parentId: ID!, afterId: String): [Post!]!
  # risingPosts(afterId: String): [Post!]!
  # trendPosts(afterId: String): [Post!]!

  # symbol(name: String!): Symbol!

  # post(id: ID!): Post!
  # event(id: ID!): Event!
  # ticker(id: ID, name: String): Ticker!

  # myPostLikes(after: String): [PostLike!]!
  # myCommentLikes(after: String): [CommentLike!]!

  # myComments(after: String): [ID!]!
  # myPosts(afterId: String): [Post!]!
  # myFollows: [Follow!]!
  # myCommits(after: String): [ID!]!
  # myCommitReviews(after: String): [CommitReview!]!
  # myWaitedCommitReviews: [CommitReview!]!

  # tagHints(term: String): [String!]!
  # tickerHints(term: String): [String!]!
  # eventHints(term: String): [String!]!

  # fetchPage(url: String!): Page!

  # myBets: [Bet!]!
  # myNotices: [Notice!]!
  # mySignals: [Signal]
  # groups: [Group]
  # myGroups: [Group]
  # groupPosts(groupId: ID): [Post]
}

type Mutation {
  # NEXT:
  createAuthor(data: AuthorInput!): Author!
  # NEXT:
  updateAuthor(id: ID!, data: AuthorInput!): Author!

  # optional noteId for connecting discuss with note
  createDiscuss(noteId: ID, data: DiscussInput!): Discuss!

  updateDiscuss(id: ID!, data: DiscussInput!): Discuss!

  # Either emoji-id or (discuss-id, code) is required
  upsertDiscussEmojiLike(
    liked: Boolean!
    emojiId: Int
    emojiCode: EmojiCode
    discussId: String
  ): [UpsertDiscussEmojiLikeResult!]!

  createDiscussPost(discussId: ID!, data: DiscussPostInput!): DiscussPost!

  updateDiscussPost(id: ID!, data: DiscussPostInput!): DiscussPost!

  upsertDiscussPostEmojiLike(
    liked: Boolean!
    emojiId: Int
    emojiCode: EmojiCode
    discussPostId: Int
  ): [UpsertDiscussPostEmojiLikeResult!]!

  upsertNoteEmojiLike(
    liked: Boolean!
    emojiId: Int
    emojiCode: EmojiCode
    noteId: String
  ): [UpsertNoteEmojiLikeResult!]!

  #  NEXT:
  createPoll(data: PollInput!): Poll!
  #  NEXT:
  createRate(data: RateInput!): Rate!
  #  NEXT:
  updateRate(id: ID!, data: RateInput!): Rate!

  # also used for merge verdict
  #  NEXT:
  createVote(pollId: ID!, data: VoteInput!): Vote!

  # csrf token not support yet
  sessionLogin(idToken: String!): User!

  sessionLogout: Boolean!

  #-------- New -------------

  # commit must be created first -> createCommit ->
  commitNoteDrafts(draftIds: [ID!]!): NoteDraftCommitResponse!

  # not sure about the type of meta, which is for creating from existing note
  createNoteDraft(
    branch: String!
    symbol: String!
    draftInput: NoteDraftInput!
  ): NoteDraft!

  createNoteDraftByLink(
    branch: String!
    linkId: String!
    draftInput: NoteDraftInput!
  ): NoteDraft!

  # input not yet decided
  updateNoteDraft(id: ID!, data: NoteDraftInput!): NoteDraft!

  dropNoteDraft(id: ID!): NoteDraftDropResponse!

  #---------------End------------------

  # --- NEXT ---

  # createPoll(data: PollInput!): Poll!
  # createPollLike(pollId: ID!, data: LikeInput!): PollLikeResonse!
  # updatePollLike(id: ID!, data: LikeInput!): PollLikeResonse!

  # createVotePost(pollId: ID!, choiceId: ID!, data: PostInput!): Post!
  # createPost(data: PostInput!, pollId: ID): Post!
  # updatePost(id: ID!, data: PostInput!): Post!
  # createPostLike(postId: ID!, data: LikeInput!): PostLikeResonse!
  # updatePostLike(id: ID!, data: LikeInput!): PostLikeResonse!

  # 允許更新postVote？
  # updatePollVote(pollId: ID!, data: VoteInput!): PollVote!

  # createCommit(data: CommitInput!): Commit!
  # updateCommit(id: ID!, data: CommitInput!): Commit!
  # applyCommitReview(commitId: ID!): ApplyCommitReviewResult!
  # applyCommitReview(commitId: ID!): CommitReview!
  # updateCommitReview(id: ID!, data: CommitReviewInput!): CommitReview!

  # createFollow(symbolId: ID!, data: FollowInput!): Follow!
  # updateFollow(symbolId: ID!, data: FollowInput!): Follow!

  ### upcoming ###

  # uploadImg(): Img
  # createBet(): Bet
  # upsertBet(data: BetInput): Bet
  # createGroup(data: GroupInput): Group
  # updateGroup(data: GroupInput): Group
  # joinGroup(id: ID): Boolean
  # leaveGroup(id: ID): Boolean
  # inviteJoin(groupId: ID, criteria: String): Boolean
}

type Author {
  id: ID!
  name: String!
  meta: AuthorMeta!
}

type AuthorMeta {
  type: AuthorType!
  job: String
  org: String
  sites: [AuthorMetaSite!]!
}

type AuthorMetaSite {
  name: String!
  url: String!
}

type Discuss {
  id: ID!
  userId: String!
  status: DiscussStatus!
  meta: JSON! # TODO: define the content of meta
  title: String!
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
  count: DiscussCount!
}

type DiscussCount {
  id: ID!
  nPosts: Int!
}

type DiscussEmoji {
  id: ID!
  code: EmojiCode!
  count: DiscussEmojiCount!
}

type DiscussEmojiCount {
  id: ID!
  nUps: Int!
}

type DiscussEmojiLike {
  id: ID!
  discussEmojiId: Int!
  liked: Boolean!
  updatedAt: DateTime!
}

type DiscussPost {
  id: String!
  userId: String!
  status: DiscussPostStatus!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DiscussPostEmoji {
  id: ID!
  code: EmojiCode!
  count: DiscussPostEmojiCount!
}

type DiscussPostEmojiCount {
  id: ID!
  nUps: Int!
}

type DiscussPostEmojiLike {
  id: ID!
  discussPostEmojiId: Int!
  liked: Boolean!
  updatedAt: DateTime!
}

type Link {
  id: ID!
  url: String!
  authorId: String
  # scraped: Scraped!
}

type NoteEmoji {
  id: ID!
  code: EmojiCode!
  count: NoteEmojiCount!
}

type NoteEmojiCount {
  id: ID!
  nUps: Int!
  nDowns: Int!
}

type NoteEmojiLike {
  id: ID!
  noteEmojiId: Int!
  liked: Boolean!
  updatedAt: DateTime!
}

type Poll {
  id: ID!
  userId: String!
  # meta: PollMeta!
  # type: PollType!
  # status: PollStatus!
  choices: [String!]!
  # nVotes: [Int!]!
  count: PollCount!
  # title: String!
  # text: String
  # start: DateTime!
  # end: DateTime!
  # nDays: Int!
  # minVotes: Int!
  # nDaysJudge: Int!
  # minJudgments: Int!
  # count: PollCount!
  # posts: [Post!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PollCount {
  id: ID!
  nVotes: [Int!]!
  # nJudgements: [Int]
  # judgeStartedAt: DateTime
  # judgeEndedAt: DateTime
  # verdictValid: Boolean
  # verdictChoice: Int
  # updatedAt: DateTime!
  # failedMsg: String
}

type Rate {
  id: ID!
  userId: String!
  authorId: String
  linkId: String
  symId: String!
  choice: RateChoice!
  # body: ShotBody
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SearchHit {
  id: String!
  str: String!
}

type Sym {
  id: ID!
  type: SymType!
  symbol: String! # this is mutable
}

type User {
  id: ID!
  email: String!
  # profileImage: String
  # trips: [Launch]!
}

type Vote {
  id: ID!
  pollId: String!
  choiceIdx: Int!
  # reward: Float
  # createdAt: DateTime!
  # updatedAt: DateTime!
}

type UpsertDiscussEmojiLikeResult {
  emoji: DiscussEmoji!
  like: DiscussEmojiLike!
}

type UpsertDiscussPostEmojiLikeResult {
  emoji: DiscussPostEmoji!
  like: DiscussPostEmojiLike!
}

type UpsertNoteEmojiLikeResult {
  emoji: NoteEmoji!
  like: NoteEmojiLike!
}

#-------New-------

type Block {
  uid: ID!
  str: String!
  parentUid: String
  docTitle: String
}

type BlockUid_DiscussId {
  blockUid: String!
  discussId: String!
  commitId: String
}

type Commit {
  id: String!
  userId: String!
  drafts: [NoteDraft!]!
  docs: [NoteDoc!]!
  updatedAt: DateTime!
}

type Note {
  id: ID!

  # branch name
  branch: String!

  sym: Sym!
  link: Link

  # meta: NoteDocMeta!

  # the latest merged NoteDoc, throw error if there is none (it's impossible to be null because first NoteDoc will auto-merge to the newly-built Note)
  doc: NoteDoc!

  updatedAt: DateTime!
}

type NoteDoc {
  id: ID!
  # noteId: String!
  commitId: String!
  fromDocId: String
  userId: String!
  status: NoteDocStatus!
  domain: String!

  # meta is updated through commiting the note-doc
  meta: NoteDocMeta!

  content: NoteDocContent!
  updatedAt: DateTime!
}

type NoteDocContent {
  discussIds: [BlockUid_DiscussId!]!
  diff: JSON
  symbolIdDict: JSON
  blocks: [Block!]!
  # a symbol-noteId map, so later the cahnge of symbol name won't affect
}

type NoteDocEntry {
  id: ID!
}

type NoteDocMeta {
  # store Sym.symbols refering to the same note (e.g $BA, [[Boeing]] both to Boeing)
  duplicatedSymbols: [String]

  # note keywords
  keywords: [String]

  # used when duplicate symbol exists
  redirectFroms: [String]

  redirectTo: String
  webpage: NoteDocMetaWebpage
}

type NoteDocMetaWebpage {
  authors: [String]
  title: String

  # when the webpage content publish at
  publishedAt: DateTime

  # tickers mentioned in the webpage content
  tickers: [String]
}

type NoteDraft {
  id: ID!
  # noteId: String  # not using for creating a draft and not this field in db
  userId: String!
  commitId: String
  fromDocId: String
  domain: String
  symbol: String
  meta: NoteDocMeta # not sure about this type
  content: NoteDocContent!
  updatedAt: DateTime!
  status: NoteDraftStatus!
}

type NoteDraftCommitResponse {
  commitId: String!
  docs: [NoteDoc!]! # corresponding to the noteDraft, for the purpose of merge status display
}

type NoteDraftDropResponse {
  response: String!
}

type NoteDraftEntry {
  id: ID!
}

# ------------------End-------------------

# ------ Inputs ------

input AuthorInput {
  name: String!
  type: AuthorType!
  job: String
  org: String
  sites: [AuthorMetaSiteInput!]!
}

input AuthorMetaSiteInput {
  name: String!
  url: String!
}

input DiscussInput {
  meta: JSON
  title: String!
  content: String
}

input DiscussPostInput {
  content: String!
}

input LikeInput {
  choice: LikeChoice!
}

input PollInput {
  # cat: PollCat!
  choices: [String!]!
}

input RateInput {
  choice: RateChoice!
  targetId: ID! # target note id
  authorId: ID # create author rate required
  linkId: ID # create author rate required
}

input VoteInput {
  choiceIdx: Int!
}

#------New-------

input BlockInput {
  uid: ID!
  str: String!
  parentUid: String
  docTitle: String
}

input BlockUid_DiscussIdInput {
  blockUid: String!
  discussId: String!
  commitId: String
}

input CommitInput {
  noteDraftInputs: [NoteDraftInput!]!
}

input NoteDraftInput {
  # noteId: String   # not using for creating a draft and not this field in db
  fromDocId: String
  domain: String!
  meta: NoteDocMetaInput!
  content: NoteDocContentInput!
}

input NoteDocContentInput {
  discussIds: [BlockUid_DiscussIdInput!]!
  diff: JSON
  symbolIdMap: JSON
  blocks: [BlockInput!]!
}

# similar to NoteDocMeta
input NoteDocMetaInput {
  duplicatedSymbols: [String]! # to store Sym.symbols refering to the same note (e.g $BA, [[Boeing]] both to Boeing)
  keywords: [String]! # note keywords
  redirectFroms: [String]! # used when duplicate symbol exists
  redirectTo: String
  webpage: NoteDocMetaWebpageInput
}

# data extracted from the webpage
input NoteDocMetaWebpageInput {
  authors: [String]!
  title: String
  publishedAt: DateTime # when the webpage content publish at
  tickers: [String]! # tickers mentioned in the webpage content
}

#---------------End-----------------

# ------ NEXT ------

# type Tick {
#   id: ID!
#   symbolId: Int!
#   value: Float!
#   at: DateTime!
# }

#-------------ENUM--------------
enum AuthorType {
  ORG
  PERSON
}

enum DiscussStatus {
  DRAFT
  ACTIVE
  LOCK
  DELETE
  ARCHIVE
  REPORTED
}

enum DiscussPostStatus {
  ACTIVE
  LOCK
  DELETE
  ARCHIVE
  REPORTED
}

enum EmojiCode {
  UP
  DOWN
  PIN
  REPORT
}

enum LikeChoice {
  UP
  # DOWN
  NEUTRAL
}

enum PollType {
  FIXED
  ADD
  ADD_BY_POST
}

enum PollStatus {
  OPEN
  JUDGE
  CLOSE_SUCCESS
  CLOSE_FAIL
}

enum RateChoice {
  LONG
  SHORT
  HOLD
}

enum SymType {
  TICKER
  TOPIC
  URL
}

#-------New-------
enum NoteDraftStatus {
  EDIT
  COMMIT
  DROP
}

enum NoteDocStatus {
  CANDIDATE
  MERGE
  REJECT
}
