function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object)
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object)
    enumerableOnly &&
      (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable
      })),
      keys.push.apply(keys, symbols)
  }
  return keys
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {}
    i % 2
      ? ownKeys(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))
      : ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key))
        })
  }
  return target
}
function _defineProperty(obj, key, value) {
  return (
    key in obj
      ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 })
      : (obj[key] = value),
    obj
  )
}
var e, r
;(self.globals = {
  serverUrl: '',
  environment: 'production',
  version: '5.0.14',
  isMobileApp: !1,
  appType: 'hypernotes',
}),
  function () {
    var FUNC_ERROR_TEXT = 'Expected a function',
      PLACEHOLDER = '__lodash_placeholder__',
      wrapFlags = [
        ['ary', 128],
        ['bind', 1],
        ['bindKey', 2],
        ['curry', 8],
        ['curryRight', 16],
        ['flip', 512],
        ['partial', 32],
        ['partialRight', 64],
        ['rearg', 256],
      ],
      argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]',
      arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]',
      reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
      reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source),
      reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g,
      reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source),
      reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/,
      reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /,
      reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
      reEscapeChar = /\\(\\)?/g,
      reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      reFlags = /\w*$/,
      reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
      reIsBinary = /^0b[01]+$/i,
      reIsHostCtor = /^\[object .+?Constructor\]$/,
      reIsOctal = /^0o[0-7]+$/i,
      reIsUint = /^(?:0|[1-9]\d*)$/,
      reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      reNoMatch = /($^)/,
      reUnescapedString = /['\n\r\u2028\u2029\\]/g,
      rsComboRange = '\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff',
      rsBreakRange =
        '\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsAstral = '[\\ud800-\\udfff]',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[\\u2700-\\u27bf]',
      rsLower = '[a-z\\xdf-\\xf6\\xf8-\\xff]',
      rsMisc =
        '[^\\ud800-\\udfff' +
        rsBreakRange +
        rsDigits +
        '\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsNonAstral = '[^\\ud800-\\udfff]',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
      rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      reOptMod = '(?:' + rsCombo + '|' + rsFitz + ')' + '?',
      rsSeq =
        '[\\ufe0e\\ufe0f]?' +
        reOptMod +
        ('(?:\\u200d(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')[\\ufe0e\\ufe0f]?' + reOptMod + ')*'),
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')',
      reApos = RegExp("['’]", 'g'),
      reComboMark = RegExp(rsCombo, 'g'),
      reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g'),
      reUnicodeWord = RegExp(
        [
          rsUpper + '?' + rsLower + "+(?:['’](?:d|ll|m|re|s|t|ve))?(?=" + [rsBreak, rsUpper, '$'].join('|') + ')',
          rsMiscUpper + "+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=" + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
          rsUpper + '?' + rsMiscLower + "+(?:['’](?:d|ll|m|re|s|t|ve))?",
          rsUpper + "+(?:['’](?:D|LL|M|RE|S|T|VE))?",
          '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
          '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
          rsDigits,
          rsEmoji,
        ].join('|'),
        'g',
      ),
      reHasUnicode = RegExp('[\\u200d\\ud800-\\udfff' + rsComboRange + '\\ufe0e\\ufe0f]'),
      reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      contextProps = [
        'Array',
        'Buffer',
        'DataView',
        'Date',
        'Error',
        'Float32Array',
        'Float64Array',
        'Function',
        'Int8Array',
        'Int16Array',
        'Int32Array',
        'Map',
        'Math',
        'Object',
        'Promise',
        'RegExp',
        'Set',
        'String',
        'Symbol',
        'TypeError',
        'Uint8Array',
        'Uint8ClampedArray',
        'Uint16Array',
        'Uint32Array',
        'WeakMap',
        '_',
        'clearTimeout',
        'isFinite',
        'parseInt',
        'setTimeout',
      ],
      templateCounter = -1,
      typedArrayTags = {}
    ;(typedArrayTags[float32Tag] =
      typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] =
      typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] =
      typedArrayTags[uint8Tag] =
      typedArrayTags['[object Uint8ClampedArray]'] =
      typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] =
        !0),
      (typedArrayTags[argsTag] =
        typedArrayTags[arrayTag] =
        typedArrayTags[arrayBufferTag] =
        typedArrayTags[boolTag] =
        typedArrayTags[dataViewTag] =
        typedArrayTags[dateTag] =
        typedArrayTags[errorTag] =
        typedArrayTags[funcTag] =
        typedArrayTags[mapTag] =
        typedArrayTags[numberTag] =
        typedArrayTags[objectTag] =
        typedArrayTags[regexpTag] =
        typedArrayTags[setTag] =
        typedArrayTags[stringTag] =
        typedArrayTags[weakMapTag] =
          !1)
    var cloneableTags = {}
    ;(cloneableTags[argsTag] =
      cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] =
      cloneableTags[dataViewTag] =
      cloneableTags[boolTag] =
      cloneableTags[dateTag] =
      cloneableTags[float32Tag] =
      cloneableTags[float64Tag] =
      cloneableTags[int8Tag] =
      cloneableTags[int16Tag] =
      cloneableTags[int32Tag] =
      cloneableTags[mapTag] =
      cloneableTags[numberTag] =
      cloneableTags[objectTag] =
      cloneableTags[regexpTag] =
      cloneableTags[setTag] =
      cloneableTags[stringTag] =
      cloneableTags[symbolTag] =
      cloneableTags[uint8Tag] =
      cloneableTags['[object Uint8ClampedArray]'] =
      cloneableTags[uint16Tag] =
      cloneableTags[uint32Tag] =
        !0),
      (cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1)
    var stringEscapes = { '\\': '\\', "'": "'", '\n': 'n', '\r': 'r', '\u2028': 'u2028', '\u2029': 'u2029' },
      freeParseFloat = parseFloat,
      freeParseInt = parseInt,
      freeGlobal = 'object' == typeof global && global && global.Object === Object && global,
      freeSelf = 'object' == typeof self && self && self.Object === Object && self,
      root = freeGlobal || freeSelf || Function('return this')(),
      freeExports = 'object' == typeof exports && exports && !exports.nodeType && exports,
      freeModule = freeExports && 'object' == typeof module && module && !module.nodeType && module,
      moduleExports = freeModule && freeModule.exports === freeExports,
      freeProcess = moduleExports && freeGlobal.process,
      nodeUtil = (function () {
        try {
          var types = freeModule && freeModule.require && freeModule.require('util').types
          return types || (freeProcess && freeProcess.binding && freeProcess.binding('util'))
        } catch (e) {}
      })(),
      nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg)
        case 1:
          return func.call(thisArg, args[0])
        case 2:
          return func.call(thisArg, args[0], args[1])
        case 3:
          return func.call(thisArg, args[0], args[1], args[2])
      }
      return func.apply(thisArg, args)
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) {
        var value = array[index]
        setter(accumulator, value, iteratee(value), array)
      }
      return accumulator
    }
    function arrayEach(array, iteratee) {
      for (
        var index = -1, length = null == array ? 0 : array.length;
        ++index < length && !1 !== iteratee(array[index], index, array);

      );
      return array
    }
    function arrayEachRight(array, iteratee) {
      for (var length = null == array ? 0 : array.length; length-- && !1 !== iteratee(array[length], length, array); );
      return array
    }
    function arrayEvery(array, predicate) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length; )
        if (!predicate(array[index], index, array)) return !1
      return !0
    }
    function arrayFilter(array, predicate) {
      for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array[index]
        predicate(value, index, array) && (result[resIndex++] = value)
      }
      return result
    }
    function arrayIncludes(array, value) {
      return !!(null == array ? 0 : array.length) && baseIndexOf(array, value, 0) > -1
    }
    function arrayIncludesWith(array, value, comparator) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length; )
        if (comparator(value, array[index])) return !0
      return !1
    }
    function arrayMap(array, iteratee) {
      for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; )
        result[index] = iteratee(array[index], index, array)
      return result
    }
    function arrayPush(array, values) {
      for (var index = -1, length = values.length, offset = array.length; ++index < length; )
        array[offset + index] = values[index]
      return array
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
        length = null == array ? 0 : array.length
      for (initAccum && length && (accumulator = array[++index]); ++index < length; )
        accumulator = iteratee(accumulator, array[index], index, array)
      return accumulator
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = null == array ? 0 : array.length
      for (initAccum && length && (accumulator = array[--length]); length--; )
        accumulator = iteratee(accumulator, array[length], length, array)
      return accumulator
    }
    function arraySome(array, predicate) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length; )
        if (predicate(array[index], index, array)) return !0
      return !1
    }
    var asciiSize = baseProperty('length')
    function baseFindKey(collection, predicate, eachFunc) {
      var result
      return (
        eachFunc(collection, function (value, key, collection) {
          if (predicate(value, key, collection)) return (result = key), !1
        }),
        result
      )
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      for (
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        fromRight ? index-- : ++index < length;

      )
        if (predicate(array[index], index, array)) return index
      return -1
    }
    function baseIndexOf(array, value, fromIndex) {
      return value == value
        ? (function (array, value, fromIndex) {
            var index = fromIndex - 1,
              length = array.length
            for (; ++index < length; ) if (array[index] === value) return index
            return -1
          })(array, value, fromIndex)
        : baseFindIndex(array, baseIsNaN, fromIndex)
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      for (var index = fromIndex - 1, length = array.length; ++index < length; )
        if (comparator(array[index], value)) return index
      return -1
    }
    function baseIsNaN(value) {
      return value != value
    }
    function baseMean(array, iteratee) {
      var length = null == array ? 0 : array.length
      return length ? baseSum(array, iteratee) / length : NaN
    }
    function baseProperty(key) {
      return function (object) {
        return null == object ? undefined : object[key]
      }
    }
    function basePropertyOf(object) {
      return function (key) {
        return null == object ? undefined : object[key]
      }
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      return (
        eachFunc(collection, function (value, index, collection) {
          accumulator = initAccum ? ((initAccum = !1), value) : iteratee(accumulator, value, index, collection)
        }),
        accumulator
      )
    }
    function baseSum(array, iteratee) {
      for (var result, index = -1, length = array.length; ++index < length; ) {
        var current = iteratee(array[index])
        undefined !== current && (result = undefined === result ? current : result + current)
      }
      return result
    }
    function baseTimes(n, iteratee) {
      for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index)
      return result
    }
    function baseUnary(func) {
      return function (value) {
        return func(value)
      }
    }
    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key]
      })
    }
    function cacheHas(cache, key) {
      return cache.has(key)
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      for (
        var index = -1, length = strSymbols.length;
        ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1;

      );
      return index
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; );
      return index
    }
    function countHolders(array, placeholder) {
      for (var length = array.length, result = 0; length--; ) array[length] === placeholder && ++result
      return result
    }
    var deburrLetter = basePropertyOf({
        À: 'A',
        Á: 'A',
        Â: 'A',
        Ã: 'A',
        Ä: 'A',
        Å: 'A',
        à: 'a',
        á: 'a',
        â: 'a',
        ã: 'a',
        ä: 'a',
        å: 'a',
        Ç: 'C',
        ç: 'c',
        Ð: 'D',
        ð: 'd',
        È: 'E',
        É: 'E',
        Ê: 'E',
        Ë: 'E',
        è: 'e',
        é: 'e',
        ê: 'e',
        ë: 'e',
        Ì: 'I',
        Í: 'I',
        Î: 'I',
        Ï: 'I',
        ì: 'i',
        í: 'i',
        î: 'i',
        ï: 'i',
        Ñ: 'N',
        ñ: 'n',
        Ò: 'O',
        Ó: 'O',
        Ô: 'O',
        Õ: 'O',
        Ö: 'O',
        Ø: 'O',
        ò: 'o',
        ó: 'o',
        ô: 'o',
        õ: 'o',
        ö: 'o',
        ø: 'o',
        Ù: 'U',
        Ú: 'U',
        Û: 'U',
        Ü: 'U',
        ù: 'u',
        ú: 'u',
        û: 'u',
        ü: 'u',
        Ý: 'Y',
        ý: 'y',
        ÿ: 'y',
        Æ: 'Ae',
        æ: 'ae',
        Þ: 'Th',
        þ: 'th',
        ß: 'ss',
        Ā: 'A',
        Ă: 'A',
        Ą: 'A',
        ā: 'a',
        ă: 'a',
        ą: 'a',
        Ć: 'C',
        Ĉ: 'C',
        Ċ: 'C',
        Č: 'C',
        ć: 'c',
        ĉ: 'c',
        ċ: 'c',
        č: 'c',
        Ď: 'D',
        Đ: 'D',
        ď: 'd',
        đ: 'd',
        Ē: 'E',
        Ĕ: 'E',
        Ė: 'E',
        Ę: 'E',
        Ě: 'E',
        ē: 'e',
        ĕ: 'e',
        ė: 'e',
        ę: 'e',
        ě: 'e',
        Ĝ: 'G',
        Ğ: 'G',
        Ġ: 'G',
        Ģ: 'G',
        ĝ: 'g',
        ğ: 'g',
        ġ: 'g',
        ģ: 'g',
        Ĥ: 'H',
        Ħ: 'H',
        ĥ: 'h',
        ħ: 'h',
        Ĩ: 'I',
        Ī: 'I',
        Ĭ: 'I',
        Į: 'I',
        İ: 'I',
        ĩ: 'i',
        ī: 'i',
        ĭ: 'i',
        į: 'i',
        ı: 'i',
        Ĵ: 'J',
        ĵ: 'j',
        Ķ: 'K',
        ķ: 'k',
        ĸ: 'k',
        Ĺ: 'L',
        Ļ: 'L',
        Ľ: 'L',
        Ŀ: 'L',
        Ł: 'L',
        ĺ: 'l',
        ļ: 'l',
        ľ: 'l',
        ŀ: 'l',
        ł: 'l',
        Ń: 'N',
        Ņ: 'N',
        Ň: 'N',
        Ŋ: 'N',
        ń: 'n',
        ņ: 'n',
        ň: 'n',
        ŋ: 'n',
        Ō: 'O',
        Ŏ: 'O',
        Ő: 'O',
        ō: 'o',
        ŏ: 'o',
        ő: 'o',
        Ŕ: 'R',
        Ŗ: 'R',
        Ř: 'R',
        ŕ: 'r',
        ŗ: 'r',
        ř: 'r',
        Ś: 'S',
        Ŝ: 'S',
        Ş: 'S',
        Š: 'S',
        ś: 's',
        ŝ: 's',
        ş: 's',
        š: 's',
        Ţ: 'T',
        Ť: 'T',
        Ŧ: 'T',
        ţ: 't',
        ť: 't',
        ŧ: 't',
        Ũ: 'U',
        Ū: 'U',
        Ŭ: 'U',
        Ů: 'U',
        Ű: 'U',
        Ų: 'U',
        ũ: 'u',
        ū: 'u',
        ŭ: 'u',
        ů: 'u',
        ű: 'u',
        ų: 'u',
        Ŵ: 'W',
        ŵ: 'w',
        Ŷ: 'Y',
        ŷ: 'y',
        Ÿ: 'Y',
        Ź: 'Z',
        Ż: 'Z',
        Ž: 'Z',
        ź: 'z',
        ż: 'z',
        ž: 'z',
        Ĳ: 'IJ',
        ĳ: 'ij',
        Œ: 'Oe',
        œ: 'oe',
        ŉ: "'n",
        ſ: 's',
      }),
      escapeHtmlChar = basePropertyOf({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })
    function escapeStringChar(chr) {
      return '\\' + stringEscapes[chr]
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string)
    }
    function mapToArray(map) {
      var index = -1,
        result = Array(map.size)
      return (
        map.forEach(function (value, key) {
          result[++index] = [key, value]
        }),
        result
      )
    }
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg))
      }
    }
    function replaceHolders(array, placeholder) {
      for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array[index]
        ;(value !== placeholder && value !== PLACEHOLDER) ||
          ((array[index] = PLACEHOLDER), (result[resIndex++] = index))
      }
      return result
    }
    function setToArray(set) {
      var index = -1,
        result = Array(set.size)
      return (
        set.forEach(function (value) {
          result[++index] = value
        }),
        result
      )
    }
    function setToPairs(set) {
      var index = -1,
        result = Array(set.size)
      return (
        set.forEach(function (value) {
          result[++index] = [value, value]
        }),
        result
      )
    }
    function stringSize(string) {
      return hasUnicode(string)
        ? (function (string) {
            var result = (reUnicode.lastIndex = 0)
            for (; reUnicode.test(string); ) ++result
            return result
          })(string)
        : asciiSize(string)
    }
    function stringToArray(string) {
      return hasUnicode(string)
        ? (function (string) {
            return string.match(reUnicode) || []
          })(string)
        : (function (string) {
            return string.split('')
          })(string)
    }
    var unescapeHtmlChar = basePropertyOf({ '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&#39;': "'" })
    var _ = (function runInContext(context) {
      var uid,
        Array = (context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps)))
          .Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError,
        arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype,
        coreJsData = context['__core-js_shared__'],
        funcToString = funcProto.toString,
        hasOwnProperty = objectProto.hasOwnProperty,
        idCounter = 0,
        maskSrcKey = (uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ''))
          ? 'Symbol(src)_1.' + uid
          : '',
        nativeObjectToString = objectProto.toString,
        objectCtorString = funcToString.call(Object),
        oldDash = root._,
        reIsNative = RegExp(
          '^' +
            funcToString
              .call(hasOwnProperty)
              .replace(reRegExpChar, '\\$&')
              .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
            '$',
        ),
        Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined,
        defineProperty = (function () {
          try {
            var func = getNative(Object, 'defineProperty')
            return func({}, '', {}), func
          } catch (e) {}
        })(),
        ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout,
        nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse,
        DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create'),
        metaMap = WeakMap && new WeakMap(),
        realNames = {},
        dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap),
        symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) return value
          if (hasOwnProperty.call(value, '__wrapped__')) return wrapperClone(value)
        }
        return new LodashWrapper(value)
      }
      var baseCreate = (function () {
        function object() {}
        return function (proto) {
          if (!isObject(proto)) return {}
          if (objectCreate) return objectCreate(proto)
          object.prototype = proto
          var result = new object()
          return (object.prototype = undefined), result
        }
      })()
      function baseLodash() {}
      function LodashWrapper(value, chainAll) {
        ;(this.__wrapped__ = value),
          (this.__actions__ = []),
          (this.__chain__ = !!chainAll),
          (this.__index__ = 0),
          (this.__values__ = undefined)
      }
      function LazyWrapper(value) {
        ;(this.__wrapped__ = value),
          (this.__actions__ = []),
          (this.__dir__ = 1),
          (this.__filtered__ = !1),
          (this.__iteratees__ = []),
          (this.__takeCount__ = 4294967295),
          (this.__views__ = [])
      }
      function Hash(entries) {
        var index = -1,
          length = null == entries ? 0 : entries.length
        for (this.clear(); ++index < length; ) {
          var entry = entries[index]
          this.set(entry[0], entry[1])
        }
      }
      function ListCache(entries) {
        var index = -1,
          length = null == entries ? 0 : entries.length
        for (this.clear(); ++index < length; ) {
          var entry = entries[index]
          this.set(entry[0], entry[1])
        }
      }
      function MapCache(entries) {
        var index = -1,
          length = null == entries ? 0 : entries.length
        for (this.clear(); ++index < length; ) {
          var entry = entries[index]
          this.set(entry[0], entry[1])
        }
      }
      function SetCache(values) {
        var index = -1,
          length = null == values ? 0 : values.length
        for (this.__data__ = new MapCache(); ++index < length; ) this.add(values[index])
      }
      function Stack(entries) {
        var data = (this.__data__ = new ListCache(entries))
        this.size = data.size
      }
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length
        for (var key in value)
          (!inherited && !hasOwnProperty.call(value, key)) ||
            (skipIndexes &&
              ('length' == key ||
                (isBuff && ('offset' == key || 'parent' == key)) ||
                (isType && ('buffer' == key || 'byteLength' == key || 'byteOffset' == key)) ||
                isIndex(key, length))) ||
            result.push(key)
        return result
      }
      function arraySample(array) {
        var length = array.length
        return length ? array[baseRandom(0, length - 1)] : undefined
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length))
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array))
      }
      function assignMergeValue(object, key, value) {
        ;((undefined !== value && !eq(object[key], value)) || (undefined === value && !(key in object))) &&
          baseAssignValue(object, key, value)
      }
      function assignValue(object, key, value) {
        var objValue = object[key]
        ;(hasOwnProperty.call(object, key) && eq(objValue, value) && (undefined !== value || key in object)) ||
          baseAssignValue(object, key, value)
      }
      function assocIndexOf(array, key) {
        for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length
        return -1
      }
      function baseAggregator(collection, setter, iteratee, accumulator) {
        return (
          baseEach(collection, function (value, key, collection) {
            setter(accumulator, value, iteratee(value), collection)
          }),
          accumulator
        )
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object)
      }
      function baseAssignValue(object, key, value) {
        '__proto__' == key && defineProperty
          ? defineProperty(object, key, { configurable: !0, enumerable: !0, value, writable: !0 })
          : (object[key] = value)
      }
      function baseAt(object, paths) {
        for (var index = -1, length = paths.length, result = Array(length), skip = null == object; ++index < length; )
          result[index] = skip ? undefined : get(object, paths[index])
        return result
      }
      function baseClamp(number, lower, upper) {
        return (
          number == number &&
            (undefined !== upper && (number = number <= upper ? number : upper),
            undefined !== lower && (number = number >= lower ? number : lower)),
          number
        )
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result,
          isDeep = 1 & bitmask,
          isFlat = 2 & bitmask,
          isFull = 4 & bitmask
        if (
          (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)),
          undefined !== result)
        )
          return result
        if (!isObject(value)) return value
        var isArr = isArray(value)
        if (isArr) {
          if (
            ((result = (function (array) {
              var length = array.length,
                result = new array.constructor(length)
              length &&
                'string' == typeof array[0] &&
                hasOwnProperty.call(array, 'index') &&
                ((result.index = array.index), (result.input = array.input))
              return result
            })(value)),
            !isDeep)
          )
            return copyArray(value, result)
        } else {
          var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag
          if (isBuffer(value)) return cloneBuffer(value, isDeep)
          if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
            if (((result = isFlat || isFunc ? {} : initCloneObject(value)), !isDeep))
              return isFlat
                ? (function (source, object) {
                    return copyObject(source, getSymbolsIn(source), object)
                  })(
                    value,
                    (function (object, source) {
                      return object && copyObject(source, keysIn(source), object)
                    })(result, value),
                  )
                : (function (source, object) {
                    return copyObject(source, getSymbols(source), object)
                  })(value, baseAssign(result, value))
          } else {
            if (!cloneableTags[tag]) return object ? value : {}
            result = (function (object, tag, isDeep) {
              var Ctor = object.constructor
              switch (tag) {
                case arrayBufferTag:
                  return cloneArrayBuffer(object)
                case boolTag:
                case dateTag:
                  return new Ctor(+object)
                case dataViewTag:
                  return (function (dataView, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer
                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
                  })(object, isDeep)
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                  return cloneTypedArray(object, isDeep)
                case mapTag:
                  return new Ctor()
                case numberTag:
                case stringTag:
                  return new Ctor(object)
                case regexpTag:
                  return (function (regexp) {
                    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp))
                    return (result.lastIndex = regexp.lastIndex), result
                  })(object)
                case setTag:
                  return new Ctor()
                case symbolTag:
                  return (symbol = object), symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
              }
              var symbol
            })(value, tag, isDeep)
          }
        }
        stack || (stack = new Stack())
        var stacked = stack.get(value)
        if (stacked) return stacked
        stack.set(value, result),
          isSet(value)
            ? value.forEach(function (subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
              })
            : isMap(value) &&
              value.forEach(function (subValue, key) {
                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
              })
        var props = isArr ? undefined : (isFull ? (isFlat ? getAllKeysIn : getAllKeys) : isFlat ? keysIn : keys)(value)
        return (
          arrayEach(props || value, function (subValue, key) {
            props && (subValue = value[(key = subValue)]),
              assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
          }),
          result
        )
      }
      function baseConformsTo(object, source, props) {
        var length = props.length
        if (null == object) return !length
        for (object = Object(object); length--; ) {
          var key = props[length],
            predicate = source[key],
            value = object[key]
          if ((undefined === value && !(key in object)) || !predicate(value)) return !1
        }
        return !0
      }
      function baseDelay(func, wait, args) {
        if ('function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
        return setTimeout(function () {
          func.apply(undefined, args)
        }, wait)
      }
      function baseDifference(array, values, iteratee, comparator) {
        var index = -1,
          includes = arrayIncludes,
          isCommon = !0,
          length = array.length,
          result = [],
          valuesLength = values.length
        if (!length) return result
        iteratee && (values = arrayMap(values, baseUnary(iteratee))),
          comparator
            ? ((includes = arrayIncludesWith), (isCommon = !1))
            : values.length >= 200 && ((includes = cacheHas), (isCommon = !1), (values = new SetCache(values)))
        outer: for (; ++index < length; ) {
          var value = array[index],
            computed = null == iteratee ? value : iteratee(value)
          if (((value = comparator || 0 !== value ? value : 0), isCommon && computed == computed)) {
            for (var valuesIndex = valuesLength; valuesIndex--; ) if (values[valuesIndex] === computed) continue outer
            result.push(value)
          } else includes(values, computed, comparator) || result.push(value)
        }
        return result
      }
      ;(lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: '',
        imports: { _: lodash },
      }),
        (lodash.prototype = baseLodash.prototype),
        (lodash.prototype.constructor = lodash),
        (LodashWrapper.prototype = baseCreate(baseLodash.prototype)),
        (LodashWrapper.prototype.constructor = LodashWrapper),
        (LazyWrapper.prototype = baseCreate(baseLodash.prototype)),
        (LazyWrapper.prototype.constructor = LazyWrapper),
        (Hash.prototype.clear = function () {
          ;(this.__data__ = nativeCreate ? nativeCreate(null) : {}), (this.size = 0)
        }),
        (Hash.prototype.delete = function (key) {
          var result = this.has(key) && delete this.__data__[key]
          return (this.size -= result ? 1 : 0), result
        }),
        (Hash.prototype.get = function (key) {
          var data = this.__data__
          if (nativeCreate) {
            var result = data[key]
            return '__lodash_hash_undefined__' === result ? undefined : result
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined
        }),
        (Hash.prototype.has = function (key) {
          var data = this.__data__
          return nativeCreate ? undefined !== data[key] : hasOwnProperty.call(data, key)
        }),
        (Hash.prototype.set = function (key, value) {
          var data = this.__data__
          return (
            (this.size += this.has(key) ? 0 : 1),
            (data[key] = nativeCreate && undefined === value ? '__lodash_hash_undefined__' : value),
            this
          )
        }),
        (ListCache.prototype.clear = function () {
          ;(this.__data__ = []), (this.size = 0)
        }),
        (ListCache.prototype.delete = function (key) {
          var data = this.__data__,
            index = assocIndexOf(data, key)
          return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), --this.size, !0)
        }),
        (ListCache.prototype.get = function (key) {
          var data = this.__data__,
            index = assocIndexOf(data, key)
          return index < 0 ? undefined : data[index][1]
        }),
        (ListCache.prototype.has = function (key) {
          return assocIndexOf(this.__data__, key) > -1
        }),
        (ListCache.prototype.set = function (key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key)
          return index < 0 ? (++this.size, data.push([key, value])) : (data[index][1] = value), this
        }),
        (MapCache.prototype.clear = function () {
          ;(this.size = 0), (this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() })
        }),
        (MapCache.prototype.delete = function (key) {
          var result = getMapData(this, key).delete(key)
          return (this.size -= result ? 1 : 0), result
        }),
        (MapCache.prototype.get = function (key) {
          return getMapData(this, key).get(key)
        }),
        (MapCache.prototype.has = function (key) {
          return getMapData(this, key).has(key)
        }),
        (MapCache.prototype.set = function (key, value) {
          var data = getMapData(this, key),
            size = data.size
          return data.set(key, value), (this.size += data.size == size ? 0 : 1), this
        }),
        (SetCache.prototype.add = SetCache.prototype.push =
          function (value) {
            return this.__data__.set(value, '__lodash_hash_undefined__'), this
          }),
        (SetCache.prototype.has = function (value) {
          return this.__data__.has(value)
        }),
        (Stack.prototype.clear = function () {
          ;(this.__data__ = new ListCache()), (this.size = 0)
        }),
        (Stack.prototype.delete = function (key) {
          var data = this.__data__,
            result = data.delete(key)
          return (this.size = data.size), result
        }),
        (Stack.prototype.get = function (key) {
          return this.__data__.get(key)
        }),
        (Stack.prototype.has = function (key) {
          return this.__data__.has(key)
        }),
        (Stack.prototype.set = function (key, value) {
          var data = this.__data__
          if (data instanceof ListCache) {
            var pairs = data.__data__
            if (!Map || pairs.length < 199) return pairs.push([key, value]), (this.size = ++data.size), this
            data = this.__data__ = new MapCache(pairs)
          }
          return data.set(key, value), (this.size = data.size), this
        })
      var baseEach = createBaseEach(baseForOwn),
        baseEachRight = createBaseEach(baseForOwnRight, !0)
      function baseEvery(collection, predicate) {
        var result = !0
        return (
          baseEach(collection, function (value, index, collection) {
            return (result = !!predicate(value, index, collection))
          }),
          result
        )
      }
      function baseExtremum(array, iteratee, comparator) {
        for (var index = -1, length = array.length; ++index < length; ) {
          var value = array[index],
            current = iteratee(value)
          if (
            null != current &&
            (undefined === computed ? current == current && !isSymbol(current) : comparator(current, computed))
          )
            var computed = current,
              result = value
        }
        return result
      }
      function baseFilter(collection, predicate) {
        var result = []
        return (
          baseEach(collection, function (value, index, collection) {
            predicate(value, index, collection) && result.push(value)
          }),
          result
        )
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1,
          length = array.length
        for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length; ) {
          var value = array[index]
          depth > 0 && predicate(value)
            ? depth > 1
              ? baseFlatten(value, depth - 1, predicate, isStrict, result)
              : arrayPush(result, value)
            : isStrict || (result[result.length] = value)
        }
        return result
      }
      var baseFor = createBaseFor(),
        baseForRight = createBaseFor(!0)
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys)
      }
      function baseForOwnRight(object, iteratee) {
        return object && baseForRight(object, iteratee, keys)
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function (key) {
          return isFunction(object[key])
        })
      }
      function baseGet(object, path) {
        for (var index = 0, length = (path = castPath(path, object)).length; null != object && index < length; )
          object = object[toKey(path[index++])]
        return index && index == length ? object : undefined
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object)
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
      }
      function baseGetTag(value) {
        return null == value
          ? undefined === value
            ? '[object Undefined]'
            : '[object Null]'
          : symToStringTag && symToStringTag in Object(value)
          ? (function (value) {
              var isOwn = hasOwnProperty.call(value, symToStringTag),
                tag = value[symToStringTag]
              try {
                value[symToStringTag] = undefined
                var unmasked = !0
              } catch (e) {}
              var result = nativeObjectToString.call(value)
              unmasked && (isOwn ? (value[symToStringTag] = tag) : delete value[symToStringTag])
              return result
            })(value)
          : (function (value) {
              return nativeObjectToString.call(value)
            })(value)
      }
      function baseGt(value, other) {
        return value > other
      }
      function baseHas(object, key) {
        return null != object && hasOwnProperty.call(object, key)
      }
      function baseHasIn(object, key) {
        return null != object && key in Object(object)
      }
      function baseIntersection(arrays, iteratee, comparator) {
        for (
          var includes = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array(othLength),
            maxLength = 1 / 0,
            result = [];
          othIndex--;

        ) {
          var array = arrays[othIndex]
          othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))),
            (maxLength = nativeMin(array.length, maxLength)),
            (caches[othIndex] =
              !comparator && (iteratee || (length >= 120 && array.length >= 120))
                ? new SetCache(othIndex && array)
                : undefined)
        }
        array = arrays[0]
        var index = -1,
          seen = caches[0]
        outer: for (; ++index < length && result.length < maxLength; ) {
          var value = array[index],
            computed = iteratee ? iteratee(value) : value
          if (
            ((value = comparator || 0 !== value ? value : 0),
            !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator)))
          ) {
            for (othIndex = othLength; --othIndex; ) {
              var cache = caches[othIndex]
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator)))
                continue outer
            }
            seen && seen.push(computed), result.push(value)
          }
        }
        return result
      }
      function baseInvoke(object, path, args) {
        var func =
          null == (object = parent(object, (path = castPath(path, object)))) ? object : object[toKey(last(path))]
        return null == func ? undefined : apply(func, object, args)
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        return (
          value === other ||
          (null == value || null == other || (!isObjectLike(value) && !isObjectLike(other))
            ? value != value && other != other
            : (function (object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object),
                  othIsArr = isArray(other),
                  objTag = objIsArr ? arrayTag : getTag(object),
                  othTag = othIsArr ? arrayTag : getTag(other),
                  objIsObj = (objTag = objTag == argsTag ? objectTag : objTag) == objectTag,
                  othIsObj = (othTag = othTag == argsTag ? objectTag : othTag) == objectTag,
                  isSameTag = objTag == othTag
                if (isSameTag && isBuffer(object)) {
                  if (!isBuffer(other)) return !1
                  ;(objIsArr = !0), (objIsObj = !1)
                }
                if (isSameTag && !objIsObj)
                  return (
                    stack || (stack = new Stack()),
                    objIsArr || isTypedArray(object)
                      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
                      : (function (object, other, tag, bitmask, customizer, equalFunc, stack) {
                          switch (tag) {
                            case dataViewTag:
                              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset)
                                return !1
                              ;(object = object.buffer), (other = other.buffer)
                            case arrayBufferTag:
                              return !(
                                object.byteLength != other.byteLength ||
                                !equalFunc(new Uint8Array(object), new Uint8Array(other))
                              )
                            case boolTag:
                            case dateTag:
                            case numberTag:
                              return eq(+object, +other)
                            case errorTag:
                              return object.name == other.name && object.message == other.message
                            case regexpTag:
                            case stringTag:
                              return object == other + ''
                            case mapTag:
                              var convert = mapToArray
                            case setTag:
                              var isPartial = 1 & bitmask
                              if ((convert || (convert = setToArray), object.size != other.size && !isPartial))
                                return !1
                              var stacked = stack.get(object)
                              if (stacked) return stacked == other
                              ;(bitmask |= 2), stack.set(object, other)
                              var result = equalArrays(
                                convert(object),
                                convert(other),
                                bitmask,
                                customizer,
                                equalFunc,
                                stack,
                              )
                              return stack.delete(object), result
                            case symbolTag:
                              if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other)
                          }
                          return !1
                        })(object, other, objTag, bitmask, customizer, equalFunc, stack)
                  )
                if (!(1 & bitmask)) {
                  var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                    othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__')
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object,
                      othUnwrapped = othIsWrapped ? other.value() : other
                    return (
                      stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)
                    )
                  }
                }
                if (!isSameTag) return !1
                return (
                  stack || (stack = new Stack()),
                  (function (object, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = 1 & bitmask,
                      objProps = getAllKeys(object),
                      objLength = objProps.length,
                      othLength = getAllKeys(other).length
                    if (objLength != othLength && !isPartial) return !1
                    var index = objLength
                    for (; index--; ) {
                      var key = objProps[index]
                      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1
                    }
                    var stacked = stack.get(object)
                    if (stacked && stack.get(other)) return stacked == other
                    var result = !0
                    stack.set(object, other), stack.set(other, object)
                    var skipCtor = isPartial
                    for (; ++index < objLength; ) {
                      var objValue = object[(key = objProps[index])],
                        othValue = other[key]
                      if (customizer)
                        var compared = isPartial
                          ? customizer(othValue, objValue, key, other, object, stack)
                          : customizer(objValue, othValue, key, object, other, stack)
                      if (
                        !(undefined === compared
                          ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)
                          : compared)
                      ) {
                        result = !1
                        break
                      }
                      skipCtor || (skipCtor = 'constructor' == key)
                    }
                    if (result && !skipCtor) {
                      var objCtor = object.constructor,
                        othCtor = other.constructor
                      objCtor == othCtor ||
                        !('constructor' in object) ||
                        !('constructor' in other) ||
                        ('function' == typeof objCtor &&
                          objCtor instanceof objCtor &&
                          'function' == typeof othCtor &&
                          othCtor instanceof othCtor) ||
                        (result = !1)
                    }
                    return stack.delete(object), stack.delete(other), result
                  })(object, other, bitmask, customizer, equalFunc, stack)
                )
              })(value, other, bitmask, customizer, baseIsEqual, stack))
        )
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length,
          length = index,
          noCustomizer = !customizer
        if (null == object) return !length
        for (object = Object(object); index--; ) {
          var data = matchData[index]
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return !1
        }
        for (; ++index < length; ) {
          var key = (data = matchData[index])[0],
            objValue = object[key],
            srcValue = data[1]
          if (noCustomizer && data[2]) {
            if (undefined === objValue && !(key in object)) return !1
          } else {
            var stack = new Stack()
            if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack)
            if (!(undefined === result ? baseIsEqual(srcValue, objValue, 3, customizer, stack) : result)) return !1
          }
        }
        return !0
      }
      function baseIsNative(value) {
        return (
          !(!isObject(value) || ((func = value), maskSrcKey && maskSrcKey in func)) &&
          (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value))
        )
        var func
      }
      function baseIteratee(value) {
        return 'function' == typeof value
          ? value
          : null == value
          ? identity
          : 'object' == typeof value
          ? isArray(value)
            ? baseMatchesProperty(value[0], value[1])
            : baseMatches(value)
          : property(value)
      }
      function baseKeys(object) {
        if (!isPrototype(object)) return nativeKeys(object)
        var result = []
        for (var key in Object(object)) hasOwnProperty.call(object, key) && 'constructor' != key && result.push(key)
        return result
      }
      function baseKeysIn(object) {
        if (!isObject(object))
          return (function (object) {
            var result = []
            if (null != object) for (var key in Object(object)) result.push(key)
            return result
          })(object)
        var isProto = isPrototype(object),
          result = []
        for (var key in object)
          ('constructor' != key || (!isProto && hasOwnProperty.call(object, key))) && result.push(key)
        return result
      }
      function baseLt(value, other) {
        return value < other
      }
      function baseMap(collection, iteratee) {
        var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : []
        return (
          baseEach(collection, function (value, key, collection) {
            result[++index] = iteratee(value, key, collection)
          }),
          result
        )
      }
      function baseMatches(source) {
        var matchData = getMatchData(source)
        return 1 == matchData.length && matchData[0][2]
          ? matchesStrictComparable(matchData[0][0], matchData[0][1])
          : function (object) {
              return object === source || baseIsMatch(object, source, matchData)
            }
      }
      function baseMatchesProperty(path, srcValue) {
        return isKey(path) && isStrictComparable(srcValue)
          ? matchesStrictComparable(toKey(path), srcValue)
          : function (object) {
              var objValue = get(object, path)
              return undefined === objValue && objValue === srcValue
                ? hasIn(object, path)
                : baseIsEqual(srcValue, objValue, 3)
            }
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        object !== source &&
          baseFor(
            source,
            function (srcValue, key) {
              if ((stack || (stack = new Stack()), isObject(srcValue)))
                !(function (object, source, key, srcIndex, mergeFunc, customizer, stack) {
                  var objValue = safeGet(object, key),
                    srcValue = safeGet(source, key),
                    stacked = stack.get(srcValue)
                  if (stacked) return void assignMergeValue(object, key, stacked)
                  var newValue = customizer
                      ? customizer(objValue, srcValue, key + '', object, source, stack)
                      : undefined,
                    isCommon = undefined === newValue
                  if (isCommon) {
                    var isArr = isArray(srcValue),
                      isBuff = !isArr && isBuffer(srcValue),
                      isTyped = !isArr && !isBuff && isTypedArray(srcValue)
                    ;(newValue = srcValue),
                      isArr || isBuff || isTyped
                        ? isArray(objValue)
                          ? (newValue = objValue)
                          : isArrayLikeObject(objValue)
                          ? (newValue = copyArray(objValue))
                          : isBuff
                          ? ((isCommon = !1), (newValue = cloneBuffer(srcValue, !0)))
                          : isTyped
                          ? ((isCommon = !1), (newValue = cloneTypedArray(srcValue, !0)))
                          : (newValue = [])
                        : isPlainObject(srcValue) || isArguments(srcValue)
                        ? ((newValue = objValue),
                          isArguments(objValue)
                            ? (newValue = toPlainObject(objValue))
                            : (isObject(objValue) && !isFunction(objValue)) || (newValue = initCloneObject(srcValue)))
                        : (isCommon = !1)
                  }
                  isCommon &&
                    (stack.set(srcValue, newValue),
                    mergeFunc(newValue, srcValue, srcIndex, customizer, stack),
                    stack.delete(srcValue))
                  assignMergeValue(object, key, newValue)
                })(object, source, key, srcIndex, baseMerge, customizer, stack)
              else {
                var newValue = customizer
                  ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack)
                  : undefined
                undefined === newValue && (newValue = srcValue), assignMergeValue(object, key, newValue)
              }
            },
            keysIn,
          )
      }
      function baseNth(array, n) {
        var length = array.length
        if (length) return isIndex((n += n < 0 ? length : 0), length) ? array[n] : undefined
      }
      function baseOrderBy(collection, iteratees, orders) {
        var index = -1
        return (
          (iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()))),
          (function (array, comparer) {
            var length = array.length
            for (array.sort(comparer); length--; ) array[length] = array[length].value
            return array
          })(
            baseMap(collection, function (value, key, collection) {
              return {
                criteria: arrayMap(iteratees, function (iteratee) {
                  return iteratee(value)
                }),
                index: ++index,
                value,
              }
            }),
            function (object, other) {
              return (function (object, other, orders) {
                var index = -1,
                  objCriteria = object.criteria,
                  othCriteria = other.criteria,
                  length = objCriteria.length,
                  ordersLength = orders.length
                for (; ++index < length; ) {
                  var result = compareAscending(objCriteria[index], othCriteria[index])
                  if (result) return index >= ordersLength ? result : result * ('desc' == orders[index] ? -1 : 1)
                }
                return object.index - other.index
              })(object, other, orders)
            },
          )
        )
      }
      function basePickBy(object, paths, predicate) {
        for (var index = -1, length = paths.length, result = {}; ++index < length; ) {
          var path = paths[index],
            value = baseGet(object, path)
          predicate(value, path) && baseSet(result, castPath(path, object), value)
        }
        return result
      }
      function basePullAll(array, values, iteratee, comparator) {
        var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array
        for (
          array === values && (values = copyArray(values)), iteratee && (seen = arrayMap(array, baseUnary(iteratee)));
          ++index < length;

        )
          for (
            var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
            (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1;

          )
            seen !== array && splice.call(seen, fromIndex, 1), splice.call(array, fromIndex, 1)
        return array
      }
      function basePullAt(array, indexes) {
        for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
          var index = indexes[length]
          if (length == lastIndex || index !== previous) {
            var previous = index
            isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index)
          }
        }
        return array
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
      }
      function baseRepeat(string, n) {
        var result = ''
        if (!string || n < 1 || n > 9007199254740991) return result
        do {
          n % 2 && (result += string), (n = nativeFloor(n / 2)) && (string += string)
        } while (n)
        return result
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + '')
      }
      function baseSample(collection) {
        return arraySample(values(collection))
      }
      function baseSampleSize(collection, n) {
        var array = values(collection)
        return shuffleSelf(array, baseClamp(n, 0, array.length))
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) return object
        for (
          var index = -1, length = (path = castPath(path, object)).length, lastIndex = length - 1, nested = object;
          null != nested && ++index < length;

        ) {
          var key = toKey(path[index]),
            newValue = value
          if (index != lastIndex) {
            var objValue = nested[key]
            undefined === (newValue = customizer ? customizer(objValue, key, nested) : undefined) &&
              (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {})
          }
          assignValue(nested, key, newValue), (nested = nested[key])
        }
        return object
      }
      var baseSetData = metaMap
          ? function (func, data) {
              return metaMap.set(func, data), func
            }
          : identity,
        baseSetToString = defineProperty
          ? function (func, string) {
              return defineProperty(func, 'toString', {
                configurable: !0,
                enumerable: !1,
                value: constant(string),
                writable: !0,
              })
            }
          : identity
      function baseShuffle(collection) {
        return shuffleSelf(values(collection))
      }
      function baseSlice(array, start, end) {
        var index = -1,
          length = array.length
        start < 0 && (start = -start > length ? 0 : length + start),
          (end = end > length ? length : end) < 0 && (end += length),
          (length = start > end ? 0 : (end - start) >>> 0),
          (start >>>= 0)
        for (var result = Array(length); ++index < length; ) result[index] = array[index + start]
        return result
      }
      function baseSome(collection, predicate) {
        var result
        return (
          baseEach(collection, function (value, index, collection) {
            return !(result = predicate(value, index, collection))
          }),
          !!result
        )
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0,
          high = null == array ? low : array.length
        if ('number' == typeof value && value == value && high <= 2147483647) {
          for (; low < high; ) {
            var mid = (low + high) >>> 1,
              computed = array[mid]
            null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)
              ? (low = mid + 1)
              : (high = mid)
          }
          return high
        }
        return baseSortedIndexBy(array, value, identity, retHighest)
      }
      function baseSortedIndexBy(array, value, iteratee, retHighest) {
        value = iteratee(value)
        for (
          var low = 0,
            high = null == array ? 0 : array.length,
            valIsNaN = value != value,
            valIsNull = null === value,
            valIsSymbol = isSymbol(value),
            valIsUndefined = undefined === value;
          low < high;

        ) {
          var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = undefined !== computed,
            othIsNull = null === computed,
            othIsReflexive = computed == computed,
            othIsSymbol = isSymbol(computed)
          if (valIsNaN) var setLow = retHighest || othIsReflexive
          else
            setLow = valIsUndefined
              ? othIsReflexive && (retHighest || othIsDefined)
              : valIsNull
              ? othIsReflexive && othIsDefined && (retHighest || !othIsNull)
              : valIsSymbol
              ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol)
              : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value)
          setLow ? (low = mid + 1) : (high = mid)
        }
        return nativeMin(high, 4294967294)
      }
      function baseSortedUniq(array, iteratee) {
        for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
          var value = array[index],
            computed = iteratee ? iteratee(value) : value
          if (!index || !eq(computed, seen)) {
            var seen = computed
            result[resIndex++] = 0 === value ? 0 : value
          }
        }
        return result
      }
      function baseToNumber(value) {
        return 'number' == typeof value ? value : isSymbol(value) ? NaN : +value
      }
      function baseToString(value) {
        if ('string' == typeof value) return value
        if (isArray(value)) return arrayMap(value, baseToString) + ''
        if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : ''
        var result = value + ''
        return '0' == result && 1 / value == -Infinity ? '-0' : result
      }
      function baseUniq(array, iteratee, comparator) {
        var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = !0,
          result = [],
          seen = result
        if (comparator) (isCommon = !1), (includes = arrayIncludesWith)
        else if (length >= 200) {
          var set = iteratee ? null : createSet(array)
          if (set) return setToArray(set)
          ;(isCommon = !1), (includes = cacheHas), (seen = new SetCache())
        } else seen = iteratee ? [] : result
        outer: for (; ++index < length; ) {
          var value = array[index],
            computed = iteratee ? iteratee(value) : value
          if (((value = comparator || 0 !== value ? value : 0), isCommon && computed == computed)) {
            for (var seenIndex = seen.length; seenIndex--; ) if (seen[seenIndex] === computed) continue outer
            iteratee && seen.push(computed), result.push(value)
          } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), result.push(value))
        }
        return result
      }
      function baseUnset(object, path) {
        return null == (object = parent(object, (path = castPath(path, object)))) || delete object[toKey(last(path))]
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer)
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        for (
          var length = array.length, index = fromRight ? length : -1;
          (fromRight ? index-- : ++index < length) && predicate(array[index], index, array);

        );
        return isDrop
          ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length)
          : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
      }
      function baseWrapperValue(value, actions) {
        var result = value
        return (
          result instanceof LazyWrapper && (result = result.value()),
          arrayReduce(
            actions,
            function (result, action) {
              return action.func.apply(action.thisArg, arrayPush([result], action.args))
            },
            result,
          )
        )
      }
      function baseXor(arrays, iteratee, comparator) {
        var length = arrays.length
        if (length < 2) return length ? baseUniq(arrays[0]) : []
        for (var index = -1, result = Array(length); ++index < length; )
          for (var array = arrays[index], othIndex = -1; ++othIndex < length; )
            othIndex != index &&
              (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator))
        return baseUniq(baseFlatten(result, 1), iteratee, comparator)
      }
      function baseZipObject(props, values, assignFunc) {
        for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length; ) {
          var value = index < valsLength ? values[index] : undefined
          assignFunc(result, props[index], value)
        }
        return result
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : []
      }
      function castFunction(value) {
        return 'function' == typeof value ? value : identity
      }
      function castPath(value, object) {
        return isArray(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value))
      }
      var castRest = baseRest
      function castSlice(array, start, end) {
        var length = array.length
        return (end = undefined === end ? length : end), !start && end >= length ? array : baseSlice(array, start, end)
      }
      var clearTimeout =
        ctxClearTimeout ||
        function (id) {
          return root.clearTimeout(id)
        }
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) return buffer.slice()
        var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length)
        return buffer.copy(result), result
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength)
        return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = undefined !== value,
            valIsNull = null === value,
            valIsReflexive = value == value,
            valIsSymbol = isSymbol(value),
            othIsDefined = undefined !== other,
            othIsNull = null === other,
            othIsReflexive = other == other,
            othIsSymbol = isSymbol(other)
          if (
            (!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive
          )
            return 1
          if (
            (!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive
          )
            return -1
        }
        return 0
      }
      function composeArgs(args, partials, holders, isCurried) {
        for (
          var argsIndex = -1,
            argsLength = args.length,
            holdersLength = holders.length,
            leftIndex = -1,
            leftLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(leftLength + rangeLength),
            isUncurried = !isCurried;
          ++leftIndex < leftLength;

        )
          result[leftIndex] = partials[leftIndex]
        for (; ++argsIndex < holdersLength; )
          (isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex])
        for (; rangeLength--; ) result[leftIndex++] = args[argsIndex++]
        return result
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        for (
          var argsIndex = -1,
            argsLength = args.length,
            holdersIndex = -1,
            holdersLength = holders.length,
            rightIndex = -1,
            rightLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(rangeLength + rightLength),
            isUncurried = !isCurried;
          ++argsIndex < rangeLength;

        )
          result[argsIndex] = args[argsIndex]
        for (var offset = argsIndex; ++rightIndex < rightLength; ) result[offset + rightIndex] = partials[rightIndex]
        for (; ++holdersIndex < holdersLength; )
          (isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++])
        return result
      }
      function copyArray(source, array) {
        var index = -1,
          length = source.length
        for (array || (array = Array(length)); ++index < length; ) array[index] = source[index]
        return array
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object
        object || (object = {})
        for (var index = -1, length = props.length; ++index < length; ) {
          var key = props[index],
            newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined
          undefined === newValue && (newValue = source[key]),
            isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue)
        }
        return object
      }
      function createAggregator(setter, initializer) {
        return function (collection, iteratee) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {}
          return func(collection, setter, getIteratee(iteratee, 2), accumulator)
        }
      }
      function createAssigner(assigner) {
        return baseRest(function (object, sources) {
          var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined
          for (
            customizer = assigner.length > 3 && 'function' == typeof customizer ? (length--, customizer) : undefined,
              guard &&
                isIterateeCall(sources[0], sources[1], guard) &&
                ((customizer = length < 3 ? undefined : customizer), (length = 1)),
              object = Object(object);
            ++index < length;

          ) {
            var source = sources[index]
            source && assigner(object, source, index, customizer)
          }
          return object
        })
      }
      function createBaseEach(eachFunc, fromRight) {
        return function (collection, iteratee) {
          if (null == collection) return collection
          if (!isArrayLike(collection)) return eachFunc(collection, iteratee)
          for (
            var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
            (fromRight ? index-- : ++index < length) && !1 !== iteratee(iterable[index], index, iterable);

          );
          return collection
        }
      }
      function createBaseFor(fromRight) {
        return function (object, iteratee, keysFunc) {
          for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
            var key = props[fromRight ? length : ++index]
            if (!1 === iteratee(iterable[key], key, iterable)) break
          }
          return object
        }
      }
      function createCaseFirst(methodName) {
        return function (string) {
          var strSymbols = hasUnicode((string = toString(string))) ? stringToArray(string) : undefined,
            chr = strSymbols ? strSymbols[0] : string.charAt(0),
            trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1)
          return chr[methodName]() + trailing
        }
      }
      function createCompounder(callback) {
        return function (string) {
          return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '')
        }
      }
      function createCtor(Ctor) {
        return function () {
          var args = arguments
          switch (args.length) {
            case 0:
              return new Ctor()
            case 1:
              return new Ctor(args[0])
            case 2:
              return new Ctor(args[0], args[1])
            case 3:
              return new Ctor(args[0], args[1], args[2])
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3])
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4])
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5])
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
          }
          var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args)
          return isObject(result) ? result : thisBinding
        }
      }
      function createFind(findIndexFunc) {
        return function (collection, predicate, fromIndex) {
          var iterable = Object(collection)
          if (!isArrayLike(collection)) {
            var iteratee = getIteratee(predicate, 3)
            ;(collection = keys(collection)),
              (predicate = function (key) {
                return iteratee(iterable[key], key, iterable)
              })
          }
          var index = findIndexFunc(collection, predicate, fromIndex)
          return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined
        }
      }
      function createFlow(fromRight) {
        return flatRest(function (funcs) {
          var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru
          for (fromRight && funcs.reverse(); index--; ) {
            var func = funcs[index]
            if ('function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
            if (prereq && !wrapper && 'wrapper' == getFuncName(func)) var wrapper = new LodashWrapper([], !0)
          }
          for (index = wrapper ? index : length; ++index < length; ) {
            var funcName = getFuncName((func = funcs[index])),
              data = 'wrapper' == funcName ? getData(func) : undefined
            wrapper =
              data && isLaziable(data[0]) && 424 == data[1] && !data[4].length && 1 == data[9]
                ? wrapper[getFuncName(data[0])].apply(wrapper, data[3])
                : 1 == func.length && isLaziable(func)
                ? wrapper[funcName]()
                : wrapper.thru(func)
          }
          return function () {
            var args = arguments,
              value = args[0]
            if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value()
            for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length; )
              result = funcs[index].call(this, result)
            return result
          }
        })
      }
      function createHybrid(
        func,
        bitmask,
        thisArg,
        partials,
        holders,
        partialsRight,
        holdersRight,
        argPos,
        ary,
        arity,
      ) {
        var isAry = 128 & bitmask,
          isBind = 1 & bitmask,
          isBindKey = 2 & bitmask,
          isCurried = 24 & bitmask,
          isFlip = 512 & bitmask,
          Ctor = isBindKey ? undefined : createCtor(func)
        return function wrapper() {
          for (var length = arguments.length, args = Array(length), index = length; index--; )
            args[index] = arguments[index]
          if (isCurried)
            var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder)
          if (
            (partials && (args = composeArgs(args, partials, holders, isCurried)),
            partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)),
            (length -= holdersCount),
            isCurried && length < arity)
          ) {
            var newHolders = replaceHolders(args, placeholder)
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary,
              arity - length,
            )
          }
          var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func
          return (
            (length = args.length),
            argPos ? (args = reorder(args, argPos)) : isFlip && length > 1 && args.reverse(),
            isAry && ary < length && (args.length = ary),
            this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)),
            fn.apply(thisBinding, args)
          )
        }
      }
      function createInverter(setter, toIteratee) {
        return function (object, iteratee) {
          return (function (object, setter, iteratee, accumulator) {
            return (
              baseForOwn(object, function (value, key, object) {
                setter(accumulator, iteratee(value), key, object)
              }),
              accumulator
            )
          })(object, setter, toIteratee(iteratee), {})
        }
      }
      function createMathOperation(operator, defaultValue) {
        return function (value, other) {
          var result
          if (undefined === value && undefined === other) return defaultValue
          if ((undefined !== value && (result = value), undefined !== other)) {
            if (undefined === result) return other
            'string' == typeof value || 'string' == typeof other
              ? ((value = baseToString(value)), (other = baseToString(other)))
              : ((value = baseToNumber(value)), (other = baseToNumber(other))),
              (result = operator(value, other))
          }
          return result
        }
      }
      function createOver(arrayFunc) {
        return flatRest(function (iteratees) {
          return (
            (iteratees = arrayMap(iteratees, baseUnary(getIteratee()))),
            baseRest(function (args) {
              var thisArg = this
              return arrayFunc(iteratees, function (iteratee) {
                return apply(iteratee, thisArg, args)
              })
            })
          )
        })
      }
      function createPadding(length, chars) {
        var charsLength = (chars = undefined === chars ? ' ' : baseToString(chars)).length
        if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars
        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)))
        return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length)
      }
      function createRange(fromRight) {
        return function (start, end, step) {
          return (
            step && 'number' != typeof step && isIterateeCall(start, end, step) && (end = step = undefined),
            (start = toFinite(start)),
            undefined === end ? ((end = start), (start = 0)) : (end = toFinite(end)),
            (function (start, end, step, fromRight) {
              for (
                var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                length--;

              )
                (result[fromRight ? length : ++index] = start), (start += step)
              return result
            })(start, end, (step = undefined === step ? (start < end ? 1 : -1) : toFinite(step)), fromRight)
          )
        }
      }
      function createRelationalOperation(operator) {
        return function (value, other) {
          return (
            ('string' == typeof value && 'string' == typeof other) ||
              ((value = toNumber(value)), (other = toNumber(other))),
            operator(value, other)
          )
        }
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
        var isCurry = 8 & bitmask
        ;(bitmask |= isCurry ? 32 : 64), 4 & (bitmask &= ~(isCurry ? 64 : 32)) || (bitmask &= -4)
        var newData = [
            func,
            bitmask,
            thisArg,
            isCurry ? partials : undefined,
            isCurry ? holders : undefined,
            isCurry ? undefined : partials,
            isCurry ? undefined : holders,
            argPos,
            ary,
            arity,
          ],
          result = wrapFunc.apply(undefined, newData)
        return (
          isLaziable(func) && setData(result, newData),
          (result.placeholder = placeholder),
          setWrapToString(result, func, bitmask)
        )
      }
      function createRound(methodName) {
        var func = Math[methodName]
        return function (number, precision) {
          if (
            ((number = toNumber(number)),
            (precision = null == precision ? 0 : nativeMin(toInteger(precision), 292)) && nativeIsFinite(number))
          ) {
            var pair = (toString(number) + 'e').split('e')
            return +(
              (pair = (toString(func(pair[0] + 'e' + (+pair[1] + precision))) + 'e').split('e'))[0] +
              'e' +
              (+pair[1] - precision)
            )
          }
          return func(number)
        }
      }
      var createSet =
        Set && 1 / setToArray(new Set([, -0]))[1] == Infinity
          ? function (values) {
              return new Set(values)
            }
          : noop
      function createToPairs(keysFunc) {
        return function (object) {
          var tag = getTag(object)
          return tag == mapTag
            ? mapToArray(object)
            : tag == setTag
            ? setToPairs(object)
            : (function (object, props) {
                return arrayMap(props, function (key) {
                  return [key, object[key]]
                })
              })(object, keysFunc(object))
        }
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
        var isBindKey = 2 & bitmask
        if (!isBindKey && 'function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
        var length = partials ? partials.length : 0
        if (
          (length || ((bitmask &= -97), (partials = holders = undefined)),
          (ary = undefined === ary ? ary : nativeMax(toInteger(ary), 0)),
          (arity = undefined === arity ? arity : toInteger(arity)),
          (length -= holders ? holders.length : 0),
          64 & bitmask)
        ) {
          var partialsRight = partials,
            holdersRight = holders
          partials = holders = undefined
        }
        var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity]
        if (
          (data &&
            (function (data, source) {
              var bitmask = data[1],
                srcBitmask = source[1],
                newBitmask = bitmask | srcBitmask,
                isCommon = newBitmask < 131,
                isCombo =
                  (128 == srcBitmask && 8 == bitmask) ||
                  (128 == srcBitmask && 256 == bitmask && data[7].length <= source[8]) ||
                  (384 == srcBitmask && source[7].length <= source[8] && 8 == bitmask)
              if (!isCommon && !isCombo) return data
              1 & srcBitmask && ((data[2] = source[2]), (newBitmask |= 1 & bitmask ? 0 : 4))
              var value = source[3]
              if (value) {
                var partials = data[3]
                ;(data[3] = partials ? composeArgs(partials, value, source[4]) : value),
                  (data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4])
              }
              ;(value = source[5]) &&
                ((partials = data[5]),
                (data[5] = partials ? composeArgsRight(partials, value, source[6]) : value),
                (data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]))
              ;(value = source[7]) && (data[7] = value)
              128 & srcBitmask && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8]))
              null == data[9] && (data[9] = source[9])
              ;(data[0] = source[0]), (data[1] = newBitmask)
            })(newData, data),
          (func = newData[0]),
          (bitmask = newData[1]),
          (thisArg = newData[2]),
          (partials = newData[3]),
          (holders = newData[4]),
          !(arity = newData[9] =
            undefined === newData[9] ? (isBindKey ? 0 : func.length) : nativeMax(newData[9] - length, 0)) &&
            24 & bitmask &&
            (bitmask &= -25),
          bitmask && 1 != bitmask)
        )
          result =
            8 == bitmask || 16 == bitmask
              ? (function (func, bitmask, arity) {
                  var Ctor = createCtor(func)
                  return function wrapper() {
                    for (
                      var length = arguments.length,
                        args = Array(length),
                        index = length,
                        placeholder = getHolder(wrapper);
                      index--;

                    )
                      args[index] = arguments[index]
                    var holders =
                      length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder
                        ? []
                        : replaceHolders(args, placeholder)
                    return (length -= holders.length) < arity
                      ? createRecurry(
                          func,
                          bitmask,
                          createHybrid,
                          wrapper.placeholder,
                          void 0,
                          args,
                          holders,
                          void 0,
                          void 0,
                          arity - length,
                        )
                      : apply(this && this !== root && this instanceof wrapper ? Ctor : func, this, args)
                  }
                })(func, bitmask, arity)
              : (32 != bitmask && 33 != bitmask) || holders.length
              ? createHybrid.apply(undefined, newData)
              : (function (func, bitmask, thisArg, partials) {
                  var isBind = 1 & bitmask,
                    Ctor = createCtor(func)
                  return function wrapper() {
                    for (
                      var argsIndex = -1,
                        argsLength = arguments.length,
                        leftIndex = -1,
                        leftLength = partials.length,
                        args = Array(leftLength + argsLength),
                        fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                      ++leftIndex < leftLength;

                    )
                      args[leftIndex] = partials[leftIndex]
                    for (; argsLength--; ) args[leftIndex++] = arguments[++argsIndex]
                    return apply(fn, isBind ? thisArg : this, args)
                  }
                })(func, bitmask, thisArg, partials)
        else
          var result = (function (func, bitmask, thisArg) {
            var isBind = 1 & bitmask,
              Ctor = createCtor(func)
            return function wrapper() {
              return (this && this !== root && this instanceof wrapper ? Ctor : func).apply(
                isBind ? thisArg : this,
                arguments,
              )
            }
          })(func, bitmask, thisArg)
        return setWrapToString((data ? baseSetData : setData)(result, newData), func, bitmask)
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        return undefined === objValue || (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))
          ? srcValue
          : objValue
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        return (
          isObject(objValue) &&
            isObject(srcValue) &&
            (stack.set(srcValue, objValue),
            baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack),
            stack.delete(srcValue)),
          objValue
        )
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined : value
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = 1 & bitmask,
          arrLength = array.length,
          othLength = other.length
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1
        var stacked = stack.get(array)
        if (stacked && stack.get(other)) return stacked == other
        var index = -1,
          result = !0,
          seen = 2 & bitmask ? new SetCache() : undefined
        for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
          var arrValue = array[index],
            othValue = other[index]
          if (customizer)
            var compared = isPartial
              ? customizer(othValue, arrValue, index, other, array, stack)
              : customizer(arrValue, othValue, index, array, other, stack)
          if (undefined !== compared) {
            if (compared) continue
            result = !1
            break
          }
          if (seen) {
            if (
              !arraySome(other, function (othValue, othIndex) {
                if (
                  !cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))
                )
                  return seen.push(othIndex)
              })
            ) {
              result = !1
              break
            }
          } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
            result = !1
            break
          }
        }
        return stack.delete(array), stack.delete(other), result
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined, flatten), func + '')
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols)
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn)
      }
      var getData = metaMap
        ? function (func) {
            return metaMap.get(func)
          }
        : noop
      function getFuncName(func) {
        for (
          var result = func.name + '',
            array = realNames[result],
            length = hasOwnProperty.call(realNames, result) ? array.length : 0;
          length--;

        ) {
          var data = array[length],
            otherFunc = data.func
          if (null == otherFunc || otherFunc == func) return data.name
        }
        return result
      }
      function getHolder(func) {
        return (hasOwnProperty.call(lodash, 'placeholder') ? lodash : func).placeholder
      }
      function getIteratee() {
        var result = lodash.iteratee || iteratee
        return (
          (result = result === iteratee ? baseIteratee : result),
          arguments.length ? result(arguments[0], arguments[1]) : result
        )
      }
      function getMapData(map, key) {
        var value,
          type,
          data = map.__data__
        return (
          'string' == (type = typeof (value = key)) || 'number' == type || 'symbol' == type || 'boolean' == type
            ? '__proto__' !== value
            : null === value
        )
          ? data['string' == typeof key ? 'string' : 'hash']
          : data.map
      }
      function getMatchData(object) {
        for (var result = keys(object), length = result.length; length--; ) {
          var key = result[length],
            value = object[key]
          result[length] = [key, value, isStrictComparable(value)]
        }
        return result
      }
      function getNative(object, key) {
        var value = (function (object, key) {
          return null == object ? void 0 : object[key]
        })(object, key)
        return baseIsNative(value) ? value : undefined
      }
      var getSymbols = nativeGetSymbols
          ? function (object) {
              return null == object
                ? []
                : ((object = Object(object)),
                  arrayFilter(nativeGetSymbols(object), function (symbol) {
                    return propertyIsEnumerable.call(object, symbol)
                  }))
            }
          : stubArray,
        getSymbolsIn = nativeGetSymbols
          ? function (object) {
              for (var result = []; object; ) arrayPush(result, getSymbols(object)), (object = getPrototype(object))
              return result
            }
          : stubArray,
        getTag = baseGetTag
      function hasPath(object, path, hasFunc) {
        for (var index = -1, length = (path = castPath(path, object)).length, result = !1; ++index < length; ) {
          var key = toKey(path[index])
          if (!(result = null != object && hasFunc(object, key))) break
          object = object[key]
        }
        return result || ++index != length
          ? result
          : !!(length = null == object ? 0 : object.length) &&
              isLength(length) &&
              isIndex(key, length) &&
              (isArray(object) || isArguments(object))
      }
      function initCloneObject(object) {
        return 'function' != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object))
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol])
      }
      function isIndex(value, length) {
        var type = typeof value
        return (
          !!(length = null == length ? 9007199254740991 : length) &&
          ('number' == type || ('symbol' != type && reIsUint.test(value))) &&
          value > -1 &&
          value % 1 == 0 &&
          value < length
        )
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) return !1
        var type = typeof index
        return (
          !!('number' == type
            ? isArrayLike(object) && isIndex(index, object.length)
            : 'string' == type && index in object) && eq(object[index], value)
        )
      }
      function isKey(value, object) {
        if (isArray(value)) return !1
        var type = typeof value
        return (
          !('number' != type && 'symbol' != type && 'boolean' != type && null != value && !isSymbol(value)) ||
          reIsPlainProp.test(value) ||
          !reIsDeepProp.test(value) ||
          (null != object && value in Object(object))
        )
      }
      function isLaziable(func) {
        var funcName = getFuncName(func),
          other = lodash[funcName]
        if ('function' != typeof other || !(funcName in LazyWrapper.prototype)) return !1
        if (func === other) return !0
        var data = getData(other)
        return !!data && func === data[0]
      }
      ;((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map()) != mapTag) ||
        (Promise && '[object Promise]' != getTag(Promise.resolve())) ||
        (Set && getTag(new Set()) != setTag) ||
        (WeakMap && getTag(new WeakMap()) != weakMapTag)) &&
        (getTag = function (value) {
          var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : ''
          if (ctorString)
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag
              case mapCtorString:
                return mapTag
              case promiseCtorString:
                return '[object Promise]'
              case setCtorString:
                return setTag
              case weakMapCtorString:
                return weakMapTag
            }
          return result
        })
      var isMaskable = coreJsData ? isFunction : stubFalse
      function isPrototype(value) {
        var Ctor = value && value.constructor
        return value === (('function' == typeof Ctor && Ctor.prototype) || objectProto)
      }
      function isStrictComparable(value) {
        return value == value && !isObject(value)
      }
      function matchesStrictComparable(key, srcValue) {
        return function (object) {
          return null != object && object[key] === srcValue && (undefined !== srcValue || key in Object(object))
        }
      }
      function overRest(func, start, transform) {
        return (
          (start = nativeMax(undefined === start ? func.length - 1 : start, 0)),
          function () {
            for (
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
              ++index < length;

            )
              array[index] = args[start + index]
            index = -1
            for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index]
            return (otherArgs[start] = transform(array)), apply(func, this, otherArgs)
          }
        )
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1))
      }
      function reorder(array, indexes) {
        for (
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          length--;

        ) {
          var index = indexes[length]
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
        }
        return array
      }
      function safeGet(object, key) {
        if (('constructor' !== key || 'function' != typeof object[key]) && '__proto__' != key) return object[key]
      }
      var setData = shortOut(baseSetData),
        setTimeout =
          ctxSetTimeout ||
          function (func, wait) {
            return root.setTimeout(func, wait)
          },
        setToString = shortOut(baseSetToString)
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + ''
        return setToString(
          wrapper,
          (function (source, details) {
            var length = details.length
            if (!length) return source
            var lastIndex = length - 1
            return (
              (details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex]),
              (details = details.join(length > 2 ? ', ' : ' ')),
              source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n')
            )
          })(
            source,
            (function (details, bitmask) {
              return (
                arrayEach(wrapFlags, function (pair) {
                  var value = '_.' + pair[0]
                  bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value)
                }),
                details.sort()
              )
            })(
              (function (source) {
                var match = source.match(reWrapDetails)
                return match ? match[1].split(reSplitDetails) : []
              })(source),
              bitmask,
            ),
          ),
        )
      }
      function shortOut(func) {
        var count = 0,
          lastCalled = 0
        return function () {
          var stamp = nativeNow(),
            remaining = 16 - (stamp - lastCalled)
          if (((lastCalled = stamp), remaining > 0)) {
            if (++count >= 800) return arguments[0]
          } else count = 0
          return func.apply(undefined, arguments)
        }
      }
      function shuffleSelf(array, size) {
        var index = -1,
          length = array.length,
          lastIndex = length - 1
        for (size = undefined === size ? length : size; ++index < size; ) {
          var rand = baseRandom(index, lastIndex),
            value = array[rand]
          ;(array[rand] = array[index]), (array[index] = value)
        }
        return (array.length = size), array
      }
      var stringToPath = (function (func) {
        var result = memoize(func, function (key) {
            return 500 === cache.size && cache.clear(), key
          }),
          cache = result.cache
        return result
      })(function (string) {
        var result = []
        return (
          46 === string.charCodeAt(0) && result.push(''),
          string.replace(rePropName, function (match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match)
          }),
          result
        )
      })
      function toKey(value) {
        if ('string' == typeof value || isSymbol(value)) return value
        var result = value + ''
        return '0' == result && 1 / value == -Infinity ? '-0' : result
      }
      function toSource(func) {
        if (null != func) {
          try {
            return funcToString.call(func)
          } catch (e) {}
          try {
            return func + ''
          } catch (e) {}
        }
        return ''
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) return wrapper.clone()
        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__)
        return (
          (result.__actions__ = copyArray(wrapper.__actions__)),
          (result.__index__ = wrapper.__index__),
          (result.__values__ = wrapper.__values__),
          result
        )
      }
      var difference = baseRest(function (array, values) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : []
        }),
        differenceBy = baseRest(function (array, values) {
          var iteratee = last(values)
          return (
            isArrayLikeObject(iteratee) && (iteratee = undefined),
            isArrayLikeObject(array)
              ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2))
              : []
          )
        }),
        differenceWith = baseRest(function (array, values) {
          var comparator = last(values)
          return (
            isArrayLikeObject(comparator) && (comparator = undefined),
            isArrayLikeObject(array)
              ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), undefined, comparator)
              : []
          )
        })
      function findIndex(array, predicate, fromIndex) {
        var length = null == array ? 0 : array.length
        if (!length) return -1
        var index = null == fromIndex ? 0 : toInteger(fromIndex)
        return (
          index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index)
        )
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = null == array ? 0 : array.length
        if (!length) return -1
        var index = length - 1
        return (
          undefined !== fromIndex &&
            ((index = toInteger(fromIndex)),
            (index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1))),
          baseFindIndex(array, getIteratee(predicate, 3), index, !0)
        )
      }
      function flatten(array) {
        return (null == array ? 0 : array.length) ? baseFlatten(array, 1) : []
      }
      function head(array) {
        return array && array.length ? array[0] : undefined
      }
      var intersection = baseRest(function (arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject)
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : []
        }),
        intersectionBy = baseRest(function (arrays) {
          var iteratee = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject)
          return (
            iteratee === last(mapped) ? (iteratee = undefined) : mapped.pop(),
            mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : []
          )
        }),
        intersectionWith = baseRest(function (arrays) {
          var comparator = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject)
          return (
            (comparator = 'function' == typeof comparator ? comparator : undefined) && mapped.pop(),
            mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : []
          )
        })
      function last(array) {
        var length = null == array ? 0 : array.length
        return length ? array[length - 1] : undefined
      }
      var pull = baseRest(pullAll)
      function pullAll(array, values) {
        return array && array.length && values && values.length ? basePullAll(array, values) : array
      }
      var pullAt = flatRest(function (array, indexes) {
        var length = null == array ? 0 : array.length,
          result = baseAt(array, indexes)
        return (
          basePullAt(
            array,
            arrayMap(indexes, function (index) {
              return isIndex(index, length) ? +index : index
            }).sort(compareAscending),
          ),
          result
        )
      })
      function reverse(array) {
        return null == array ? array : nativeReverse.call(array)
      }
      var union = baseRest(function (arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0))
        }),
        unionBy = baseRest(function (arrays) {
          var iteratee = last(arrays)
          return (
            isArrayLikeObject(iteratee) && (iteratee = undefined),
            baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2))
          )
        }),
        unionWith = baseRest(function (arrays) {
          var comparator = last(arrays)
          return (
            (comparator = 'function' == typeof comparator ? comparator : undefined),
            baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined, comparator)
          )
        })
      function unzip(array) {
        if (!array || !array.length) return []
        var length = 0
        return (
          (array = arrayFilter(array, function (group) {
            if (isArrayLikeObject(group)) return (length = nativeMax(group.length, length)), !0
          })),
          baseTimes(length, function (index) {
            return arrayMap(array, baseProperty(index))
          })
        )
      }
      function unzipWith(array, iteratee) {
        if (!array || !array.length) return []
        var result = unzip(array)
        return null == iteratee
          ? result
          : arrayMap(result, function (group) {
              return apply(iteratee, undefined, group)
            })
      }
      var without = baseRest(function (array, values) {
          return isArrayLikeObject(array) ? baseDifference(array, values) : []
        }),
        xor = baseRest(function (arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject))
        }),
        xorBy = baseRest(function (arrays) {
          var iteratee = last(arrays)
          return (
            isArrayLikeObject(iteratee) && (iteratee = undefined),
            baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2))
          )
        }),
        xorWith = baseRest(function (arrays) {
          var comparator = last(arrays)
          return (
            (comparator = 'function' == typeof comparator ? comparator : undefined),
            baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator)
          )
        }),
        zip = baseRest(unzip)
      var zipWith = baseRest(function (arrays) {
        var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined
        return (
          (iteratee = 'function' == typeof iteratee ? (arrays.pop(), iteratee) : undefined), unzipWith(arrays, iteratee)
        )
      })
      function chain(value) {
        var result = lodash(value)
        return (result.__chain__ = !0), result
      }
      function thru(value, interceptor) {
        return interceptor(value)
      }
      var wrapperAt = flatRest(function (paths) {
        var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function (object) {
            return baseAt(object, paths)
          }
        return !(length > 1 || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start)
          ? ((value = value.slice(start, +start + (length ? 1 : 0))).__actions__.push({
              func: thru,
              args: [interceptor],
              thisArg: undefined,
            }),
            new LodashWrapper(value, this.__chain__).thru(function (array) {
              return length && !array.length && array.push(undefined), array
            }))
          : this.thru(interceptor)
      })
      var countBy = createAggregator(function (result, value, key) {
        hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1)
      })
      var find = createFind(findIndex),
        findLast = createFind(findLastIndex)
      function forEach(collection, iteratee) {
        return (isArray(collection) ? arrayEach : baseEach)(collection, getIteratee(iteratee, 3))
      }
      function forEachRight(collection, iteratee) {
        return (isArray(collection) ? arrayEachRight : baseEachRight)(collection, getIteratee(iteratee, 3))
      }
      var groupBy = createAggregator(function (result, value, key) {
        hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [value])
      })
      var invokeMap = baseRest(function (collection, path, args) {
          var index = -1,
            isFunc = 'function' == typeof path,
            result = isArrayLike(collection) ? Array(collection.length) : []
          return (
            baseEach(collection, function (value) {
              result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args)
            }),
            result
          )
        }),
        keyBy = createAggregator(function (result, value, key) {
          baseAssignValue(result, key, value)
        })
      function map(collection, iteratee) {
        return (isArray(collection) ? arrayMap : baseMap)(collection, getIteratee(iteratee, 3))
      }
      var partition = createAggregator(
        function (result, value, key) {
          result[key ? 0 : 1].push(value)
        },
        function () {
          return [[], []]
        },
      )
      var sortBy = baseRest(function (collection, iteratees) {
          if (null == collection) return []
          var length = iteratees.length
          return (
            length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])
              ? (iteratees = [])
              : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]),
            baseOrderBy(collection, baseFlatten(iteratees, 1), [])
          )
        }),
        now =
          ctxNow ||
          function () {
            return root.Date.now()
          }
      function ary(func, n, guard) {
        return (
          (n = guard ? undefined : n),
          createWrap(func, 128, undefined, undefined, undefined, undefined, (n = func && null == n ? func.length : n))
        )
      }
      function before(n, func) {
        var result
        if ('function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
        return (
          (n = toInteger(n)),
          function () {
            return --n > 0 && (result = func.apply(this, arguments)), n <= 1 && (func = undefined), result
          }
        )
      }
      var bind = baseRest(function (func, thisArg, partials) {
          var bitmask = 1
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind))
            bitmask |= 32
          }
          return createWrap(func, bitmask, thisArg, partials, holders)
        }),
        bindKey = baseRest(function (object, key, partials) {
          var bitmask = 3
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey))
            bitmask |= 32
          }
          return createWrap(key, bitmask, object, partials, holders)
        })
      function debounce(func, wait, options) {
        var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = !1,
          maxing = !1,
          trailing = !0
        if ('function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
        function invokeFunc(time) {
          var args = lastArgs,
            thisArg = lastThis
          return (lastArgs = lastThis = undefined), (lastInvokeTime = time), (result = func.apply(thisArg, args))
        }
        function leadingEdge(time) {
          return (
            (lastInvokeTime = time), (timerId = setTimeout(timerExpired, wait)), leading ? invokeFunc(time) : result
          )
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime
          return (
            undefined === lastCallTime ||
            timeSinceLastCall >= wait ||
            timeSinceLastCall < 0 ||
            (maxing && time - lastInvokeTime >= maxWait)
          )
        }
        function timerExpired() {
          var time = now()
          if (shouldInvoke(time)) return trailingEdge(time)
          timerId = setTimeout(
            timerExpired,
            (function (time) {
              var timeWaiting = wait - (time - lastCallTime)
              return maxing ? nativeMin(timeWaiting, maxWait - (time - lastInvokeTime)) : timeWaiting
            })(time),
          )
        }
        function trailingEdge(time) {
          return (
            (timerId = undefined), trailing && lastArgs ? invokeFunc(time) : ((lastArgs = lastThis = undefined), result)
          )
        }
        function debounced() {
          var time = now(),
            isInvoking = shouldInvoke(time)
          if (((lastArgs = arguments), (lastThis = this), (lastCallTime = time), isInvoking)) {
            if (undefined === timerId) return leadingEdge(lastCallTime)
            if (maxing)
              return clearTimeout(timerId), (timerId = setTimeout(timerExpired, wait)), invokeFunc(lastCallTime)
          }
          return undefined === timerId && (timerId = setTimeout(timerExpired, wait)), result
        }
        return (
          (wait = toNumber(wait) || 0),
          isObject(options) &&
            ((leading = !!options.leading),
            (maxWait = (maxing = 'maxWait' in options) ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait),
            (trailing = 'trailing' in options ? !!options.trailing : trailing)),
          (debounced.cancel = function () {
            undefined !== timerId && clearTimeout(timerId),
              (lastInvokeTime = 0),
              (lastArgs = lastCallTime = lastThis = timerId = undefined)
          }),
          (debounced.flush = function () {
            return undefined === timerId ? result : trailingEdge(now())
          }),
          debounced
        )
      }
      var defer = baseRest(function (func, args) {
          return baseDelay(func, 1, args)
        }),
        delay = baseRest(function (func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args)
        })
      function memoize(func, resolver) {
        if ('function' != typeof func || (null != resolver && 'function' != typeof resolver))
          throw new TypeError(FUNC_ERROR_TEXT)
        var memoized = function memoized() {
          var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache
          if (cache.has(key)) return cache.get(key)
          var result = func.apply(this, args)
          return (memoized.cache = cache.set(key, result) || cache), result
        }
        return (memoized.cache = new (memoize.Cache || MapCache)()), memoized
      }
      function negate(predicate) {
        if ('function' != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT)
        return function () {
          var args = arguments
          switch (args.length) {
            case 0:
              return !predicate.call(this)
            case 1:
              return !predicate.call(this, args[0])
            case 2:
              return !predicate.call(this, args[0], args[1])
            case 3:
              return !predicate.call(this, args[0], args[1], args[2])
          }
          return !predicate.apply(this, args)
        }
      }
      memoize.Cache = MapCache
      var overArgs = castRest(function (func, transforms) {
          var funcsLength = (transforms =
            1 == transforms.length && isArray(transforms[0])
              ? arrayMap(transforms[0], baseUnary(getIteratee()))
              : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()))).length
          return baseRest(function (args) {
            for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; )
              args[index] = transforms[index].call(this, args[index])
            return apply(func, this, args)
          })
        }),
        partial = baseRest(function (func, partials) {
          return createWrap(func, 32, undefined, partials, replaceHolders(partials, getHolder(partial)))
        }),
        partialRight = baseRest(function (func, partials) {
          return createWrap(func, 64, undefined, partials, replaceHolders(partials, getHolder(partialRight)))
        }),
        rearg = flatRest(function (func, indexes) {
          return createWrap(func, 256, undefined, undefined, undefined, indexes)
        })
      function eq(value, other) {
        return value === other || (value != value && other != other)
      }
      var gt = createRelationalOperation(baseGt),
        gte = createRelationalOperation(function (value, other) {
          return value >= other
        }),
        isArguments = baseIsArguments(
          (function () {
            return arguments
          })(),
        )
          ? baseIsArguments
          : function (value) {
              return (
                isObjectLike(value) &&
                hasOwnProperty.call(value, 'callee') &&
                !propertyIsEnumerable.call(value, 'callee')
              )
            },
        isArray = Array.isArray,
        isArrayBuffer = nodeIsArrayBuffer
          ? baseUnary(nodeIsArrayBuffer)
          : function (value) {
              return isObjectLike(value) && baseGetTag(value) == arrayBufferTag
            }
      function isArrayLike(value) {
        return null != value && isLength(value.length) && !isFunction(value)
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value)
      }
      var isBuffer = nativeIsBuffer || stubFalse,
        isDate = nodeIsDate
          ? baseUnary(nodeIsDate)
          : function (value) {
              return isObjectLike(value) && baseGetTag(value) == dateTag
            }
      function isError(value) {
        if (!isObjectLike(value)) return !1
        var tag = baseGetTag(value)
        return (
          tag == errorTag ||
          '[object DOMException]' == tag ||
          ('string' == typeof value.message && 'string' == typeof value.name && !isPlainObject(value))
        )
      }
      function isFunction(value) {
        if (!isObject(value)) return !1
        var tag = baseGetTag(value)
        return tag == funcTag || tag == genTag || '[object AsyncFunction]' == tag || '[object Proxy]' == tag
      }
      function isInteger(value) {
        return 'number' == typeof value && value == toInteger(value)
      }
      function isLength(value) {
        return 'number' == typeof value && value > -1 && value % 1 == 0 && value <= 9007199254740991
      }
      function isObject(value) {
        var type = typeof value
        return null != value && ('object' == type || 'function' == type)
      }
      function isObjectLike(value) {
        return null != value && 'object' == typeof value
      }
      var isMap = nodeIsMap
        ? baseUnary(nodeIsMap)
        : function (value) {
            return isObjectLike(value) && getTag(value) == mapTag
          }
      function isNumber(value) {
        return 'number' == typeof value || (isObjectLike(value) && baseGetTag(value) == numberTag)
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1
        var proto = getPrototype(value)
        if (null === proto) return !0
        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor
        return 'function' == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
      }
      var isRegExp = nodeIsRegExp
        ? baseUnary(nodeIsRegExp)
        : function (value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag
          }
      var isSet = nodeIsSet
        ? baseUnary(nodeIsSet)
        : function (value) {
            return isObjectLike(value) && getTag(value) == setTag
          }
      function isString(value) {
        return 'string' == typeof value || (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag)
      }
      function isSymbol(value) {
        return 'symbol' == typeof value || (isObjectLike(value) && baseGetTag(value) == symbolTag)
      }
      var isTypedArray = nodeIsTypedArray
        ? baseUnary(nodeIsTypedArray)
        : function (value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]
          }
      var lt = createRelationalOperation(baseLt),
        lte = createRelationalOperation(function (value, other) {
          return value <= other
        })
      function toArray(value) {
        if (!value) return []
        if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value)
        if (symIterator && value[symIterator])
          return (function (iterator) {
            for (var data, result = []; !(data = iterator.next()).done; ) result.push(data.value)
            return result
          })(value[symIterator]())
        var tag = getTag(value)
        return (tag == mapTag ? mapToArray : tag == setTag ? setToArray : values)(value)
      }
      function toFinite(value) {
        return value
          ? Infinity === (value = toNumber(value)) || -Infinity === value
            ? 17976931348623157e292 * (value < 0 ? -1 : 1)
            : value == value
            ? value
            : 0
          : 0 === value
          ? value
          : 0
      }
      function toInteger(value) {
        var result = toFinite(value),
          remainder = result % 1
        return result == result ? (remainder ? result - remainder : result) : 0
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, 4294967295) : 0
      }
      function toNumber(value) {
        if ('number' == typeof value) return value
        if (isSymbol(value)) return NaN
        if (isObject(value)) {
          var other = 'function' == typeof value.valueOf ? value.valueOf() : value
          value = isObject(other) ? other + '' : other
        }
        if ('string' != typeof value) return 0 === value ? value : +value
        value = value.replace(reTrim, '')
        var isBinary = reIsBinary.test(value)
        return isBinary || reIsOctal.test(value)
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : reIsBadHex.test(value)
          ? NaN
          : +value
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value))
      }
      function toString(value) {
        return null == value ? '' : baseToString(value)
      }
      var assign = createAssigner(function (object, source) {
          if (isPrototype(source) || isArrayLike(source)) copyObject(source, keys(source), object)
          else for (var key in source) hasOwnProperty.call(source, key) && assignValue(object, key, source[key])
        }),
        assignIn = createAssigner(function (object, source) {
          copyObject(source, keysIn(source), object)
        }),
        assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer)
        }),
        assignWith = createAssigner(function (object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer)
        }),
        at = flatRest(baseAt)
      var defaults = baseRest(function (object, sources) {
          object = Object(object)
          var index = -1,
            length = sources.length,
            guard = length > 2 ? sources[2] : undefined
          for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; )
            for (
              var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length;
              ++propsIndex < propsLength;

            ) {
              var key = props[propsIndex],
                value = object[key]
              ;(undefined === value || (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) &&
                (object[key] = source[key])
            }
          return object
        }),
        defaultsDeep = baseRest(function (args) {
          return args.push(undefined, customDefaultsMerge), apply(mergeWith, undefined, args)
        })
      function get(object, path, defaultValue) {
        var result = null == object ? undefined : baseGet(object, path)
        return undefined === result ? defaultValue : result
      }
      function hasIn(object, path) {
        return null != object && hasPath(object, path, baseHasIn)
      }
      var invert = createInverter(function (result, value, key) {
          null != value && 'function' != typeof value.toString && (value = nativeObjectToString.call(value)),
            (result[value] = key)
        }, constant(identity)),
        invertBy = createInverter(function (result, value, key) {
          null != value && 'function' != typeof value.toString && (value = nativeObjectToString.call(value)),
            hasOwnProperty.call(result, value) ? result[value].push(key) : (result[value] = [key])
        }, getIteratee),
        invoke = baseRest(baseInvoke)
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object)
      }
      var merge = createAssigner(function (object, source, srcIndex) {
          baseMerge(object, source, srcIndex)
        }),
        mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer)
        }),
        omit = flatRest(function (object, paths) {
          var result = {}
          if (null == object) return result
          var isDeep = !1
          ;(paths = arrayMap(paths, function (path) {
            return (path = castPath(path, object)), isDeep || (isDeep = path.length > 1), path
          })),
            copyObject(object, getAllKeysIn(object), result),
            isDeep && (result = baseClone(result, 7, customOmitClone))
          for (var length = paths.length; length--; ) baseUnset(result, paths[length])
          return result
        })
      var pick = flatRest(function (object, paths) {
        return null == object
          ? {}
          : (function (object, paths) {
              return basePickBy(object, paths, function (value, path) {
                return hasIn(object, path)
              })
            })(object, paths)
      })
      function pickBy(object, predicate) {
        if (null == object) return {}
        var props = arrayMap(getAllKeysIn(object), function (prop) {
          return [prop]
        })
        return (
          (predicate = getIteratee(predicate)),
          basePickBy(object, props, function (value, path) {
            return predicate(value, path[0])
          })
        )
      }
      var toPairs = createToPairs(keys),
        toPairsIn = createToPairs(keysIn)
      function values(object) {
        return null == object ? [] : baseValues(object, keys(object))
      }
      var camelCase = createCompounder(function (result, word, index) {
        return (word = word.toLowerCase()), result + (index ? capitalize(word) : word)
      })
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase())
      }
      function deburr(string) {
        return (string = toString(string)) && string.replace(reLatin, deburrLetter).replace(reComboMark, '')
      }
      var kebabCase = createCompounder(function (result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase()
        }),
        lowerCase = createCompounder(function (result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase()
        }),
        lowerFirst = createCaseFirst('toLowerCase')
      var snakeCase = createCompounder(function (result, word, index) {
        return result + (index ? '_' : '') + word.toLowerCase()
      })
      var startCase = createCompounder(function (result, word, index) {
        return result + (index ? ' ' : '') + upperFirst(word)
      })
      var upperCase = createCompounder(function (result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase()
        }),
        upperFirst = createCaseFirst('toUpperCase')
      function words(string, pattern, guard) {
        return (
          (string = toString(string)),
          undefined === (pattern = guard ? undefined : pattern)
            ? (function (string) {
                return reHasUnicodeWord.test(string)
              })(string)
              ? (function (string) {
                  return string.match(reUnicodeWord) || []
                })(string)
              : (function (string) {
                  return string.match(reAsciiWord) || []
                })(string)
            : string.match(pattern) || []
        )
      }
      var attempt = baseRest(function (func, args) {
          try {
            return apply(func, undefined, args)
          } catch (e) {
            return isError(e) ? e : new Error(e)
          }
        }),
        bindAll = flatRest(function (object, methodNames) {
          return (
            arrayEach(methodNames, function (key) {
              ;(key = toKey(key)), baseAssignValue(object, key, bind(object[key], object))
            }),
            object
          )
        })
      function constant(value) {
        return function () {
          return value
        }
      }
      var flow = createFlow(),
        flowRight = createFlow(!0)
      function identity(value) {
        return value
      }
      function iteratee(func) {
        return baseIteratee('function' == typeof func ? func : baseClone(func, 1))
      }
      var method = baseRest(function (path, args) {
          return function (object) {
            return baseInvoke(object, path, args)
          }
        }),
        methodOf = baseRest(function (object, args) {
          return function (path) {
            return baseInvoke(object, path, args)
          }
        })
      function mixin(object, source, options) {
        var props = keys(source),
          methodNames = baseFunctions(source, props)
        null != options ||
          (isObject(source) && (methodNames.length || !props.length)) ||
          ((options = source), (source = object), (object = this), (methodNames = baseFunctions(source, keys(source))))
        var chain = !(isObject(options) && 'chain' in options && !options.chain),
          isFunc = isFunction(object)
        return (
          arrayEach(methodNames, function (methodName) {
            var func = source[methodName]
            ;(object[methodName] = func),
              isFunc &&
                (object.prototype[methodName] = function () {
                  var chainAll = this.__chain__
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                      actions = (result.__actions__ = copyArray(this.__actions__))
                    return (
                      actions.push({ func, args: arguments, thisArg: object }), (result.__chain__ = chainAll), result
                    )
                  }
                  return func.apply(object, arrayPush([this.value()], arguments))
                })
          }),
          object
        )
      }
      function noop() {}
      var over = createOver(arrayMap),
        overEvery = createOver(arrayEvery),
        overSome = createOver(arraySome)
      function property(path) {
        return isKey(path)
          ? baseProperty(toKey(path))
          : (function (path) {
              return function (object) {
                return baseGet(object, path)
              }
            })(path)
      }
      var range = createRange(),
        rangeRight = createRange(!0)
      function stubArray() {
        return []
      }
      function stubFalse() {
        return !1
      }
      var add = createMathOperation(function (augend, addend) {
          return augend + addend
        }, 0),
        ceil = createRound('ceil'),
        divide = createMathOperation(function (dividend, divisor) {
          return dividend / divisor
        }, 1),
        floor = createRound('floor')
      var source,
        multiply = createMathOperation(function (multiplier, multiplicand) {
          return multiplier * multiplicand
        }, 1),
        round = createRound('round'),
        subtract = createMathOperation(function (minuend, subtrahend) {
          return minuend - subtrahend
        }, 0)
      return (
        (lodash.after = function (n, func) {
          if ('function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
          return (
            (n = toInteger(n)),
            function () {
              if (--n < 1) return func.apply(this, arguments)
            }
          )
        }),
        (lodash.ary = ary),
        (lodash.assign = assign),
        (lodash.assignIn = assignIn),
        (lodash.assignInWith = assignInWith),
        (lodash.assignWith = assignWith),
        (lodash.at = at),
        (lodash.before = before),
        (lodash.bind = bind),
        (lodash.bindAll = bindAll),
        (lodash.bindKey = bindKey),
        (lodash.castArray = function () {
          if (!arguments.length) return []
          var value = arguments[0]
          return isArray(value) ? value : [value]
        }),
        (lodash.chain = chain),
        (lodash.chunk = function (array, size, guard) {
          size = (guard ? isIterateeCall(array, size, guard) : undefined === size) ? 1 : nativeMax(toInteger(size), 0)
          var length = null == array ? 0 : array.length
          if (!length || size < 1) return []
          for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); index < length; )
            result[resIndex++] = baseSlice(array, index, (index += size))
          return result
        }),
        (lodash.compact = function (array) {
          for (
            var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = [];
            ++index < length;

          ) {
            var value = array[index]
            value && (result[resIndex++] = value)
          }
          return result
        }),
        (lodash.concat = function () {
          var length = arguments.length
          if (!length) return []
          for (var args = Array(length - 1), array = arguments[0], index = length; index--; )
            args[index - 1] = arguments[index]
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1))
        }),
        (lodash.cond = function (pairs) {
          var length = null == pairs ? 0 : pairs.length,
            toIteratee = getIteratee()
          return (
            (pairs = length
              ? arrayMap(pairs, function (pair) {
                  if ('function' != typeof pair[1]) throw new TypeError(FUNC_ERROR_TEXT)
                  return [toIteratee(pair[0]), pair[1]]
                })
              : []),
            baseRest(function (args) {
              for (var index = -1; ++index < length; ) {
                var pair = pairs[index]
                if (apply(pair[0], this, args)) return apply(pair[1], this, args)
              }
            })
          )
        }),
        (lodash.conforms = function (source) {
          return (function (source) {
            var props = keys(source)
            return function (object) {
              return baseConformsTo(object, source, props)
            }
          })(baseClone(source, 1))
        }),
        (lodash.constant = constant),
        (lodash.countBy = countBy),
        (lodash.create = function (prototype, properties) {
          var result = baseCreate(prototype)
          return null == properties ? result : baseAssign(result, properties)
        }),
        (lodash.curry = function curry(func, arity, guard) {
          var result = createWrap(
            func,
            8,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            (arity = guard ? undefined : arity),
          )
          return (result.placeholder = curry.placeholder), result
        }),
        (lodash.curryRight = function curryRight(func, arity, guard) {
          var result = createWrap(
            func,
            16,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            (arity = guard ? undefined : arity),
          )
          return (result.placeholder = curryRight.placeholder), result
        }),
        (lodash.debounce = debounce),
        (lodash.defaults = defaults),
        (lodash.defaultsDeep = defaultsDeep),
        (lodash.defer = defer),
        (lodash.delay = delay),
        (lodash.difference = difference),
        (lodash.differenceBy = differenceBy),
        (lodash.differenceWith = differenceWith),
        (lodash.drop = function (array, n, guard) {
          var length = null == array ? 0 : array.length
          return length ? baseSlice(array, (n = guard || undefined === n ? 1 : toInteger(n)) < 0 ? 0 : n, length) : []
        }),
        (lodash.dropRight = function (array, n, guard) {
          var length = null == array ? 0 : array.length
          return length
            ? baseSlice(array, 0, (n = length - (n = guard || undefined === n ? 1 : toInteger(n))) < 0 ? 0 : n)
            : []
        }),
        (lodash.dropRightWhile = function (array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : []
        }),
        (lodash.dropWhile = function (array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : []
        }),
        (lodash.fill = function (array, value, start, end) {
          var length = null == array ? 0 : array.length
          return length
            ? (start &&
                'number' != typeof start &&
                isIterateeCall(array, value, start) &&
                ((start = 0), (end = length)),
              (function (array, value, start, end) {
                var length = array.length
                for (
                  (start = toInteger(start)) < 0 && (start = -start > length ? 0 : length + start),
                    (end = void 0 === end || end > length ? length : toInteger(end)) < 0 && (end += length),
                    end = start > end ? 0 : toLength(end);
                  start < end;

                )
                  array[start++] = value
                return array
              })(array, value, start, end))
            : []
        }),
        (lodash.filter = function (collection, predicate) {
          return (isArray(collection) ? arrayFilter : baseFilter)(collection, getIteratee(predicate, 3))
        }),
        (lodash.flatMap = function (collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1)
        }),
        (lodash.flatMapDeep = function (collection, iteratee) {
          return baseFlatten(map(collection, iteratee), Infinity)
        }),
        (lodash.flatMapDepth = function (collection, iteratee, depth) {
          return (depth = undefined === depth ? 1 : toInteger(depth)), baseFlatten(map(collection, iteratee), depth)
        }),
        (lodash.flatten = flatten),
        (lodash.flattenDeep = function (array) {
          return (null == array ? 0 : array.length) ? baseFlatten(array, Infinity) : []
        }),
        (lodash.flattenDepth = function (array, depth) {
          return (null == array ? 0 : array.length)
            ? baseFlatten(array, (depth = undefined === depth ? 1 : toInteger(depth)))
            : []
        }),
        (lodash.flip = function (func) {
          return createWrap(func, 512)
        }),
        (lodash.flow = flow),
        (lodash.flowRight = flowRight),
        (lodash.fromPairs = function (pairs) {
          for (var index = -1, length = null == pairs ? 0 : pairs.length, result = {}; ++index < length; ) {
            var pair = pairs[index]
            result[pair[0]] = pair[1]
          }
          return result
        }),
        (lodash.functions = function (object) {
          return null == object ? [] : baseFunctions(object, keys(object))
        }),
        (lodash.functionsIn = function (object) {
          return null == object ? [] : baseFunctions(object, keysIn(object))
        }),
        (lodash.groupBy = groupBy),
        (lodash.initial = function (array) {
          return (null == array ? 0 : array.length) ? baseSlice(array, 0, -1) : []
        }),
        (lodash.intersection = intersection),
        (lodash.intersectionBy = intersectionBy),
        (lodash.intersectionWith = intersectionWith),
        (lodash.invert = invert),
        (lodash.invertBy = invertBy),
        (lodash.invokeMap = invokeMap),
        (lodash.iteratee = iteratee),
        (lodash.keyBy = keyBy),
        (lodash.keys = keys),
        (lodash.keysIn = keysIn),
        (lodash.map = map),
        (lodash.mapKeys = function (object, iteratee) {
          var result = {}
          return (
            (iteratee = getIteratee(iteratee, 3)),
            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, iteratee(value, key, object), value)
            }),
            result
          )
        }),
        (lodash.mapValues = function (object, iteratee) {
          var result = {}
          return (
            (iteratee = getIteratee(iteratee, 3)),
            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, key, iteratee(value, key, object))
            }),
            result
          )
        }),
        (lodash.matches = function (source) {
          return baseMatches(baseClone(source, 1))
        }),
        (lodash.matchesProperty = function (path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, 1))
        }),
        (lodash.memoize = memoize),
        (lodash.merge = merge),
        (lodash.mergeWith = mergeWith),
        (lodash.method = method),
        (lodash.methodOf = methodOf),
        (lodash.mixin = mixin),
        (lodash.negate = negate),
        (lodash.nthArg = function (n) {
          return (
            (n = toInteger(n)),
            baseRest(function (args) {
              return baseNth(args, n)
            })
          )
        }),
        (lodash.omit = omit),
        (lodash.omitBy = function (object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)))
        }),
        (lodash.once = function (func) {
          return before(2, func)
        }),
        (lodash.orderBy = function (collection, iteratees, orders, guard) {
          return null == collection
            ? []
            : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [iteratees]),
              isArray((orders = guard ? undefined : orders)) || (orders = null == orders ? [] : [orders]),
              baseOrderBy(collection, iteratees, orders))
        }),
        (lodash.over = over),
        (lodash.overArgs = overArgs),
        (lodash.overEvery = overEvery),
        (lodash.overSome = overSome),
        (lodash.partial = partial),
        (lodash.partialRight = partialRight),
        (lodash.partition = partition),
        (lodash.pick = pick),
        (lodash.pickBy = pickBy),
        (lodash.property = property),
        (lodash.propertyOf = function (object) {
          return function (path) {
            return null == object ? undefined : baseGet(object, path)
          }
        }),
        (lodash.pull = pull),
        (lodash.pullAll = pullAll),
        (lodash.pullAllBy = function (array, values, iteratee) {
          return array && array.length && values && values.length
            ? basePullAll(array, values, getIteratee(iteratee, 2))
            : array
        }),
        (lodash.pullAllWith = function (array, values, comparator) {
          return array && array.length && values && values.length
            ? basePullAll(array, values, undefined, comparator)
            : array
        }),
        (lodash.pullAt = pullAt),
        (lodash.range = range),
        (lodash.rangeRight = rangeRight),
        (lodash.rearg = rearg),
        (lodash.reject = function (collection, predicate) {
          return (isArray(collection) ? arrayFilter : baseFilter)(collection, negate(getIteratee(predicate, 3)))
        }),
        (lodash.remove = function (array, predicate) {
          var result = []
          if (!array || !array.length) return result
          var index = -1,
            indexes = [],
            length = array.length
          for (predicate = getIteratee(predicate, 3); ++index < length; ) {
            var value = array[index]
            predicate(value, index, array) && (result.push(value), indexes.push(index))
          }
          return basePullAt(array, indexes), result
        }),
        (lodash.rest = function (func, start) {
          if ('function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
          return baseRest(func, (start = undefined === start ? start : toInteger(start)))
        }),
        (lodash.reverse = reverse),
        (lodash.sampleSize = function (collection, n, guard) {
          return (
            (n = (guard ? isIterateeCall(collection, n, guard) : undefined === n) ? 1 : toInteger(n)),
            (isArray(collection) ? arraySampleSize : baseSampleSize)(collection, n)
          )
        }),
        (lodash.set = function (object, path, value) {
          return null == object ? object : baseSet(object, path, value)
        }),
        (lodash.setWith = function (object, path, value, customizer) {
          return (
            (customizer = 'function' == typeof customizer ? customizer : undefined),
            null == object ? object : baseSet(object, path, value, customizer)
          )
        }),
        (lodash.shuffle = function (collection) {
          return (isArray(collection) ? arrayShuffle : baseShuffle)(collection)
        }),
        (lodash.slice = function (array, start, end) {
          var length = null == array ? 0 : array.length
          return length
            ? (end && 'number' != typeof end && isIterateeCall(array, start, end)
                ? ((start = 0), (end = length))
                : ((start = null == start ? 0 : toInteger(start)), (end = undefined === end ? length : toInteger(end))),
              baseSlice(array, start, end))
            : []
        }),
        (lodash.sortBy = sortBy),
        (lodash.sortedUniq = function (array) {
          return array && array.length ? baseSortedUniq(array) : []
        }),
        (lodash.sortedUniqBy = function (array, iteratee) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : []
        }),
        (lodash.split = function (string, separator, limit) {
          return (
            limit &&
              'number' != typeof limit &&
              isIterateeCall(string, separator, limit) &&
              (separator = limit = undefined),
            (limit = undefined === limit ? 4294967295 : limit >>> 0)
              ? (string = toString(string)) &&
                ('string' == typeof separator || (null != separator && !isRegExp(separator))) &&
                !(separator = baseToString(separator)) &&
                hasUnicode(string)
                ? castSlice(stringToArray(string), 0, limit)
                : string.split(separator, limit)
              : []
          )
        }),
        (lodash.spread = function (func, start) {
          if ('function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
          return (
            (start = null == start ? 0 : nativeMax(toInteger(start), 0)),
            baseRest(function (args) {
              var array = args[start],
                otherArgs = castSlice(args, 0, start)
              return array && arrayPush(otherArgs, array), apply(func, this, otherArgs)
            })
          )
        }),
        (lodash.tail = function (array) {
          var length = null == array ? 0 : array.length
          return length ? baseSlice(array, 1, length) : []
        }),
        (lodash.take = function (array, n, guard) {
          return array && array.length
            ? baseSlice(array, 0, (n = guard || undefined === n ? 1 : toInteger(n)) < 0 ? 0 : n)
            : []
        }),
        (lodash.takeRight = function (array, n, guard) {
          var length = null == array ? 0 : array.length
          return length
            ? baseSlice(array, (n = length - (n = guard || undefined === n ? 1 : toInteger(n))) < 0 ? 0 : n, length)
            : []
        }),
        (lodash.takeRightWhile = function (array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : []
        }),
        (lodash.takeWhile = function (array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : []
        }),
        (lodash.tap = function (value, interceptor) {
          return interceptor(value), value
        }),
        (lodash.throttle = function (func, wait, options) {
          var leading = !0,
            trailing = !0
          if ('function' != typeof func) throw new TypeError(FUNC_ERROR_TEXT)
          return (
            isObject(options) &&
              ((leading = 'leading' in options ? !!options.leading : leading),
              (trailing = 'trailing' in options ? !!options.trailing : trailing)),
            debounce(func, wait, { leading, maxWait: wait, trailing })
          )
        }),
        (lodash.thru = thru),
        (lodash.toArray = toArray),
        (lodash.toPairs = toPairs),
        (lodash.toPairsIn = toPairsIn),
        (lodash.toPath = function (value) {
          return isArray(value)
            ? arrayMap(value, toKey)
            : isSymbol(value)
            ? [value]
            : copyArray(stringToPath(toString(value)))
        }),
        (lodash.toPlainObject = toPlainObject),
        (lodash.transform = function (object, iteratee, accumulator) {
          var isArr = isArray(object),
            isArrLike = isArr || isBuffer(object) || isTypedArray(object)
          if (((iteratee = getIteratee(iteratee, 4)), null == accumulator)) {
            var Ctor = object && object.constructor
            accumulator = isArrLike
              ? isArr
                ? new Ctor()
                : []
              : isObject(object) && isFunction(Ctor)
              ? baseCreate(getPrototype(object))
              : {}
          }
          return (
            (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
              return iteratee(accumulator, value, index, object)
            }),
            accumulator
          )
        }),
        (lodash.unary = function (func) {
          return ary(func, 1)
        }),
        (lodash.union = union),
        (lodash.unionBy = unionBy),
        (lodash.unionWith = unionWith),
        (lodash.uniq = function (array) {
          return array && array.length ? baseUniq(array) : []
        }),
        (lodash.uniqBy = function (array, iteratee) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : []
        }),
        (lodash.uniqWith = function (array, comparator) {
          return (
            (comparator = 'function' == typeof comparator ? comparator : undefined),
            array && array.length ? baseUniq(array, undefined, comparator) : []
          )
        }),
        (lodash.unset = function (object, path) {
          return null == object || baseUnset(object, path)
        }),
        (lodash.unzip = unzip),
        (lodash.unzipWith = unzipWith),
        (lodash.update = function (object, path, updater) {
          return null == object ? object : baseUpdate(object, path, castFunction(updater))
        }),
        (lodash.updateWith = function (object, path, updater, customizer) {
          return (
            (customizer = 'function' == typeof customizer ? customizer : undefined),
            null == object ? object : baseUpdate(object, path, castFunction(updater), customizer)
          )
        }),
        (lodash.values = values),
        (lodash.valuesIn = function (object) {
          return null == object ? [] : baseValues(object, keysIn(object))
        }),
        (lodash.without = without),
        (lodash.words = words),
        (lodash.wrap = function (value, wrapper) {
          return partial(castFunction(wrapper), value)
        }),
        (lodash.xor = xor),
        (lodash.xorBy = xorBy),
        (lodash.xorWith = xorWith),
        (lodash.zip = zip),
        (lodash.zipObject = function (props, values) {
          return baseZipObject(props || [], values || [], assignValue)
        }),
        (lodash.zipObjectDeep = function (props, values) {
          return baseZipObject(props || [], values || [], baseSet)
        }),
        (lodash.zipWith = zipWith),
        (lodash.entries = toPairs),
        (lodash.entriesIn = toPairsIn),
        (lodash.extend = assignIn),
        (lodash.extendWith = assignInWith),
        mixin(lodash, lodash),
        (lodash.add = add),
        (lodash.attempt = attempt),
        (lodash.camelCase = camelCase),
        (lodash.capitalize = capitalize),
        (lodash.ceil = ceil),
        (lodash.clamp = function (number, lower, upper) {
          return (
            undefined === upper && ((upper = lower), (lower = undefined)),
            undefined !== upper && (upper = (upper = toNumber(upper)) == upper ? upper : 0),
            undefined !== lower && (lower = (lower = toNumber(lower)) == lower ? lower : 0),
            baseClamp(toNumber(number), lower, upper)
          )
        }),
        (lodash.clone = function (value) {
          return baseClone(value, 4)
        }),
        (lodash.cloneDeep = function (value) {
          return baseClone(value, 5)
        }),
        (lodash.cloneDeepWith = function (value, customizer) {
          return baseClone(value, 5, (customizer = 'function' == typeof customizer ? customizer : undefined))
        }),
        (lodash.cloneWith = function (value, customizer) {
          return baseClone(value, 4, (customizer = 'function' == typeof customizer ? customizer : undefined))
        }),
        (lodash.conformsTo = function (object, source) {
          return null == source || baseConformsTo(object, source, keys(source))
        }),
        (lodash.deburr = deburr),
        (lodash.defaultTo = function (value, defaultValue) {
          return null == value || value != value ? defaultValue : value
        }),
        (lodash.divide = divide),
        (lodash.endsWith = function (string, target, position) {
          ;(string = toString(string)), (target = baseToString(target))
          var length = string.length,
            end = (position = undefined === position ? length : baseClamp(toInteger(position), 0, length))
          return (position -= target.length) >= 0 && string.slice(position, end) == target
        }),
        (lodash.eq = eq),
        (lodash.escape = function (string) {
          return (string = toString(string)) && reHasUnescapedHtml.test(string)
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string
        }),
        (lodash.escapeRegExp = function (string) {
          return (string = toString(string)) && reHasRegExpChar.test(string)
            ? string.replace(reRegExpChar, '\\$&')
            : string
        }),
        (lodash.every = function (collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery
          return (
            guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined),
            func(collection, getIteratee(predicate, 3))
          )
        }),
        (lodash.find = find),
        (lodash.findIndex = findIndex),
        (lodash.findKey = function (object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn)
        }),
        (lodash.findLast = findLast),
        (lodash.findLastIndex = findLastIndex),
        (lodash.findLastKey = function (object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight)
        }),
        (lodash.floor = floor),
        (lodash.forEach = forEach),
        (lodash.forEachRight = forEachRight),
        (lodash.forIn = function (object, iteratee) {
          return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn)
        }),
        (lodash.forInRight = function (object, iteratee) {
          return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn)
        }),
        (lodash.forOwn = function (object, iteratee) {
          return object && baseForOwn(object, getIteratee(iteratee, 3))
        }),
        (lodash.forOwnRight = function (object, iteratee) {
          return object && baseForOwnRight(object, getIteratee(iteratee, 3))
        }),
        (lodash.get = get),
        (lodash.gt = gt),
        (lodash.gte = gte),
        (lodash.has = function (object, path) {
          return null != object && hasPath(object, path, baseHas)
        }),
        (lodash.hasIn = hasIn),
        (lodash.head = head),
        (lodash.identity = identity),
        (lodash.includes = function (collection, value, fromIndex, guard) {
          ;(collection = isArrayLike(collection) ? collection : values(collection)),
            (fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0)
          var length = collection.length
          return (
            fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)),
            isString(collection)
              ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
              : !!length && baseIndexOf(collection, value, fromIndex) > -1
          )
        }),
        (lodash.indexOf = function (array, value, fromIndex) {
          var length = null == array ? 0 : array.length
          if (!length) return -1
          var index = null == fromIndex ? 0 : toInteger(fromIndex)
          return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index)
        }),
        (lodash.inRange = function (number, start, end) {
          return (
            (start = toFinite(start)),
            undefined === end ? ((end = start), (start = 0)) : (end = toFinite(end)),
            (function (number, start, end) {
              return number >= nativeMin(start, end) && number < nativeMax(start, end)
            })((number = toNumber(number)), start, end)
          )
        }),
        (lodash.invoke = invoke),
        (lodash.isArguments = isArguments),
        (lodash.isArray = isArray),
        (lodash.isArrayBuffer = isArrayBuffer),
        (lodash.isArrayLike = isArrayLike),
        (lodash.isArrayLikeObject = isArrayLikeObject),
        (lodash.isBoolean = function (value) {
          return !0 === value || !1 === value || (isObjectLike(value) && baseGetTag(value) == boolTag)
        }),
        (lodash.isBuffer = isBuffer),
        (lodash.isDate = isDate),
        (lodash.isElement = function (value) {
          return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value)
        }),
        (lodash.isEmpty = function (value) {
          if (null == value) return !0
          if (
            isArrayLike(value) &&
            (isArray(value) ||
              'string' == typeof value ||
              'function' == typeof value.splice ||
              isBuffer(value) ||
              isTypedArray(value) ||
              isArguments(value))
          )
            return !value.length
          var tag = getTag(value)
          if (tag == mapTag || tag == setTag) return !value.size
          if (isPrototype(value)) return !baseKeys(value).length
          for (var key in value) if (hasOwnProperty.call(value, key)) return !1
          return !0
        }),
        (lodash.isEqual = function (value, other) {
          return baseIsEqual(value, other)
        }),
        (lodash.isEqualWith = function (value, other, customizer) {
          var result = (customizer = 'function' == typeof customizer ? customizer : undefined)
            ? customizer(value, other)
            : undefined
          return undefined === result ? baseIsEqual(value, other, undefined, customizer) : !!result
        }),
        (lodash.isError = isError),
        (lodash.isFinite = function (value) {
          return 'number' == typeof value && nativeIsFinite(value)
        }),
        (lodash.isFunction = isFunction),
        (lodash.isInteger = isInteger),
        (lodash.isLength = isLength),
        (lodash.isMap = isMap),
        (lodash.isMatch = function (object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source))
        }),
        (lodash.isMatchWith = function (object, source, customizer) {
          return (
            (customizer = 'function' == typeof customizer ? customizer : undefined),
            baseIsMatch(object, source, getMatchData(source), customizer)
          )
        }),
        (lodash.isNaN = function (value) {
          return isNumber(value) && value != +value
        }),
        (lodash.isNative = function (value) {
          if (isMaskable(value)) throw new Error('Unsupported core-js use. Try https://npms.io/search?q=ponyfill.')
          return baseIsNative(value)
        }),
        (lodash.isNil = function (value) {
          return null == value
        }),
        (lodash.isNull = function (value) {
          return null === value
        }),
        (lodash.isNumber = isNumber),
        (lodash.isObject = isObject),
        (lodash.isObjectLike = isObjectLike),
        (lodash.isPlainObject = isPlainObject),
        (lodash.isRegExp = isRegExp),
        (lodash.isSafeInteger = function (value) {
          return isInteger(value) && value >= -9007199254740991 && value <= 9007199254740991
        }),
        (lodash.isSet = isSet),
        (lodash.isString = isString),
        (lodash.isSymbol = isSymbol),
        (lodash.isTypedArray = isTypedArray),
        (lodash.isUndefined = function (value) {
          return undefined === value
        }),
        (lodash.isWeakMap = function (value) {
          return isObjectLike(value) && getTag(value) == weakMapTag
        }),
        (lodash.isWeakSet = function (value) {
          return isObjectLike(value) && '[object WeakSet]' == baseGetTag(value)
        }),
        (lodash.join = function (array, separator) {
          return null == array ? '' : nativeJoin.call(array, separator)
        }),
        (lodash.kebabCase = kebabCase),
        (lodash.last = last),
        (lodash.lastIndexOf = function (array, value, fromIndex) {
          var length = null == array ? 0 : array.length
          if (!length) return -1
          var index = length
          return (
            undefined !== fromIndex &&
              (index =
                (index = toInteger(fromIndex)) < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)),
            value == value
              ? (function (array, value, fromIndex) {
                  for (var index = fromIndex + 1; index--; ) if (array[index] === value) return index
                  return index
                })(array, value, index)
              : baseFindIndex(array, baseIsNaN, index, !0)
          )
        }),
        (lodash.lowerCase = lowerCase),
        (lodash.lowerFirst = lowerFirst),
        (lodash.lt = lt),
        (lodash.lte = lte),
        (lodash.max = function (array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined
        }),
        (lodash.maxBy = function (array, iteratee) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined
        }),
        (lodash.mean = function (array) {
          return baseMean(array, identity)
        }),
        (lodash.meanBy = function (array, iteratee) {
          return baseMean(array, getIteratee(iteratee, 2))
        }),
        (lodash.min = function (array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined
        }),
        (lodash.minBy = function (array, iteratee) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined
        }),
        (lodash.stubArray = stubArray),
        (lodash.stubFalse = stubFalse),
        (lodash.stubObject = function () {
          return {}
        }),
        (lodash.stubString = function () {
          return ''
        }),
        (lodash.stubTrue = function () {
          return !0
        }),
        (lodash.multiply = multiply),
        (lodash.nth = function (array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined
        }),
        (lodash.noConflict = function () {
          return root._ === this && (root._ = oldDash), this
        }),
        (lodash.noop = noop),
        (lodash.now = now),
        (lodash.pad = function (string, length, chars) {
          string = toString(string)
          var strLength = (length = toInteger(length)) ? stringSize(string) : 0
          if (!length || strLength >= length) return string
          var mid = (length - strLength) / 2
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars)
        }),
        (lodash.padEnd = function (string, length, chars) {
          string = toString(string)
          var strLength = (length = toInteger(length)) ? stringSize(string) : 0
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string
        }),
        (lodash.padStart = function (string, length, chars) {
          string = toString(string)
          var strLength = (length = toInteger(length)) ? stringSize(string) : 0
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string
        }),
        (lodash.parseInt = function (string, radix, guard) {
          return (
            guard || null == radix ? (radix = 0) : radix && (radix = +radix),
            nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0)
          )
        }),
        (lodash.random = function (lower, upper, floating) {
          if (
            (floating &&
              'boolean' != typeof floating &&
              isIterateeCall(lower, upper, floating) &&
              (upper = floating = undefined),
            undefined === floating &&
              ('boolean' == typeof upper
                ? ((floating = upper), (upper = undefined))
                : 'boolean' == typeof lower && ((floating = lower), (lower = undefined))),
            undefined === lower && undefined === upper
              ? ((lower = 0), (upper = 1))
              : ((lower = toFinite(lower)),
                undefined === upper ? ((upper = lower), (lower = 0)) : (upper = toFinite(upper))),
            lower > upper)
          ) {
            var temp = lower
            ;(lower = upper), (upper = temp)
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom()
            return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper)
          }
          return baseRandom(lower, upper)
        }),
        (lodash.reduce = function (collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
            initAccum = arguments.length < 3
          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach)
        }),
        (lodash.reduceRight = function (collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
            initAccum = arguments.length < 3
          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight)
        }),
        (lodash.repeat = function (string, n, guard) {
          return (
            (n = (guard ? isIterateeCall(string, n, guard) : undefined === n) ? 1 : toInteger(n)),
            baseRepeat(toString(string), n)
          )
        }),
        (lodash.replace = function () {
          var args = arguments,
            string = toString(args[0])
          return args.length < 3 ? string : string.replace(args[1], args[2])
        }),
        (lodash.result = function (object, path, defaultValue) {
          var index = -1,
            length = (path = castPath(path, object)).length
          for (length || ((length = 1), (object = undefined)); ++index < length; ) {
            var value = null == object ? undefined : object[toKey(path[index])]
            undefined === value && ((index = length), (value = defaultValue)),
              (object = isFunction(value) ? value.call(object) : value)
          }
          return object
        }),
        (lodash.round = round),
        (lodash.runInContext = runInContext),
        (lodash.sample = function (collection) {
          return (isArray(collection) ? arraySample : baseSample)(collection)
        }),
        (lodash.size = function (collection) {
          if (null == collection) return 0
          if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length
          var tag = getTag(collection)
          return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length
        }),
        (lodash.snakeCase = snakeCase),
        (lodash.some = function (collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome
          return (
            guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined),
            func(collection, getIteratee(predicate, 3))
          )
        }),
        (lodash.sortedIndex = function (array, value) {
          return baseSortedIndex(array, value)
        }),
        (lodash.sortedIndexBy = function (array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2))
        }),
        (lodash.sortedIndexOf = function (array, value) {
          var length = null == array ? 0 : array.length
          if (length) {
            var index = baseSortedIndex(array, value)
            if (index < length && eq(array[index], value)) return index
          }
          return -1
        }),
        (lodash.sortedLastIndex = function (array, value) {
          return baseSortedIndex(array, value, !0)
        }),
        (lodash.sortedLastIndexBy = function (array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), !0)
        }),
        (lodash.sortedLastIndexOf = function (array, value) {
          if (null == array ? 0 : array.length) {
            var index = baseSortedIndex(array, value, !0) - 1
            if (eq(array[index], value)) return index
          }
          return -1
        }),
        (lodash.startCase = startCase),
        (lodash.startsWith = function (string, target, position) {
          return (
            (string = toString(string)),
            (position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length)),
            (target = baseToString(target)),
            string.slice(position, position + target.length) == target
          )
        }),
        (lodash.subtract = subtract),
        (lodash.sum = function (array) {
          return array && array.length ? baseSum(array, identity) : 0
        }),
        (lodash.sumBy = function (array, iteratee) {
          return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0
        }),
        (lodash.template = function (string, options, guard) {
          var settings = lodash.templateSettings
          guard && isIterateeCall(string, options, guard) && (options = undefined),
            (string = toString(string)),
            (options = assignInWith({}, options, settings, customDefaultsAssignIn))
          var isEscaping,
            isEvaluating,
            imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
            importsKeys = keys(imports),
            importsValues = baseValues(imports, importsKeys),
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '",
            reDelimiters = RegExp(
              (options.escape || reNoMatch).source +
                '|' +
                interpolate.source +
                '|' +
                (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source +
                '|' +
                (options.evaluate || reNoMatch).source +
                '|$',
              'g',
            ),
            sourceURL =
              '//# sourceURL=' +
              (hasOwnProperty.call(options, 'sourceURL')
                ? (options.sourceURL + '').replace(/[\r\n]/g, ' ')
                : 'lodash.templateSources[' + ++templateCounter + ']') +
              '\n'
          string.replace(
            reDelimiters,
            function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              return (
                interpolateValue || (interpolateValue = esTemplateValue),
                (source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar)),
                escapeValue && ((isEscaping = !0), (source += "' +\n__e(" + escapeValue + ") +\n'")),
                evaluateValue && ((isEvaluating = !0), (source += "';\n" + evaluateValue + ";\n__p += '")),
                interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"),
                (index = offset + match.length),
                match
              )
            },
          ),
            (source += "';\n")
          var variable = hasOwnProperty.call(options, 'variable') && options.variable
          variable || (source = 'with (obj) {\n' + source + '\n}\n'),
            (source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
              .replace(reEmptyStringMiddle, '$1')
              .replace(reEmptyStringTrailing, '$1;')),
            (source =
              'function(' +
              (variable || 'obj') +
              ') {\n' +
              (variable ? '' : 'obj || (obj = {});\n') +
              "var __t, __p = ''" +
              (isEscaping ? ', __e = _.escape' : '') +
              (isEvaluating
                ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n"
                : ';\n') +
              source +
              'return __p\n}')
          var result = attempt(function () {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues)
          })
          if (((result.source = source), isError(result))) throw result
          return result
        }),
        (lodash.times = function (n, iteratee) {
          if ((n = toInteger(n)) < 1 || n > 9007199254740991) return []
          var index = 4294967295,
            length = nativeMin(n, 4294967295)
          n -= 4294967295
          for (var result = baseTimes(length, (iteratee = getIteratee(iteratee))); ++index < n; ) iteratee(index)
          return result
        }),
        (lodash.toFinite = toFinite),
        (lodash.toInteger = toInteger),
        (lodash.toLength = toLength),
        (lodash.toLower = function (value) {
          return toString(value).toLowerCase()
        }),
        (lodash.toNumber = toNumber),
        (lodash.toSafeInteger = function (value) {
          return value ? baseClamp(toInteger(value), -9007199254740991, 9007199254740991) : 0 === value ? value : 0
        }),
        (lodash.toString = toString),
        (lodash.toUpper = function (value) {
          return toString(value).toUpperCase()
        }),
        (lodash.trim = function (string, chars, guard) {
          if ((string = toString(string)) && (guard || undefined === chars)) return string.replace(reTrim, '')
          if (!string || !(chars = baseToString(chars))) return string
          var strSymbols = stringToArray(string),
            chrSymbols = stringToArray(chars)
          return castSlice(
            strSymbols,
            charsStartIndex(strSymbols, chrSymbols),
            charsEndIndex(strSymbols, chrSymbols) + 1,
          ).join('')
        }),
        (lodash.trimEnd = function (string, chars, guard) {
          if ((string = toString(string)) && (guard || undefined === chars)) return string.replace(reTrimEnd, '')
          if (!string || !(chars = baseToString(chars))) return string
          var strSymbols = stringToArray(string)
          return castSlice(strSymbols, 0, charsEndIndex(strSymbols, stringToArray(chars)) + 1).join('')
        }),
        (lodash.trimStart = function (string, chars, guard) {
          if ((string = toString(string)) && (guard || undefined === chars)) return string.replace(reTrimStart, '')
          if (!string || !(chars = baseToString(chars))) return string
          var strSymbols = stringToArray(string)
          return castSlice(strSymbols, charsStartIndex(strSymbols, stringToArray(chars))).join('')
        }),
        (lodash.truncate = function (string, options) {
          var length = 30,
            omission = '...'
          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator
            ;(length = 'length' in options ? toInteger(options.length) : length),
              (omission = 'omission' in options ? baseToString(options.omission) : omission)
          }
          var strLength = (string = toString(string)).length
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string)
            strLength = strSymbols.length
          }
          if (length >= strLength) return string
          var end = length - stringSize(omission)
          if (end < 1) return omission
          var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end)
          if (undefined === separator) return result + omission
          if ((strSymbols && (end += result.length - end), isRegExp(separator))) {
            if (string.slice(end).search(separator)) {
              var match,
                substring = result
              for (
                separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g')),
                  separator.lastIndex = 0;
                (match = separator.exec(substring));

              )
                var newEnd = match.index
              result = result.slice(0, undefined === newEnd ? end : newEnd)
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result.lastIndexOf(separator)
            index > -1 && (result = result.slice(0, index))
          }
          return result + omission
        }),
        (lodash.unescape = function (string) {
          return (string = toString(string)) && reHasEscapedHtml.test(string)
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string
        }),
        (lodash.uniqueId = function (prefix) {
          var id = ++idCounter
          return toString(prefix) + id
        }),
        (lodash.upperCase = upperCase),
        (lodash.upperFirst = upperFirst),
        (lodash.each = forEach),
        (lodash.eachRight = forEachRight),
        (lodash.first = head),
        mixin(
          lodash,
          ((source = {}),
          baseForOwn(lodash, function (func, methodName) {
            hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func)
          }),
          source),
          { chain: !1 },
        ),
        (lodash.VERSION = '4.17.13'),
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
          lodash[methodName].placeholder = lodash
        }),
        arrayEach(['drop', 'take'], function (methodName, index) {
          ;(LazyWrapper.prototype[methodName] = function (n) {
            n = undefined === n ? 1 : nativeMax(toInteger(n), 0)
            var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone()
            return (
              result.__filtered__
                ? (result.__takeCount__ = nativeMin(n, result.__takeCount__))
                : result.__views__.push({
                    size: nativeMin(n, 4294967295),
                    type: methodName + (result.__dir__ < 0 ? 'Right' : ''),
                  }),
              result
            )
          }),
            (LazyWrapper.prototype[methodName + 'Right'] = function (n) {
              return this.reverse()[methodName](n).reverse()
            })
        }),
        arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
          var type = index + 1,
            isFilter = 1 == type || 3 == type
          LazyWrapper.prototype[methodName] = function (iteratee) {
            var result = this.clone()
            return (
              result.__iteratees__.push({ iteratee: getIteratee(iteratee, 3), type }),
              (result.__filtered__ = result.__filtered__ || isFilter),
              result
            )
          }
        }),
        arrayEach(['head', 'last'], function (methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '')
          LazyWrapper.prototype[methodName] = function () {
            return this[takeName](1).value()[0]
          }
        }),
        arrayEach(['initial', 'tail'], function (methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right')
          LazyWrapper.prototype[methodName] = function () {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
          }
        }),
        (LazyWrapper.prototype.compact = function () {
          return this.filter(identity)
        }),
        (LazyWrapper.prototype.find = function (predicate) {
          return this.filter(predicate).head()
        }),
        (LazyWrapper.prototype.findLast = function (predicate) {
          return this.reverse().find(predicate)
        }),
        (LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
          return 'function' == typeof path
            ? new LazyWrapper(this)
            : this.map(function (value) {
                return baseInvoke(value, path, args)
              })
        })),
        (LazyWrapper.prototype.reject = function (predicate) {
          return this.filter(negate(getIteratee(predicate)))
        }),
        (LazyWrapper.prototype.slice = function (start, end) {
          start = toInteger(start)
          var result = this
          return result.__filtered__ && (start > 0 || end < 0)
            ? new LazyWrapper(result)
            : (start < 0 ? (result = result.takeRight(-start)) : start && (result = result.drop(start)),
              undefined !== end &&
                (result = (end = toInteger(end)) < 0 ? result.dropRight(-end) : result.take(end - start)),
              result)
        }),
        (LazyWrapper.prototype.takeRightWhile = function (predicate) {
          return this.reverse().takeWhile(predicate).reverse()
        }),
        (LazyWrapper.prototype.toArray = function () {
          return this.take(4294967295)
        }),
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
            isTaker = /^(?:head|last)$/.test(methodName),
            lodashFunc = lodash[isTaker ? 'take' + ('last' == methodName ? 'Right' : '') : methodName],
            retUnwrapped = isTaker || /^find/.test(methodName)
          lodashFunc &&
            (lodash.prototype[methodName] = function () {
              var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value),
                interceptor = function (value) {
                  var result = lodashFunc.apply(lodash, arrayPush([value], args))
                  return isTaker && chainAll ? result[0] : result
                }
              useLazy &&
                checkIteratee &&
                'function' == typeof iteratee &&
                1 != iteratee.length &&
                (isLazy = useLazy = !1)
              var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this)
                var result = func.apply(value, args)
                return (
                  result.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined }),
                  new LodashWrapper(result, chainAll)
                )
              }
              return isUnwrapped && onlyLazy
                ? func.apply(this, args)
                : ((result = this.thru(interceptor)),
                  isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result)
            })
        }),
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
          var func = arrayProto[methodName],
            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
            retUnwrapped = /^(?:pop|shift)$/.test(methodName)
          lodash.prototype[methodName] = function () {
            var args = arguments
            if (retUnwrapped && !this.__chain__) {
              var value = this.value()
              return func.apply(isArray(value) ? value : [], args)
            }
            return this[chainName](function (value) {
              return func.apply(isArray(value) ? value : [], args)
            })
          }
        }),
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var lodashFunc = lodash[methodName]
          if (lodashFunc) {
            var key = lodashFunc.name + ''
            hasOwnProperty.call(realNames, key) || (realNames[key] = []),
              realNames[key].push({ name: methodName, func: lodashFunc })
          }
        }),
        (realNames[createHybrid(undefined, 2).name] = [{ name: 'wrapper', func: undefined }]),
        (LazyWrapper.prototype.clone = function () {
          var result = new LazyWrapper(this.__wrapped__)
          return (
            (result.__actions__ = copyArray(this.__actions__)),
            (result.__dir__ = this.__dir__),
            (result.__filtered__ = this.__filtered__),
            (result.__iteratees__ = copyArray(this.__iteratees__)),
            (result.__takeCount__ = this.__takeCount__),
            (result.__views__ = copyArray(this.__views__)),
            result
          )
        }),
        (LazyWrapper.prototype.reverse = function () {
          if (this.__filtered__) {
            var result = new LazyWrapper(this)
            ;(result.__dir__ = -1), (result.__filtered__ = !0)
          } else (result = this.clone()).__dir__ *= -1
          return result
        }),
        (LazyWrapper.prototype.value = function () {
          var array = this.__wrapped__.value(),
            dir = this.__dir__,
            isArr = isArray(array),
            isRight = dir < 0,
            arrLength = isArr ? array.length : 0,
            view = (function (start, end, transforms) {
              var index = -1,
                length = transforms.length
              for (; ++index < length; ) {
                var data = transforms[index],
                  size = data.size
                switch (data.type) {
                  case 'drop':
                    start += size
                    break
                  case 'dropRight':
                    end -= size
                    break
                  case 'take':
                    end = nativeMin(end, start + size)
                    break
                  case 'takeRight':
                    start = nativeMax(start, end - size)
                }
              }
              return { start, end }
            })(0, arrLength, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : start - 1,
            iteratees = this.__iteratees__,
            iterLength = iteratees.length,
            resIndex = 0,
            takeCount = nativeMin(length, this.__takeCount__)
          if (!isArr || (!isRight && arrLength == length && takeCount == length))
            return baseWrapperValue(array, this.__actions__)
          var result = []
          outer: for (; length-- && resIndex < takeCount; ) {
            for (var iterIndex = -1, value = array[(index += dir)]; ++iterIndex < iterLength; ) {
              var data = iteratees[iterIndex],
                iteratee = data.iteratee,
                type = data.type,
                computed = iteratee(value)
              if (2 == type) value = computed
              else if (!computed) {
                if (1 == type) continue outer
                break outer
              }
            }
            result[resIndex++] = value
          }
          return result
        }),
        (lodash.prototype.at = wrapperAt),
        (lodash.prototype.chain = function () {
          return chain(this)
        }),
        (lodash.prototype.commit = function () {
          return new LodashWrapper(this.value(), this.__chain__)
        }),
        (lodash.prototype.next = function () {
          undefined === this.__values__ && (this.__values__ = toArray(this.value()))
          var done = this.__index__ >= this.__values__.length
          return { done, value: done ? undefined : this.__values__[this.__index__++] }
        }),
        (lodash.prototype.plant = function (value) {
          for (var result, parent = this; parent instanceof baseLodash; ) {
            var clone = wrapperClone(parent)
            ;(clone.__index__ = 0),
              (clone.__values__ = undefined),
              result ? (previous.__wrapped__ = clone) : (result = clone)
            var previous = clone
            parent = parent.__wrapped__
          }
          return (previous.__wrapped__ = value), result
        }),
        (lodash.prototype.reverse = function () {
          var value = this.__wrapped__
          if (value instanceof LazyWrapper) {
            var wrapped = value
            return (
              this.__actions__.length && (wrapped = new LazyWrapper(this)),
              (wrapped = wrapped.reverse()).__actions__.push({ func: thru, args: [reverse], thisArg: undefined }),
              new LodashWrapper(wrapped, this.__chain__)
            )
          }
          return this.thru(reverse)
        }),
        (lodash.prototype.toJSON =
          lodash.prototype.valueOf =
          lodash.prototype.value =
            function () {
              return baseWrapperValue(this.__wrapped__, this.__actions__)
            }),
        (lodash.prototype.first = lodash.prototype.head),
        symIterator &&
          (lodash.prototype[symIterator] = function () {
            return this
          }),
        lodash
      )
    })()
    'function' == typeof define && 'object' == typeof define.amd && define.amd
      ? ((root._ = _),
        define(function () {
          return _
        }))
      : freeModule
      ? (((freeModule.exports = _)._ = _), (freeExports._ = _))
      : (root._ = _)
  }.call(this),
  (function (root, name, definition) {
    'undefined' != typeof module && module.exports
      ? (module.exports = definition())
      : 'function' == typeof define && define.amd
      ? define('bowser', definition)
      : (root.bowser = definition())
  })(this, 0, function () {
    var t = !0
    function detect(ua) {
      function getFirstMatch(regex) {
        var match = ua.match(regex)
        return (match && match.length > 1 && match[1]) || ''
      }
      function getSecondMatch(regex) {
        var match = ua.match(regex)
        return (match && match.length > 1 && match[2]) || ''
      }
      var result,
        iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(),
        android = !/like android/i.test(ua) && /android/i.test(ua),
        nexusMobile = /nexus\s*[0-6]\s*/i.test(ua),
        nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua),
        chromeos = /CrOS/.test(ua),
        silk = /silk/i.test(ua),
        sailfish = /sailfish/i.test(ua),
        tizen = /tizen/i.test(ua),
        webos = /(web|hpw)(o|0)s/i.test(ua),
        windowsphone = /windows phone/i.test(ua),
        windows = (/SamsungBrowser/i.test(ua), !windowsphone && /windows/i.test(ua)),
        mac = !iosdevice && !silk && /macintosh/i.test(ua),
        linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua),
        edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i),
        versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i),
        tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua),
        mobile = !tablet && /[^-]mobi/i.test(ua),
        xbox = /xbox/i.test(ua)
      ;/opera/i.test(ua)
        ? (result = {
            name: 'Opera',
            opera: t,
            version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i),
          })
        : /opr\/|opios/i.test(ua)
        ? (result = {
            name: 'Opera',
            opera: t,
            version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier,
          })
        : /SamsungBrowser/i.test(ua)
        ? (result = {
            name: 'Samsung Internet for Android',
            samsungBrowser: t,
            version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i),
          })
        : /Whale/i.test(ua)
        ? (result = {
            name: 'NAVER Whale browser',
            whale: t,
            version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i),
          })
        : /MZBrowser/i.test(ua)
        ? (result = { name: 'MZ Browser', mzbrowser: t, version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i) })
        : /coast/i.test(ua)
        ? (result = {
            name: 'Opera Coast',
            coast: t,
            version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i),
          })
        : /focus/i.test(ua)
        ? (result = { name: 'Focus', focus: t, version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i) })
        : /yabrowser/i.test(ua)
        ? (result = {
            name: 'Yandex Browser',
            yandexbrowser: t,
            version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i),
          })
        : /ucbrowser/i.test(ua)
        ? (result = { name: 'UC Browser', ucbrowser: t, version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i) })
        : /mxios/i.test(ua)
        ? (result = { name: 'Maxthon', maxthon: t, version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i) })
        : /epiphany/i.test(ua)
        ? (result = { name: 'Epiphany', epiphany: t, version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i) })
        : /puffin/i.test(ua)
        ? (result = { name: 'Puffin', puffin: t, version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i) })
        : /sleipnir/i.test(ua)
        ? (result = { name: 'Sleipnir', sleipnir: t, version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i) })
        : /k-meleon/i.test(ua)
        ? (result = { name: 'K-Meleon', kMeleon: t, version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i) })
        : windowsphone
        ? ((result = { name: 'Windows Phone', osname: 'Windows Phone', windowsphone: t }),
          edgeVersion
            ? ((result.msedge = t), (result.version = edgeVersion))
            : ((result.msie = t), (result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i))))
        : /msie|trident/i.test(ua)
        ? (result = { name: 'Internet Explorer', msie: t, version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i) })
        : chromeos
        ? (result = {
            name: 'Chrome',
            osname: 'Chrome OS',
            chromeos: t,
            chromeBook: t,
            chrome: t,
            version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i),
          })
        : /edg([ea]|ios)/i.test(ua)
        ? (result = { name: 'Microsoft Edge', msedge: t, version: edgeVersion })
        : /vivaldi/i.test(ua)
        ? (result = {
            name: 'Vivaldi',
            vivaldi: t,
            version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier,
          })
        : sailfish
        ? (result = {
            name: 'Sailfish',
            osname: 'Sailfish OS',
            sailfish: t,
            version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i),
          })
        : /seamonkey\//i.test(ua)
        ? (result = { name: 'SeaMonkey', seamonkey: t, version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i) })
        : /firefox|iceweasel|fxios/i.test(ua)
        ? ((result = {
            name: 'Firefox',
            firefox: t,
            version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i),
          }),
          /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua) && ((result.firefoxos = t), (result.osname = 'Firefox OS')))
        : silk
        ? (result = { name: 'Amazon Silk', silk: t, version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i) })
        : /phantom/i.test(ua)
        ? (result = { name: 'PhantomJS', phantom: t, version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i) })
        : /slimerjs/i.test(ua)
        ? (result = { name: 'SlimerJS', slimer: t, version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i) })
        : /blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)
        ? (result = {
            name: 'BlackBerry',
            osname: 'BlackBerry OS',
            blackberry: t,
            version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i),
          })
        : webos
        ? ((result = {
            name: 'WebOS',
            osname: 'WebOS',
            webos: t,
            version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i),
          }),
          /touchpad\//i.test(ua) && (result.touchpad = t))
        : /bada/i.test(ua)
        ? (result = { name: 'Bada', osname: 'Bada', bada: t, version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i) })
        : tizen
        ? (result = {
            name: 'Tizen',
            osname: 'Tizen',
            tizen: t,
            version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier,
          })
        : /qupzilla/i.test(ua)
        ? (result = {
            name: 'QupZilla',
            qupzilla: t,
            version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier,
          })
        : /chromium/i.test(ua)
        ? (result = {
            name: 'Chromium',
            chromium: t,
            version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier,
          })
        : /chrome|crios|crmo/i.test(ua)
        ? (result = { name: 'Chrome', chrome: t, version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i) })
        : android
        ? (result = { name: 'Android', version: versionIdentifier })
        : /safari|applewebkit/i.test(ua)
        ? ((result = { name: 'Safari', safari: t }), versionIdentifier && (result.version = versionIdentifier))
        : iosdevice
        ? ((result = { name: 'iphone' == iosdevice ? 'iPhone' : 'ipad' == iosdevice ? 'iPad' : 'iPod' }),
          versionIdentifier && (result.version = versionIdentifier))
        : (result = /googlebot/i.test(ua)
            ? {
                name: 'Googlebot',
                googlebot: t,
                version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier,
              }
            : { name: getFirstMatch(/^(.*)\/(.*) /), version: getSecondMatch(/^(.*)\/(.*) /) }),
        !result.msedge && /(apple)?webkit/i.test(ua)
          ? (/(apple)?webkit\/537\.36/i.test(ua)
              ? ((result.name = result.name || 'Blink'), (result.blink = t))
              : ((result.name = result.name || 'Webkit'), (result.webkit = t)),
            !result.version && versionIdentifier && (result.version = versionIdentifier))
          : !result.opera &&
            /gecko\//i.test(ua) &&
            ((result.name = result.name || 'Gecko'),
            (result.gecko = t),
            (result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i))),
        result.windowsphone || (!android && !result.silk)
          ? !result.windowsphone && iosdevice
            ? ((result[iosdevice] = t), (result.ios = t), (result.osname = 'iOS'))
            : mac
            ? ((result.mac = t), (result.osname = 'macOS'))
            : xbox
            ? ((result.xbox = t), (result.osname = 'Xbox'))
            : windows
            ? ((result.windows = t), (result.osname = 'Windows'))
            : linux && ((result.linux = t), (result.osname = 'Linux'))
          : ((result.android = t), (result.osname = 'Android'))
      var osVersion = ''
      result.windows
        ? (osVersion = (function (s) {
            switch (s) {
              case 'NT':
                return 'NT'
              case 'XP':
                return 'XP'
              case 'NT 5.0':
                return '2000'
              case 'NT 5.1':
                return 'XP'
              case 'NT 5.2':
                return '2003'
              case 'NT 6.0':
                return 'Vista'
              case 'NT 6.1':
                return '7'
              case 'NT 6.2':
                return '8'
              case 'NT 6.3':
                return '8.1'
              case 'NT 10.0':
                return '10'
              default:
                return
            }
          })(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i)))
        : result.windowsphone
        ? (osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i))
        : result.mac
        ? (osVersion = (osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i)).replace(/[_\s]/g, '.'))
        : iosdevice
        ? (osVersion = (osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i)).replace(/[_\s]/g, '.'))
        : android
        ? (osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i))
        : result.webos
        ? (osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i))
        : result.blackberry
        ? (osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i))
        : result.bada
        ? (osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i))
        : result.tizen && (osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i)),
        osVersion && (result.osversion = osVersion)
      var osMajorVersion = !result.windows && osVersion.split('.')[0]
      return (
        tablet ||
        nexusTablet ||
        'ipad' == iosdevice ||
        (android && (3 == osMajorVersion || (osMajorVersion >= 4 && !mobile))) ||
        result.silk
          ? (result.tablet = t)
          : (mobile ||
              'iphone' == iosdevice ||
              'ipod' == iosdevice ||
              android ||
              nexusMobile ||
              result.blackberry ||
              result.webos ||
              result.bada) &&
            (result.mobile = t),
        result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
        (result.vivaldi && result.version >= 1) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.whale && 1 === compareVersions([result.version, '1.0'])) ||
        (result.mzbrowser && 1 === compareVersions([result.version, '6.0'])) ||
        (result.focus && 1 === compareVersions([result.version, '1.0'])) ||
        (result.firefox && result.version >= 20) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10) ||
        (result.ios && result.osversion && result.osversion.split('.')[0] >= 6) ||
        (result.blackberry && result.version >= 10.1) ||
        (result.chromium && result.version >= 20)
          ? (result.a = t)
          : (result.msie && result.version < 10) ||
            (result.chrome && result.version < 20) ||
            (result.firefox && result.version < 20) ||
            (result.safari && result.version < 6) ||
            (result.opera && result.version < 10) ||
            (result.ios && result.osversion && result.osversion.split('.')[0] < 6) ||
            (result.chromium && result.version < 20)
          ? (result.c = t)
          : (result.x = t),
        result
      )
    }
    var bowser = detect(('undefined' != typeof navigator && navigator.userAgent) || '')
    function getVersionPrecision(version) {
      return version.split('.').length
    }
    function map(arr, iterator) {
      var i,
        result = []
      if (Array.prototype.map) return Array.prototype.map.call(arr, iterator)
      for (i = 0; i < arr.length; i++) result.push(iterator(arr[i]))
      return result
    }
    function compareVersions(versions) {
      for (
        var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1])),
          chunks = map(versions, function (version) {
            var delta = precision - getVersionPrecision(version)
            return map((version += new Array(delta + 1).join('.0')).split('.'), function (chunk) {
              return new Array(20 - chunk.length).join('0') + chunk
            }).reverse()
          });
        --precision >= 0;

      ) {
        if (chunks[0][precision] > chunks[1][precision]) return 1
        if (chunks[0][precision] !== chunks[1][precision]) return -1
        if (0 === precision) return 0
      }
    }
    function isUnsupportedBrowser(minVersions, strictMode, ua) {
      var _bowser = bowser
      'string' == typeof strictMode && ((ua = strictMode), (strictMode = void 0)),
        void 0 === strictMode && (strictMode = !1),
        ua && (_bowser = detect(ua))
      var version = '' + _bowser.version
      for (var browser in minVersions)
        if (minVersions.hasOwnProperty(browser) && _bowser[browser]) {
          if ('string' != typeof minVersions[browser])
            throw new Error(
              'Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions),
            )
          return compareVersions([version, minVersions[browser]]) < 0
        }
      return strictMode
    }
    return (
      (bowser.test = function (browserList) {
        for (var i = 0; i < browserList.length; ++i) {
          var browserItem = browserList[i]
          if ('string' == typeof browserItem && browserItem in bowser) return !0
        }
        return !1
      }),
      (bowser.isUnsupportedBrowser = isUnsupportedBrowser),
      (bowser.compareVersions = compareVersions),
      (bowser.check = function (minVersions, strictMode, ua) {
        return !isUnsupportedBrowser(minVersions, strictMode, ua)
      }),
      (bowser._detect = detect),
      (bowser.detect = detect),
      bowser
    )
  }),
  (e = this),
  (r = function (e) {
    'use strict'
    var r,
      t,
      o =
        'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
          ? function (e) {
              return typeof e
            }
          : function (e) {
              return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype
                ? 'symbol'
                : typeof e
            },
      a = (function () {
        function e(e, r) {
          for (var t = 0; t < r.length; t++) {
            var n = r[t]
            ;(n.enumerable = n.enumerable || !1),
              (n.configurable = !0),
              'value' in n && (n.writable = !0),
              Object.defineProperty(e, n.key, n)
          }
        }
        return function (r, t, n) {
          return t && e(r.prototype, t), n && e(r, n), r
        }
      })(),
      f =
        'undefined' != typeof Symbol
          ? Symbol('immer-nothing')
          : (!0,
            (t = 'immer-nothing') in (r = {})
              ? Object.defineProperty(r, t, { value: true, enumerable: !0, configurable: !0, writable: !0 })
              : (r[t] = true),
            r),
      u = 'undefined' != typeof Symbol ? Symbol('immer-draftable') : '__$immer_draftable',
      c = 'undefined' != typeof Symbol ? Symbol('immer-state') : '__$immer_state'
    function s(e) {
      return !!e && !!e[c]
    }
    function l(e) {
      if (!e || 'object' !== (void 0 === e ? 'undefined' : o(e))) return !1
      if (Array.isArray(e)) return !0
      var r = Object.getPrototypeOf(e)
      return !r || r === Object.prototype || !!e[u] || !!e.constructor[u]
    }
    var p =
        Object.assign ||
        function (e, r) {
          for (var t in r) b(r, t) && (e[t] = r[t])
          return e
        },
      d =
        'undefined' != typeof Reflect && Reflect.ownKeys
          ? Reflect.ownKeys
          : void 0 !== Object.getOwnPropertySymbols
          ? function (e) {
              return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
            }
          : Object.getOwnPropertyNames
    function h(e) {
      var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
      if (Array.isArray(e)) return e.slice()
      var t = Object.create(Object.getPrototypeOf(e))
      return (
        d(e).forEach(function (n) {
          if (n !== c) {
            var o = Object.getOwnPropertyDescriptor(e, n)
            if (o.get) {
              if (!r) throw new Error('Immer drafts cannot have computed properties')
              o.value = o.get.call(e)
            }
            o.enumerable
              ? (t[n] = o.value)
              : Object.defineProperty(t, n, { value: o.value, writable: !0, configurable: !0 })
          }
        }),
        t
      )
    }
    function y(e, r) {
      if (Array.isArray(e)) for (var t = 0; t < e.length; t++) r(t, e[t], e)
      else
        d(e).forEach(function (t) {
          return r(t, e[t], e)
        })
    }
    function v(e, r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable
    }
    function b(e, r) {
      return Object.prototype.hasOwnProperty.call(e, r)
    }
    function g(e, r) {
      return e === r ? 0 !== e || 1 / e == 1 / r : e != e && r != r
    }
    var m = {},
      w = [],
      O = function () {
        return w[w.length - 1]
      }
    function j() {
      this.revoked = !0
    }
    function z(e) {
      return e.copy || e.base
    }
    function A(e) {
      e.modified || ((e.modified = !0), e.parent && A(e.parent))
    }
    function E(e) {
      e.copy || (e.copy = k(e.base))
    }
    function k(e) {
      var r = e && e[c]
      if (r) {
        r.finalizing = !0
        var t = h(r.draft, !0)
        return (r.finalizing = !1), t
      }
      return h(e)
    }
    function x(e) {
      if (!0 === e.revoked)
        throw new Error(
          'Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? ' +
            JSON.stringify(z(e)),
        )
    }
    function S(e) {
      for (var r = e.base, t = e.draft, n = Object.keys(t), o = n.length - 1; o >= 0; o--)
        if (void 0 === r[n[o]] && !b(r, n[o])) return !0
      return n.length !== Object.keys(r).length
    }
    function D(e) {
      var r = e.draft
      if (r.length !== e.base.length) return !0
      var t = Object.getOwnPropertyDescriptor(r, r.length - 1)
      return !(!t || t.get)
    }
    var F = Object.freeze({
        scopes: w,
        currentScope: O,
        willFinalize: function (e, r, t) {
          var n = O()
          n.forEach(function (e) {
            return (e.finalizing = !0)
          }),
            (void 0 !== e && e !== r) ||
              (t &&
                (function e(r) {
                  if (r && 'object' === (void 0 === r ? 'undefined' : o(r))) {
                    var t = r[c]
                    if (t) {
                      var n = t.base,
                        i = t.draft,
                        a = t.assigned
                      if (Array.isArray(r)) {
                        if (D(t)) {
                          if ((A(t), (a.length = !0), i.length < n.length))
                            for (var f = i.length; f < n.length; f++) a[f] = !1
                          else for (var u = n.length; u < i.length; u++) a[u] = !0
                          for (var s = 0; s < i.length; s++) void 0 === a[s] && e(i[s])
                        }
                      } else
                        Object.keys(i).forEach(function (r) {
                          void 0 !== n[r] || b(n, r) ? a[r] || e(i[r]) : ((a[r] = !0), A(t))
                        }),
                          Object.keys(n).forEach(function (e) {
                            void 0 !== i[e] || b(i, e) || ((a[e] = !1), A(t))
                          })
                    }
                  }
                })(r),
              (function (e) {
                for (var r = e.length - 1; r >= 0; r--) {
                  var t = e[r]
                  !1 === t.modified && (Array.isArray(t.base) ? D(t) && A(t) : S(t) && A(t))
                }
              })(n))
        },
        createDraft: function P(e, r) {
          var t = Array.isArray(e),
            n = k(e)
          y(n, function (r) {
            !(function (e, r, t) {
              var n = m[r]
              n
                ? (n.enumerable = t)
                : (m[r] = n =
                    {
                      configurable: !0,
                      enumerable: t,
                      get: function () {
                        return (function (e, r) {
                          x(e)
                          var t = z(e)[r]
                          return !e.finalizing && t === e.base[r] && l(t) ? (E(e), (e.copy[r] = P(t, e))) : t
                        })(this[c], r)
                      },
                      set: function (e) {
                        !(function (e, r, t) {
                          if ((x(e), (e.assigned[r] = !0), !e.modified)) {
                            if (g(z(e)[r], t)) return
                            A(e), E(e)
                          }
                          e.copy[r] = t
                        })(this[c], r, e)
                      },
                    }),
                Object.defineProperty(e, r, n)
            })(n, r, t || v(e, r))
          })
          var o,
            i,
            a,
            f = {
              scope: r ? r.scope : O(),
              modified: !1,
              finalizing: !1,
              finalized: !1,
              assigned: {},
              parent: r,
              base: e,
              draft: n,
              copy: null,
              revoke: j,
              revoked: !1,
            }
          return (
            (o = n),
            (i = c),
            (a = f),
            Object.defineProperty(o, i, { value: a, enumerable: !1, writable: !0 }),
            f.scope.push(f),
            n
          )
        },
      }),
      I = [],
      N = function () {
        return I[I.length - 1]
      }
    function _(e, r) {
      var t = {
          scope: r ? r.scope : N(),
          modified: !1,
          finalized: !1,
          assigned: {},
          parent: r,
          base: e,
          draft: null,
          drafts: {},
          copy: null,
          revoke: null,
        },
        n = Array.isArray(e) ? Proxy.revocable([t], R) : Proxy.revocable(t, C),
        o = n.revoke,
        i = n.proxy
      return (t.draft = i), (t.revoke = o), t.scope.push(t), i
    }
    var C = {
        get: function (e, r) {
          if (r === c) return e
          var t = e.drafts
          if (!e.modified && b(t, r)) return t[r]
          var n = U(e)[r]
          if (e.finalized || !l(n)) return n
          if (e.modified) {
            if (n !== e.base[r]) return n
            t = e.copy
          }
          return (t[r] = _(n, e))
        },
        has: function (e, r) {
          return r in U(e)
        },
        ownKeys: function (e) {
          return Reflect.ownKeys(U(e))
        },
        set: function (e, r, t) {
          if (!e.modified) {
            if (t ? g(e.base[r], t) || t === e.drafts[r] : g(e.base[r], t) && r in e.base) return !0
            K(e)
          }
          return (e.assigned[r] = !0), (e.copy[r] = t), !0
        },
        deleteProperty: function (e, r) {
          return (void 0 !== e.base[r] || r in e.base) && ((e.assigned[r] = !1), K(e)), e.copy && delete e.copy[r], !0
        },
        getOwnPropertyDescriptor: function (e, r) {
          var t = U(e),
            n = Reflect.getOwnPropertyDescriptor(t, r)
          return n && ((n.writable = !0), (n.configurable = !Array.isArray(t) || 'length' !== r)), n
        },
        defineProperty: function () {
          throw new Error('Object.defineProperty() cannot be used on an Immer draft')
        },
        getPrototypeOf: function (e) {
          return Object.getPrototypeOf(e.base)
        },
        setPrototypeOf: function () {
          throw new Error('Object.setPrototypeOf() cannot be used on an Immer draft')
        },
      },
      R = {}
    function U(e) {
      return e.copy || e.base
    }
    function K(e) {
      e.modified || ((e.modified = !0), (e.copy = p(h(e.base), e.drafts)), (e.drafts = null), e.parent && K(e.parent))
    }
    y(C, function (e, r) {
      R[e] = function () {
        return (arguments[0] = arguments[0][0]), r.apply(this, arguments)
      }
    }),
      (R.deleteProperty = function (e, r) {
        if (isNaN(parseInt(r))) throw new Error('Immer only supports deleting array indices')
        return C.deleteProperty.call(this, e[0], r)
      }),
      (R.set = function (e, r, t) {
        if ('length' !== r && isNaN(parseInt(r)))
          throw new Error("Immer only supports setting array indices and the 'length' property")
        return C.set.call(this, e[0], r, t)
      })
    var T = Object.freeze({ scopes: I, currentScope: N, willFinalize: function () {}, createDraft: _ })
    function $(e, r) {
      for (var t = 0; t < r.length; t++) {
        var n = r[t],
          i = n.path
        if (0 === i.length && 'replace' === n.op) e = n.value
        else {
          for (var a = e, f = 0; f < i.length - 1; f++)
            if (!(a = a[i[f]]) || 'object' !== (void 0 === a ? 'undefined' : o(a)))
              throw new Error("Cannot apply patch, path doesn't resolve: " + i.join('/'))
          var u = i[i.length - 1]
          switch (n.op) {
            case 'replace':
            case 'add':
              a[u] = n.value
              break
            case 'remove':
              if (Array.isArray(a)) {
                if (u !== a.length - 1)
                  throw new Error(
                    'Only the last index of an array can be removed, index: ' + u + ', length: ' + a.length,
                  )
                a.length -= 1
              } else delete a[u]
              break
            default:
              throw new Error('Unsupported patch operation: ' + n.op)
          }
        }
      }
      return e
    }
    var J = {
        useProxies: 'undefined' != typeof Proxy && 'undefined' != typeof Reflect,
        autoFreeze:
          'undefined' != typeof process
            ? 'production' !== process.env.NODE_ENV
            : 'verifyMinified' === function () {}.name,
        onAssign: null,
        onDelete: null,
        onCopy: null,
      },
      V = (function () {
        function e(r) {
          ;(function (e, r) {
            if (!(e instanceof r)) throw new TypeError('Cannot call a class as a function')
          })(this, e),
            p(this, J, r),
            this.setUseProxies(this.useProxies),
            (this.produce = this.produce.bind(this))
        }
        return (
          a(e, [
            {
              key: 'produce',
              value: function (e, r, t) {
                var n = this
                if ('function' == typeof e && 'function' != typeof r) {
                  var o = r
                  return (
                    (r = e),
                    function () {
                      for (var e = arguments.length, t = Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
                        t[i - 1] = arguments[i]
                      var a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o
                      return n.produce(a, function (e) {
                        var n
                        return (n = r).call.apply(n, [e, e].concat(t))
                      })
                    }
                  )
                }
                if ('function' != typeof r)
                  throw new Error(
                    'if first argument is not a function, the second argument to produce should be a function',
                  )
                if (void 0 !== t && 'function' != typeof t)
                  throw new Error('the third argument of a producer should not be set or a function')
                var i = void 0
                if (l(e)) {
                  this.scopes.push([])
                  var a = this.createDraft(e)
                  try {
                    ;(i = r.call(a, a)), this.willFinalize(i, a, !!t)
                    var u = t && [],
                      s = t && []
                    if (void 0 === i || i === a) i = this.finalize(a, [], u, s)
                    else {
                      if (a[c].modified)
                        throw new Error(
                          'An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.',
                        )
                      l(i) && (i = this.finalize(i)),
                        t &&
                          (u.push({ op: 'replace', path: [], value: i }), s.push({ op: 'replace', path: [], value: e }))
                    }
                  } finally {
                    this.currentScope().forEach(function (e) {
                      return e.revoke()
                    }),
                      this.scopes.pop()
                  }
                  t && t(u, s)
                } else if (void 0 === (i = r(e))) return e
                return i === f ? void 0 : i
              },
            },
            {
              key: 'setAutoFreeze',
              value: function (e) {
                this.autoFreeze = e
              },
            },
            {
              key: 'setUseProxies',
              value: function (e) {
                ;(this.useProxies = e), p(this, e ? T : F)
              },
            },
            {
              key: 'applyPatches',
              value: function (e, r) {
                return s(e)
                  ? $(e, r)
                  : this.produce(e, function (e) {
                      return $(e, r)
                    })
              },
            },
            {
              key: 'finalize',
              value: function (e, r, t, n) {
                var o = this,
                  i = e[c]
                if (!i) return Object.isFrozen(e) ? e : this.finalizeTree(e)
                if (i.scope !== this.currentScope()) return e
                if (!i.modified) return i.base
                if (!i.finalized) {
                  if (((i.finalized = !0), this.finalizeTree(i.draft, r, t, n), this.onDelete))
                    if (this.useProxies) {
                      var a = i.assigned
                      for (var f in a) a[f] || this.onDelete(i, f)
                    } else {
                      var u = i.base,
                        s = i.copy
                      y(u, function (e) {
                        b(s, e) || o.onDelete(i, e)
                      })
                    }
                  this.onCopy && this.onCopy(i),
                    this.autoFreeze && 1 === this.scopes.length && Object.freeze(i.copy),
                    t &&
                      (function (e, r, t, n) {
                        Array.isArray(e.base)
                          ? (function (e, r, t, n) {
                              for (
                                var o = e.base, i = e.copy, a = e.assigned, f = Math.min(o.length, i.length), u = 0;
                                u < f;
                                u++
                              )
                                if (a[u] && o[u] !== i[u]) {
                                  var c = r.concat(u)
                                  t.push({ op: 'replace', path: c, value: i[u] }),
                                    n.push({ op: 'replace', path: c, value: o[u] })
                                }
                              if (f < i.length) {
                                for (var s = f; s < i.length; s++) t.push({ op: 'add', path: r.concat(s), value: i[s] })
                                n.push({ op: 'replace', path: r.concat('length'), value: o.length })
                              } else if (f < o.length) {
                                t.push({ op: 'replace', path: r.concat('length'), value: i.length })
                                for (var l = f; l < o.length; l++) n.push({ op: 'add', path: r.concat(l), value: o[l] })
                              }
                            })(e, r, t, n)
                          : (function (e, r, t, n) {
                              var o = e.base,
                                i = e.copy
                              y(e.assigned, function (e, a) {
                                var f = o[e],
                                  u = i[e],
                                  c = a ? (e in o ? 'replace' : 'add') : 'remove'
                                if (f !== u || 'replace' !== c) {
                                  var s = r.concat(e)
                                  t.push('remove' === c ? { op: c, path: s } : { op: c, path: s, value: u }),
                                    n.push(
                                      'add' === c
                                        ? { op: 'remove', path: s }
                                        : 'remove' === c
                                        ? { op: 'add', path: s, value: f }
                                        : { op: 'replace', path: s, value: f },
                                    )
                                }
                              })
                            })(e, r, t, n)
                      })(i, r, t, n)
                }
                return i.copy
              },
            },
            {
              key: 'finalizeTree',
              value: function (e, r, t, n) {
                var o = this,
                  i = e[c]
                i &&
                  (this.useProxies || ((i.finalizing = !0), (i.copy = h(i.draft, !0)), (i.finalizing = !1)),
                  (e = i.copy))
                var a = this.onAssign
                return (
                  y(e, function f(u, c, p) {
                    if (c === p) throw Error('Immer forbids circular references')
                    var d = !!i && p === e
                    if (s(c)) {
                      if (
                        ((c = t && d && !i.assigned[u] ? o.finalize(c, r.concat(u), t, n) : o.finalize(c)),
                        Array.isArray(p) || v(p, u) ? (p[u] = c) : Object.defineProperty(p, u, { value: c }),
                        d && c === i.base[u])
                      )
                        return
                    } else {
                      if (d && g(c, i.base[u])) return
                      l(c) && !Object.isFrozen(c) && y(c, f)
                    }
                    d && a && a(i, u, c)
                  }),
                  e
                )
              },
            },
          ]),
          e
        )
      })(),
      q = new V(),
      B = q.produce,
      G = q.setAutoFreeze.bind(q),
      H = q.setUseProxies.bind(q),
      L = q.applyPatches.bind(q)
    ;(e.produce = B),
      (e.default = B),
      (e.setAutoFreeze = G),
      (e.setUseProxies = H),
      (e.applyPatches = L),
      (e.Immer = V),
      (e.original = function (e) {
        if (e && e[c]) return e[c].base
      }),
      (e.isDraft = s),
      (e.isDraftable = l),
      (e.nothing = f),
      (e.immerable = u),
      Object.defineProperty(e, '__esModule', { value: !0 })
  }),
  'object' == typeof exports && 'undefined' != typeof module
    ? r(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], r)
    : r((e.immer = {})),
  (function (global, factory) {
    'object' == typeof exports && 'undefined' != typeof module
      ? (module.exports = factory())
      : 'function' == typeof define && define.amd
      ? define(factory)
      : (global.moment = factory())
  })(this, function () {
    'use strict'
    var hookCallback, some
    function hooks() {
      return hookCallback.apply(null, arguments)
    }
    function isArray(input) {
      return input instanceof Array || '[object Array]' === Object.prototype.toString.call(input)
    }
    function isObject(input) {
      return null != input && '[object Object]' === Object.prototype.toString.call(input)
    }
    function isUndefined(input) {
      return void 0 === input
    }
    function isNumber(input) {
      return 'number' == typeof input || '[object Number]' === Object.prototype.toString.call(input)
    }
    function isDate(input) {
      return input instanceof Date || '[object Date]' === Object.prototype.toString.call(input)
    }
    function map(arr, fn) {
      var i,
        res = []
      for (i = 0; i < arr.length; ++i) res.push(fn(arr[i], i))
      return res
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b)
    }
    function extend(a, b) {
      for (var i in b) hasOwnProp(b, i) && (a[i] = b[i])
      return (
        hasOwnProp(b, 'toString') && (a.toString = b.toString), hasOwnProp(b, 'valueOf') && (a.valueOf = b.valueOf), a
      )
    }
    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, !0).utc()
    }
    function getParsingFlags(m) {
      return (
        null == m._pf &&
          (m._pf = {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: !1,
            weekdayMismatch: !1,
          }),
        m._pf
      )
    }
    function isValid(m) {
      if (null == m._isValid) {
        var flags = getParsingFlags(m),
          parsedParts = some.call(flags.parsedDateParts, function (i) {
            return null != i
          }),
          isNowValid =
            !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts))
        if (
          (m._strict &&
            (isNowValid =
              isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour),
          null != Object.isFrozen && Object.isFrozen(m))
        )
          return isNowValid
        m._isValid = isNowValid
      }
      return m._isValid
    }
    function createInvalid(flags) {
      var m = createUTC(NaN)
      return null != flags ? extend(getParsingFlags(m), flags) : (getParsingFlags(m).userInvalidated = !0), m
    }
    some = Array.prototype.some
      ? Array.prototype.some
      : function (fun) {
          for (var t = Object(this), len = t.length >>> 0, i = 0; i < len; i++)
            if (i in t && fun.call(this, t[i], i, t)) return !0
          return !1
        }
    var momentProperties = (hooks.momentProperties = [])
    function copyConfig(to, from) {
      var i, prop, val
      if (
        (isUndefined(from._isAMomentObject) || (to._isAMomentObject = from._isAMomentObject),
        isUndefined(from._i) || (to._i = from._i),
        isUndefined(from._f) || (to._f = from._f),
        isUndefined(from._l) || (to._l = from._l),
        isUndefined(from._strict) || (to._strict = from._strict),
        isUndefined(from._tzm) || (to._tzm = from._tzm),
        isUndefined(from._isUTC) || (to._isUTC = from._isUTC),
        isUndefined(from._offset) || (to._offset = from._offset),
        isUndefined(from._pf) || (to._pf = getParsingFlags(from)),
        isUndefined(from._locale) || (to._locale = from._locale),
        momentProperties.length > 0)
      )
        for (i = 0; i < momentProperties.length; i++)
          isUndefined((val = from[(prop = momentProperties[i])])) || (to[prop] = val)
      return to
    }
    var updateInProgress = !1
    function Moment(config) {
      copyConfig(this, config),
        (this._d = new Date(null != config._d ? config._d.getTime() : NaN)),
        this.isValid() || (this._d = new Date(NaN)),
        !1 === updateInProgress && ((updateInProgress = !0), hooks.updateOffset(this), (updateInProgress = !1))
    }
    function isMoment(obj) {
      return obj instanceof Moment || (null != obj && null != obj._isAMomentObject)
    }
    function absFloor(number) {
      return number < 0 ? Math.ceil(number) || 0 : Math.floor(number)
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
        value = 0
      return 0 !== coercedNumber && isFinite(coercedNumber) && (value = absFloor(coercedNumber)), value
    }
    function compareArrays(array1, array2, dontConvert) {
      var i,
        len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0
      for (i = 0; i < len; i++)
        ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) && diffs++
      return diffs + lengthDiff
    }
    function warn(msg) {
      !1 === hooks.suppressDeprecationWarnings &&
        'undefined' != typeof console &&
        console.warn &&
        console.warn('Deprecation warning: ' + msg)
    }
    function deprecate(msg, fn) {
      var firstTime = !0
      return extend(function () {
        if ((null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), firstTime)) {
          for (var arg, args = [], i = 0; i < arguments.length; i++) {
            if (((arg = ''), 'object' == typeof arguments[i])) {
              for (var key in ((arg += '\n[' + i + '] '), arguments[0])) arg += key + ': ' + arguments[0][key] + ', '
              arg = arg.slice(0, -2)
            } else arg = arguments[i]
            args.push(arg)
          }
          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack),
            (firstTime = !1)
        }
        return fn.apply(this, arguments)
      }, fn)
    }
    var keys,
      deprecations = {}
    function deprecateSimple(name, msg) {
      null != hooks.deprecationHandler && hooks.deprecationHandler(name, msg),
        deprecations[name] || (warn(msg), (deprecations[name] = !0))
    }
    function isFunction(input) {
      return input instanceof Function || '[object Function]' === Object.prototype.toString.call(input)
    }
    function mergeConfigs(parentConfig, childConfig) {
      var prop,
        res = extend({}, parentConfig)
      for (prop in childConfig)
        hasOwnProp(childConfig, prop) &&
          (isObject(parentConfig[prop]) && isObject(childConfig[prop])
            ? ((res[prop] = {}), extend(res[prop], parentConfig[prop]), extend(res[prop], childConfig[prop]))
            : null != childConfig[prop]
            ? (res[prop] = childConfig[prop])
            : delete res[prop])
      for (prop in parentConfig)
        hasOwnProp(parentConfig, prop) &&
          !hasOwnProp(childConfig, prop) &&
          isObject(parentConfig[prop]) &&
          (res[prop] = extend({}, res[prop]))
      return res
    }
    function Locale(config) {
      null != config && this.set(config)
    }
    ;(hooks.suppressDeprecationWarnings = !1),
      (hooks.deprecationHandler = null),
      (keys = Object.keys
        ? Object.keys
        : function (obj) {
            var i,
              res = []
            for (i in obj) hasOwnProp(obj, i) && res.push(i)
            return res
          })
    var aliases = {}
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase()
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit
    }
    function normalizeUnits(units) {
      return 'string' == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedProp,
        prop,
        normalizedInput = {}
      for (prop in inputObject)
        hasOwnProp(inputObject, prop) &&
          (normalizedProp = normalizeUnits(prop)) &&
          (normalizedInput[normalizedProp] = inputObject[prop])
      return normalizedInput
    }
    var priorities = {}
    function addUnitPriority(unit, priority) {
      priorities[unit] = priority
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length
      return (
        (number >= 0 ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
        absNumber
      )
    }
    var formattingTokens =
        /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
      localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
      formatFunctions = {},
      formatTokenFunctions = {}
    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback
      'string' == typeof callback &&
        (func = function () {
          return this[callback]()
        }),
        token && (formatTokenFunctions[token] = func),
        padded &&
          (formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2])
          }),
        ordinal &&
          (formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token)
          })
    }
    function formatMoment(m, format) {
      return m.isValid()
        ? ((format = expandFormat(format, m.localeData())),
          (formatFunctions[format] =
            formatFunctions[format] ||
            (function (format) {
              var i,
                length,
                input,
                array = format.match(formattingTokens)
              for (i = 0, length = array.length; i < length; i++)
                formatTokenFunctions[array[i]]
                  ? (array[i] = formatTokenFunctions[array[i]])
                  : (array[i] = (input = array[i]).match(/\[[\s\S]/)
                      ? input.replace(/^\[|\]$/g, '')
                      : input.replace(/\\/g, ''))
              return function (mom) {
                var i,
                  output = ''
                for (i = 0; i < length; i++) output += isFunction(array[i]) ? array[i].call(mom, format) : array[i]
                return output
              }
            })(format)),
          formatFunctions[format](m))
        : m.localeData().invalidDate()
    }
    function expandFormat(format, locale) {
      var i = 5
      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input
      }
      for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format); )
        (format = format.replace(localFormattingTokens, replaceLongDateFormatTokens)),
          (localFormattingTokens.lastIndex = 0),
          (i -= 1)
      return format
    }
    var match1 = /\d/,
      match2 = /\d\d/,
      match3 = /\d{3}/,
      match4 = /\d{4}/,
      match6 = /[+-]?\d{6}/,
      match1to2 = /\d\d?/,
      match3to4 = /\d\d\d\d?/,
      match5to6 = /\d\d\d\d\d\d?/,
      match1to3 = /\d{1,3}/,
      match1to4 = /\d{1,4}/,
      match1to6 = /[+-]?\d{1,6}/,
      matchUnsigned = /\d+/,
      matchSigned = /[+-]?\d+/,
      matchOffset = /Z|[+-]\d\d:?\d\d/gi,
      matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
      matchWord =
        /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
      regexes = {}
    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex)
        ? regex
        : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex
          }
    }
    function getParseRegexForToken(token, config) {
      return hasOwnProp(regexes, token)
        ? regexes[token](config._strict, config._locale)
        : new RegExp(
            regexEscape(
              token
                .replace('\\', '')
                .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                  return p1 || p2 || p3 || p4
                }),
            ),
          )
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
    }
    var tokens = {}
    function addParseToken(token, callback) {
      var i,
        func = callback
      for (
        'string' == typeof token && (token = [token]),
          isNumber(callback) &&
            (func = function (input, array) {
              array[callback] = toInt(input)
            }),
          i = 0;
        i < token.length;
        i++
      )
        tokens[token[i]] = func
    }
    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        ;(config._w = config._w || {}), callback(input, config._w, config, token)
      })
    }
    function addTimeToArrayFromToken(token, input, config) {
      null != input && hasOwnProp(tokens, token) && tokens[token](input, config._a, config, token)
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365
    }
    function isLeapYear(year) {
      return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0
    }
    addFormatToken('Y', 0, 0, function () {
      var y = this.year()
      return y <= 9999 ? '' + y : '+' + y
    }),
      addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100
      }),
      addFormatToken(0, ['YYYY', 4], 0, 'year'),
      addFormatToken(0, ['YYYYY', 5], 0, 'year'),
      addFormatToken(0, ['YYYYYY', 6, !0], 0, 'year'),
      addUnitAlias('year', 'y'),
      addUnitPriority('year', 1),
      addRegexToken('Y', matchSigned),
      addRegexToken('YY', match1to2, match2),
      addRegexToken('YYYY', match1to4, match4),
      addRegexToken('YYYYY', match1to6, match6),
      addRegexToken('YYYYYY', match1to6, match6),
      addParseToken(['YYYYY', 'YYYYYY'], 0),
      addParseToken('YYYY', function (input, array) {
        array[0] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input)
      }),
      addParseToken('YY', function (input, array) {
        array[0] = hooks.parseTwoDigitYear(input)
      }),
      addParseToken('Y', function (input, array) {
        array[0] = parseInt(input, 10)
      }),
      (hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3)
      })
    var indexOf,
      getSetYear = makeGetSet('FullYear', !0)
    function makeGetSet(unit, keepTime) {
      return function (value) {
        return null != value ? (set$1(this, unit, value), hooks.updateOffset(this, keepTime), this) : get(this, unit)
      }
    }
    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN
    }
    function set$1(mom, unit, value) {
      mom.isValid() &&
        !isNaN(value) &&
        ('FullYear' === unit && isLeapYear(mom.year()) && 1 === mom.month() && 29 === mom.date()
          ? mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()))
          : mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value))
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) return NaN
      var x,
        modMonth = ((month % (x = 12)) + x) % x
      return (
        (year += (month - modMonth) / 12), 1 === modMonth ? (isLeapYear(year) ? 29 : 28) : 31 - ((modMonth % 7) % 2)
      )
    }
    ;(indexOf = Array.prototype.indexOf
      ? Array.prototype.indexOf
      : function (o) {
          var i
          for (i = 0; i < this.length; ++i) if (this[i] === o) return i
          return -1
        }),
      addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1
      }),
      addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format)
      }),
      addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format)
      }),
      addUnitAlias('month', 'M'),
      addUnitPriority('month', 8),
      addRegexToken('M', match1to2),
      addRegexToken('MM', match1to2, match2),
      addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict)
      }),
      addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict)
      }),
      addParseToken(['M', 'MM'], function (input, array) {
        array[1] = toInt(input) - 1
      }),
      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict)
        null != month ? (array[1] = month) : (getParsingFlags(config).invalidMonth = input)
      })
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
      defaultLocaleMonths =
        'January_February_March_April_May_June_July_August_September_October_November_December'.split('_')
    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_')
    function handleStrictParse(monthName, format, strict) {
      var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase()
      if (!this._monthsParse)
        for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], i = 0; i < 12; ++i)
          (mom = createUTC([2e3, i])),
            (this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase()),
            (this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase())
      return strict
        ? 'MMM' === format
          ? -1 !== (ii = indexOf.call(this._shortMonthsParse, llc))
            ? ii
            : null
          : -1 !== (ii = indexOf.call(this._longMonthsParse, llc))
          ? ii
          : null
        : 'MMM' === format
        ? -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) ||
          -1 !== (ii = indexOf.call(this._longMonthsParse, llc))
          ? ii
          : null
        : -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) ||
          -1 !== (ii = indexOf.call(this._shortMonthsParse, llc))
        ? ii
        : null
    }
    function setMonth(mom, value) {
      var dayOfMonth
      if (!mom.isValid()) return mom
      if ('string' == typeof value)
        if (/^\d+$/.test(value)) value = toInt(value)
        else if (!isNumber((value = mom.localeData().monthsParse(value)))) return mom
      return (
        (dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value))),
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth),
        mom
      )
    }
    function getSetMonth(value) {
      return null != value ? (setMonth(this, value), hooks.updateOffset(this, !0), this) : get(this, 'Month')
    }
    var defaultMonthsShortRegex = matchWord
    var defaultMonthsRegex = matchWord
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length
      }
      var i,
        mom,
        shortPieces = [],
        longPieces = [],
        mixedPieces = []
      for (i = 0; i < 12; i++)
        (mom = createUTC([2e3, i])),
          shortPieces.push(this.monthsShort(mom, '')),
          longPieces.push(this.months(mom, '')),
          mixedPieces.push(this.months(mom, '')),
          mixedPieces.push(this.monthsShort(mom, ''))
      for (shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), i = 0; i < 12; i++)
        (shortPieces[i] = regexEscape(shortPieces[i])), (longPieces[i] = regexEscape(longPieces[i]))
      for (i = 0; i < 24; i++) mixedPieces[i] = regexEscape(mixedPieces[i])
      ;(this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i')),
        (this._monthsShortRegex = this._monthsRegex),
        (this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i')),
        (this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i'))
    }
    function createDate(y, m, d, h, M, s, ms) {
      var date
      return (
        y < 100 && y >= 0
          ? ((date = new Date(y + 400, m, d, h, M, s, ms)), isFinite(date.getFullYear()) && date.setFullYear(y))
          : (date = new Date(y, m, d, h, M, s, ms)),
        date
      )
    }
    function createUTCDate(y) {
      var date
      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments)
        ;(args[0] = y + 400),
          (date = new Date(Date.UTC.apply(null, args))),
          isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y)
      } else date = new Date(Date.UTC.apply(null, arguments))
      return date
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy
      return -((7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7) + fwd - 1
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var resYear,
        resDayOfYear,
        dayOfYear = 1 + 7 * (week - 1) + ((7 + weekday - dow) % 7) + firstWeekOffset(year, dow, doy)
      return (
        dayOfYear <= 0
          ? (resDayOfYear = daysInYear((resYear = year - 1)) + dayOfYear)
          : dayOfYear > daysInYear(year)
          ? ((resYear = year + 1), (resDayOfYear = dayOfYear - daysInYear(year)))
          : ((resYear = year), (resDayOfYear = dayOfYear)),
        { year: resYear, dayOfYear: resDayOfYear }
      )
    }
    function weekOfYear(mom, dow, doy) {
      var resWeek,
        resYear,
        weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1
      return (
        week < 1
          ? (resWeek = week + weeksInYear((resYear = mom.year() - 1), dow, doy))
          : week > weeksInYear(mom.year(), dow, doy)
          ? ((resWeek = week - weeksInYear(mom.year(), dow, doy)), (resYear = mom.year() + 1))
          : ((resYear = mom.year()), (resWeek = week)),
        { week: resWeek, year: resYear }
      )
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy)
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7
    }
    addFormatToken('w', ['ww', 2], 'wo', 'week'),
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'),
      addUnitAlias('week', 'w'),
      addUnitAlias('isoWeek', 'W'),
      addUnitPriority('week', 5),
      addUnitPriority('isoWeek', 5),
      addRegexToken('w', match1to2),
      addRegexToken('ww', match1to2, match2),
      addRegexToken('W', match1to2),
      addRegexToken('WW', match1to2, match2),
      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input)
      })
    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n))
    }
    addFormatToken('d', 0, 'do', 'day'),
      addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format)
      }),
      addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format)
      }),
      addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format)
      }),
      addFormatToken('e', 0, 0, 'weekday'),
      addFormatToken('E', 0, 0, 'isoWeekday'),
      addUnitAlias('day', 'd'),
      addUnitAlias('weekday', 'e'),
      addUnitAlias('isoWeekday', 'E'),
      addUnitPriority('day', 11),
      addUnitPriority('weekday', 11),
      addUnitPriority('isoWeekday', 11),
      addRegexToken('d', match1to2),
      addRegexToken('e', match1to2),
      addRegexToken('E', match1to2),
      addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict)
      }),
      addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict)
      }),
      addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict)
      }),
      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict)
        null != weekday ? (week.d = weekday) : (getParsingFlags(config).invalidWeekday = input)
      }),
      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input)
      })
    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_')
    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_')
    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_')
    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase()
      if (!this._weekdaysParse)
        for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], i = 0; i < 7; ++i)
          (mom = createUTC([2e3, 1]).day(i)),
            (this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase()),
            (this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase()),
            (this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase())
      return strict
        ? 'dddd' === format
          ? -1 !== (ii = indexOf.call(this._weekdaysParse, llc))
            ? ii
            : null
          : 'ddd' === format
          ? -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc))
            ? ii
            : null
          : -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc))
          ? ii
          : null
        : 'dddd' === format
        ? -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) ||
          -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) ||
          -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc))
          ? ii
          : null
        : 'ddd' === format
        ? -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) ||
          -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) ||
          -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc))
          ? ii
          : null
        : -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ||
          -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) ||
          -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc))
        ? ii
        : null
    }
    var defaultWeekdaysRegex = matchWord
    var defaultWeekdaysShortRegex = matchWord
    var defaultWeekdaysMinRegex = matchWord
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length
      }
      var i,
        mom,
        minp,
        shortp,
        longp,
        minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = []
      for (i = 0; i < 7; i++)
        (mom = createUTC([2e3, 1]).day(i)),
          (minp = this.weekdaysMin(mom, '')),
          (shortp = this.weekdaysShort(mom, '')),
          (longp = this.weekdays(mom, '')),
          minPieces.push(minp),
          shortPieces.push(shortp),
          longPieces.push(longp),
          mixedPieces.push(minp),
          mixedPieces.push(shortp),
          mixedPieces.push(longp)
      for (
        minPieces.sort(cmpLenRev),
          shortPieces.sort(cmpLenRev),
          longPieces.sort(cmpLenRev),
          mixedPieces.sort(cmpLenRev),
          i = 0;
        i < 7;
        i++
      )
        (shortPieces[i] = regexEscape(shortPieces[i])),
          (longPieces[i] = regexEscape(longPieces[i])),
          (mixedPieces[i] = regexEscape(mixedPieces[i]))
      ;(this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i')),
        (this._weekdaysShortRegex = this._weekdaysRegex),
        (this._weekdaysMinRegex = this._weekdaysRegex),
        (this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i')),
        (this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i')),
        (this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i'))
    }
    function hFormat() {
      return this.hours() % 12 || 12
    }
    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase)
      })
    }
    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse
    }
    addFormatToken('H', ['HH', 2], 0, 'hour'),
      addFormatToken('h', ['hh', 2], 0, hFormat),
      addFormatToken('k', ['kk', 2], 0, function () {
        return this.hours() || 24
      }),
      addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2)
      }),
      addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
      }),
      addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2)
      }),
      addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
      }),
      meridiem('a', !0),
      meridiem('A', !1),
      addUnitAlias('hour', 'h'),
      addUnitPriority('hour', 13),
      addRegexToken('a', matchMeridiem),
      addRegexToken('A', matchMeridiem),
      addRegexToken('H', match1to2),
      addRegexToken('h', match1to2),
      addRegexToken('k', match1to2),
      addRegexToken('HH', match1to2, match2),
      addRegexToken('hh', match1to2, match2),
      addRegexToken('kk', match1to2, match2),
      addRegexToken('hmm', match3to4),
      addRegexToken('hmmss', match5to6),
      addRegexToken('Hmm', match3to4),
      addRegexToken('Hmmss', match5to6),
      addParseToken(['H', 'HH'], 3),
      addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input)
        array[3] = 24 === kInput ? 0 : kInput
      }),
      addParseToken(['a', 'A'], function (input, array, config) {
        ;(config._isPm = config._locale.isPM(input)), (config._meridiem = input)
      }),
      addParseToken(['h', 'hh'], function (input, array, config) {
        ;(array[3] = toInt(input)), (getParsingFlags(config).bigHour = !0)
      }),
      addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2
        ;(array[3] = toInt(input.substr(0, pos))),
          (array[4] = toInt(input.substr(pos))),
          (getParsingFlags(config).bigHour = !0)
      }),
      addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
          pos2 = input.length - 2
        ;(array[3] = toInt(input.substr(0, pos1))),
          (array[4] = toInt(input.substr(pos1, 2))),
          (array[5] = toInt(input.substr(pos2))),
          (getParsingFlags(config).bigHour = !0)
      }),
      addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2
        ;(array[3] = toInt(input.substr(0, pos))), (array[4] = toInt(input.substr(pos)))
      }),
      addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
          pos2 = input.length - 2
        ;(array[3] = toInt(input.substr(0, pos1))),
          (array[4] = toInt(input.substr(pos1, 2))),
          (array[5] = toInt(input.substr(pos2)))
      })
    var globalLocale,
      getSetHour = makeGetSet('Hours', !0),
      baseConfig = {
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
        },
        longDateFormat: {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
        },
        invalidDate: 'Invalid date',
        ordinal: '%d',
        dayOfMonthOrdinalParse: /\d{1,2}/,
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        },
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: { dow: 0, doy: 6 },
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: /[ap]\.?m?\.?/i,
      },
      locales = {},
      localeFamilies = {}
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key
    }
    function loadLocale(name) {
      var oldLocale = null
      if (!locales[name] && 'undefined' != typeof module && module && module.exports)
        try {
          ;(oldLocale = globalLocale._abbr), require('./locale/' + name), getSetGlobalLocale(oldLocale)
        } catch (e) {}
      return locales[name]
    }
    function getSetGlobalLocale(key, values) {
      var data
      return (
        key &&
          ((data = isUndefined(values) ? getLocale(key) : defineLocale(key, values))
            ? (globalLocale = data)
            : 'undefined' != typeof console &&
              console.warn &&
              console.warn('Locale ' + key + ' not found. Did you forget to load it?')),
        globalLocale._abbr
      )
    }
    function defineLocale(name, config) {
      if (null !== config) {
        var locale,
          parentConfig = baseConfig
        if (((config.abbr = name), null != locales[name]))
          deprecateSimple(
            'defineLocaleOverride',
            'use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.',
          ),
            (parentConfig = locales[name]._config)
        else if (null != config.parentLocale)
          if (null != locales[config.parentLocale]) parentConfig = locales[config.parentLocale]._config
          else {
            if (null == (locale = loadLocale(config.parentLocale)))
              return (
                localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []),
                localeFamilies[config.parentLocale].push({ name, config }),
                null
              )
            parentConfig = locale._config
          }
        return (
          (locales[name] = new Locale(mergeConfigs(parentConfig, config))),
          localeFamilies[name] &&
            localeFamilies[name].forEach(function (x) {
              defineLocale(x.name, x.config)
            }),
          getSetGlobalLocale(name),
          locales[name]
        )
      }
      return delete locales[name], null
    }
    function getLocale(key) {
      var locale
      if ((key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key)) return globalLocale
      if (!isArray(key)) {
        if ((locale = loadLocale(key))) return locale
        key = [key]
      }
      return (function (names) {
        for (var j, next, locale, split, i = 0; i < names.length; ) {
          for (
            j = (split = normalizeLocale(names[i]).split('-')).length,
              next = (next = normalizeLocale(names[i + 1])) ? next.split('-') : null;
            j > 0;

          ) {
            if ((locale = loadLocale(split.slice(0, j).join('-')))) return locale
            if (next && next.length >= j && compareArrays(split, next, !0) >= j - 1) break
            j--
          }
          i++
        }
        return globalLocale
      })(key)
    }
    function checkOverflow(m) {
      var overflow,
        a = m._a
      return (
        a &&
          -2 === getParsingFlags(m).overflow &&
          ((overflow =
            a[1] < 0 || a[1] > 11
              ? 1
              : a[2] < 1 || a[2] > daysInMonth(a[0], a[1])
              ? 2
              : a[3] < 0 || a[3] > 24 || (24 === a[3] && (0 !== a[4] || 0 !== a[5] || 0 !== a[6]))
              ? 3
              : a[4] < 0 || a[4] > 59
              ? 4
              : a[5] < 0 || a[5] > 59
              ? 5
              : a[6] < 0 || a[6] > 999
              ? 6
              : -1),
          getParsingFlags(m)._overflowDayOfYear && (overflow < 0 || overflow > 2) && (overflow = 2),
          getParsingFlags(m)._overflowWeeks && -1 === overflow && (overflow = 7),
          getParsingFlags(m)._overflowWeekday && -1 === overflow && (overflow = 8),
          (getParsingFlags(m).overflow = overflow)),
        m
      )
    }
    function defaults(a, b, c) {
      return null != a ? a : null != b ? b : c
    }
    function configFromArray(config) {
      var i,
        date,
        currentDate,
        expectedWeekday,
        yearToUse,
        input = []
      if (!config._d) {
        for (
          currentDate = (function (config) {
            var nowValue = new Date(hooks.now())
            return config._useUTC
              ? [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()]
              : [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()]
          })(config),
            config._w &&
              null == config._a[2] &&
              null == config._a[1] &&
              (function (config) {
                var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow
                if (null != (w = config._w).GG || null != w.W || null != w.E)
                  (dow = 1),
                    (doy = 4),
                    (weekYear = defaults(w.GG, config._a[0], weekOfYear(createLocal(), 1, 4).year)),
                    (week = defaults(w.W, 1)),
                    ((weekday = defaults(w.E, 1)) < 1 || weekday > 7) && (weekdayOverflow = !0)
                else {
                  ;(dow = config._locale._week.dow), (doy = config._locale._week.doy)
                  var curWeek = weekOfYear(createLocal(), dow, doy)
                  ;(weekYear = defaults(w.gg, config._a[0], curWeek.year)),
                    (week = defaults(w.w, curWeek.week)),
                    null != w.d
                      ? ((weekday = w.d) < 0 || weekday > 6) && (weekdayOverflow = !0)
                      : null != w.e
                      ? ((weekday = w.e + dow), (w.e < 0 || w.e > 6) && (weekdayOverflow = !0))
                      : (weekday = dow)
                }
                week < 1 || week > weeksInYear(weekYear, dow, doy)
                  ? (getParsingFlags(config)._overflowWeeks = !0)
                  : null != weekdayOverflow
                  ? (getParsingFlags(config)._overflowWeekday = !0)
                  : ((temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy)),
                    (config._a[0] = temp.year),
                    (config._dayOfYear = temp.dayOfYear))
              })(config),
            null != config._dayOfYear &&
              ((yearToUse = defaults(config._a[0], currentDate[0])),
              (config._dayOfYear > daysInYear(yearToUse) || 0 === config._dayOfYear) &&
                (getParsingFlags(config)._overflowDayOfYear = !0),
              (date = createUTCDate(yearToUse, 0, config._dayOfYear)),
              (config._a[1] = date.getUTCMonth()),
              (config._a[2] = date.getUTCDate())),
            i = 0;
          i < 3 && null == config._a[i];
          ++i
        )
          config._a[i] = input[i] = currentDate[i]
        for (; i < 7; i++) config._a[i] = input[i] = null == config._a[i] ? (2 === i ? 1 : 0) : config._a[i]
        24 === config._a[3] &&
          0 === config._a[4] &&
          0 === config._a[5] &&
          0 === config._a[6] &&
          ((config._nextDay = !0), (config._a[3] = 0)),
          (config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input)),
          (expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay()),
          null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm),
          config._nextDay && (config._a[3] = 24),
          config._w &&
            void 0 !== config._w.d &&
            config._w.d !== expectedWeekday &&
            (getParsingFlags(config).weekdayMismatch = !0)
      }
    }
    var extendedIsoRegex =
        /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
      basicIsoRegex =
        /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
      tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
      isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, !1],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, !1],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, !1],
        ['YYYYDDD', /\d{7}/],
      ],
      isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/],
      ],
      aspNetJsonRegex = /^\/?Date\((\-?\d+)/i
    function configFromISO(config) {
      var i,
        l,
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string)
      if (match) {
        for (getParsingFlags(config).iso = !0, i = 0, l = isoDates.length; i < l; i++)
          if (isoDates[i][1].exec(match[1])) {
            ;(dateFormat = isoDates[i][0]), (allowTime = !1 !== isoDates[i][2])
            break
          }
        if (null == dateFormat) return void (config._isValid = !1)
        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++)
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || ' ') + isoTimes[i][0]
              break
            }
          if (null == timeFormat) return void (config._isValid = !1)
        }
        if (!allowTime && null != timeFormat) return void (config._isValid = !1)
        if (match[4]) {
          if (!tzRegex.exec(match[4])) return void (config._isValid = !1)
          tzFormat = 'Z'
        }
        ;(config._f = dateFormat + (timeFormat || '') + (tzFormat || '')), configFromStringAndFormat(config)
      } else config._isValid = !1
    }
    var rfc2822 =
      /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10)
      return year <= 49 ? 2e3 + year : year <= 999 ? 1900 + year : year
    }
    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -240,
      EST: -300,
      CDT: -300,
      CST: -360,
      MDT: -360,
      MST: -420,
      PDT: -420,
      PST: -480,
    }
    function configFromRFC2822(config) {
      var yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr,
        result,
        match = rfc2822.exec(
          config._i
            .replace(/\([^)]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, ''),
        )
      if (match) {
        var parsedArray =
          ((yearStr = match[4]),
          (monthStr = match[3]),
          (dayStr = match[2]),
          (hourStr = match[5]),
          (minuteStr = match[6]),
          (secondStr = match[7]),
          (result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
          ]),
          secondStr && result.push(parseInt(secondStr, 10)),
          result)
        if (
          !(function (weekdayStr, parsedInput, config) {
            return (
              !weekdayStr ||
              defaultLocaleWeekdaysShort.indexOf(weekdayStr) ===
                new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay() ||
              ((getParsingFlags(config).weekdayMismatch = !0), (config._isValid = !1), !1)
            )
          })(match[1], parsedArray, config)
        )
          return
        ;(config._a = parsedArray),
          (config._tzm = (function (obsOffset, militaryOffset, numOffset) {
            if (obsOffset) return obsOffsets[obsOffset]
            if (militaryOffset) return 0
            var hm = parseInt(numOffset, 10),
              m = hm % 100
            return ((hm - m) / 100) * 60 + m
          })(match[8], match[9], match[10])),
          (config._d = createUTCDate.apply(null, config._a)),
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm),
          (getParsingFlags(config).rfc2822 = !0)
      } else config._isValid = !1
    }
    function configFromStringAndFormat(config) {
      if (config._f !== hooks.ISO_8601)
        if (config._f !== hooks.RFC_2822) {
          ;(config._a = []), (getParsingFlags(config).empty = !0)
          var i,
            parsedInput,
            tokens,
            token,
            skipped,
            string = '' + config._i,
            stringLength = string.length,
            totalParsedInputLength = 0
          for (
            tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], i = 0;
            i < tokens.length;
            i++
          )
            (token = tokens[i]),
              (parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]) &&
                ((skipped = string.substr(0, string.indexOf(parsedInput))).length > 0 &&
                  getParsingFlags(config).unusedInput.push(skipped),
                (string = string.slice(string.indexOf(parsedInput) + parsedInput.length)),
                (totalParsedInputLength += parsedInput.length)),
              formatTokenFunctions[token]
                ? (parsedInput
                    ? (getParsingFlags(config).empty = !1)
                    : getParsingFlags(config).unusedTokens.push(token),
                  addTimeToArrayFromToken(token, parsedInput, config))
                : config._strict && !parsedInput && getParsingFlags(config).unusedTokens.push(token)
          ;(getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength),
            string.length > 0 && getParsingFlags(config).unusedInput.push(string),
            config._a[3] <= 12 &&
              !0 === getParsingFlags(config).bigHour &&
              config._a[3] > 0 &&
              (getParsingFlags(config).bigHour = void 0),
            (getParsingFlags(config).parsedDateParts = config._a.slice(0)),
            (getParsingFlags(config).meridiem = config._meridiem),
            (config._a[3] = (function (locale, hour, meridiem) {
              var isPm
              if (null == meridiem) return hour
              return null != locale.meridiemHour
                ? locale.meridiemHour(hour, meridiem)
                : null != locale.isPM
                ? ((isPm = locale.isPM(meridiem)) && hour < 12 && (hour += 12), isPm || 12 !== hour || (hour = 0), hour)
                : hour
            })(config._locale, config._a[3], config._meridiem)),
            configFromArray(config),
            checkOverflow(config)
        } else configFromRFC2822(config)
      else configFromISO(config)
    }
    function prepareConfig(config) {
      var input = config._i,
        format = config._f
      return (
        (config._locale = config._locale || getLocale(config._l)),
        null === input || (void 0 === format && '' === input)
          ? createInvalid({ nullInput: !0 })
          : ('string' == typeof input && (config._i = input = config._locale.preparse(input)),
            isMoment(input)
              ? new Moment(checkOverflow(input))
              : (isDate(input)
                  ? (config._d = input)
                  : isArray(format)
                  ? (function (config) {
                      var tempConfig, bestMoment, scoreToBeat, i, currentScore
                      if (0 === config._f.length)
                        return (getParsingFlags(config).invalidFormat = !0), void (config._d = new Date(NaN))
                      for (i = 0; i < config._f.length; i++)
                        (currentScore = 0),
                          (tempConfig = copyConfig({}, config)),
                          null != config._useUTC && (tempConfig._useUTC = config._useUTC),
                          (tempConfig._f = config._f[i]),
                          configFromStringAndFormat(tempConfig),
                          isValid(tempConfig) &&
                            ((currentScore += getParsingFlags(tempConfig).charsLeftOver),
                            (currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length),
                            (getParsingFlags(tempConfig).score = currentScore),
                            (null == scoreToBeat || currentScore < scoreToBeat) &&
                              ((scoreToBeat = currentScore), (bestMoment = tempConfig)))
                      extend(config, bestMoment || tempConfig)
                    })(config)
                  : format
                  ? configFromStringAndFormat(config)
                  : (function (config) {
                      var input = config._i
                      isUndefined(input)
                        ? (config._d = new Date(hooks.now()))
                        : isDate(input)
                        ? (config._d = new Date(input.valueOf()))
                        : 'string' == typeof input
                        ? (function (config) {
                            var matched = aspNetJsonRegex.exec(config._i)
                            null === matched
                              ? (configFromISO(config),
                                !1 === config._isValid &&
                                  (delete config._isValid,
                                  configFromRFC2822(config),
                                  !1 === config._isValid &&
                                    (delete config._isValid, hooks.createFromInputFallback(config))))
                              : (config._d = new Date(+matched[1]))
                          })(config)
                        : isArray(input)
                        ? ((config._a = map(input.slice(0), function (obj) {
                            return parseInt(obj, 10)
                          })),
                          configFromArray(config))
                        : isObject(input)
                        ? (function (config) {
                            if (!config._d) {
                              var i = normalizeObjectUnits(config._i)
                              ;(config._a = map(
                                [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond],
                                function (obj) {
                                  return obj && parseInt(obj, 10)
                                },
                              )),
                                configFromArray(config)
                            }
                          })(config)
                        : isNumber(input)
                        ? (config._d = new Date(input))
                        : hooks.createFromInputFallback(config)
                    })(config),
                isValid(config) || (config._d = null),
                config))
      )
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var res,
        c = {}
      return (
        (!0 !== locale && !1 !== locale) || ((strict = locale), (locale = void 0)),
        ((isObject(input) &&
          (function (obj) {
            if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(obj).length
            var k
            for (k in obj) if (obj.hasOwnProperty(k)) return !1
            return !0
          })(input)) ||
          (isArray(input) && 0 === input.length)) &&
          (input = void 0),
        (c._isAMomentObject = !0),
        (c._useUTC = c._isUTC = isUTC),
        (c._l = locale),
        (c._i = input),
        (c._f = format),
        (c._strict = strict),
        (res = new Moment(checkOverflow(prepareConfig(c))))._nextDay && (res.add(1, 'd'), (res._nextDay = void 0)),
        res
      )
    }
    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, !1)
    }
    ;(hooks.createFromInputFallback = deprecate(
      'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
      function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''))
      },
    )),
      (hooks.ISO_8601 = function () {}),
      (hooks.RFC_2822 = function () {})
    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
          var other = createLocal.apply(null, arguments)
          return this.isValid() && other.isValid() ? (other < this ? this : other) : createInvalid()
        },
      ),
      prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
          var other = createLocal.apply(null, arguments)
          return this.isValid() && other.isValid() ? (other > this ? this : other) : createInvalid()
        },
      )
    function pickBy(fn, moments) {
      var res, i
      if ((1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length)) return createLocal()
      for (res = moments[0], i = 1; i < moments.length; ++i)
        (moments[i].isValid() && !moments[i][fn](res)) || (res = moments[i])
      return res
    }
    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0
      ;(this._isValid = (function (m) {
        for (var key in m) if (-1 === indexOf.call(ordering, key) || (null != m[key] && isNaN(m[key]))) return !1
        for (var unitHasDecimal = !1, i = 0; i < ordering.length; ++i)
          if (m[ordering[i]]) {
            if (unitHasDecimal) return !1
            parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]]) && (unitHasDecimal = !0)
          }
        return !0
      })(normalizedInput)),
        (this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60),
        (this._days = +days + 7 * weeks),
        (this._months = +months + 3 * quarters + 12 * years),
        (this._data = {}),
        (this._locale = getLocale()),
        this._bubble()
    }
    function isDuration(obj) {
      return obj instanceof Duration
    }
    function absRound(number) {
      return number < 0 ? -1 * Math.round(-1 * number) : Math.round(number)
    }
    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset(),
          sign = '+'
        return (
          offset < 0 && ((offset = -offset), (sign = '-')),
          sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2)
        )
      })
    }
    offset('Z', ':'),
      offset('ZZ', ''),
      addRegexToken('Z', matchShortOffset),
      addRegexToken('ZZ', matchShortOffset),
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
        ;(config._useUTC = !0), (config._tzm = offsetFromString(matchShortOffset, input))
      })
    var chunkOffset = /([\+\-]|\d\d)/gi
    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher)
      if (null === matches) return null
      var parts = ((matches[matches.length - 1] || []) + '').match(chunkOffset) || ['-', 0, 0],
        minutes = 60 * parts[1] + toInt(parts[2])
      return 0 === minutes ? 0 : '+' === parts[0] ? minutes : -minutes
    }
    function cloneWithOffset(input, model) {
      var res, diff
      return model._isUTC
        ? ((res = model.clone()),
          (diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf()),
          res._d.setTime(res._d.valueOf() + diff),
          hooks.updateOffset(res, !1),
          res)
        : createLocal(input).local()
    }
    function getDateOffset(m) {
      return 15 * -Math.round(m._d.getTimezoneOffset() / 15)
    }
    function isUtc() {
      return !!this.isValid() && this._isUTC && 0 === this._offset
    }
    hooks.updateOffset = function () {}
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
      isoRegex =
        /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/
    function createDuration(input, key) {
      var sign,
        ret,
        diffRes,
        duration = input,
        match = null
      return (
        isDuration(input)
          ? (duration = { ms: input._milliseconds, d: input._days, M: input._months })
          : isNumber(input)
          ? ((duration = {}), key ? (duration[key] = input) : (duration.milliseconds = input))
          : (match = aspNetRegex.exec(input))
          ? ((sign = '-' === match[1] ? -1 : 1),
            (duration = {
              y: 0,
              d: toInt(match[2]) * sign,
              h: toInt(match[3]) * sign,
              m: toInt(match[4]) * sign,
              s: toInt(match[5]) * sign,
              ms: toInt(absRound(1e3 * match[6])) * sign,
            }))
          : (match = isoRegex.exec(input))
          ? ((sign = '-' === match[1] ? -1 : 1),
            (duration = {
              y: parseIso(match[2], sign),
              M: parseIso(match[3], sign),
              w: parseIso(match[4], sign),
              d: parseIso(match[5], sign),
              h: parseIso(match[6], sign),
              m: parseIso(match[7], sign),
              s: parseIso(match[8], sign),
            }))
          : null == duration
          ? (duration = {})
          : 'object' == typeof duration &&
            ('from' in duration || 'to' in duration) &&
            ((diffRes = (function (base, other) {
              var res
              if (!base.isValid() || !other.isValid()) return { milliseconds: 0, months: 0 }
              ;(other = cloneWithOffset(other, base)),
                base.isBefore(other)
                  ? (res = positiveMomentsDifference(base, other))
                  : (((res = positiveMomentsDifference(other, base)).milliseconds = -res.milliseconds),
                    (res.months = -res.months))
              return res
            })(createLocal(duration.from), createLocal(duration.to))),
            ((duration = {}).ms = diffRes.milliseconds),
            (duration.M = diffRes.months)),
        (ret = new Duration(duration)),
        isDuration(input) && hasOwnProp(input, '_locale') && (ret._locale = input._locale),
        ret
      )
    }
    function parseIso(inp, sign) {
      var res = inp && parseFloat(inp.replace(',', '.'))
      return (isNaN(res) ? 0 : res) * sign
    }
    function positiveMomentsDifference(base, other) {
      var res = {}
      return (
        (res.months = other.month() - base.month() + 12 * (other.year() - base.year())),
        base.clone().add(res.months, 'M').isAfter(other) && --res.months,
        (res.milliseconds = +other - +base.clone().add(res.months, 'M')),
        res
      )
    }
    function createAdder(direction, name) {
      return function (val, period) {
        var tmp
        return (
          null === period ||
            isNaN(+period) ||
            (deprecateSimple(
              name,
              'moment().' +
                name +
                '(period, number) is deprecated. Please use moment().' +
                name +
                '(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.',
            ),
            (tmp = val),
            (val = period),
            (period = tmp)),
          addSubtract(this, createDuration((val = 'string' == typeof val ? +val : val), period), direction),
          this
        )
      }
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months)
      mom.isValid() &&
        ((updateOffset = null == updateOffset || updateOffset),
        months && setMonth(mom, get(mom, 'Month') + months * isAdding),
        days && set$1(mom, 'Date', get(mom, 'Date') + days * isAdding),
        milliseconds && mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding),
        updateOffset && hooks.updateOffset(mom, days || months))
    }
    ;(createDuration.fn = Duration.prototype),
      (createDuration.invalid = function () {
        return createDuration(NaN)
      })
    var add = createAdder(1, 'add'),
      subtract = createAdder(-1, 'subtract')
    function monthDiff(a, b) {
      var wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()),
        anchor = a.clone().add(wholeMonthDiff, 'months')
      return (
        -(
          wholeMonthDiff +
          (b - anchor < 0
            ? (b - anchor) / (anchor - a.clone().add(wholeMonthDiff - 1, 'months'))
            : (b - anchor) / (a.clone().add(wholeMonthDiff + 1, 'months') - anchor))
        ) || 0
      )
    }
    function locale(key) {
      var newLocaleData
      return void 0 === key
        ? this._locale._abbr
        : (null != (newLocaleData = getLocale(key)) && (this._locale = newLocaleData), this)
    }
    ;(hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ'), (hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]')
    var lang = deprecate(
      'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
      function (key) {
        return void 0 === key ? this.localeData() : this.locale(key)
      },
    )
    function localeData() {
      return this._locale
    }
    function mod$1(dividend, divisor) {
      return ((dividend % divisor) + divisor) % divisor
    }
    function localStartOfDate(y, m, d) {
      return y < 100 && y >= 0 ? new Date(y + 400, m, d) - 126227808e5 : new Date(y, m, d).valueOf()
    }
    function utcStartOfDate(y, m, d) {
      return y < 100 && y >= 0 ? Date.UTC(y + 400, m, d) - 126227808e5 : Date.UTC(y, m, d)
    }
    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter)
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget
      return null == input
        ? weekOfYear(this, dow, doy).year
        : (week > (weeksTarget = weeksInYear(input, dow, doy)) && (week = weeksTarget),
          setWeekAll.call(this, input, week, weekday, dow, doy))
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear)
      return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), this
    }
    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100
    }),
      addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100
      }),
      addWeekYearFormatToken('gggg', 'weekYear'),
      addWeekYearFormatToken('ggggg', 'weekYear'),
      addWeekYearFormatToken('GGGG', 'isoWeekYear'),
      addWeekYearFormatToken('GGGGG', 'isoWeekYear'),
      addUnitAlias('weekYear', 'gg'),
      addUnitAlias('isoWeekYear', 'GG'),
      addUnitPriority('weekYear', 1),
      addUnitPriority('isoWeekYear', 1),
      addRegexToken('G', matchSigned),
      addRegexToken('g', matchSigned),
      addRegexToken('GG', match1to2, match2),
      addRegexToken('gg', match1to2, match2),
      addRegexToken('GGGG', match1to4, match4),
      addRegexToken('gggg', match1to4, match4),
      addRegexToken('GGGGG', match1to6, match6),
      addRegexToken('ggggg', match1to6, match6),
      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input)
      }),
      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input)
      }),
      addFormatToken('Q', 0, 'Qo', 'quarter'),
      addUnitAlias('quarter', 'Q'),
      addUnitPriority('quarter', 7),
      addRegexToken('Q', match1),
      addParseToken('Q', function (input, array) {
        array[1] = 3 * (toInt(input) - 1)
      }),
      addFormatToken('D', ['DD', 2], 'Do', 'date'),
      addUnitAlias('date', 'D'),
      addUnitPriority('date', 9),
      addRegexToken('D', match1to2),
      addRegexToken('DD', match1to2, match2),
      addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient
      }),
      addParseToken(['D', 'DD'], 2),
      addParseToken('Do', function (input, array) {
        array[2] = toInt(input.match(match1to2)[0])
      })
    var getSetDayOfMonth = makeGetSet('Date', !0)
    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'),
      addUnitAlias('dayOfYear', 'DDD'),
      addUnitPriority('dayOfYear', 4),
      addRegexToken('DDD', match1to3),
      addRegexToken('DDDD', match3),
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input)
      }),
      addFormatToken('m', ['mm', 2], 0, 'minute'),
      addUnitAlias('minute', 'm'),
      addUnitPriority('minute', 14),
      addRegexToken('m', match1to2),
      addRegexToken('mm', match1to2, match2),
      addParseToken(['m', 'mm'], 4)
    var getSetMinute = makeGetSet('Minutes', !1)
    addFormatToken('s', ['ss', 2], 0, 'second'),
      addUnitAlias('second', 's'),
      addUnitPriority('second', 15),
      addRegexToken('s', match1to2),
      addRegexToken('ss', match1to2, match2),
      addParseToken(['s', 'ss'], 5)
    var token,
      getSetSecond = makeGetSet('Seconds', !1)
    for (
      addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100)
      }),
        addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10)
        }),
        addFormatToken(0, ['SSS', 3], 0, 'millisecond'),
        addFormatToken(0, ['SSSS', 4], 0, function () {
          return 10 * this.millisecond()
        }),
        addFormatToken(0, ['SSSSS', 5], 0, function () {
          return 100 * this.millisecond()
        }),
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return 1e3 * this.millisecond()
        }),
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return 1e4 * this.millisecond()
        }),
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return 1e5 * this.millisecond()
        }),
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return 1e6 * this.millisecond()
        }),
        addUnitAlias('millisecond', 'ms'),
        addUnitPriority('millisecond', 16),
        addRegexToken('S', match1to3, match1),
        addRegexToken('SS', match1to3, match2),
        addRegexToken('SSS', match1to3, match3),
        token = 'SSSS';
      token.length <= 9;
      token += 'S'
    )
      addRegexToken(token, matchUnsigned)
    function parseMs(input, array) {
      array[6] = toInt(1e3 * ('0.' + input))
    }
    for (token = 'S'; token.length <= 9; token += 'S') addParseToken(token, parseMs)
    var getSetMillisecond = makeGetSet('Milliseconds', !1)
    addFormatToken('z', 0, 0, 'zoneAbbr'), addFormatToken('zz', 0, 0, 'zoneName')
    var proto = Moment.prototype
    function preParsePostFormat(string) {
      return string
    }
    ;(proto.add = add),
      (proto.calendar = function (time, formats) {
        var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse',
          output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format])
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)))
      }),
      (proto.clone = function () {
        return new Moment(this)
      }),
      (proto.diff = function (input, units, asFloat) {
        var that, zoneDelta, output
        if (!this.isValid()) return NaN
        if (!(that = cloneWithOffset(input, this)).isValid()) return NaN
        switch (((zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset())), (units = normalizeUnits(units)))) {
          case 'year':
            output = monthDiff(this, that) / 12
            break
          case 'month':
            output = monthDiff(this, that)
            break
          case 'quarter':
            output = monthDiff(this, that) / 3
            break
          case 'second':
            output = (this - that) / 1e3
            break
          case 'minute':
            output = (this - that) / 6e4
            break
          case 'hour':
            output = (this - that) / 36e5
            break
          case 'day':
            output = (this - that - zoneDelta) / 864e5
            break
          case 'week':
            output = (this - that - zoneDelta) / 6048e5
            break
          default:
            output = this - that
        }
        return asFloat ? output : absFloor(output)
      }),
      (proto.endOf = function (units) {
        var time
        if (void 0 === (units = normalizeUnits(units)) || 'millisecond' === units || !this.isValid()) return this
        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate
        switch (units) {
          case 'year':
            time = startOfDate(this.year() + 1, 0, 1) - 1
            break
          case 'quarter':
            time = startOfDate(this.year(), this.month() - (this.month() % 3) + 3, 1) - 1
            break
          case 'month':
            time = startOfDate(this.year(), this.month() + 1, 1) - 1
            break
          case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1
            break
          case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1
            break
          case 'day':
          case 'date':
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1
            break
          case 'hour':
            ;(time = this._d.valueOf()),
              (time += 36e5 - mod$1(time + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5) - 1)
            break
          case 'minute':
            ;(time = this._d.valueOf()), (time += 6e4 - mod$1(time, 6e4) - 1)
            break
          case 'second':
            ;(time = this._d.valueOf()), (time += 1e3 - mod$1(time, 1e3) - 1)
        }
        return this._d.setTime(time), hooks.updateOffset(this, !0), this
      }),
      (proto.format = function (inputString) {
        inputString || (inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat)
        var output = formatMoment(this, inputString)
        return this.localeData().postformat(output)
      }),
      (proto.from = function (time, withoutSuffix) {
        return this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ? createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix)
          : this.localeData().invalidDate()
      }),
      (proto.fromNow = function (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix)
      }),
      (proto.to = function (time, withoutSuffix) {
        return this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ? createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix)
          : this.localeData().invalidDate()
      }),
      (proto.toNow = function (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix)
      }),
      (proto.get = function (units) {
        return isFunction(this[(units = normalizeUnits(units))]) ? this[units]() : this
      }),
      (proto.invalidAt = function () {
        return getParsingFlags(this).overflow
      }),
      (proto.isAfter = function (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input)
        return (
          !(!this.isValid() || !localInput.isValid()) &&
          ('millisecond' === (units = normalizeUnits(units) || 'millisecond')
            ? this.valueOf() > localInput.valueOf()
            : localInput.valueOf() < this.clone().startOf(units).valueOf())
        )
      }),
      (proto.isBefore = function (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input)
        return (
          !(!this.isValid() || !localInput.isValid()) &&
          ('millisecond' === (units = normalizeUnits(units) || 'millisecond')
            ? this.valueOf() < localInput.valueOf()
            : this.clone().endOf(units).valueOf() < localInput.valueOf())
        )
      }),
      (proto.isBetween = function (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to)
        return (
          !!(this.isValid() && localFrom.isValid() && localTo.isValid()) &&
          ('(' === (inclusivity = inclusivity || '()')[0]
            ? this.isAfter(localFrom, units)
            : !this.isBefore(localFrom, units)) &&
          (')' === inclusivity[1] ? this.isBefore(localTo, units) : !this.isAfter(localTo, units))
        )
      }),
      (proto.isSame = function (input, units) {
        var inputMs,
          localInput = isMoment(input) ? input : createLocal(input)
        return (
          !(!this.isValid() || !localInput.isValid()) &&
          ('millisecond' === (units = normalizeUnits(units) || 'millisecond')
            ? this.valueOf() === localInput.valueOf()
            : ((inputMs = localInput.valueOf()),
              this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf()))
        )
      }),
      (proto.isSameOrAfter = function (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units)
      }),
      (proto.isSameOrBefore = function (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units)
      }),
      (proto.isValid = function () {
        return isValid(this)
      }),
      (proto.lang = lang),
      (proto.locale = locale),
      (proto.localeData = localeData),
      (proto.max = prototypeMax),
      (proto.min = prototypeMin),
      (proto.parsingFlags = function () {
        return extend({}, getParsingFlags(this))
      }),
      (proto.set = function (units, value) {
        if ('object' == typeof units)
          for (
            var prioritized = (function (unitsObj) {
                var units = []
                for (var u in unitsObj) units.push({ unit: u, priority: priorities[u] })
                return (
                  units.sort(function (a, b) {
                    return a.priority - b.priority
                  }),
                  units
                )
              })((units = normalizeObjectUnits(units))),
              i = 0;
            i < prioritized.length;
            i++
          )
            this[prioritized[i].unit](units[prioritized[i].unit])
        else if (isFunction(this[(units = normalizeUnits(units))])) return this[units](value)
        return this
      }),
      (proto.startOf = function (units) {
        var time
        if (void 0 === (units = normalizeUnits(units)) || 'millisecond' === units || !this.isValid()) return this
        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate
        switch (units) {
          case 'year':
            time = startOfDate(this.year(), 0, 1)
            break
          case 'quarter':
            time = startOfDate(this.year(), this.month() - (this.month() % 3), 1)
            break
          case 'month':
            time = startOfDate(this.year(), this.month(), 1)
            break
          case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday())
            break
          case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1))
            break
          case 'day':
          case 'date':
            time = startOfDate(this.year(), this.month(), this.date())
            break
          case 'hour':
            ;(time = this._d.valueOf()), (time -= mod$1(time + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5))
            break
          case 'minute':
            ;(time = this._d.valueOf()), (time -= mod$1(time, 6e4))
            break
          case 'second':
            ;(time = this._d.valueOf()), (time -= mod$1(time, 1e3))
        }
        return this._d.setTime(time), hooks.updateOffset(this, !0), this
      }),
      (proto.subtract = subtract),
      (proto.toArray = function () {
        var m = this
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()]
      }),
      (proto.toObject = function () {
        var m = this
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds(),
        }
      }),
      (proto.toDate = function () {
        return new Date(this.valueOf())
      }),
      (proto.toISOString = function (keepOffset) {
        if (!this.isValid()) return null
        var utc = !0 !== keepOffset,
          m = utc ? this.clone().utc() : this
        return m.year() < 0 || m.year() > 9999
          ? formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ')
          : isFunction(Date.prototype.toISOString)
          ? utc
            ? this.toDate().toISOString()
            : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace('Z', formatMoment(m, 'Z'))
          : formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ')
      }),
      (proto.inspect = function () {
        if (!this.isValid()) return 'moment.invalid(/* ' + this._i + ' */)'
        var func = 'moment',
          zone = ''
        this.isLocal() || ((func = 0 === this.utcOffset() ? 'moment.utc' : 'moment.parseZone'), (zone = 'Z'))
        var prefix = '[' + func + '("]',
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY',
          suffix = zone + '[")]'
        return this.format(prefix + year + '-MM-DD[T]HH:mm:ss.SSS' + suffix)
      }),
      (proto.toJSON = function () {
        return this.isValid() ? this.toISOString() : null
      }),
      (proto.toString = function () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ')
      }),
      (proto.unix = function () {
        return Math.floor(this.valueOf() / 1e3)
      }),
      (proto.valueOf = function () {
        return this._d.valueOf() - 6e4 * (this._offset || 0)
      }),
      (proto.creationData = function () {
        return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict }
      }),
      (proto.year = getSetYear),
      (proto.isLeapYear = function () {
        return isLeapYear(this.year())
      }),
      (proto.weekYear = function (input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy,
        )
      }),
      (proto.isoWeekYear = function (input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4)
      }),
      (proto.quarter = proto.quarters =
        function (input) {
          return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + (this.month() % 3))
        }),
      (proto.month = getSetMonth),
      (proto.daysInMonth = function () {
        return daysInMonth(this.year(), this.month())
      }),
      (proto.week = proto.weeks =
        function (input) {
          var week = this.localeData().week(this)
          return null == input ? week : this.add(7 * (input - week), 'd')
        }),
      (proto.isoWeek = proto.isoWeeks =
        function (input) {
          var week = weekOfYear(this, 1, 4).week
          return null == input ? week : this.add(7 * (input - week), 'd')
        }),
      (proto.weeksInYear = function () {
        var weekInfo = this.localeData()._week
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy)
      }),
      (proto.isoWeeksInYear = function () {
        return weeksInYear(this.year(), 1, 4)
      }),
      (proto.date = getSetDayOfMonth),
      (proto.day = proto.days =
        function (input) {
          if (!this.isValid()) return null != input ? this : NaN
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay()
          return null != input
            ? ((input = (function (input, locale) {
                return 'string' != typeof input
                  ? input
                  : isNaN(input)
                  ? 'number' == typeof (input = locale.weekdaysParse(input))
                    ? input
                    : null
                  : parseInt(input, 10)
              })(input, this.localeData())),
              this.add(input - day, 'd'))
            : day
        }),
      (proto.weekday = function (input) {
        if (!this.isValid()) return null != input ? this : NaN
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7
        return null == input ? weekday : this.add(input - weekday, 'd')
      }),
      (proto.isoWeekday = function (input) {
        if (!this.isValid()) return null != input ? this : NaN
        if (null != input) {
          var weekday = (function (input, locale) {
            return 'string' == typeof input ? locale.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input
          })(input, this.localeData())
          return this.day(this.day() % 7 ? weekday : weekday - 7)
        }
        return this.day() || 7
      }),
      (proto.dayOfYear = function (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1
        return null == input ? dayOfYear : this.add(input - dayOfYear, 'd')
      }),
      (proto.hour = proto.hours = getSetHour),
      (proto.minute = proto.minutes = getSetMinute),
      (proto.second = proto.seconds = getSetSecond),
      (proto.millisecond = proto.milliseconds = getSetMillisecond),
      (proto.utcOffset = function (input, keepLocalTime, keepMinutes) {
        var localAdjust,
          offset = this._offset || 0
        if (!this.isValid()) return null != input ? this : NaN
        if (null != input) {
          if ('string' == typeof input) {
            if (null === (input = offsetFromString(matchShortOffset, input))) return this
          } else Math.abs(input) < 16 && !keepMinutes && (input *= 60)
          return (
            !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)),
            (this._offset = input),
            (this._isUTC = !0),
            null != localAdjust && this.add(localAdjust, 'm'),
            offset !== input &&
              (!keepLocalTime || this._changeInProgress
                ? addSubtract(this, createDuration(input - offset, 'm'), 1, !1)
                : this._changeInProgress ||
                  ((this._changeInProgress = !0), hooks.updateOffset(this, !0), (this._changeInProgress = null))),
            this
          )
        }
        return this._isUTC ? offset : getDateOffset(this)
      }),
      (proto.utc = function (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime)
      }),
      (proto.local = function (keepLocalTime) {
        return (
          this._isUTC &&
            (this.utcOffset(0, keepLocalTime),
            (this._isUTC = !1),
            keepLocalTime && this.subtract(getDateOffset(this), 'm')),
          this
        )
      }),
      (proto.parseZone = function () {
        if (null != this._tzm) this.utcOffset(this._tzm, !1, !0)
        else if ('string' == typeof this._i) {
          var tZone = offsetFromString(matchOffset, this._i)
          null != tZone ? this.utcOffset(tZone) : this.utcOffset(0, !0)
        }
        return this
      }),
      (proto.hasAlignedHourOffset = function (input) {
        return (
          !!this.isValid() &&
          ((input = input ? createLocal(input).utcOffset() : 0), (this.utcOffset() - input) % 60 == 0)
        )
      }),
      (proto.isDST = function () {
        return (
          this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
        )
      }),
      (proto.isLocal = function () {
        return !!this.isValid() && !this._isUTC
      }),
      (proto.isUtcOffset = function () {
        return !!this.isValid() && this._isUTC
      }),
      (proto.isUtc = isUtc),
      (proto.isUTC = isUtc),
      (proto.zoneAbbr = function () {
        return this._isUTC ? 'UTC' : ''
      }),
      (proto.zoneName = function () {
        return this._isUTC ? 'Coordinated Universal Time' : ''
      }),
      (proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth)),
      (proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth)),
      (proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear)),
      (proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        function (input, keepLocalTime) {
          return null != input
            ? ('string' != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), this)
            : -this.utcOffset()
        },
      )),
      (proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        function () {
          if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted
          var c = {}
          if ((copyConfig(c, this), (c = prepareConfig(c))._a)) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a)
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0
          } else this._isDSTShifted = !1
          return this._isDSTShifted
        },
      ))
    var proto$1 = Locale.prototype
    function get$1(format, index, field, setter) {
      var locale = getLocale(),
        utc = createUTC().set(setter, index)
      return locale[field](utc, format)
    }
    function listMonthsImpl(format, index, field) {
      if ((isNumber(format) && ((index = format), (format = void 0)), (format = format || ''), null != index))
        return get$1(format, index, field, 'month')
      var i,
        out = []
      for (i = 0; i < 12; i++) out[i] = get$1(format, i, field, 'month')
      return out
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
      'boolean' == typeof localeSorted
        ? (isNumber(format) && ((index = format), (format = void 0)), (format = format || ''))
        : ((index = format = localeSorted),
          (localeSorted = !1),
          isNumber(format) && ((index = format), (format = void 0)),
          (format = format || ''))
      var i,
        locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0
      if (null != index) return get$1(format, (index + shift) % 7, field, 'day')
      var out = []
      for (i = 0; i < 7; i++) out[i] = get$1(format, (i + shift) % 7, field, 'day')
      return out
    }
    ;(proto$1.calendar = function (key, mom, now) {
      var output = this._calendar[key] || this._calendar.sameElse
      return isFunction(output) ? output.call(mom, now) : output
    }),
      (proto$1.longDateFormat = function (key) {
        var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()]
        return format || !formatUpper
          ? format
          : ((this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
              return val.slice(1)
            })),
            this._longDateFormat[key])
      }),
      (proto$1.invalidDate = function () {
        return this._invalidDate
      }),
      (proto$1.ordinal = function (number) {
        return this._ordinal.replace('%d', number)
      }),
      (proto$1.preparse = preParsePostFormat),
      (proto$1.postformat = preParsePostFormat),
      (proto$1.relativeTime = function (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string]
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
      }),
      (proto$1.pastFuture = function (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past']
        return isFunction(format) ? format(output) : format.replace(/%s/i, output)
      }),
      (proto$1.set = function (config) {
        var prop, i
        for (i in config) isFunction((prop = config[i])) ? (this[i] = prop) : (this['_' + i] = prop)
        ;(this._config = config),
          (this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source,
          ))
      }),
      (proto$1.months = function (m, format) {
        return m
          ? isArray(this._months)
            ? this._months[m.month()]
            : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][
                m.month()
              ]
          : isArray(this._months)
          ? this._months
          : this._months.standalone
      }),
      (proto$1.monthsShort = function (m, format) {
        return m
          ? isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()]
          : isArray(this._monthsShort)
          ? this._monthsShort
          : this._monthsShort.standalone
      }),
      (proto$1.monthsParse = function (monthName, format, strict) {
        var i, mom, regex
        if (this._monthsParseExact) return handleStrictParse.call(this, monthName, format, strict)
        for (
          this._monthsParse || ((this._monthsParse = []), (this._longMonthsParse = []), (this._shortMonthsParse = [])),
            i = 0;
          i < 12;
          i++
        ) {
          if (
            ((mom = createUTC([2e3, i])),
            strict &&
              !this._longMonthsParse[i] &&
              ((this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i')),
              (this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i'))),
            strict ||
              this._monthsParse[i] ||
              ((regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '')),
              (this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i'))),
            strict && 'MMMM' === format && this._longMonthsParse[i].test(monthName))
          )
            return i
          if (strict && 'MMM' === format && this._shortMonthsParse[i].test(monthName)) return i
          if (!strict && this._monthsParse[i].test(monthName)) return i
        }
      }),
      (proto$1.monthsRegex = function (isStrict) {
        return this._monthsParseExact
          ? (hasOwnProp(this, '_monthsRegex') || computeMonthsParse.call(this),
            isStrict ? this._monthsStrictRegex : this._monthsRegex)
          : (hasOwnProp(this, '_monthsRegex') || (this._monthsRegex = defaultMonthsRegex),
            this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex)
      }),
      (proto$1.monthsShortRegex = function (isStrict) {
        return this._monthsParseExact
          ? (hasOwnProp(this, '_monthsRegex') || computeMonthsParse.call(this),
            isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex)
          : (hasOwnProp(this, '_monthsShortRegex') || (this._monthsShortRegex = defaultMonthsShortRegex),
            this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex)
      }),
      (proto$1.week = function (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week
      }),
      (proto$1.firstDayOfYear = function () {
        return this._week.doy
      }),
      (proto$1.firstDayOfWeek = function () {
        return this._week.dow
      }),
      (proto$1.weekdays = function (m, format) {
        var weekdays = isArray(this._weekdays)
          ? this._weekdays
          : this._weekdays[m && !0 !== m && this._weekdays.isFormat.test(format) ? 'format' : 'standalone']
        return !0 === m ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays
      }),
      (proto$1.weekdaysMin = function (m) {
        return !0 === m
          ? shiftWeekdays(this._weekdaysMin, this._week.dow)
          : m
          ? this._weekdaysMin[m.day()]
          : this._weekdaysMin
      }),
      (proto$1.weekdaysShort = function (m) {
        return !0 === m
          ? shiftWeekdays(this._weekdaysShort, this._week.dow)
          : m
          ? this._weekdaysShort[m.day()]
          : this._weekdaysShort
      }),
      (proto$1.weekdaysParse = function (weekdayName, format, strict) {
        var i, mom, regex
        if (this._weekdaysParseExact) return handleStrictParse$1.call(this, weekdayName, format, strict)
        for (
          this._weekdaysParse ||
            ((this._weekdaysParse = []),
            (this._minWeekdaysParse = []),
            (this._shortWeekdaysParse = []),
            (this._fullWeekdaysParse = [])),
            i = 0;
          i < 7;
          i++
        ) {
          if (
            ((mom = createUTC([2e3, 1]).day(i)),
            strict &&
              !this._fullWeekdaysParse[i] &&
              ((this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i')),
              (this._shortWeekdaysParse[i] = new RegExp(
                '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                'i',
              )),
              (this._minWeekdaysParse[i] = new RegExp(
                '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                'i',
              ))),
            this._weekdaysParse[i] ||
              ((regex =
                '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '')),
              (this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i'))),
            strict && 'dddd' === format && this._fullWeekdaysParse[i].test(weekdayName))
          )
            return i
          if (strict && 'ddd' === format && this._shortWeekdaysParse[i].test(weekdayName)) return i
          if (strict && 'dd' === format && this._minWeekdaysParse[i].test(weekdayName)) return i
          if (!strict && this._weekdaysParse[i].test(weekdayName)) return i
        }
      }),
      (proto$1.weekdaysRegex = function (isStrict) {
        return this._weekdaysParseExact
          ? (hasOwnProp(this, '_weekdaysRegex') || computeWeekdaysParse.call(this),
            isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex)
          : (hasOwnProp(this, '_weekdaysRegex') || (this._weekdaysRegex = defaultWeekdaysRegex),
            this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex)
      }),
      (proto$1.weekdaysShortRegex = function (isStrict) {
        return this._weekdaysParseExact
          ? (hasOwnProp(this, '_weekdaysRegex') || computeWeekdaysParse.call(this),
            isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
          : (hasOwnProp(this, '_weekdaysShortRegex') || (this._weekdaysShortRegex = defaultWeekdaysShortRegex),
            this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
      }),
      (proto$1.weekdaysMinRegex = function (isStrict) {
        return this._weekdaysParseExact
          ? (hasOwnProp(this, '_weekdaysRegex') || computeWeekdaysParse.call(this),
            isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
          : (hasOwnProp(this, '_weekdaysMinRegex') || (this._weekdaysMinRegex = defaultWeekdaysMinRegex),
            this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
      }),
      (proto$1.isPM = function (input) {
        return 'p' === (input + '').toLowerCase().charAt(0)
      }),
      (proto$1.meridiem = function (hours, minutes, isLower) {
        return hours > 11 ? (isLower ? 'pm' : 'PM') : isLower ? 'am' : 'AM'
      }),
      getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 === toInt((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
      }),
      (hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale)),
      (hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale))
    var mathAbs = Math.abs
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value)
      return (
        (duration._milliseconds += direction * other._milliseconds),
        (duration._days += direction * other._days),
        (duration._months += direction * other._months),
        duration._bubble()
      )
    }
    function absCeil(number) {
      return number < 0 ? Math.floor(number) : Math.ceil(number)
    }
    function daysToMonths(days) {
      return (4800 * days) / 146097
    }
    function monthsToDays(months) {
      return (146097 * months) / 4800
    }
    function makeAs(alias) {
      return function () {
        return this.as(alias)
      }
    }
    var asMilliseconds = makeAs('ms'),
      asSeconds = makeAs('s'),
      asMinutes = makeAs('m'),
      asHours = makeAs('h'),
      asDays = makeAs('d'),
      asWeeks = makeAs('w'),
      asMonths = makeAs('M'),
      asQuarters = makeAs('Q'),
      asYears = makeAs('y')
    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN
      }
    }
    var milliseconds = makeGetter('milliseconds'),
      seconds = makeGetter('seconds'),
      minutes = makeGetter('minutes'),
      hours = makeGetter('hours'),
      days = makeGetter('days'),
      months = makeGetter('months'),
      years = makeGetter('years')
    var round = Math.round,
      thresholds = { ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11 }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
    }
    var abs$1 = Math.abs
    function sign(x) {
      return (x > 0) - (x < 0) || +x
    }
    function toISOString$1() {
      if (!this.isValid()) return this.localeData().invalidDate()
      var minutes,
        hours,
        seconds = abs$1(this._milliseconds) / 1e3,
        days = abs$1(this._days),
        months = abs$1(this._months)
      ;(minutes = absFloor(seconds / 60)), (hours = absFloor(minutes / 60)), (seconds %= 60), (minutes %= 60)
      var Y = absFloor(months / 12),
        M = (months %= 12),
        D = days,
        h = hours,
        m = minutes,
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '',
        total = this.asSeconds()
      if (!total) return 'P0D'
      var totalSign = total < 0 ? '-' : '',
        ymSign = sign(this._months) !== sign(total) ? '-' : '',
        daysSign = sign(this._days) !== sign(total) ? '-' : '',
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : ''
      return (
        totalSign +
        'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        (h || m || s ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '')
      )
    }
    var proto$2 = Duration.prototype
    ;(proto$2.isValid = function () {
      return this._isValid
    }),
      (proto$2.abs = function () {
        var data = this._data
        return (
          (this._milliseconds = mathAbs(this._milliseconds)),
          (this._days = mathAbs(this._days)),
          (this._months = mathAbs(this._months)),
          (data.milliseconds = mathAbs(data.milliseconds)),
          (data.seconds = mathAbs(data.seconds)),
          (data.minutes = mathAbs(data.minutes)),
          (data.hours = mathAbs(data.hours)),
          (data.months = mathAbs(data.months)),
          (data.years = mathAbs(data.years)),
          this
        )
      }),
      (proto$2.add = function (input, value) {
        return addSubtract$1(this, input, value, 1)
      }),
      (proto$2.subtract = function (input, value) {
        return addSubtract$1(this, input, value, -1)
      }),
      (proto$2.as = function (units) {
        if (!this.isValid()) return NaN
        var days,
          months,
          milliseconds = this._milliseconds
        if ('month' === (units = normalizeUnits(units)) || 'quarter' === units || 'year' === units)
          switch (((days = this._days + milliseconds / 864e5), (months = this._months + daysToMonths(days)), units)) {
            case 'month':
              return months
            case 'quarter':
              return months / 3
            case 'year':
              return months / 12
          }
        else
          switch (((days = this._days + Math.round(monthsToDays(this._months))), units)) {
            case 'week':
              return days / 7 + milliseconds / 6048e5
            case 'day':
              return days + milliseconds / 864e5
            case 'hour':
              return 24 * days + milliseconds / 36e5
            case 'minute':
              return 1440 * days + milliseconds / 6e4
            case 'second':
              return 86400 * days + milliseconds / 1e3
            case 'millisecond':
              return Math.floor(864e5 * days) + milliseconds
            default:
              throw new Error('Unknown unit ' + units)
          }
      }),
      (proto$2.asMilliseconds = asMilliseconds),
      (proto$2.asSeconds = asSeconds),
      (proto$2.asMinutes = asMinutes),
      (proto$2.asHours = asHours),
      (proto$2.asDays = asDays),
      (proto$2.asWeeks = asWeeks),
      (proto$2.asMonths = asMonths),
      (proto$2.asQuarters = asQuarters),
      (proto$2.asYears = asYears),
      (proto$2.valueOf = function () {
        return this.isValid()
          ? this._milliseconds + 864e5 * this._days + (this._months % 12) * 2592e6 + 31536e6 * toInt(this._months / 12)
          : NaN
      }),
      (proto$2._bubble = function () {
        var seconds,
          minutes,
          hours,
          years,
          monthsFromDays,
          milliseconds = this._milliseconds,
          days = this._days,
          months = this._months,
          data = this._data
        return (
          (milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0) ||
            ((milliseconds += 864e5 * absCeil(monthsToDays(months) + days)), (days = 0), (months = 0)),
          (data.milliseconds = milliseconds % 1e3),
          (seconds = absFloor(milliseconds / 1e3)),
          (data.seconds = seconds % 60),
          (minutes = absFloor(seconds / 60)),
          (data.minutes = minutes % 60),
          (hours = absFloor(minutes / 60)),
          (data.hours = hours % 24),
          (days += absFloor(hours / 24)),
          (months += monthsFromDays = absFloor(daysToMonths(days))),
          (days -= absCeil(monthsToDays(monthsFromDays))),
          (years = absFloor(months / 12)),
          (months %= 12),
          (data.days = days),
          (data.months = months),
          (data.years = years),
          this
        )
      }),
      (proto$2.clone = function () {
        return createDuration(this)
      }),
      (proto$2.get = function (units) {
        return (units = normalizeUnits(units)), this.isValid() ? this[units + 's']() : NaN
      }),
      (proto$2.milliseconds = milliseconds),
      (proto$2.seconds = seconds),
      (proto$2.minutes = minutes),
      (proto$2.hours = hours),
      (proto$2.days = days),
      (proto$2.weeks = function () {
        return absFloor(this.days() / 7)
      }),
      (proto$2.months = months),
      (proto$2.years = years),
      (proto$2.humanize = function (withSuffix) {
        if (!this.isValid()) return this.localeData().invalidDate()
        var locale = this.localeData(),
          output = (function (posNegDuration, withoutSuffix, locale) {
            var duration = createDuration(posNegDuration).abs(),
              seconds = round(duration.as('s')),
              minutes = round(duration.as('m')),
              hours = round(duration.as('h')),
              days = round(duration.as('d')),
              months = round(duration.as('M')),
              years = round(duration.as('y')),
              a = (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]) ||
                (months <= 1 && ['M']) ||
                (months < thresholds.M && ['MM', months]) ||
                (years <= 1 && ['y']) || ['yy', years]
            return (
              (a[2] = withoutSuffix), (a[3] = +posNegDuration > 0), (a[4] = locale), substituteTimeAgo.apply(null, a)
            )
          })(this, !withSuffix, locale)
        return withSuffix && (output = locale.pastFuture(+this, output)), locale.postformat(output)
      }),
      (proto$2.toISOString = toISOString$1),
      (proto$2.toString = toISOString$1),
      (proto$2.toJSON = toISOString$1),
      (proto$2.locale = locale),
      (proto$2.localeData = localeData),
      (proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1,
      )),
      (proto$2.lang = lang),
      addFormatToken('X', 0, 0, 'unix'),
      addFormatToken('x', 0, 0, 'valueOf'),
      addRegexToken('x', matchSigned),
      addRegexToken('X', /[+-]?\d+(\.\d{1,3})?/),
      addParseToken('X', function (input, array, config) {
        config._d = new Date(1e3 * parseFloat(input, 10))
      }),
      addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input))
      }),
      //! moment.js
      (hooks.version = '2.24.0'),
      (hookCallback = createLocal),
      (hooks.fn = proto),
      (hooks.min = function () {
        var args = [].slice.call(arguments, 0)
        return pickBy('isBefore', args)
      }),
      (hooks.max = function () {
        var args = [].slice.call(arguments, 0)
        return pickBy('isAfter', args)
      }),
      (hooks.now = function () {
        return Date.now ? Date.now() : +new Date()
      }),
      (hooks.utc = createUTC),
      (hooks.unix = function (input) {
        return createLocal(1e3 * input)
      }),
      (hooks.months = function (format, index) {
        return listMonthsImpl(format, index, 'months')
      }),
      (hooks.isDate = isDate),
      (hooks.locale = getSetGlobalLocale),
      (hooks.invalid = createInvalid),
      (hooks.duration = createDuration),
      (hooks.isMoment = isMoment),
      (hooks.weekdays = function (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays')
      }),
      (hooks.parseZone = function () {
        return createLocal.apply(null, arguments).parseZone()
      }),
      (hooks.localeData = getLocale),
      (hooks.isDuration = isDuration),
      (hooks.monthsShort = function (format, index) {
        return listMonthsImpl(format, index, 'monthsShort')
      }),
      (hooks.weekdaysMin = function (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin')
      }),
      (hooks.defineLocale = defineLocale),
      (hooks.updateLocale = function (name, config) {
        if (null != config) {
          var locale,
            tmpLocale,
            parentConfig = baseConfig
          null != (tmpLocale = loadLocale(name)) && (parentConfig = tmpLocale._config),
            ((locale = new Locale((config = mergeConfigs(parentConfig, config)))).parentLocale = locales[name]),
            (locales[name] = locale),
            getSetGlobalLocale(name)
        } else
          null != locales[name] &&
            (null != locales[name].parentLocale
              ? (locales[name] = locales[name].parentLocale)
              : null != locales[name] && delete locales[name])
        return locales[name]
      }),
      (hooks.locales = function () {
        return keys(locales)
      }),
      (hooks.weekdaysShort = function (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort')
      }),
      (hooks.normalizeUnits = normalizeUnits),
      (hooks.relativeTimeRounding = function (roundingFunction) {
        return void 0 === roundingFunction
          ? round
          : 'function' == typeof roundingFunction && ((round = roundingFunction), !0)
      }),
      (hooks.relativeTimeThreshold = function (threshold, limit) {
        return (
          void 0 !== thresholds[threshold] &&
          (void 0 === limit
            ? thresholds[threshold]
            : ((thresholds[threshold] = limit), 's' === threshold && (thresholds.ss = limit - 1), !0))
        )
      }),
      (hooks.calendarFormat = function (myMoment, now) {
        var diff = myMoment.diff(now, 'days', !0)
        return diff < -6
          ? 'sameElse'
          : diff < -1
          ? 'lastWeek'
          : diff < 0
          ? 'lastDay'
          : diff < 1
          ? 'sameDay'
          : diff < 2
          ? 'nextDay'
          : diff < 7
          ? 'nextWeek'
          : 'sameElse'
      }),
      (hooks.prototype = proto),
      (hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
        DATE: 'YYYY-MM-DD',
        TIME: 'HH:mm',
        TIME_SECONDS: 'HH:mm:ss',
        TIME_MS: 'HH:mm:ss.SSS',
        WEEK: 'GGGG-[W]WW',
        MONTH: 'YYYY-MM',
      }), //! moment.js locale configuration
      hooks.defineLocale('af', {
        months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split(
          '_',
        ),
        monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM: function (input) {
          return /^nm$/i.test(input)
        },
        meridiem: function (hours, minutes, isLower) {
          return hours < 12 ? (isLower ? 'vm' : 'VM') : isLower ? 'nm' : 'NM'
        },
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Vandag om] LT',
          nextDay: '[Môre om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[Gister om] LT',
          lastWeek: '[Laas] dddd [om] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'oor %s',
          past: '%s gelede',
          s: "'n paar sekondes",
          ss: '%d sekondes',
          m: "'n minuut",
          mm: '%d minute',
          h: "'n uur",
          hh: '%d ure',
          d: "'n dag",
          dd: '%d dae',
          M: "'n maand",
          MM: '%d maande',
          y: "'n jaar",
          yy: '%d jaar',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
          return number + (1 === number || 8 === number || number >= 20 ? 'ste' : 'de')
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('ar-dz', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'أح_إث_ثلا_أر_خم_جم_سب'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          ss: '%d ثانية',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات',
        },
        week: { dow: 0, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('ar-kw', {
        months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          ss: '%d ثانية',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات',
        },
        week: { dow: 0, doy: 12 },
      }) //! moment.js locale configuration
    var symbolMap = { 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 0: '0' },
      pluralForm = function (n) {
        return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5
      },
      plurals = {
        s: ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m: ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h: ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d: ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M: ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y: ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام'],
      },
      pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
          var f = pluralForm(number),
            str = plurals[u][pluralForm(number)]
          return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number)
        }
      },
      months$1 = [
        'يناير',
        'فبراير',
        'مارس',
        'أبريل',
        'مايو',
        'يونيو',
        'يوليو',
        'أغسطس',
        'سبتمبر',
        'أكتوبر',
        'نوفمبر',
        'ديسمبر',
      ]
    hooks.defineLocale('ar-ly', {
      months: months$1,
      monthsShort: months$1,
      weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
      weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
      weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'D/‏M/‏YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /ص|م/,
      isPM: function (input) {
        return 'م' === input
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 12 ? 'ص' : 'م'
      },
      calendar: {
        sameDay: '[اليوم عند الساعة] LT',
        nextDay: '[غدًا عند الساعة] LT',
        nextWeek: 'dddd [عند الساعة] LT',
        lastDay: '[أمس عند الساعة] LT',
        lastWeek: 'dddd [عند الساعة] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'بعد %s',
        past: 'منذ %s',
        s: pluralize('s'),
        ss: pluralize('s'),
        m: pluralize('m'),
        mm: pluralize('m'),
        h: pluralize('h'),
        hh: pluralize('h'),
        d: pluralize('d'),
        dd: pluralize('d'),
        M: pluralize('M'),
        MM: pluralize('M'),
        y: pluralize('y'),
        yy: pluralize('y'),
      },
      preparse: function (string) {
        return string.replace(/،/g, ',')
      },
      postformat: function (string) {
        return string
          .replace(/\d/g, function (match) {
            return symbolMap[match]
          })
          .replace(/,/g, '،')
      },
      week: { dow: 6, doy: 12 },
    }), //! moment.js locale configuration
      hooks.defineLocale('ar-ma', {
        months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          ss: '%d ثانية',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات',
        },
        week: { dow: 6, doy: 12 },
      }) //! moment.js locale configuration
    var symbolMap$1 = { 1: '١', 2: '٢', 3: '٣', 4: '٤', 5: '٥', 6: '٦', 7: '٧', 8: '٨', 9: '٩', 0: '٠' },
      numberMap = { '١': '1', '٢': '2', '٣': '3', '٤': '4', '٥': '5', '٦': '6', '٧': '7', '٨': '8', '٩': '9', '٠': '0' }
    hooks.defineLocale('ar-sa', {
      months: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
      monthsShort: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
      weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
      weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
      weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /ص|م/,
      isPM: function (input) {
        return 'م' === input
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 12 ? 'ص' : 'م'
      },
      calendar: {
        sameDay: '[اليوم على الساعة] LT',
        nextDay: '[غدا على الساعة] LT',
        nextWeek: 'dddd [على الساعة] LT',
        lastDay: '[أمس على الساعة] LT',
        lastWeek: 'dddd [على الساعة] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'في %s',
        past: 'منذ %s',
        s: 'ثوان',
        ss: '%d ثانية',
        m: 'دقيقة',
        mm: '%d دقائق',
        h: 'ساعة',
        hh: '%d ساعات',
        d: 'يوم',
        dd: '%d أيام',
        M: 'شهر',
        MM: '%d أشهر',
        y: 'سنة',
        yy: '%d سنوات',
      },
      preparse: function (string) {
        return string
          .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
            return numberMap[match]
          })
          .replace(/،/g, ',')
      },
      postformat: function (string) {
        return string
          .replace(/\d/g, function (match) {
            return symbolMap$1[match]
          })
          .replace(/,/g, '،')
      },
      week: { dow: 0, doy: 6 },
    }), //! moment.js locale configuration
      hooks.defineLocale('ar-tn', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          ss: '%d ثانية',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات',
        },
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var symbolMap$2 = { 1: '١', 2: '٢', 3: '٣', 4: '٤', 5: '٥', 6: '٦', 7: '٧', 8: '٨', 9: '٩', 0: '٠' },
      numberMap$1 = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0',
      },
      pluralForm$1 = function (n) {
        return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5
      },
      plurals$1 = {
        s: ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m: ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h: ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d: ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M: ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y: ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام'],
      },
      pluralize$1 = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
          var f = pluralForm$1(number),
            str = plurals$1[u][pluralForm$1(number)]
          return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number)
        }
      },
      months$2 = [
        'يناير',
        'فبراير',
        'مارس',
        'أبريل',
        'مايو',
        'يونيو',
        'يوليو',
        'أغسطس',
        'سبتمبر',
        'أكتوبر',
        'نوفمبر',
        'ديسمبر',
      ]
    hooks.defineLocale('ar', {
      months: months$2,
      monthsShort: months$2,
      weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
      weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
      weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'D/‏M/‏YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /ص|م/,
      isPM: function (input) {
        return 'م' === input
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 12 ? 'ص' : 'م'
      },
      calendar: {
        sameDay: '[اليوم عند الساعة] LT',
        nextDay: '[غدًا عند الساعة] LT',
        nextWeek: 'dddd [عند الساعة] LT',
        lastDay: '[أمس عند الساعة] LT',
        lastWeek: 'dddd [عند الساعة] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'بعد %s',
        past: 'منذ %s',
        s: pluralize$1('s'),
        ss: pluralize$1('s'),
        m: pluralize$1('m'),
        mm: pluralize$1('m'),
        h: pluralize$1('h'),
        hh: pluralize$1('h'),
        d: pluralize$1('d'),
        dd: pluralize$1('d'),
        M: pluralize$1('M'),
        MM: pluralize$1('M'),
        y: pluralize$1('y'),
        yy: pluralize$1('y'),
      },
      preparse: function (string) {
        return string
          .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
            return numberMap$1[match]
          })
          .replace(/،/g, ',')
      },
      postformat: function (string) {
        return string
          .replace(/\d/g, function (match) {
            return symbolMap$2[match]
          })
          .replace(/,/g, '،')
      },
      week: { dow: 6, doy: 12 },
    }) //! moment.js locale configuration
    var suffixes = {
      1: '-inci',
      5: '-inci',
      8: '-inci',
      70: '-inci',
      80: '-inci',
      2: '-nci',
      7: '-nci',
      20: '-nci',
      50: '-nci',
      3: '-üncü',
      4: '-üncü',
      100: '-üncü',
      6: '-ncı',
      9: '-uncu',
      10: '-uncu',
      30: '-uncu',
      60: '-ıncı',
      90: '-ıncı',
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
      return 'm' === key
        ? withoutSuffix
          ? 'хвіліна'
          : 'хвіліну'
        : 'h' === key
        ? withoutSuffix
          ? 'гадзіна'
          : 'гадзіну'
        : number +
          ' ' + //! moment.js locale configuration
          (function (word, num) {
            var forms = word.split('_')
            return num % 10 == 1 && num % 100 != 11
              ? forms[0]
              : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
              ? forms[1]
              : forms[2]
          })(
            {
              ss: withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
              mm: withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
              hh: withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
              dd: 'дзень_дні_дзён',
              MM: 'месяц_месяцы_месяцаў',
              yy: 'год_гады_гадоў',
            }[key],
            +number,
          )
    }
    hooks.defineLocale('az', {
      months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
      monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
      weekdays: 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
      weekdaysShort: 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
      weekdaysMin: 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[bugün saat] LT',
        nextDay: '[sabah saat] LT',
        nextWeek: '[gələn həftə] dddd [saat] LT',
        lastDay: '[dünən] LT',
        lastWeek: '[keçən həftə] dddd [saat] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s sonra',
        past: '%s əvvəl',
        s: 'birneçə saniyə',
        ss: '%d saniyə',
        m: 'bir dəqiqə',
        mm: '%d dəqiqə',
        h: 'bir saat',
        hh: '%d saat',
        d: 'bir gün',
        dd: '%d gün',
        M: 'bir ay',
        MM: '%d ay',
        y: 'bir il',
        yy: '%d il',
      },
      meridiemParse: /gecə|səhər|gündüz|axşam/,
      isPM: function (input) {
        return /^(gündüz|axşam)$/.test(input)
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'gecə' : hour < 12 ? 'səhər' : hour < 17 ? 'gündüz' : 'axşam'
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
      ordinal: function (number) {
        if (0 === number) return number + '-ıncı'
        var a = number % 10
        return number + (suffixes[a] || suffixes[(number % 100) - a] || suffixes[number >= 100 ? 100 : null])
      },
      week: { dow: 1, doy: 7 },
    }),
      hooks.defineLocale('be', {
        months: {
          format:
            'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split(
              '_',
            ),
          standalone:
            'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split(
              '_',
            ),
        },
        monthsShort: 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
        weekdays: {
          format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
          standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
          isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/,
        },
        weekdaysShort: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        weekdaysMin: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY г.',
          LLL: 'D MMMM YYYY г., HH:mm',
          LLLL: 'dddd, D MMMM YYYY г., HH:mm',
        },
        calendar: {
          sameDay: '[Сёння ў] LT',
          nextDay: '[Заўтра ў] LT',
          lastDay: '[Учора ў] LT',
          nextWeek: function () {
            return '[У] dddd [ў] LT'
          },
          lastWeek: function () {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return '[У мінулую] dddd [ў] LT'
              case 1:
              case 2:
              case 4:
                return '[У мінулы] dddd [ў] LT'
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'праз %s',
          past: '%s таму',
          s: 'некалькі секунд',
          m: relativeTimeWithPlural,
          mm: relativeTimeWithPlural,
          h: relativeTimeWithPlural,
          hh: relativeTimeWithPlural,
          d: 'дзень',
          dd: relativeTimeWithPlural,
          M: 'месяц',
          MM: relativeTimeWithPlural,
          y: 'год',
          yy: relativeTimeWithPlural,
        },
        meridiemParse: /ночы|раніцы|дня|вечара/,
        isPM: function (input) {
          return /^(дня|вечара)$/.test(input)
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 4 ? 'ночы' : hour < 12 ? 'раніцы' : hour < 17 ? 'дня' : 'вечара'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
              return (number % 10 != 2 && number % 10 != 3) || number % 100 == 12 || number % 100 == 13
                ? number + '-ы'
                : number + '-і'
            case 'D':
              return number + '-га'
            default:
              return number
          }
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('bg', {
        months: 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort: 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
        weekdays: 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
        weekdaysShort: 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
        weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'D.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
          sameDay: '[Днес в] LT',
          nextDay: '[Утре в] LT',
          nextWeek: 'dddd [в] LT',
          lastDay: '[Вчера в] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return '[В изминалата] dddd [в] LT'
              case 1:
              case 2:
              case 4:
              case 5:
                return '[В изминалия] dddd [в] LT'
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'след %s',
          past: 'преди %s',
          s: 'няколко секунди',
          ss: '%d секунди',
          m: 'минута',
          mm: '%d минути',
          h: 'час',
          hh: '%d часа',
          d: 'ден',
          dd: '%d дни',
          M: 'месец',
          MM: '%d месеца',
          y: 'година',
          yy: '%d години',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal: function (number) {
          var lastDigit = number % 10,
            last2Digits = number % 100
          return 0 === number
            ? number + '-ев'
            : 0 === last2Digits
            ? number + '-ен'
            : last2Digits > 10 && last2Digits < 20
            ? number + '-ти'
            : 1 === lastDigit
            ? number + '-ви'
            : 2 === lastDigit
            ? number + '-ри'
            : 7 === lastDigit || 8 === lastDigit
            ? number + '-ми'
            : number + '-ти'
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('bm', {
        months:
          'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo'.split(
            '_',
          ),
        monthsShort: 'Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des'.split('_'),
        weekdays: 'Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
        weekdaysShort: 'Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib'.split('_'),
        weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'MMMM [tile] D [san] YYYY',
          LLL: 'MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
          LLLL: 'dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
        },
        calendar: {
          sameDay: '[Bi lɛrɛ] LT',
          nextDay: '[Sini lɛrɛ] LT',
          nextWeek: 'dddd [don lɛrɛ] LT',
          lastDay: '[Kunu lɛrɛ] LT',
          lastWeek: 'dddd [tɛmɛnen lɛrɛ] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s kɔnɔ',
          past: 'a bɛ %s bɔ',
          s: 'sanga dama dama',
          ss: 'sekondi %d',
          m: 'miniti kelen',
          mm: 'miniti %d',
          h: 'lɛrɛ kelen',
          hh: 'lɛrɛ %d',
          d: 'tile kelen',
          dd: 'tile %d',
          M: 'kalo kelen',
          MM: 'kalo %d',
          y: 'san kelen',
          yy: 'san %d',
        },
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var symbolMap$3 = { 1: '১', 2: '২', 3: '৩', 4: '৪', 5: '৫', 6: '৬', 7: '৭', 8: '৮', 9: '৯', 0: '০' },
      numberMap$2 = {
        '১': '1',
        '২': '2',
        '৩': '3',
        '৪': '4',
        '৫': '5',
        '৬': '6',
        '৭': '7',
        '৮': '8',
        '৯': '9',
        '০': '0',
      }
    hooks.defineLocale('bn', {
      months: 'জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
      monthsShort: 'জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে'.split('_'),
      weekdays: 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split('_'),
      weekdaysShort: 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
      weekdaysMin: 'রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি'.split('_'),
      longDateFormat: {
        LT: 'A h:mm সময়',
        LTS: 'A h:mm:ss সময়',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm সময়',
        LLLL: 'dddd, D MMMM YYYY, A h:mm সময়',
      },
      calendar: {
        sameDay: '[আজ] LT',
        nextDay: '[আগামীকাল] LT',
        nextWeek: 'dddd, LT',
        lastDay: '[গতকাল] LT',
        lastWeek: '[গত] dddd, LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s পরে',
        past: '%s আগে',
        s: 'কয়েক সেকেন্ড',
        ss: '%d সেকেন্ড',
        m: 'এক মিনিট',
        mm: '%d মিনিট',
        h: 'এক ঘন্টা',
        hh: '%d ঘন্টা',
        d: 'এক দিন',
        dd: '%d দিন',
        M: 'এক মাস',
        MM: '%d মাস',
        y: 'এক বছর',
        yy: '%d বছর',
      },
      preparse: function (string) {
        return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
          return numberMap$2[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$3[match]
        })
      },
      meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          ('রাত' === meridiem && hour >= 4) || ('দুপুর' === meridiem && hour < 5) || 'বিকাল' === meridiem
            ? hour + 12
            : hour
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'রাত' : hour < 10 ? 'সকাল' : hour < 17 ? 'দুপুর' : hour < 20 ? 'বিকাল' : 'রাত'
      },
      week: { dow: 0, doy: 6 },
    }) //! moment.js locale configuration
    var symbolMap$4 = { 1: '༡', 2: '༢', 3: '༣', 4: '༤', 5: '༥', 6: '༦', 7: '༧', 8: '༨', 9: '༩', 0: '༠' },
      numberMap$3 = {
        '༡': '1',
        '༢': '2',
        '༣': '3',
        '༤': '4',
        '༥': '5',
        '༦': '6',
        '༧': '7',
        '༨': '8',
        '༩': '9',
        '༠': '0',
      } //! moment.js locale configuration
    function relativeTimeWithMutation(number, withoutSuffix, key) {
      return (
        number +
        ' ' +
        (function (text, number) {
          if (2 === number)
            return (function (text) {
              var mutationTable = { m: 'v', b: 'v', d: 'z' }
              if (void 0 === mutationTable[text.charAt(0)]) return text
              return mutationTable[text.charAt(0)] + text.substring(1)
            })(text)
          return text
        })({ mm: 'munutenn', MM: 'miz', dd: 'devezh' }[key], number)
      )
    }
    function lastNumber(number) {
      return number > 9 ? lastNumber(number % 10) : number
    } //! moment.js locale configuration
    function translate(number, withoutSuffix, key) {
      var result = number + ' '
      switch (key) {
        case 'ss':
          return (result +=
            1 === number ? 'sekunda' : 2 === number || 3 === number || 4 === number ? 'sekunde' : 'sekundi')
        case 'm':
          return withoutSuffix ? 'jedna minuta' : 'jedne minute'
        case 'mm':
          return (result +=
            1 === number ? 'minuta' : 2 === number || 3 === number || 4 === number ? 'minute' : 'minuta')
        case 'h':
          return withoutSuffix ? 'jedan sat' : 'jednog sata'
        case 'hh':
          return (result += 1 === number ? 'sat' : 2 === number || 3 === number || 4 === number ? 'sata' : 'sati')
        case 'dd':
          return (result += 1 === number ? 'dan' : 'dana')
        case 'MM':
          return (result +=
            1 === number ? 'mjesec' : 2 === number || 3 === number || 4 === number ? 'mjeseca' : 'mjeseci')
        case 'yy':
          return (result +=
            1 === number ? 'godina' : 2 === number || 3 === number || 4 === number ? 'godine' : 'godina')
      }
    }
    hooks.defineLocale('bo', {
      months:
        'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split(
          '_',
        ),
      monthsShort:
        'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split(
          '_',
        ),
      weekdays: 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
      weekdaysShort: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
      weekdaysMin: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
      longDateFormat: {
        LT: 'A h:mm',
        LTS: 'A h:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm',
        LLLL: 'dddd, D MMMM YYYY, A h:mm',
      },
      calendar: {
        sameDay: '[དི་རིང] LT',
        nextDay: '[སང་ཉིན] LT',
        nextWeek: '[བདུན་ཕྲག་རྗེས་མ], LT',
        lastDay: '[ཁ་སང] LT',
        lastWeek: '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s ལ་',
        past: '%s སྔན་ལ',
        s: 'ལམ་སང',
        ss: '%d སྐར་ཆ།',
        m: 'སྐར་མ་གཅིག',
        mm: '%d སྐར་མ',
        h: 'ཆུ་ཚོད་གཅིག',
        hh: '%d ཆུ་ཚོད',
        d: 'ཉིན་གཅིག',
        dd: '%d ཉིན་',
        M: 'ཟླ་བ་གཅིག',
        MM: '%d ཟླ་བ',
        y: 'ལོ་གཅིག',
        yy: '%d ལོ',
      },
      preparse: function (string) {
        return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
          return numberMap$3[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$4[match]
        })
      },
      meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          ('མཚན་མོ' === meridiem && hour >= 4) || ('ཉིན་གུང' === meridiem && hour < 5) || 'དགོང་དག' === meridiem
            ? hour + 12
            : hour
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'མཚན་མོ' : hour < 10 ? 'ཞོགས་ཀས' : hour < 17 ? 'ཉིན་གུང' : hour < 20 ? 'དགོང་དག' : 'མཚན་མོ'
      },
      week: { dow: 0, doy: 6 },
    }),
      hooks.defineLocale('br', {
        months: "Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split('_'),
        monthsShort: "Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split('_'),
        weekdays: "Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split('_'),
        weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'h[e]mm A',
          LTS: 'h[e]mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D [a viz] MMMM YYYY',
          LLL: 'D [a viz] MMMM YYYY h[e]mm A',
          LLLL: 'dddd, D [a viz] MMMM YYYY h[e]mm A',
        },
        calendar: {
          sameDay: '[Hiziv da] LT',
          nextDay: "[Warc'hoazh da] LT",
          nextWeek: 'dddd [da] LT',
          lastDay: "[Dec'h da] LT",
          lastWeek: 'dddd [paset da] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'a-benn %s',
          past: "%s 'zo",
          s: 'un nebeud segondennoù',
          ss: '%d eilenn',
          m: 'ur vunutenn',
          mm: relativeTimeWithMutation,
          h: 'un eur',
          hh: '%d eur',
          d: 'un devezh',
          dd: relativeTimeWithMutation,
          M: 'ur miz',
          MM: relativeTimeWithMutation,
          y: 'ur bloaz',
          yy: function (number) {
            switch (lastNumber(number)) {
              case 1:
              case 3:
              case 4:
              case 5:
              case 9:
                return number + ' bloaz'
              default:
                return number + ' vloaz'
            }
          },
        },
        dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
        ordinal: function (number) {
          return number + (1 === number ? 'añ' : 'vet')
        },
        week: { dow: 1, doy: 4 },
      }),
      hooks.defineLocale('bs', {
        months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sutra u] LT',
          nextWeek: function () {
            switch (this.day()) {
              case 0:
                return '[u] [nedjelju] [u] LT'
              case 3:
                return '[u] [srijedu] [u] LT'
              case 6:
                return '[u] [subotu] [u] LT'
              case 1:
              case 2:
              case 4:
              case 5:
                return '[u] dddd [u] LT'
            }
          },
          lastDay: '[jučer u] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 0:
              case 3:
                return '[prošlu] dddd [u] LT'
              case 6:
                return '[prošle] [subote] [u] LT'
              case 1:
              case 2:
              case 4:
              case 5:
                return '[prošli] dddd [u] LT'
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'za %s',
          past: 'prije %s',
          s: 'par sekundi',
          ss: translate,
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: 'dan',
          dd: translate,
          M: 'mjesec',
          MM: translate,
          y: 'godinu',
          yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('ca', {
        months: {
          standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
          format:
            "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split(
              '_',
            ),
          isFormat: /D[oD]?(\s)+MMMM/,
        },
        monthsShort: 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM [de] YYYY',
          ll: 'D MMM YYYY',
          LLL: 'D MMMM [de] YYYY [a les] H:mm',
          lll: 'D MMM YYYY, H:mm',
          LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
          llll: 'ddd D MMM YYYY, H:mm',
        },
        calendar: {
          sameDay: function () {
            return '[avui a ' + (1 !== this.hours() ? 'les' : 'la') + '] LT'
          },
          nextDay: function () {
            return '[demà a ' + (1 !== this.hours() ? 'les' : 'la') + '] LT'
          },
          nextWeek: function () {
            return 'dddd [a ' + (1 !== this.hours() ? 'les' : 'la') + '] LT'
          },
          lastDay: function () {
            return '[ahir a ' + (1 !== this.hours() ? 'les' : 'la') + '] LT'
          },
          lastWeek: function () {
            return '[el] dddd [passat a ' + (1 !== this.hours() ? 'les' : 'la') + '] LT'
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: "d'aquí %s",
          past: 'fa %s',
          s: 'uns segons',
          ss: '%d segons',
          m: 'un minut',
          mm: '%d minuts',
          h: 'una hora',
          hh: '%d hores',
          d: 'un dia',
          dd: '%d dies',
          M: 'un mes',
          MM: '%d mesos',
          y: 'un any',
          yy: '%d anys',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal: function (number, period) {
          var output = 1 === number ? 'r' : 2 === number ? 'n' : 3 === number ? 'r' : 4 === number ? 't' : 'è'
          return ('w' !== period && 'W' !== period) || (output = 'a'), number + output
        },
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var months$3 = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
      monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_'),
      monthsParse = [
        /^led/i,
        /^úno/i,
        /^bře/i,
        /^dub/i,
        /^kvě/i,
        /^(čvn|červen$|června)/i,
        /^(čvc|červenec|července)/i,
        /^srp/i,
        /^zář/i,
        /^říj/i,
        /^lis/i,
        /^pro/i,
      ],
      monthsRegex$1 =
        /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i
    function plural$1(n) {
      return n > 1 && n < 5 && 1 != ~~(n / 10)
    }
    function translate$1(number, withoutSuffix, key, isFuture) {
      var result = number + ' '
      switch (key) {
        case 's':
          return withoutSuffix || isFuture ? 'pár sekund' : 'pár sekundami'
        case 'ss':
          return withoutSuffix || isFuture ? result + (plural$1(number) ? 'sekundy' : 'sekund') : result + 'sekundami'
        case 'm':
          return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou'
        case 'mm':
          return withoutSuffix || isFuture ? result + (plural$1(number) ? 'minuty' : 'minut') : result + 'minutami'
        case 'h':
          return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou'
        case 'hh':
          return withoutSuffix || isFuture ? result + (plural$1(number) ? 'hodiny' : 'hodin') : result + 'hodinami'
        case 'd':
          return withoutSuffix || isFuture ? 'den' : 'dnem'
        case 'dd':
          return withoutSuffix || isFuture ? result + (plural$1(number) ? 'dny' : 'dní') : result + 'dny'
        case 'M':
          return withoutSuffix || isFuture ? 'měsíc' : 'měsícem'
        case 'MM':
          return withoutSuffix || isFuture ? result + (plural$1(number) ? 'měsíce' : 'měsíců') : result + 'měsíci'
        case 'y':
          return withoutSuffix || isFuture ? 'rok' : 'rokem'
        case 'yy':
          return withoutSuffix || isFuture ? result + (plural$1(number) ? 'roky' : 'let') : result + 'lety'
      }
    } //! moment.js locale configuration
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
      var format = {
        m: ['eine Minute', 'einer Minute'],
        h: ['eine Stunde', 'einer Stunde'],
        d: ['ein Tag', 'einem Tag'],
        dd: [number + ' Tage', number + ' Tagen'],
        M: ['ein Monat', 'einem Monat'],
        MM: [number + ' Monate', number + ' Monaten'],
        y: ['ein Jahr', 'einem Jahr'],
        yy: [number + ' Jahre', number + ' Jahren'],
      }
      return withoutSuffix ? format[key][0] : format[key][1]
    } //! moment.js locale configuration
    function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
      var format = {
        m: ['eine Minute', 'einer Minute'],
        h: ['eine Stunde', 'einer Stunde'],
        d: ['ein Tag', 'einem Tag'],
        dd: [number + ' Tage', number + ' Tagen'],
        M: ['ein Monat', 'einem Monat'],
        MM: [number + ' Monate', number + ' Monaten'],
        y: ['ein Jahr', 'einem Jahr'],
        yy: [number + ' Jahre', number + ' Jahren'],
      }
      return withoutSuffix ? format[key][0] : format[key][1]
    } //! moment.js locale configuration
    function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
      var format = {
        m: ['eine Minute', 'einer Minute'],
        h: ['eine Stunde', 'einer Stunde'],
        d: ['ein Tag', 'einem Tag'],
        dd: [number + ' Tage', number + ' Tagen'],
        M: ['ein Monat', 'einem Monat'],
        MM: [number + ' Monate', number + ' Monaten'],
        y: ['ein Jahr', 'einem Jahr'],
        yy: [number + ' Jahre', number + ' Jahren'],
      }
      return withoutSuffix ? format[key][0] : format[key][1]
    }
    hooks.defineLocale('cs', {
      months: months$3,
      monthsShort,
      monthsRegex: monthsRegex$1,
      monthsShortRegex: monthsRegex$1,
      monthsStrictRegex:
        /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,
      monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,
      monthsParse,
      longMonthsParse: monthsParse,
      shortMonthsParse: monthsParse,
      weekdays: 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
      weekdaysShort: 'ne_po_út_st_čt_pá_so'.split('_'),
      weekdaysMin: 'ne_po_út_st_čt_pá_so'.split('_'),
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd D. MMMM YYYY H:mm',
        l: 'D. M. YYYY',
      },
      calendar: {
        sameDay: '[dnes v] LT',
        nextDay: '[zítra v] LT',
        nextWeek: function () {
          switch (this.day()) {
            case 0:
              return '[v neděli v] LT'
            case 1:
            case 2:
              return '[v] dddd [v] LT'
            case 3:
              return '[ve středu v] LT'
            case 4:
              return '[ve čtvrtek v] LT'
            case 5:
              return '[v pátek v] LT'
            case 6:
              return '[v sobotu v] LT'
          }
        },
        lastDay: '[včera v] LT',
        lastWeek: function () {
          switch (this.day()) {
            case 0:
              return '[minulou neděli v] LT'
            case 1:
            case 2:
              return '[minulé] dddd [v] LT'
            case 3:
              return '[minulou středu v] LT'
            case 4:
            case 5:
              return '[minulý] dddd [v] LT'
            case 6:
              return '[minulou sobotu v] LT'
          }
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'za %s',
        past: 'před %s',
        s: translate$1,
        ss: translate$1,
        m: translate$1,
        mm: translate$1,
        h: translate$1,
        hh: translate$1,
        d: translate$1,
        dd: translate$1,
        M: translate$1,
        MM: translate$1,
        y: translate$1,
        yy: translate$1,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 4 },
    }), //! moment.js locale configuration
      hooks.defineLocale('cv', {
        months: 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
        monthsShort: 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
        weekdays: 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
        weekdaysShort: 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
        weekdaysMin: 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD-MM-YYYY',
          LL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
          LLL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
          LLLL: 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
        },
        calendar: {
          sameDay: '[Паян] LT [сехетре]',
          nextDay: '[Ыран] LT [сехетре]',
          lastDay: '[Ӗнер] LT [сехетре]',
          nextWeek: '[Ҫитес] dddd LT [сехетре]',
          lastWeek: '[Иртнӗ] dddd LT [сехетре]',
          sameElse: 'L',
        },
        relativeTime: {
          future: function (output) {
            return output + (/сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран')
          },
          past: '%s каялла',
          s: 'пӗр-ик ҫеккунт',
          ss: '%d ҫеккунт',
          m: 'пӗр минут',
          mm: '%d минут',
          h: 'пӗр сехет',
          hh: '%d сехет',
          d: 'пӗр кун',
          dd: '%d кун',
          M: 'пӗр уйӑх',
          MM: '%d уйӑх',
          y: 'пӗр ҫул',
          yy: '%d ҫул',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
        ordinal: '%d-мӗш',
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Heddiw am] LT',
          nextDay: '[Yfory am] LT',
          nextWeek: 'dddd [am] LT',
          lastDay: '[Ddoe am] LT',
          lastWeek: 'dddd [diwethaf am] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'mewn %s',
          past: '%s yn ôl',
          s: 'ychydig eiliadau',
          ss: '%d eiliad',
          m: 'munud',
          mm: '%d munud',
          h: 'awr',
          hh: '%d awr',
          d: 'diwrnod',
          dd: '%d diwrnod',
          M: 'mis',
          MM: '%d mis',
          y: 'blwyddyn',
          yy: '%d flynedd',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        ordinal: function (number) {
          var output = ''
          return (
            number > 20
              ? (output =
                  40 === number || 50 === number || 60 === number || 80 === number || 100 === number ? 'fed' : 'ain')
              : number > 0 &&
                (output = [
                  '',
                  'af',
                  'il',
                  'ydd',
                  'ydd',
                  'ed',
                  'ed',
                  'ed',
                  'fed',
                  'fed',
                  'fed',
                  'eg',
                  'fed',
                  'eg',
                  'eg',
                  'fed',
                  'eg',
                  'eg',
                  'fed',
                  'eg',
                  'fed',
                ][number]),
            number + output
          )
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('da', {
        months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort: 'søn_man_tir_ons_tor_fre_lør'.split('_'),
        weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
          sameDay: '[i dag kl.] LT',
          nextDay: '[i morgen kl.] LT',
          nextWeek: 'på dddd [kl.] LT',
          lastDay: '[i går kl.] LT',
          lastWeek: '[i] dddd[s kl.] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'om %s',
          past: '%s siden',
          s: 'få sekunder',
          ss: '%d sekunder',
          m: 'et minut',
          mm: '%d minutter',
          h: 'en time',
          hh: '%d timer',
          d: 'en dag',
          dd: '%d dage',
          M: 'en måned',
          MM: '%d måneder',
          y: 'et år',
          yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }),
      hooks.defineLocale('de-at', {
        months: 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          ss: '%d Sekunden',
          m: processRelativeTime,
          mm: '%d Minuten',
          h: processRelativeTime,
          hh: '%d Stunden',
          d: processRelativeTime,
          dd: processRelativeTime,
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }),
      hooks.defineLocale('de-ch', {
        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          ss: '%d Sekunden',
          m: processRelativeTime$1,
          mm: '%d Minuten',
          h: processRelativeTime$1,
          hh: '%d Stunden',
          d: processRelativeTime$1,
          dd: processRelativeTime$1,
          M: processRelativeTime$1,
          MM: processRelativeTime$1,
          y: processRelativeTime$1,
          yy: processRelativeTime$1,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }),
      hooks.defineLocale('de', {
        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          ss: '%d Sekunden',
          m: processRelativeTime$2,
          mm: '%d Minuten',
          h: processRelativeTime$2,
          hh: '%d Stunden',
          d: processRelativeTime$2,
          dd: processRelativeTime$2,
          M: processRelativeTime$2,
          MM: processRelativeTime$2,
          y: processRelativeTime$2,
          yy: processRelativeTime$2,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var months$4 = [
        'ޖެނުއަރީ',
        'ފެބްރުއަރީ',
        'މާރިޗު',
        'އޭޕްރީލު',
        'މޭ',
        'ޖޫން',
        'ޖުލައި',
        'އޯގަސްޓު',
        'ސެޕްޓެމްބަރު',
        'އޮކްޓޯބަރު',
        'ނޮވެމްބަރު',
        'ޑިސެމްބަރު',
      ],
      weekdays = ['އާދިއްތަ', 'ހޯމަ', 'އަންގާރަ', 'ބުދަ', 'ބުރާސްފަތި', 'ހުކުރު', 'ހޮނިހިރު']
    hooks.defineLocale('dv', {
      months: months$4,
      monthsShort: months$4,
      weekdays,
      weekdaysShort: weekdays,
      weekdaysMin: 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'D/M/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /މކ|މފ/,
      isPM: function (input) {
        return 'މފ' === input
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 12 ? 'މކ' : 'މފ'
      },
      calendar: {
        sameDay: '[މިއަދު] LT',
        nextDay: '[މާދަމާ] LT',
        nextWeek: 'dddd LT',
        lastDay: '[އިއްޔެ] LT',
        lastWeek: '[ފާއިތުވި] dddd LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'ތެރޭގައި %s',
        past: 'ކުރިން %s',
        s: 'ސިކުންތުކޮޅެއް',
        ss: 'd% ސިކުންތު',
        m: 'މިނިޓެއް',
        mm: 'މިނިޓު %d',
        h: 'ގަޑިއިރެއް',
        hh: 'ގަޑިއިރު %d',
        d: 'ދުވަހެއް',
        dd: 'ދުވަސް %d',
        M: 'މަހެއް',
        MM: 'މަސް %d',
        y: 'އަހަރެއް',
        yy: 'އަހަރު %d',
      },
      preparse: function (string) {
        return string.replace(/،/g, ',')
      },
      postformat: function (string) {
        return string.replace(/,/g, '،')
      },
      week: { dow: 7, doy: 12 },
    }), //! moment.js locale configuration
      hooks.defineLocale('el', {
        monthsNominativeEl:
          'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split(
            '_',
          ),
        monthsGenitiveEl:
          'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split(
            '_',
          ),
        months: function (momentToFormat, format) {
          return momentToFormat
            ? 'string' == typeof format && /D/.test(format.substring(0, format.indexOf('MMMM')))
              ? this._monthsGenitiveEl[momentToFormat.month()]
              : this._monthsNominativeEl[momentToFormat.month()]
            : this._monthsNominativeEl
        },
        monthsShort: 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
        weekdays: 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
        weekdaysShort: 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
        weekdaysMin: 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
        meridiem: function (hours, minutes, isLower) {
          return hours > 11 ? (isLower ? 'μμ' : 'ΜΜ') : isLower ? 'πμ' : 'ΠΜ'
        },
        isPM: function (input) {
          return 'μ' === (input + '').toLowerCase()[0]
        },
        meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendarEl: {
          sameDay: '[Σήμερα {}] LT',
          nextDay: '[Αύριο {}] LT',
          nextWeek: 'dddd [{}] LT',
          lastDay: '[Χθες {}] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 6:
                return '[το προηγούμενο] dddd [{}] LT'
              default:
                return '[την προηγούμενη] dddd [{}] LT'
            }
          },
          sameElse: 'L',
        },
        calendar: function (key, mom) {
          var output = this._calendarEl[key],
            hours = mom && mom.hours()
          return (
            isFunction(output) && (output = output.apply(mom)), output.replace('{}', hours % 12 == 1 ? 'στη' : 'στις')
          )
        },
        relativeTime: {
          future: 'σε %s',
          past: '%s πριν',
          s: 'λίγα δευτερόλεπτα',
          ss: '%d δευτερόλεπτα',
          m: 'ένα λεπτό',
          mm: '%d λεπτά',
          h: 'μία ώρα',
          hh: '%d ώρες',
          d: 'μία μέρα',
          dd: '%d μέρες',
          M: 'ένας μήνας',
          MM: '%d μήνες',
          y: 'ένας χρόνος',
          yy: '%d χρόνια',
        },
        dayOfMonthOrdinalParse: /\d{1,2}η/,
        ordinal: '%dη',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('en-SG', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('en-au', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('en-ca', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'YYYY-MM-DD',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
      }), //! moment.js locale configuration
      hooks.defineLocale('en-gb', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('en-ie', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('en-il', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
      }), //! moment.js locale configuration
      hooks.defineLocale('en-nz', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('eo', {
        months: 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
        weekdays: 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
        weekdaysShort: 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
        weekdaysMin: 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'D[-a de] MMMM, YYYY',
          LLL: 'D[-a de] MMMM, YYYY HH:mm',
          LLLL: 'dddd, [la] D[-a de] MMMM, YYYY HH:mm',
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
          return 'p' === input.charAt(0).toLowerCase()
        },
        meridiem: function (hours, minutes, isLower) {
          return hours > 11 ? (isLower ? 'p.t.m.' : 'P.T.M.') : isLower ? 'a.t.m.' : 'A.T.M.'
        },
        calendar: {
          sameDay: '[Hodiaŭ je] LT',
          nextDay: '[Morgaŭ je] LT',
          nextWeek: 'dddd [je] LT',
          lastDay: '[Hieraŭ je] LT',
          lastWeek: '[pasinta] dddd [je] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'post %s',
          past: 'antaŭ %s',
          s: 'sekundoj',
          ss: '%d sekundoj',
          m: 'minuto',
          mm: '%d minutoj',
          h: 'horo',
          hh: '%d horoj',
          d: 'tago',
          dd: '%d tagoj',
          M: 'monato',
          MM: '%d monatoj',
          y: 'jaro',
          yy: '%d jaroj',
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal: '%da',
        week: { dow: 1, doy: 7 },
      }) //! moment.js locale configuration
    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort$1 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse$1 = [
        /^ene/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i,
      ],
      monthsRegex$2 =
        /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i
    hooks.defineLocale('es-do', {
      months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
      monthsShort: function (m, format) {
        return m ? (/-MMM-/.test(format) ? monthsShort$1[m.month()] : monthsShortDot[m.month()]) : monthsShortDot
      },
      monthsRegex: monthsRegex$2,
      monthsShortRegex: monthsRegex$2,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$1,
      longMonthsParse: monthsParse$1,
      shortMonthsParse: monthsParse$1,
      weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
      weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'h:mm A',
        LTS: 'h:mm:ss A',
        L: 'DD/MM/YYYY',
        LL: 'D [de] MMMM [de] YYYY',
        LLL: 'D [de] MMMM [de] YYYY h:mm A',
        LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
      },
      calendar: {
        sameDay: function () {
          return '[hoy a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        nextDay: function () {
          return '[mañana a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        nextWeek: function () {
          return 'dddd [a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        lastDay: function () {
          return '[ayer a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        lastWeek: function () {
          return '[el] dddd [pasado a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'en %s',
        past: 'hace %s',
        s: 'unos segundos',
        ss: '%d segundos',
        m: 'un minuto',
        mm: '%d minutos',
        h: 'una hora',
        hh: '%d horas',
        d: 'un día',
        dd: '%d días',
        M: 'un mes',
        MM: '%d meses',
        y: 'un año',
        yy: '%d años',
      },
      dayOfMonthOrdinalParse: /\d{1,2}º/,
      ordinal: '%dº',
      week: { dow: 1, doy: 4 },
    }) //! moment.js locale configuration
    var monthsShortDot$1 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort$2 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse$2 = [
        /^ene/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i,
      ],
      monthsRegex$3 =
        /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i
    hooks.defineLocale('es-us', {
      months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
      monthsShort: function (m, format) {
        return m ? (/-MMM-/.test(format) ? monthsShort$2[m.month()] : monthsShortDot$1[m.month()]) : monthsShortDot$1
      },
      monthsRegex: monthsRegex$3,
      monthsShortRegex: monthsRegex$3,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$2,
      longMonthsParse: monthsParse$2,
      shortMonthsParse: monthsParse$2,
      weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
      weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'h:mm A',
        LTS: 'h:mm:ss A',
        L: 'MM/DD/YYYY',
        LL: 'D [de] MMMM [de] YYYY',
        LLL: 'D [de] MMMM [de] YYYY h:mm A',
        LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
      },
      calendar: {
        sameDay: function () {
          return '[hoy a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        nextDay: function () {
          return '[mañana a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        nextWeek: function () {
          return 'dddd [a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        lastDay: function () {
          return '[ayer a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        lastWeek: function () {
          return '[el] dddd [pasado a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'en %s',
        past: 'hace %s',
        s: 'unos segundos',
        ss: '%d segundos',
        m: 'un minuto',
        mm: '%d minutos',
        h: 'una hora',
        hh: '%d horas',
        d: 'un día',
        dd: '%d días',
        M: 'un mes',
        MM: '%d meses',
        y: 'un año',
        yy: '%d años',
      },
      dayOfMonthOrdinalParse: /\d{1,2}º/,
      ordinal: '%dº',
      week: { dow: 0, doy: 6 },
    }) //! moment.js locale configuration
    var monthsShortDot$2 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort$3 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse$3 = [
        /^ene/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i,
      ],
      monthsRegex$4 =
        /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i //! moment.js locale configuration
    function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
      var format = {
        s: ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
        ss: [number + 'sekundi', number + 'sekundit'],
        m: ['ühe minuti', 'üks minut'],
        mm: [number + ' minuti', number + ' minutit'],
        h: ['ühe tunni', 'tund aega', 'üks tund'],
        hh: [number + ' tunni', number + ' tundi'],
        d: ['ühe päeva', 'üks päev'],
        M: ['kuu aja', 'kuu aega', 'üks kuu'],
        MM: [number + ' kuu', number + ' kuud'],
        y: ['ühe aasta', 'aasta', 'üks aasta'],
        yy: [number + ' aasta', number + ' aastat'],
      }
      return withoutSuffix
        ? format[key][2]
          ? format[key][2]
          : format[key][1]
        : isFuture
        ? format[key][0]
        : format[key][1]
    }
    hooks.defineLocale('es', {
      months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
      monthsShort: function (m, format) {
        return m ? (/-MMM-/.test(format) ? monthsShort$3[m.month()] : monthsShortDot$2[m.month()]) : monthsShortDot$2
      },
      monthsRegex: monthsRegex$4,
      monthsShortRegex: monthsRegex$4,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$3,
      longMonthsParse: monthsParse$3,
      shortMonthsParse: monthsParse$3,
      weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
      weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D [de] MMMM [de] YYYY',
        LLL: 'D [de] MMMM [de] YYYY H:mm',
        LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
      },
      calendar: {
        sameDay: function () {
          return '[hoy a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        nextDay: function () {
          return '[mañana a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        nextWeek: function () {
          return 'dddd [a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        lastDay: function () {
          return '[ayer a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        lastWeek: function () {
          return '[el] dddd [pasado a la' + (1 !== this.hours() ? 's' : '') + '] LT'
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'en %s',
        past: 'hace %s',
        s: 'unos segundos',
        ss: '%d segundos',
        m: 'un minuto',
        mm: '%d minutos',
        h: 'una hora',
        hh: '%d horas',
        d: 'un día',
        dd: '%d días',
        M: 'un mes',
        MM: '%d meses',
        y: 'un año',
        yy: '%d años',
      },
      dayOfMonthOrdinalParse: /\d{1,2}º/,
      ordinal: '%dº',
      week: { dow: 1, doy: 4 },
    }),
      hooks.defineLocale('et', {
        months: 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort: 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays: 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
        weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
          sameDay: '[Täna,] LT',
          nextDay: '[Homme,] LT',
          nextWeek: '[Järgmine] dddd LT',
          lastDay: '[Eile,] LT',
          lastWeek: '[Eelmine] dddd LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s pärast',
          past: '%s tagasi',
          s: processRelativeTime$3,
          ss: processRelativeTime$3,
          m: processRelativeTime$3,
          mm: processRelativeTime$3,
          h: processRelativeTime$3,
          hh: processRelativeTime$3,
          d: processRelativeTime$3,
          dd: '%d päeva',
          M: processRelativeTime$3,
          MM: processRelativeTime$3,
          y: processRelativeTime$3,
          yy: processRelativeTime$3,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('eu', {
        months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split(
          '_',
        ),
        monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY[ko] MMMM[ren] D[a]',
          LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
          LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
          l: 'YYYY-M-D',
          ll: 'YYYY[ko] MMM D[a]',
          lll: 'YYYY[ko] MMM D[a] HH:mm',
          llll: 'ddd, YYYY[ko] MMM D[a] HH:mm',
        },
        calendar: {
          sameDay: '[gaur] LT[etan]',
          nextDay: '[bihar] LT[etan]',
          nextWeek: 'dddd LT[etan]',
          lastDay: '[atzo] LT[etan]',
          lastWeek: '[aurreko] dddd LT[etan]',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s barru',
          past: 'duela %s',
          s: 'segundo batzuk',
          ss: '%d segundo',
          m: 'minutu bat',
          mm: '%d minutu',
          h: 'ordu bat',
          hh: '%d ordu',
          d: 'egun bat',
          dd: '%d egun',
          M: 'hilabete bat',
          MM: '%d hilabete',
          y: 'urte bat',
          yy: '%d urte',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 7 },
      }) //! moment.js locale configuration
    var symbolMap$5 = { 1: '۱', 2: '۲', 3: '۳', 4: '۴', 5: '۵', 6: '۶', 7: '۷', 8: '۸', 9: '۹', 0: '۰' },
      numberMap$4 = {
        '۱': '1',
        '۲': '2',
        '۳': '3',
        '۴': '4',
        '۵': '5',
        '۶': '6',
        '۷': '7',
        '۸': '8',
        '۹': '9',
        '۰': '0',
      }
    hooks.defineLocale('fa', {
      months: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
      monthsShort: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
      weekdays: 'یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه'.split('_'),
      weekdaysShort: 'یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه'.split('_'),
      weekdaysMin: 'ی_د_س_چ_پ_ج_ش'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      meridiemParse: /قبل از ظهر|بعد از ظهر/,
      isPM: function (input) {
        return /بعد از ظهر/.test(input)
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 12 ? 'قبل از ظهر' : 'بعد از ظهر'
      },
      calendar: {
        sameDay: '[امروز ساعت] LT',
        nextDay: '[فردا ساعت] LT',
        nextWeek: 'dddd [ساعت] LT',
        lastDay: '[دیروز ساعت] LT',
        lastWeek: 'dddd [پیش] [ساعت] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'در %s',
        past: '%s پیش',
        s: 'چند ثانیه',
        ss: 'ثانیه d%',
        m: 'یک دقیقه',
        mm: '%d دقیقه',
        h: 'یک ساعت',
        hh: '%d ساعت',
        d: 'یک روز',
        dd: '%d روز',
        M: 'یک ماه',
        MM: '%d ماه',
        y: 'یک سال',
        yy: '%d سال',
      },
      preparse: function (string) {
        return string
          .replace(/[۰-۹]/g, function (match) {
            return numberMap$4[match]
          })
          .replace(/،/g, ',')
      },
      postformat: function (string) {
        return string
          .replace(/\d/g, function (match) {
            return symbolMap$5[match]
          })
          .replace(/,/g, '،')
      },
      dayOfMonthOrdinalParse: /\d{1,2}م/,
      ordinal: '%dم',
      week: { dow: 6, doy: 12 },
    }) //! moment.js locale configuration
    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
      numbersFuture = [
        'nolla',
        'yhden',
        'kahden',
        'kolmen',
        'neljän',
        'viiden',
        'kuuden',
        numbersPast[7],
        numbersPast[8],
        numbersPast[9],
      ]
    function translate$2(number, withoutSuffix, key, isFuture) {
      var result = ''
      switch (key) {
        case 's':
          return isFuture ? 'muutaman sekunnin' : 'muutama sekunti'
        case 'ss':
          return isFuture ? 'sekunnin' : 'sekuntia'
        case 'm':
          return isFuture ? 'minuutin' : 'minuutti'
        case 'mm':
          result = isFuture ? 'minuutin' : 'minuuttia'
          break
        case 'h':
          return isFuture ? 'tunnin' : 'tunti'
        case 'hh':
          result = isFuture ? 'tunnin' : 'tuntia'
          break
        case 'd':
          return isFuture ? 'päivän' : 'päivä'
        case 'dd':
          result = isFuture ? 'päivän' : 'päivää'
          break
        case 'M':
          return isFuture ? 'kuukauden' : 'kuukausi'
        case 'MM':
          result = isFuture ? 'kuukauden' : 'kuukautta'
          break
        case 'y':
          return isFuture ? 'vuoden' : 'vuosi'
        case 'yy':
          result = isFuture ? 'vuoden' : 'vuotta'
      }
      return (result =
        (function (number, isFuture) {
          return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number
        })(number, isFuture) +
        ' ' +
        result)
    }
    hooks.defineLocale('fi', {
      months:
        'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split(
          '_',
        ),
      monthsShort: 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
      weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
      weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
      weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
      longDateFormat: {
        LT: 'HH.mm',
        LTS: 'HH.mm.ss',
        L: 'DD.MM.YYYY',
        LL: 'Do MMMM[ta] YYYY',
        LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
        LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
        l: 'D.M.YYYY',
        ll: 'Do MMM YYYY',
        lll: 'Do MMM YYYY, [klo] HH.mm',
        llll: 'ddd, Do MMM YYYY, [klo] HH.mm',
      },
      calendar: {
        sameDay: '[tänään] [klo] LT',
        nextDay: '[huomenna] [klo] LT',
        nextWeek: 'dddd [klo] LT',
        lastDay: '[eilen] [klo] LT',
        lastWeek: '[viime] dddd[na] [klo] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s päästä',
        past: '%s sitten',
        s: translate$2,
        ss: translate$2,
        m: translate$2,
        mm: translate$2,
        h: translate$2,
        hh: translate$2,
        d: translate$2,
        dd: translate$2,
        M: translate$2,
        MM: translate$2,
        y: translate$2,
        yy: translate$2,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 4 },
    }), //! moment.js locale configuration
      hooks.defineLocale('fo', {
        months: 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays: 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
        weekdaysShort: 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
        weekdaysMin: 'su_má_tý_mi_hó_fr_le'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D. MMMM, YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Í dag kl.] LT',
          nextDay: '[Í morgin kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[Í gjár kl.] LT',
          lastWeek: '[síðstu] dddd [kl] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'um %s',
          past: '%s síðani',
          s: 'fá sekund',
          ss: '%d sekundir',
          m: 'ein minuttur',
          mm: '%d minuttir',
          h: 'ein tími',
          hh: '%d tímar',
          d: 'ein dagur',
          dd: '%d dagar',
          M: 'ein mánaður',
          MM: '%d mánaðir',
          y: 'eitt ár',
          yy: '%d ár',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('fr-ca', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Aujourd’hui à] LT',
          nextDay: '[Demain à] LT',
          nextWeek: 'dddd [à] LT',
          lastDay: '[Hier à] LT',
          lastWeek: 'dddd [dernier à] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          ss: '%d secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function (number, period) {
          switch (period) {
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
              return number + (1 === number ? 'er' : 'e')
            case 'w':
            case 'W':
              return number + (1 === number ? 're' : 'e')
          }
        },
      }), //! moment.js locale configuration
      hooks.defineLocale('fr-ch', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Aujourd’hui à] LT',
          nextDay: '[Demain à] LT',
          nextWeek: 'dddd [à] LT',
          lastDay: '[Hier à] LT',
          lastWeek: 'dddd [dernier à] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          ss: '%d secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function (number, period) {
          switch (period) {
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
              return number + (1 === number ? 'er' : 'e')
            case 'w':
            case 'W':
              return number + (1 === number ? 're' : 'e')
          }
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('fr', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Aujourd’hui à] LT',
          nextDay: '[Demain à] LT',
          nextWeek: 'dddd [à] LT',
          lastDay: '[Hier à] LT',
          lastWeek: 'dddd [dernier à] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          ss: '%d secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'D':
              return number + (1 === number ? 'er' : '')
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
              return number + (1 === number ? 'er' : 'e')
            case 'w':
            case 'W':
              return number + (1 === number ? 're' : 'e')
          }
        },
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_')
    hooks.defineLocale('fy', {
      months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split(
        '_',
      ),
      monthsShort: function (m, format) {
        return m
          ? /-MMM-/.test(format)
            ? monthsShortWithoutDots[m.month()]
            : monthsShortWithDots[m.month()]
          : monthsShortWithDots
      },
      monthsParseExact: !0,
      weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
      weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
      weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD-MM-YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[hjoed om] LT',
        nextDay: '[moarn om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[juster om] LT',
        lastWeek: '[ôfrûne] dddd [om] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'oer %s',
        past: '%s lyn',
        s: 'in pear sekonden',
        ss: '%d sekonden',
        m: 'ien minút',
        mm: '%d minuten',
        h: 'ien oere',
        hh: '%d oeren',
        d: 'ien dei',
        dd: '%d dagen',
        M: 'ien moanne',
        MM: '%d moannen',
        y: 'ien jier',
        yy: '%d jierren',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function (number) {
        return number + (1 === number || 8 === number || number >= 20 ? 'ste' : 'de')
      },
      week: { dow: 1, doy: 4 },
    })
    hooks.defineLocale('ga', {
      months: [
        'Eanáir',
        'Feabhra',
        'Márta',
        'Aibreán',
        'Bealtaine',
        'Méitheamh',
        'Iúil',
        'Lúnasa',
        'Meán Fómhair',
        'Deaireadh Fómhair',
        'Samhain',
        'Nollaig',
      ],
      monthsShort: ['Eaná', 'Feab', 'Márt', 'Aibr', 'Beal', 'Méit', 'Iúil', 'Lúna', 'Meán', 'Deai', 'Samh', 'Noll'],
      monthsParseExact: !0,
      weekdays: ['Dé Domhnaigh', 'Dé Luain', 'Dé Máirt', 'Dé Céadaoin', 'Déardaoin', 'Dé hAoine', 'Dé Satharn'],
      weekdaysShort: ['Dom', 'Lua', 'Mái', 'Céa', 'Déa', 'hAo', 'Sat'],
      weekdaysMin: ['Do', 'Lu', 'Má', 'Ce', 'Dé', 'hA', 'Sa'],
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[Inniu ag] LT',
        nextDay: '[Amárach ag] LT',
        nextWeek: 'dddd [ag] LT',
        lastDay: '[Inné aig] LT',
        lastWeek: 'dddd [seo caite] [ag] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'i %s',
        past: '%s ó shin',
        s: 'cúpla soicind',
        ss: '%d soicind',
        m: 'nóiméad',
        mm: '%d nóiméad',
        h: 'uair an chloig',
        hh: '%d uair an chloig',
        d: 'lá',
        dd: '%d lá',
        M: 'mí',
        MM: '%d mí',
        y: 'bliain',
        yy: '%d bliain',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
      ordinal: function (number) {
        return number + (1 === number ? 'd' : number % 10 == 2 ? 'na' : 'mh')
      },
      week: { dow: 1, doy: 4 },
    }) //! moment.js locale configuration
    function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
      var format = {
        s: ['thodde secondanim', 'thodde second'],
        ss: [number + ' secondanim', number + ' second'],
        m: ['eka mintan', 'ek minute'],
        mm: [number + ' mintanim', number + ' mintam'],
        h: ['eka voran', 'ek vor'],
        hh: [number + ' voranim', number + ' voram'],
        d: ['eka disan', 'ek dis'],
        dd: [number + ' disanim', number + ' dis'],
        M: ['eka mhoinean', 'ek mhoino'],
        MM: [number + ' mhoineanim', number + ' mhoine'],
        y: ['eka vorsan', 'ek voros'],
        yy: [number + ' vorsanim', number + ' vorsam'],
      }
      return withoutSuffix ? format[key][0] : format[key][1]
    }
    hooks.defineLocale('gd', {
      months: [
        'Am Faoilleach',
        'An Gearran',
        'Am Màrt',
        'An Giblean',
        'An Cèitean',
        'An t-Ògmhios',
        'An t-Iuchar',
        'An Lùnastal',
        'An t-Sultain',
        'An Dàmhair',
        'An t-Samhain',
        'An Dùbhlachd',
      ],
      monthsShort: ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'],
      monthsParseExact: !0,
      weekdays: ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'],
      weekdaysShort: ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
      weekdaysMin: ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'],
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[An-diugh aig] LT',
        nextDay: '[A-màireach aig] LT',
        nextWeek: 'dddd [aig] LT',
        lastDay: '[An-dè aig] LT',
        lastWeek: 'dddd [seo chaidh] [aig] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'ann an %s',
        past: 'bho chionn %s',
        s: 'beagan diogan',
        ss: '%d diogan',
        m: 'mionaid',
        mm: '%d mionaidean',
        h: 'uair',
        hh: '%d uairean',
        d: 'latha',
        dd: '%d latha',
        M: 'mìos',
        MM: '%d mìosan',
        y: 'bliadhna',
        yy: '%d bliadhna',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
      ordinal: function (number) {
        return number + (1 === number ? 'd' : number % 10 == 2 ? 'na' : 'mh')
      },
      week: { dow: 1, doy: 4 },
    }), //! moment.js locale configuration
      hooks.defineLocale('gl', {
        months: 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
        monthsShort: 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mé_xo_ve_sá'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY H:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
        },
        calendar: {
          sameDay: function () {
            return '[hoxe ' + (1 !== this.hours() ? 'ás' : 'á') + '] LT'
          },
          nextDay: function () {
            return '[mañá ' + (1 !== this.hours() ? 'ás' : 'á') + '] LT'
          },
          nextWeek: function () {
            return 'dddd [' + (1 !== this.hours() ? 'ás' : 'a') + '] LT'
          },
          lastDay: function () {
            return '[onte ' + (1 !== this.hours() ? 'á' : 'a') + '] LT'
          },
          lastWeek: function () {
            return '[o] dddd [pasado ' + (1 !== this.hours() ? 'ás' : 'a') + '] LT'
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: function (str) {
            return 0 === str.indexOf('un') ? 'n' + str : 'en ' + str
          },
          past: 'hai %s',
          s: 'uns segundos',
          ss: '%d segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'unha hora',
          hh: '%d horas',
          d: 'un día',
          dd: '%d días',
          M: 'un mes',
          MM: '%d meses',
          y: 'un ano',
          yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: { dow: 1, doy: 4 },
      }),
      hooks.defineLocale('gom-latn', {
        months: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
        monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
        monthsParseExact: !0,
        weekdays: "Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son'var".split('_'),
        weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
        weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'A h:mm [vazta]',
          LTS: 'A h:mm:ss [vazta]',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY A h:mm [vazta]',
          LLLL: 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
          llll: 'ddd, D MMM YYYY, A h:mm [vazta]',
        },
        calendar: {
          sameDay: '[Aiz] LT',
          nextDay: '[Faleam] LT',
          nextWeek: '[Ieta to] dddd[,] LT',
          lastDay: '[Kal] LT',
          lastWeek: '[Fatlo] dddd[,] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s',
          past: '%s adim',
          s: processRelativeTime$4,
          ss: processRelativeTime$4,
          m: processRelativeTime$4,
          mm: processRelativeTime$4,
          h: processRelativeTime$4,
          hh: processRelativeTime$4,
          d: processRelativeTime$4,
          dd: processRelativeTime$4,
          M: processRelativeTime$4,
          MM: processRelativeTime$4,
          y: processRelativeTime$4,
          yy: processRelativeTime$4,
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'D':
              return number + 'er'
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
            case 'w':
            case 'W':
              return number
          }
        },
        week: { dow: 1, doy: 4 },
        meridiemParse: /rati|sokalli|donparam|sanje/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            'rati' === meridiem
              ? hour < 4
                ? hour
                : hour + 12
              : 'sokalli' === meridiem
              ? hour
              : 'donparam' === meridiem
              ? hour > 12
                ? hour
                : hour + 12
              : 'sanje' === meridiem
              ? hour + 12
              : void 0
          )
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 4 ? 'rati' : hour < 12 ? 'sokalli' : hour < 16 ? 'donparam' : hour < 20 ? 'sanje' : 'rati'
        },
      }) //! moment.js locale configuration
    var symbolMap$6 = { 1: '૧', 2: '૨', 3: '૩', 4: '૪', 5: '૫', 6: '૬', 7: '૭', 8: '૮', 9: '૯', 0: '૦' },
      numberMap$5 = {
        '૧': '1',
        '૨': '2',
        '૩': '3',
        '૪': '4',
        '૫': '5',
        '૬': '6',
        '૭': '7',
        '૮': '8',
        '૯': '9',
        '૦': '0',
      }
    hooks.defineLocale('gu', {
      months: 'જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર'.split('_'),
      monthsShort: 'જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.'.split('_'),
      monthsParseExact: !0,
      weekdays: 'રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર'.split('_'),
      weekdaysShort: 'રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ'.split('_'),
      weekdaysMin: 'ર_સો_મં_બુ_ગુ_શુ_શ'.split('_'),
      longDateFormat: {
        LT: 'A h:mm વાગ્યે',
        LTS: 'A h:mm:ss વાગ્યે',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm વાગ્યે',
        LLLL: 'dddd, D MMMM YYYY, A h:mm વાગ્યે',
      },
      calendar: {
        sameDay: '[આજ] LT',
        nextDay: '[કાલે] LT',
        nextWeek: 'dddd, LT',
        lastDay: '[ગઇકાલે] LT',
        lastWeek: '[પાછલા] dddd, LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s મા',
        past: '%s પેહલા',
        s: 'અમુક પળો',
        ss: '%d સેકંડ',
        m: 'એક મિનિટ',
        mm: '%d મિનિટ',
        h: 'એક કલાક',
        hh: '%d કલાક',
        d: 'એક દિવસ',
        dd: '%d દિવસ',
        M: 'એક મહિનો',
        MM: '%d મહિનો',
        y: 'એક વર્ષ',
        yy: '%d વર્ષ',
      },
      preparse: function (string) {
        return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
          return numberMap$5[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$6[match]
        })
      },
      meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          'રાત' === meridiem
            ? hour < 4
              ? hour
              : hour + 12
            : 'સવાર' === meridiem
            ? hour
            : 'બપોર' === meridiem
            ? hour >= 10
              ? hour
              : hour + 12
            : 'સાંજ' === meridiem
            ? hour + 12
            : void 0
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'રાત' : hour < 10 ? 'સવાર' : hour < 17 ? 'બપોર' : hour < 20 ? 'સાંજ' : 'રાત'
      },
      week: { dow: 0, doy: 6 },
    }), //! moment.js locale configuration
      hooks.defineLocale('he', {
        months: 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
        monthsShort: 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
        weekdays: 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
        weekdaysShort: 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
        weekdaysMin: 'א_ב_ג_ד_ה_ו_ש'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [ב]MMMM YYYY',
          LLL: 'D [ב]MMMM YYYY HH:mm',
          LLLL: 'dddd, D [ב]MMMM YYYY HH:mm',
          l: 'D/M/YYYY',
          ll: 'D MMM YYYY',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd, D MMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[היום ב־]LT',
          nextDay: '[מחר ב־]LT',
          nextWeek: 'dddd [בשעה] LT',
          lastDay: '[אתמול ב־]LT',
          lastWeek: '[ביום] dddd [האחרון בשעה] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'בעוד %s',
          past: 'לפני %s',
          s: 'מספר שניות',
          ss: '%d שניות',
          m: 'דקה',
          mm: '%d דקות',
          h: 'שעה',
          hh: function (number) {
            return 2 === number ? 'שעתיים' : number + ' שעות'
          },
          d: 'יום',
          dd: function (number) {
            return 2 === number ? 'יומיים' : number + ' ימים'
          },
          M: 'חודש',
          MM: function (number) {
            return 2 === number ? 'חודשיים' : number + ' חודשים'
          },
          y: 'שנה',
          yy: function (number) {
            return 2 === number ? 'שנתיים' : number % 10 == 0 && 10 !== number ? number + ' שנה' : number + ' שנים'
          },
        },
        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
        isPM: function (input) {
          return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input)
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 5
            ? 'לפנות בוקר'
            : hour < 10
            ? 'בבוקר'
            : hour < 12
            ? isLower
              ? 'לפנה"צ'
              : 'לפני הצהריים'
            : hour < 18
            ? isLower
              ? 'אחה"צ'
              : 'אחרי הצהריים'
            : 'בערב'
        },
      }) //! moment.js locale configuration
    var symbolMap$7 = { 1: '१', 2: '२', 3: '३', 4: '४', 5: '५', 6: '६', 7: '७', 8: '८', 9: '९', 0: '०' },
      numberMap$6 = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0',
      } //! moment.js locale configuration
    function translate$3(number, withoutSuffix, key) {
      var result = number + ' '
      switch (key) {
        case 'ss':
          return (result +=
            1 === number ? 'sekunda' : 2 === number || 3 === number || 4 === number ? 'sekunde' : 'sekundi')
        case 'm':
          return withoutSuffix ? 'jedna minuta' : 'jedne minute'
        case 'mm':
          return (result +=
            1 === number ? 'minuta' : 2 === number || 3 === number || 4 === number ? 'minute' : 'minuta')
        case 'h':
          return withoutSuffix ? 'jedan sat' : 'jednog sata'
        case 'hh':
          return (result += 1 === number ? 'sat' : 2 === number || 3 === number || 4 === number ? 'sata' : 'sati')
        case 'dd':
          return (result += 1 === number ? 'dan' : 'dana')
        case 'MM':
          return (result +=
            1 === number ? 'mjesec' : 2 === number || 3 === number || 4 === number ? 'mjeseca' : 'mjeseci')
        case 'yy':
          return (result +=
            1 === number ? 'godina' : 2 === number || 3 === number || 4 === number ? 'godine' : 'godina')
      }
    }
    hooks.defineLocale('hi', {
      months: 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
      monthsShort: 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
      monthsParseExact: !0,
      weekdays: 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
      weekdaysShort: 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
      weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
      longDateFormat: {
        LT: 'A h:mm बजे',
        LTS: 'A h:mm:ss बजे',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm बजे',
        LLLL: 'dddd, D MMMM YYYY, A h:mm बजे',
      },
      calendar: {
        sameDay: '[आज] LT',
        nextDay: '[कल] LT',
        nextWeek: 'dddd, LT',
        lastDay: '[कल] LT',
        lastWeek: '[पिछले] dddd, LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s में',
        past: '%s पहले',
        s: 'कुछ ही क्षण',
        ss: '%d सेकंड',
        m: 'एक मिनट',
        mm: '%d मिनट',
        h: 'एक घंटा',
        hh: '%d घंटे',
        d: 'एक दिन',
        dd: '%d दिन',
        M: 'एक महीने',
        MM: '%d महीने',
        y: 'एक वर्ष',
        yy: '%d वर्ष',
      },
      preparse: function (string) {
        return string.replace(/[१२३४५६७८९०]/g, function (match) {
          return numberMap$6[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$7[match]
        })
      },
      meridiemParse: /रात|सुबह|दोपहर|शाम/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          'रात' === meridiem
            ? hour < 4
              ? hour
              : hour + 12
            : 'सुबह' === meridiem
            ? hour
            : 'दोपहर' === meridiem
            ? hour >= 10
              ? hour
              : hour + 12
            : 'शाम' === meridiem
            ? hour + 12
            : void 0
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'रात' : hour < 10 ? 'सुबह' : hour < 17 ? 'दोपहर' : hour < 20 ? 'शाम' : 'रात'
      },
      week: { dow: 0, doy: 6 },
    }),
      hooks.defineLocale('hr', {
        months: {
          format:
            'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split(
              '_',
            ),
          standalone:
            'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
        },
        monthsShort: 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sutra u] LT',
          nextWeek: function () {
            switch (this.day()) {
              case 0:
                return '[u] [nedjelju] [u] LT'
              case 3:
                return '[u] [srijedu] [u] LT'
              case 6:
                return '[u] [subotu] [u] LT'
              case 1:
              case 2:
              case 4:
              case 5:
                return '[u] dddd [u] LT'
            }
          },
          lastDay: '[jučer u] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 0:
              case 3:
                return '[prošlu] dddd [u] LT'
              case 6:
                return '[prošle] [subote] [u] LT'
              case 1:
              case 2:
              case 4:
              case 5:
                return '[prošli] dddd [u] LT'
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'za %s',
          past: 'prije %s',
          s: 'par sekundi',
          ss: translate$3,
          m: translate$3,
          mm: translate$3,
          h: translate$3,
          hh: translate$3,
          d: 'dan',
          dd: translate$3,
          M: 'mjesec',
          MM: translate$3,
          y: 'godinu',
          yy: translate$3,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 7 },
      }) //! moment.js locale configuration
    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ')
    function translate$4(number, withoutSuffix, key, isFuture) {
      var num = number
      switch (key) {
        case 's':
          return isFuture || withoutSuffix ? 'néhány másodperc' : 'néhány másodperce'
        case 'ss':
          return num + (isFuture || withoutSuffix) ? ' másodperc' : ' másodperce'
        case 'm':
          return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce')
        case 'mm':
          return num + (isFuture || withoutSuffix ? ' perc' : ' perce')
        case 'h':
          return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája')
        case 'hh':
          return num + (isFuture || withoutSuffix ? ' óra' : ' órája')
        case 'd':
          return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja')
        case 'dd':
          return num + (isFuture || withoutSuffix ? ' nap' : ' napja')
        case 'M':
          return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja')
        case 'MM':
          return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja')
        case 'y':
          return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve')
        case 'yy':
          return num + (isFuture || withoutSuffix ? ' év' : ' éve')
      }
      return ''
    }
    function week(isFuture) {
      return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]'
    } //! moment.js locale configuration
    function plural$2(n) {
      return n % 100 == 11 || n % 10 != 1
    }
    function translate$5(number, withoutSuffix, key, isFuture) {
      var result = number + ' '
      switch (key) {
        case 's':
          return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum'
        case 'ss':
          return plural$2(number) ? result + (withoutSuffix || isFuture ? 'sekúndur' : 'sekúndum') : result + 'sekúnda'
        case 'm':
          return withoutSuffix ? 'mínúta' : 'mínútu'
        case 'mm':
          return plural$2(number)
            ? result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum')
            : withoutSuffix
            ? result + 'mínúta'
            : result + 'mínútu'
        case 'hh':
          return plural$2(number)
            ? result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum')
            : result + 'klukkustund'
        case 'd':
          return withoutSuffix ? 'dagur' : isFuture ? 'dag' : 'degi'
        case 'dd':
          return plural$2(number)
            ? withoutSuffix
              ? result + 'dagar'
              : result + (isFuture ? 'daga' : 'dögum')
            : withoutSuffix
            ? result + 'dagur'
            : result + (isFuture ? 'dag' : 'degi')
        case 'M':
          return withoutSuffix ? 'mánuður' : isFuture ? 'mánuð' : 'mánuði'
        case 'MM':
          return plural$2(number)
            ? withoutSuffix
              ? result + 'mánuðir'
              : result + (isFuture ? 'mánuði' : 'mánuðum')
            : withoutSuffix
            ? result + 'mánuður'
            : result + (isFuture ? 'mánuð' : 'mánuði')
        case 'y':
          return withoutSuffix || isFuture ? 'ár' : 'ári'
        case 'yy':
          return plural$2(number)
            ? result + (withoutSuffix || isFuture ? 'ár' : 'árum')
            : result + (withoutSuffix || isFuture ? 'ár' : 'ári')
      }
    }
    hooks.defineLocale('hu', {
      months: 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split(
        '_',
      ),
      monthsShort: 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
      weekdays: 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
      weekdaysShort: 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
      weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'YYYY.MM.DD.',
        LL: 'YYYY. MMMM D.',
        LLL: 'YYYY. MMMM D. H:mm',
        LLLL: 'YYYY. MMMM D., dddd H:mm',
      },
      meridiemParse: /de|du/i,
      isPM: function (input) {
        return 'u' === input.charAt(1).toLowerCase()
      },
      meridiem: function (hours, minutes, isLower) {
        return hours < 12 ? (!0 === isLower ? 'de' : 'DE') : !0 === isLower ? 'du' : 'DU'
      },
      calendar: {
        sameDay: '[ma] LT[-kor]',
        nextDay: '[holnap] LT[-kor]',
        nextWeek: function () {
          return week.call(this, !0)
        },
        lastDay: '[tegnap] LT[-kor]',
        lastWeek: function () {
          return week.call(this, !1)
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s múlva',
        past: '%s',
        s: translate$4,
        ss: translate$4,
        m: translate$4,
        mm: translate$4,
        h: translate$4,
        hh: translate$4,
        d: translate$4,
        dd: translate$4,
        M: translate$4,
        MM: translate$4,
        y: translate$4,
        yy: translate$4,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 4 },
    }), //! moment.js locale configuration
      hooks.defineLocale('hy-am', {
        months: {
          format:
            'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split(
              '_',
            ),
          standalone:
            'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_'),
        },
        monthsShort: 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
        weekdays: 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
        weekdaysShort: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        weekdaysMin: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY թ.',
          LLL: 'D MMMM YYYY թ., HH:mm',
          LLLL: 'dddd, D MMMM YYYY թ., HH:mm',
        },
        calendar: {
          sameDay: '[այսօր] LT',
          nextDay: '[վաղը] LT',
          lastDay: '[երեկ] LT',
          nextWeek: function () {
            return 'dddd [օրը ժամը] LT'
          },
          lastWeek: function () {
            return '[անցած] dddd [օրը ժամը] LT'
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s հետո',
          past: '%s առաջ',
          s: 'մի քանի վայրկյան',
          ss: '%d վայրկյան',
          m: 'րոպե',
          mm: '%d րոպե',
          h: 'ժամ',
          hh: '%d ժամ',
          d: 'օր',
          dd: '%d օր',
          M: 'ամիս',
          MM: '%d ամիս',
          y: 'տարի',
          yy: '%d տարի',
        },
        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
        isPM: function (input) {
          return /^(ցերեկվա|երեկոյան)$/.test(input)
        },
        meridiem: function (hour) {
          return hour < 4 ? 'գիշերվա' : hour < 12 ? 'առավոտվա' : hour < 17 ? 'ցերեկվա' : 'երեկոյան'
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
              return 1 === number ? number + '-ին' : number + '-րդ'
            default:
              return number
          }
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('id', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            'pagi' === meridiem
              ? hour
              : 'siang' === meridiem
              ? hour >= 11
                ? hour
                : hour + 12
              : 'sore' === meridiem || 'malam' === meridiem
              ? hour + 12
              : void 0
          )
        },
        meridiem: function (hours, minutes, isLower) {
          return hours < 11 ? 'pagi' : hours < 15 ? 'siang' : hours < 19 ? 'sore' : 'malam'
        },
        calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Besok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kemarin pukul] LT',
          lastWeek: 'dddd [lalu pukul] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'dalam %s',
          past: '%s yang lalu',
          s: 'beberapa detik',
          ss: '%d detik',
          m: 'semenit',
          mm: '%d menit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun',
        },
        week: { dow: 1, doy: 7 },
      }),
      hooks.defineLocale('is', {
        months: 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
        weekdays: 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
        weekdaysShort: 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
        weekdaysMin: 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] H:mm',
          LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm',
        },
        calendar: {
          sameDay: '[í dag kl.] LT',
          nextDay: '[á morgun kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[í gær kl.] LT',
          lastWeek: '[síðasta] dddd [kl.] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'eftir %s',
          past: 'fyrir %s síðan',
          s: translate$5,
          ss: translate$5,
          m: translate$5,
          mm: translate$5,
          h: 'klukkustund',
          hh: translate$5,
          d: translate$5,
          dd: translate$5,
          M: translate$5,
          MM: translate$5,
          y: translate$5,
          yy: translate$5,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('it-ch', {
        months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
          '_',
        ),
        monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
        weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Oggi alle] LT',
          nextDay: '[Domani alle] LT',
          nextWeek: 'dddd [alle] LT',
          lastDay: '[Ieri alle] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 0:
                return '[la scorsa] dddd [alle] LT'
              default:
                return '[lo scorso] dddd [alle] LT'
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: function (s) {
            return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s
          },
          past: '%s fa',
          s: 'alcuni secondi',
          ss: '%d secondi',
          m: 'un minuto',
          mm: '%d minuti',
          h: "un'ora",
          hh: '%d ore',
          d: 'un giorno',
          dd: '%d giorni',
          M: 'un mese',
          MM: '%d mesi',
          y: 'un anno',
          yy: '%d anni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('it', {
        months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
          '_',
        ),
        monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
        weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Oggi alle] LT',
          nextDay: '[Domani alle] LT',
          nextWeek: 'dddd [alle] LT',
          lastDay: '[Ieri alle] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 0:
                return '[la scorsa] dddd [alle] LT'
              default:
                return '[lo scorso] dddd [alle] LT'
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: function (s) {
            return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s
          },
          past: '%s fa',
          s: 'alcuni secondi',
          ss: '%d secondi',
          m: 'un minuto',
          mm: '%d minuti',
          h: "un'ora",
          hh: '%d ore',
          d: 'un giorno',
          dd: '%d giorni',
          M: 'un mese',
          MM: '%d mesi',
          y: 'un anno',
          yy: '%d anni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('ja', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays: '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort: '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin: '日_月_火_水_木_金_土'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY年M月D日',
          LLL: 'YYYY年M月D日 HH:mm',
          LLLL: 'YYYY年M月D日 dddd HH:mm',
          l: 'YYYY/MM/DD',
          ll: 'YYYY年M月D日',
          lll: 'YYYY年M月D日 HH:mm',
          llll: 'YYYY年M月D日(ddd) HH:mm',
        },
        meridiemParse: /午前|午後/i,
        isPM: function (input) {
          return '午後' === input
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 12 ? '午前' : '午後'
        },
        calendar: {
          sameDay: '[今日] LT',
          nextDay: '[明日] LT',
          nextWeek: function (now) {
            return now.week() < this.week() ? '[来週]dddd LT' : 'dddd LT'
          },
          lastDay: '[昨日] LT',
          lastWeek: function (now) {
            return this.week() < now.week() ? '[先週]dddd LT' : 'dddd LT'
          },
          sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}日/,
        ordinal: function (number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '日'
            default:
              return number
          }
        },
        relativeTime: {
          future: '%s後',
          past: '%s前',
          s: '数秒',
          ss: '%d秒',
          m: '1分',
          mm: '%d分',
          h: '1時間',
          hh: '%d時間',
          d: '1日',
          dd: '%d日',
          M: '1ヶ月',
          MM: '%dヶ月',
          y: '1年',
          yy: '%d年',
        },
      }), //! moment.js locale configuration
      hooks.defineLocale('jv', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            'enjing' === meridiem
              ? hour
              : 'siyang' === meridiem
              ? hour >= 11
                ? hour
                : hour + 12
              : 'sonten' === meridiem || 'ndalu' === meridiem
              ? hour + 12
              : void 0
          )
        },
        meridiem: function (hours, minutes, isLower) {
          return hours < 11 ? 'enjing' : hours < 15 ? 'siyang' : hours < 19 ? 'sonten' : 'ndalu'
        },
        calendar: {
          sameDay: '[Dinten puniko pukul] LT',
          nextDay: '[Mbenjang pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kala wingi pukul] LT',
          lastWeek: 'dddd [kepengker pukul] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'wonten ing %s',
          past: '%s ingkang kepengker',
          s: 'sawetawis detik',
          ss: '%d detik',
          m: 'setunggal menit',
          mm: '%d menit',
          h: 'setunggal jam',
          hh: '%d jam',
          d: 'sedinten',
          dd: '%d dinten',
          M: 'sewulan',
          MM: '%d wulan',
          y: 'setaun',
          yy: '%d taun',
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('ka', {
        months: {
          standalone:
            'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split(
              '_',
            ),
          format:
            'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split(
              '_',
            ),
        },
        monthsShort: 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
        weekdays: {
          standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
          format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
          isFormat: /(წინა|შემდეგ)/,
        },
        weekdaysShort: 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
        weekdaysMin: 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
          sameDay: '[დღეს] LT[-ზე]',
          nextDay: '[ხვალ] LT[-ზე]',
          lastDay: '[გუშინ] LT[-ზე]',
          nextWeek: '[შემდეგ] dddd LT[-ზე]',
          lastWeek: '[წინა] dddd LT-ზე',
          sameElse: 'L',
        },
        relativeTime: {
          future: function (s) {
            return /(წამი|წუთი|საათი|წელი)/.test(s) ? s.replace(/ი$/, 'ში') : s + 'ში'
          },
          past: function (s) {
            return /(წამი|წუთი|საათი|დღე|თვე)/.test(s)
              ? s.replace(/(ი|ე)$/, 'ის წინ')
              : /წელი/.test(s)
              ? s.replace(/წელი$/, 'წლის წინ')
              : void 0
          },
          s: 'რამდენიმე წამი',
          ss: '%d წამი',
          m: 'წუთი',
          mm: '%d წუთი',
          h: 'საათი',
          hh: '%d საათი',
          d: 'დღე',
          dd: '%d დღე',
          M: 'თვე',
          MM: '%d თვე',
          y: 'წელი',
          yy: '%d წელი',
        },
        dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
        ordinal: function (number) {
          return 0 === number
            ? number
            : 1 === number
            ? number + '-ლი'
            : number < 20 || (number <= 100 && number % 20 == 0) || number % 100 == 0
            ? 'მე-' + number
            : number + '-ე'
        },
        week: { dow: 1, doy: 7 },
      }) //! moment.js locale configuration
    var suffixes$1 = {
      0: '-ші',
      1: '-ші',
      2: '-ші',
      3: '-ші',
      4: '-ші',
      5: '-ші',
      6: '-шы',
      7: '-ші',
      8: '-ші',
      9: '-шы',
      10: '-шы',
      20: '-шы',
      30: '-шы',
      40: '-шы',
      50: '-ші',
      60: '-шы',
      70: '-ші',
      80: '-ші',
      90: '-шы',
      100: '-ші',
    }
    hooks.defineLocale('kk', {
      months: 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
      monthsShort: 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
      weekdays: 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
      weekdaysShort: 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
      weekdaysMin: 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[Бүгін сағат] LT',
        nextDay: '[Ертең сағат] LT',
        nextWeek: 'dddd [сағат] LT',
        lastDay: '[Кеше сағат] LT',
        lastWeek: '[Өткен аптаның] dddd [сағат] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s ішінде',
        past: '%s бұрын',
        s: 'бірнеше секунд',
        ss: '%d секунд',
        m: 'бір минут',
        mm: '%d минут',
        h: 'бір сағат',
        hh: '%d сағат',
        d: 'бір күн',
        dd: '%d күн',
        M: 'бір ай',
        MM: '%d ай',
        y: 'бір жыл',
        yy: '%d жыл',
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
      ordinal: function (number) {
        return number + (suffixes$1[number] || suffixes$1[number % 10] || suffixes$1[number >= 100 ? 100 : null])
      },
      week: { dow: 1, doy: 7 },
    }) //! moment.js locale configuration
    var symbolMap$8 = { 1: '១', 2: '២', 3: '៣', 4: '៤', 5: '៥', 6: '៦', 7: '៧', 8: '៨', 9: '៩', 0: '០' },
      numberMap$7 = {
        '១': '1',
        '២': '2',
        '៣': '3',
        '៤': '4',
        '៥': '5',
        '៦': '6',
        '៧': '7',
        '៨': '8',
        '៩': '9',
        '០': '0',
      }
    hooks.defineLocale('km', {
      months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
      monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
      weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
      weekdaysShort: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
      weekdaysMin: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      meridiemParse: /ព្រឹក|ល្ងាច/,
      isPM: function (input) {
        return 'ល្ងាច' === input
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 12 ? 'ព្រឹក' : 'ល្ងាច'
      },
      calendar: {
        sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
        nextDay: '[ស្អែក ម៉ោង] LT',
        nextWeek: 'dddd [ម៉ោង] LT',
        lastDay: '[ម្សិលមិញ ម៉ោង] LT',
        lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%sទៀត',
        past: '%sមុន',
        s: 'ប៉ុន្មានវិនាទី',
        ss: '%d វិនាទី',
        m: 'មួយនាទី',
        mm: '%d នាទី',
        h: 'មួយម៉ោង',
        hh: '%d ម៉ោង',
        d: 'មួយថ្ងៃ',
        dd: '%d ថ្ងៃ',
        M: 'មួយខែ',
        MM: '%d ខែ',
        y: 'មួយឆ្នាំ',
        yy: '%d ឆ្នាំ',
      },
      dayOfMonthOrdinalParse: /ទី\d{1,2}/,
      ordinal: 'ទី%d',
      preparse: function (string) {
        return string.replace(/[១២៣៤៥៦៧៨៩០]/g, function (match) {
          return numberMap$7[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$8[match]
        })
      },
      week: { dow: 1, doy: 4 },
    }) //! moment.js locale configuration
    var symbolMap$9 = { 1: '೧', 2: '೨', 3: '೩', 4: '೪', 5: '೫', 6: '೬', 7: '೭', 8: '೮', 9: '೯', 0: '೦' },
      numberMap$8 = {
        '೧': '1',
        '೨': '2',
        '೩': '3',
        '೪': '4',
        '೫': '5',
        '೬': '6',
        '೭': '7',
        '೮': '8',
        '೯': '9',
        '೦': '0',
      }
    hooks.defineLocale('kn', {
      months: 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split('_'),
      monthsShort: 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ'.split('_'),
      monthsParseExact: !0,
      weekdays: 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split('_'),
      weekdaysShort: 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
      weekdaysMin: 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
      longDateFormat: {
        LT: 'A h:mm',
        LTS: 'A h:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm',
        LLLL: 'dddd, D MMMM YYYY, A h:mm',
      },
      calendar: {
        sameDay: '[ಇಂದು] LT',
        nextDay: '[ನಾಳೆ] LT',
        nextWeek: 'dddd, LT',
        lastDay: '[ನಿನ್ನೆ] LT',
        lastWeek: '[ಕೊನೆಯ] dddd, LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s ನಂತರ',
        past: '%s ಹಿಂದೆ',
        s: 'ಕೆಲವು ಕ್ಷಣಗಳು',
        ss: '%d ಸೆಕೆಂಡುಗಳು',
        m: 'ಒಂದು ನಿಮಿಷ',
        mm: '%d ನಿಮಿಷ',
        h: 'ಒಂದು ಗಂಟೆ',
        hh: '%d ಗಂಟೆ',
        d: 'ಒಂದು ದಿನ',
        dd: '%d ದಿನ',
        M: 'ಒಂದು ತಿಂಗಳು',
        MM: '%d ತಿಂಗಳು',
        y: 'ಒಂದು ವರ್ಷ',
        yy: '%d ವರ್ಷ',
      },
      preparse: function (string) {
        return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
          return numberMap$8[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$9[match]
        })
      },
      meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          'ರಾತ್ರಿ' === meridiem
            ? hour < 4
              ? hour
              : hour + 12
            : 'ಬೆಳಿಗ್ಗೆ' === meridiem
            ? hour
            : 'ಮಧ್ಯಾಹ್ನ' === meridiem
            ? hour >= 10
              ? hour
              : hour + 12
            : 'ಸಂಜೆ' === meridiem
            ? hour + 12
            : void 0
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'ರಾತ್ರಿ' : hour < 10 ? 'ಬೆಳಿಗ್ಗೆ' : hour < 17 ? 'ಮಧ್ಯಾಹ್ನ' : hour < 20 ? 'ಸಂಜೆ' : 'ರಾತ್ರಿ'
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
      ordinal: function (number) {
        return number + 'ನೇ'
      },
      week: { dow: 0, doy: 6 },
    }), //! moment.js locale configuration
      hooks.defineLocale('ko', {
        months: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        monthsShort: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        weekdays: '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
        weekdaysShort: '일_월_화_수_목_금_토'.split('_'),
        weekdaysMin: '일_월_화_수_목_금_토'.split('_'),
        longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'YYYY.MM.DD.',
          LL: 'YYYY년 MMMM D일',
          LLL: 'YYYY년 MMMM D일 A h:mm',
          LLLL: 'YYYY년 MMMM D일 dddd A h:mm',
          l: 'YYYY.MM.DD.',
          ll: 'YYYY년 MMMM D일',
          lll: 'YYYY년 MMMM D일 A h:mm',
          llll: 'YYYY년 MMMM D일 dddd A h:mm',
        },
        calendar: {
          sameDay: '오늘 LT',
          nextDay: '내일 LT',
          nextWeek: 'dddd LT',
          lastDay: '어제 LT',
          lastWeek: '지난주 dddd LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s 후',
          past: '%s 전',
          s: '몇 초',
          ss: '%d초',
          m: '1분',
          mm: '%d분',
          h: '한 시간',
          hh: '%d시간',
          d: '하루',
          dd: '%d일',
          M: '한 달',
          MM: '%d달',
          y: '일 년',
          yy: '%d년',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '일'
            case 'M':
              return number + '월'
            case 'w':
            case 'W':
              return number + '주'
            default:
              return number
          }
        },
        meridiemParse: /오전|오후/,
        isPM: function (token) {
          return '오후' === token
        },
        meridiem: function (hour, minute, isUpper) {
          return hour < 12 ? '오전' : '오후'
        },
      }) //! moment.js locale configuration
    var symbolMap$a = { 1: '١', 2: '٢', 3: '٣', 4: '٤', 5: '٥', 6: '٦', 7: '٧', 8: '٨', 9: '٩', 0: '٠' },
      numberMap$9 = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0',
      },
      months$7 = [
        'کانونی دووەم',
        'شوبات',
        'ئازار',
        'نیسان',
        'ئایار',
        'حوزەیران',
        'تەمموز',
        'ئاب',
        'ئەیلوول',
        'تشرینی یەكەم',
        'تشرینی دووەم',
        'كانونی یەکەم',
      ]
    hooks.defineLocale('ku', {
      months: months$7,
      monthsShort: months$7,
      weekdays: 'یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌'.split('_'),
      weekdaysShort: 'یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌'.split('_'),
      weekdaysMin: 'ی_د_س_چ_پ_ه_ش'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      meridiemParse: /ئێواره‌|به‌یانی/,
      isPM: function (input) {
        return /ئێواره‌/.test(input)
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 12 ? 'به‌یانی' : 'ئێواره‌'
      },
      calendar: {
        sameDay: '[ئه‌مرۆ كاتژمێر] LT',
        nextDay: '[به‌یانی كاتژمێر] LT',
        nextWeek: 'dddd [كاتژمێر] LT',
        lastDay: '[دوێنێ كاتژمێر] LT',
        lastWeek: 'dddd [كاتژمێر] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'له‌ %s',
        past: '%s',
        s: 'چه‌ند چركه‌یه‌ك',
        ss: 'چركه‌ %d',
        m: 'یه‌ك خوله‌ك',
        mm: '%d خوله‌ك',
        h: 'یه‌ك كاتژمێر',
        hh: '%d كاتژمێر',
        d: 'یه‌ك ڕۆژ',
        dd: '%d ڕۆژ',
        M: 'یه‌ك مانگ',
        MM: '%d مانگ',
        y: 'یه‌ك ساڵ',
        yy: '%d ساڵ',
      },
      preparse: function (string) {
        return string
          .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
            return numberMap$9[match]
          })
          .replace(/،/g, ',')
      },
      postformat: function (string) {
        return string
          .replace(/\d/g, function (match) {
            return symbolMap$a[match]
          })
          .replace(/,/g, '،')
      },
      week: { dow: 6, doy: 12 },
    }) //! moment.js locale configuration
    var suffixes$2 = {
      0: '-чү',
      1: '-чи',
      2: '-чи',
      3: '-чү',
      4: '-чү',
      5: '-чи',
      6: '-чы',
      7: '-чи',
      8: '-чи',
      9: '-чу',
      10: '-чу',
      20: '-чы',
      30: '-чу',
      40: '-чы',
      50: '-чү',
      60: '-чы',
      70: '-чи',
      80: '-чи',
      90: '-чу',
      100: '-чү',
    } //! moment.js locale configuration
    function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
      var format = {
        m: ['eng Minutt', 'enger Minutt'],
        h: ['eng Stonn', 'enger Stonn'],
        d: ['een Dag', 'engem Dag'],
        M: ['ee Mount', 'engem Mount'],
        y: ['ee Joer', 'engem Joer'],
      }
      return withoutSuffix ? format[key][0] : format[key][1]
    }
    function eifelerRegelAppliesToNumber(number) {
      if (((number = parseInt(number, 10)), isNaN(number))) return !1
      if (number < 0) return !0
      if (number < 10) return 4 <= number && number <= 7
      if (number < 100) {
        var lastDigit = number % 10
        return eifelerRegelAppliesToNumber(0 === lastDigit ? number / 10 : lastDigit)
      }
      if (number < 1e4) {
        for (; number >= 10; ) number /= 10
        return eifelerRegelAppliesToNumber(number)
      }
      return eifelerRegelAppliesToNumber((number /= 1e3))
    }
    hooks.defineLocale('ky', {
      months: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
      monthsShort: 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
      weekdays: 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
      weekdaysShort: 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
      weekdaysMin: 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[Бүгүн саат] LT',
        nextDay: '[Эртең саат] LT',
        nextWeek: 'dddd [саат] LT',
        lastDay: '[Кечээ саат] LT',
        lastWeek: '[Өткөн аптанын] dddd [күнү] [саат] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s ичинде',
        past: '%s мурун',
        s: 'бирнече секунд',
        ss: '%d секунд',
        m: 'бир мүнөт',
        mm: '%d мүнөт',
        h: 'бир саат',
        hh: '%d саат',
        d: 'бир күн',
        dd: '%d күн',
        M: 'бир ай',
        MM: '%d ай',
        y: 'бир жыл',
        yy: '%d жыл',
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
      ordinal: function (number) {
        return number + (suffixes$2[number] || suffixes$2[number % 10] || suffixes$2[number >= 100 ? 100 : null])
      },
      week: { dow: 1, doy: 7 },
    }),
      hooks.defineLocale('lb', {
        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'H:mm [Auer]',
          LTS: 'H:mm:ss [Auer]',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm [Auer]',
          LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]',
        },
        calendar: {
          sameDay: '[Haut um] LT',
          sameElse: 'L',
          nextDay: '[Muer um] LT',
          nextWeek: 'dddd [um] LT',
          lastDay: '[Gëschter um] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 2:
              case 4:
                return '[Leschten] dddd [um] LT'
              default:
                return '[Leschte] dddd [um] LT'
            }
          },
        },
        relativeTime: {
          future: function (string) {
            return eifelerRegelAppliesToNumber(string.substr(0, string.indexOf(' '))) ? 'a ' + string : 'an ' + string
          },
          past: function (string) {
            return eifelerRegelAppliesToNumber(string.substr(0, string.indexOf(' ')))
              ? 'viru ' + string
              : 'virun ' + string
          },
          s: 'e puer Sekonnen',
          ss: '%d Sekonnen',
          m: processRelativeTime$5,
          mm: '%d Minutten',
          h: processRelativeTime$5,
          hh: '%d Stonnen',
          d: processRelativeTime$5,
          dd: '%d Deeg',
          M: processRelativeTime$5,
          MM: '%d Méint',
          y: processRelativeTime$5,
          yy: '%d Joer',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('lo', {
        months: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
        monthsShort: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
        weekdays: 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysShort: 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysMin: 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'ວັນdddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
        isPM: function (input) {
          return 'ຕອນແລງ' === input
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 12 ? 'ຕອນເຊົ້າ' : 'ຕອນແລງ'
        },
        calendar: {
          sameDay: '[ມື້ນີ້ເວລາ] LT',
          nextDay: '[ມື້ອື່ນເວລາ] LT',
          nextWeek: '[ວັນ]dddd[ໜ້າເວລາ] LT',
          lastDay: '[ມື້ວານນີ້ເວລາ] LT',
          lastWeek: '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'ອີກ %s',
          past: '%sຜ່ານມາ',
          s: 'ບໍ່ເທົ່າໃດວິນາທີ',
          ss: '%d ວິນາທີ',
          m: '1 ນາທີ',
          mm: '%d ນາທີ',
          h: '1 ຊົ່ວໂມງ',
          hh: '%d ຊົ່ວໂມງ',
          d: '1 ມື້',
          dd: '%d ມື້',
          M: '1 ເດືອນ',
          MM: '%d ເດືອນ',
          y: '1 ປີ',
          yy: '%d ປີ',
        },
        dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
        ordinal: function (number) {
          return 'ທີ່' + number
        },
      }) //! moment.js locale configuration
    var units = {
      ss: 'sekundė_sekundžių_sekundes',
      m: 'minutė_minutės_minutę',
      mm: 'minutės_minučių_minutes',
      h: 'valanda_valandos_valandą',
      hh: 'valandos_valandų_valandas',
      d: 'diena_dienos_dieną',
      dd: 'dienos_dienų_dienas',
      M: 'mėnuo_mėnesio_mėnesį',
      MM: 'mėnesiai_mėnesių_mėnesius',
      y: 'metai_metų_metus',
      yy: 'metai_metų_metus',
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
      return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2]
    }
    function special(number) {
      return number % 10 == 0 || (number > 10 && number < 20)
    }
    function forms(key) {
      return units[key].split('_')
    }
    function translate$6(number, withoutSuffix, key, isFuture) {
      var result = number + ' '
      return 1 === number
        ? result + translateSingular(0, withoutSuffix, key[0], isFuture)
        : withoutSuffix
        ? result + (special(number) ? forms(key)[1] : forms(key)[0])
        : isFuture
        ? result + forms(key)[1]
        : result + (special(number) ? forms(key)[1] : forms(key)[2])
    }
    hooks.defineLocale('lt', {
      months: {
        format:
          'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split(
            '_',
          ),
        standalone:
          'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/,
      },
      monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
      weekdays: {
        format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
        standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split(
          '_',
        ),
        isFormat: /dddd HH:mm/,
      },
      weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
      weekdaysMin: 'S_P_A_T_K_Pn_Š'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'YYYY-MM-DD',
        LL: 'YYYY [m.] MMMM D [d.]',
        LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
        l: 'YYYY-MM-DD',
        ll: 'YYYY [m.] MMMM D [d.]',
        lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]',
      },
      calendar: {
        sameDay: '[Šiandien] LT',
        nextDay: '[Rytoj] LT',
        nextWeek: 'dddd LT',
        lastDay: '[Vakar] LT',
        lastWeek: '[Praėjusį] dddd LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'po %s',
        past: 'prieš %s',
        s: function (number, withoutSuffix, key, isFuture) {
          return withoutSuffix ? 'kelios sekundės' : isFuture ? 'kelių sekundžių' : 'kelias sekundes'
        },
        ss: translate$6,
        m: translateSingular,
        mm: translate$6,
        h: translateSingular,
        hh: translate$6,
        d: translateSingular,
        dd: translate$6,
        M: translateSingular,
        MM: translate$6,
        y: translateSingular,
        yy: translate$6,
      },
      dayOfMonthOrdinalParse: /\d{1,2}-oji/,
      ordinal: function (number) {
        return number + '-oji'
      },
      week: { dow: 1, doy: 4 },
    }) //! moment.js locale configuration
    var units$1 = {
      ss: 'sekundes_sekundēm_sekunde_sekundes'.split('_'),
      m: 'minūtes_minūtēm_minūte_minūtes'.split('_'),
      mm: 'minūtes_minūtēm_minūte_minūtes'.split('_'),
      h: 'stundas_stundām_stunda_stundas'.split('_'),
      hh: 'stundas_stundām_stunda_stundas'.split('_'),
      d: 'dienas_dienām_diena_dienas'.split('_'),
      dd: 'dienas_dienām_diena_dienas'.split('_'),
      M: 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
      MM: 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
      y: 'gada_gadiem_gads_gadi'.split('_'),
      yy: 'gada_gadiem_gads_gadi'.split('_'),
    }
    function format$1(forms, number, withoutSuffix) {
      return withoutSuffix
        ? number % 10 == 1 && number % 100 != 11
          ? forms[2]
          : forms[3]
        : number % 10 == 1 && number % 100 != 11
        ? forms[0]
        : forms[1]
    }
    function relativeTimeWithPlural$1(number, withoutSuffix, key) {
      return number + ' ' + format$1(units$1[key], number, withoutSuffix)
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
      return format$1(units$1[key], number, withoutSuffix)
    }
    hooks.defineLocale('lv', {
      months:
        'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split(
          '_',
        ),
      monthsShort: 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
      weekdays: 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
      weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
      weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY.',
        LL: 'YYYY. [gada] D. MMMM',
        LLL: 'YYYY. [gada] D. MMMM, HH:mm',
        LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm',
      },
      calendar: {
        sameDay: '[Šodien pulksten] LT',
        nextDay: '[Rīt pulksten] LT',
        nextWeek: 'dddd [pulksten] LT',
        lastDay: '[Vakar pulksten] LT',
        lastWeek: '[Pagājušā] dddd [pulksten] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'pēc %s',
        past: 'pirms %s',
        s: function (number, withoutSuffix) {
          return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm'
        },
        ss: relativeTimeWithPlural$1,
        m: relativeTimeWithSingular,
        mm: relativeTimeWithPlural$1,
        h: relativeTimeWithSingular,
        hh: relativeTimeWithPlural$1,
        d: relativeTimeWithSingular,
        dd: relativeTimeWithPlural$1,
        M: relativeTimeWithSingular,
        MM: relativeTimeWithPlural$1,
        y: relativeTimeWithSingular,
        yy: relativeTimeWithPlural$1,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 4 },
    }) //! moment.js locale configuration
    var translator = {
      words: {
        ss: ['sekund', 'sekunda', 'sekundi'],
        m: ['jedan minut', 'jednog minuta'],
        mm: ['minut', 'minuta', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mjesec', 'mjeseca', 'mjeseci'],
        yy: ['godina', 'godine', 'godina'],
      },
      correctGrammaticalCase: function (number, wordKey) {
        return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]
      },
      translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key]
        return 1 === key.length
          ? withoutSuffix
            ? wordKey[0]
            : wordKey[1]
          : number + ' ' + translator.correctGrammaticalCase(number, wordKey)
      },
    } //! moment.js locale configuration
    function translate$7(number, withoutSuffix, key, isFuture) {
      switch (key) {
        case 's':
          return withoutSuffix ? 'хэдхэн секунд' : 'хэдхэн секундын'
        case 'ss':
          return number + (withoutSuffix ? ' секунд' : ' секундын')
        case 'm':
        case 'mm':
          return number + (withoutSuffix ? ' минут' : ' минутын')
        case 'h':
        case 'hh':
          return number + (withoutSuffix ? ' цаг' : ' цагийн')
        case 'd':
        case 'dd':
          return number + (withoutSuffix ? ' өдөр' : ' өдрийн')
        case 'M':
        case 'MM':
          return number + (withoutSuffix ? ' сар' : ' сарын')
        case 'y':
        case 'yy':
          return number + (withoutSuffix ? ' жил' : ' жилийн')
        default:
          return number
      }
    }
    hooks.defineLocale('me', {
      months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
      monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
      monthsParseExact: !0,
      weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
      weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
      weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm',
      },
      calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sjutra u] LT',
        nextWeek: function () {
          switch (this.day()) {
            case 0:
              return '[u] [nedjelju] [u] LT'
            case 3:
              return '[u] [srijedu] [u] LT'
            case 6:
              return '[u] [subotu] [u] LT'
            case 1:
            case 2:
            case 4:
            case 5:
              return '[u] dddd [u] LT'
          }
        },
        lastDay: '[juče u] LT',
        lastWeek: function () {
          return [
            '[prošle] [nedjelje] [u] LT',
            '[prošlog] [ponedjeljka] [u] LT',
            '[prošlog] [utorka] [u] LT',
            '[prošle] [srijede] [u] LT',
            '[prošlog] [četvrtka] [u] LT',
            '[prošlog] [petka] [u] LT',
            '[prošle] [subote] [u] LT',
          ][this.day()]
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'za %s',
        past: 'prije %s',
        s: 'nekoliko sekundi',
        ss: translator.translate,
        m: translator.translate,
        mm: translator.translate,
        h: translator.translate,
        hh: translator.translate,
        d: 'dan',
        dd: translator.translate,
        M: 'mjesec',
        MM: translator.translate,
        y: 'godinu',
        yy: translator.translate,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 7 },
    }), //! moment.js locale configuration
      hooks.defineLocale('mi', {
        months:
          'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split(
            '_',
          ),
        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
        weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [i] HH:mm',
          LLLL: 'dddd, D MMMM YYYY [i] HH:mm',
        },
        calendar: {
          sameDay: '[i teie mahana, i] LT',
          nextDay: '[apopo i] LT',
          nextWeek: 'dddd [i] LT',
          lastDay: '[inanahi i] LT',
          lastWeek: 'dddd [whakamutunga i] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'i roto i %s',
          past: '%s i mua',
          s: 'te hēkona ruarua',
          ss: '%d hēkona',
          m: 'he meneti',
          mm: '%d meneti',
          h: 'te haora',
          hh: '%d haora',
          d: 'he ra',
          dd: '%d ra',
          M: 'he marama',
          MM: '%d marama',
          y: 'he tau',
          yy: '%d tau',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('mk', {
        months: 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort: 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
        weekdays: 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
        weekdaysShort: 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
        weekdaysMin: 'нe_пo_вт_ср_че_пе_сa'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'D.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
          sameDay: '[Денес во] LT',
          nextDay: '[Утре во] LT',
          nextWeek: '[Во] dddd [во] LT',
          lastDay: '[Вчера во] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return '[Изминатата] dddd [во] LT'
              case 1:
              case 2:
              case 4:
              case 5:
                return '[Изминатиот] dddd [во] LT'
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'после %s',
          past: 'пред %s',
          s: 'неколку секунди',
          ss: '%d секунди',
          m: 'минута',
          mm: '%d минути',
          h: 'час',
          hh: '%d часа',
          d: 'ден',
          dd: '%d дена',
          M: 'месец',
          MM: '%d месеци',
          y: 'година',
          yy: '%d години',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal: function (number) {
          var lastDigit = number % 10,
            last2Digits = number % 100
          return 0 === number
            ? number + '-ев'
            : 0 === last2Digits
            ? number + '-ен'
            : last2Digits > 10 && last2Digits < 20
            ? number + '-ти'
            : 1 === lastDigit
            ? number + '-ви'
            : 2 === lastDigit
            ? number + '-ри'
            : 7 === lastDigit || 8 === lastDigit
            ? number + '-ми'
            : number + '-ти'
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('ml', {
        months: 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
        monthsShort: 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
        weekdaysShort: 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
        weekdaysMin: 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
        longDateFormat: {
          LT: 'A h:mm -നു',
          LTS: 'A h:mm:ss -നു',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm -നു',
          LLLL: 'dddd, D MMMM YYYY, A h:mm -നു',
        },
        calendar: {
          sameDay: '[ഇന്ന്] LT',
          nextDay: '[നാളെ] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[ഇന്നലെ] LT',
          lastWeek: '[കഴിഞ്ഞ] dddd, LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s കഴിഞ്ഞ്',
          past: '%s മുൻപ്',
          s: 'അൽപ നിമിഷങ്ങൾ',
          ss: '%d സെക്കൻഡ്',
          m: 'ഒരു മിനിറ്റ്',
          mm: '%d മിനിറ്റ്',
          h: 'ഒരു മണിക്കൂർ',
          hh: '%d മണിക്കൂർ',
          d: 'ഒരു ദിവസം',
          dd: '%d ദിവസം',
          M: 'ഒരു മാസം',
          MM: '%d മാസം',
          y: 'ഒരു വർഷം',
          yy: '%d വർഷം',
        },
        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            ('രാത്രി' === meridiem && hour >= 4) || 'ഉച്ച കഴിഞ്ഞ്' === meridiem || 'വൈകുന്നേരം' === meridiem
              ? hour + 12
              : hour
          )
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 4
            ? 'രാത്രി'
            : hour < 12
            ? 'രാവിലെ'
            : hour < 17
            ? 'ഉച്ച കഴിഞ്ഞ്'
            : hour < 20
            ? 'വൈകുന്നേരം'
            : 'രാത്രി'
        },
      }),
      hooks.defineLocale('mn', {
        months:
          'Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар'.split(
            '_',
          ),
        monthsShort: '1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар'.split('_'),
        monthsParseExact: !0,
        weekdays: 'Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба'.split('_'),
        weekdaysShort: 'Ням_Дав_Мяг_Лха_Пүр_Баа_Бям'.split('_'),
        weekdaysMin: 'Ня_Да_Мя_Лх_Пү_Ба_Бя'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY оны MMMMын D',
          LLL: 'YYYY оны MMMMын D HH:mm',
          LLLL: 'dddd, YYYY оны MMMMын D HH:mm',
        },
        meridiemParse: /ҮӨ|ҮХ/i,
        isPM: function (input) {
          return 'ҮХ' === input
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 12 ? 'ҮӨ' : 'ҮХ'
        },
        calendar: {
          sameDay: '[Өнөөдөр] LT',
          nextDay: '[Маргааш] LT',
          nextWeek: '[Ирэх] dddd LT',
          lastDay: '[Өчигдөр] LT',
          lastWeek: '[Өнгөрсөн] dddd LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s дараа',
          past: '%s өмнө',
          s: translate$7,
          ss: translate$7,
          m: translate$7,
          mm: translate$7,
          h: translate$7,
          hh: translate$7,
          d: translate$7,
          dd: translate$7,
          M: translate$7,
          MM: translate$7,
          y: translate$7,
          yy: translate$7,
        },
        dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
        ordinal: function (number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + ' өдөр'
            default:
              return number
          }
        },
      }) //! moment.js locale configuration
    var symbolMap$b = { 1: '१', 2: '२', 3: '३', 4: '४', 5: '५', 6: '६', 7: '७', 8: '८', 9: '९', 0: '०' },
      numberMap$a = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0',
      }
    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
      var output = ''
      if (withoutSuffix)
        switch (string) {
          case 's':
            output = 'काही सेकंद'
            break
          case 'ss':
            output = '%d सेकंद'
            break
          case 'm':
            output = 'एक मिनिट'
            break
          case 'mm':
            output = '%d मिनिटे'
            break
          case 'h':
            output = 'एक तास'
            break
          case 'hh':
            output = '%d तास'
            break
          case 'd':
            output = 'एक दिवस'
            break
          case 'dd':
            output = '%d दिवस'
            break
          case 'M':
            output = 'एक महिना'
            break
          case 'MM':
            output = '%d महिने'
            break
          case 'y':
            output = 'एक वर्ष'
            break
          case 'yy':
            output = '%d वर्षे'
        }
      else
        switch (string) {
          case 's':
            output = 'काही सेकंदां'
            break
          case 'ss':
            output = '%d सेकंदां'
            break
          case 'm':
            output = 'एका मिनिटा'
            break
          case 'mm':
            output = '%d मिनिटां'
            break
          case 'h':
            output = 'एका तासा'
            break
          case 'hh':
            output = '%d तासां'
            break
          case 'd':
            output = 'एका दिवसा'
            break
          case 'dd':
            output = '%d दिवसां'
            break
          case 'M':
            output = 'एका महिन्या'
            break
          case 'MM':
            output = '%d महिन्यां'
            break
          case 'y':
            output = 'एका वर्षा'
            break
          case 'yy':
            output = '%d वर्षां'
        }
      return output.replace(/%d/i, number)
    }
    hooks.defineLocale('mr', {
      months: 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
      monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
      monthsParseExact: !0,
      weekdays: 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
      weekdaysShort: 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
      weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
      longDateFormat: {
        LT: 'A h:mm वाजता',
        LTS: 'A h:mm:ss वाजता',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm वाजता',
        LLLL: 'dddd, D MMMM YYYY, A h:mm वाजता',
      },
      calendar: {
        sameDay: '[आज] LT',
        nextDay: '[उद्या] LT',
        nextWeek: 'dddd, LT',
        lastDay: '[काल] LT',
        lastWeek: '[मागील] dddd, LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%sमध्ये',
        past: '%sपूर्वी',
        s: relativeTimeMr,
        ss: relativeTimeMr,
        m: relativeTimeMr,
        mm: relativeTimeMr,
        h: relativeTimeMr,
        hh: relativeTimeMr,
        d: relativeTimeMr,
        dd: relativeTimeMr,
        M: relativeTimeMr,
        MM: relativeTimeMr,
        y: relativeTimeMr,
        yy: relativeTimeMr,
      },
      preparse: function (string) {
        return string.replace(/[१२३४५६७८९०]/g, function (match) {
          return numberMap$a[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$b[match]
        })
      },
      meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          'रात्री' === meridiem
            ? hour < 4
              ? hour
              : hour + 12
            : 'सकाळी' === meridiem
            ? hour
            : 'दुपारी' === meridiem
            ? hour >= 10
              ? hour
              : hour + 12
            : 'सायंकाळी' === meridiem
            ? hour + 12
            : void 0
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'रात्री' : hour < 10 ? 'सकाळी' : hour < 17 ? 'दुपारी' : hour < 20 ? 'सायंकाळी' : 'रात्री'
      },
      week: { dow: 0, doy: 6 },
    }), //! moment.js locale configuration
      hooks.defineLocale('ms-my', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            'pagi' === meridiem
              ? hour
              : 'tengahari' === meridiem
              ? hour >= 11
                ? hour
                : hour + 12
              : 'petang' === meridiem || 'malam' === meridiem
              ? hour + 12
              : void 0
          )
        },
        meridiem: function (hours, minutes, isLower) {
          return hours < 11 ? 'pagi' : hours < 15 ? 'tengahari' : hours < 19 ? 'petang' : 'malam'
        },
        calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Esok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kelmarin pukul] LT',
          lastWeek: 'dddd [lepas pukul] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'dalam %s',
          past: '%s yang lepas',
          s: 'beberapa saat',
          ss: '%d saat',
          m: 'seminit',
          mm: '%d minit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun',
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('ms', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            'pagi' === meridiem
              ? hour
              : 'tengahari' === meridiem
              ? hour >= 11
                ? hour
                : hour + 12
              : 'petang' === meridiem || 'malam' === meridiem
              ? hour + 12
              : void 0
          )
        },
        meridiem: function (hours, minutes, isLower) {
          return hours < 11 ? 'pagi' : hours < 15 ? 'tengahari' : hours < 19 ? 'petang' : 'malam'
        },
        calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Esok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kelmarin pukul] LT',
          lastWeek: 'dddd [lepas pukul] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'dalam %s',
          past: '%s yang lepas',
          s: 'beberapa saat',
          ss: '%d saat',
          m: 'seminit',
          mm: '%d minit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun',
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('mt', {
        months: 'Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru'.split('_'),
        monthsShort: 'Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ'.split('_'),
        weekdays: 'Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt'.split('_'),
        weekdaysShort: 'Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib'.split('_'),
        weekdaysMin: 'Ħa_Tn_Tl_Er_Ħa_Ġi_Si'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Illum fil-]LT',
          nextDay: '[Għada fil-]LT',
          nextWeek: 'dddd [fil-]LT',
          lastDay: '[Il-bieraħ fil-]LT',
          lastWeek: 'dddd [li għadda] [fil-]LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'f’ %s',
          past: '%s ilu',
          s: 'ftit sekondi',
          ss: '%d sekondi',
          m: 'minuta',
          mm: '%d minuti',
          h: 'siegħa',
          hh: '%d siegħat',
          d: 'ġurnata',
          dd: '%d ġranet',
          M: 'xahar',
          MM: '%d xhur',
          y: 'sena',
          yy: '%d sni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var symbolMap$c = { 1: '၁', 2: '၂', 3: '၃', 4: '၄', 5: '၅', 6: '၆', 7: '၇', 8: '၈', 9: '၉', 0: '၀' },
      numberMap$b = {
        '၁': '1',
        '၂': '2',
        '၃': '3',
        '၄': '4',
        '၅': '5',
        '၆': '6',
        '၇': '7',
        '၈': '8',
        '၉': '9',
        '၀': '0',
      }
    hooks.defineLocale('my', {
      months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
      monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
      weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
      weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
      weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[ယနေ.] LT [မှာ]',
        nextDay: '[မနက်ဖြန်] LT [မှာ]',
        nextWeek: 'dddd LT [မှာ]',
        lastDay: '[မနေ.က] LT [မှာ]',
        lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'လာမည့် %s မှာ',
        past: 'လွန်ခဲ့သော %s က',
        s: 'စက္ကန်.အနည်းငယ်',
        ss: '%d စက္ကန့်',
        m: 'တစ်မိနစ်',
        mm: '%d မိနစ်',
        h: 'တစ်နာရီ',
        hh: '%d နာရီ',
        d: 'တစ်ရက်',
        dd: '%d ရက်',
        M: 'တစ်လ',
        MM: '%d လ',
        y: 'တစ်နှစ်',
        yy: '%d နှစ်',
      },
      preparse: function (string) {
        return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
          return numberMap$b[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$c[match]
        })
      },
      week: { dow: 1, doy: 4 },
    }), //! moment.js locale configuration
      hooks.defineLocale('nb', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort: 'sø._ma._ti._on._to._fr._lø.'.split('_'),
        weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] HH:mm',
          LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
          sameDay: '[i dag kl.] LT',
          nextDay: '[i morgen kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[i går kl.] LT',
          lastWeek: '[forrige] dddd [kl.] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'om %s',
          past: '%s siden',
          s: 'noen sekunder',
          ss: '%d sekunder',
          m: 'ett minutt',
          mm: '%d minutter',
          h: 'en time',
          hh: '%d timer',
          d: 'en dag',
          dd: '%d dager',
          M: 'en måned',
          MM: '%d måneder',
          y: 'ett år',
          yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var symbolMap$d = { 1: '१', 2: '२', 3: '३', 4: '४', 5: '५', 6: '६', 7: '७', 8: '८', 9: '९', 0: '०' },
      numberMap$c = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0',
      }
    hooks.defineLocale('ne', {
      months: 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
      monthsShort: 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
      monthsParseExact: !0,
      weekdays: 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
      weekdaysShort: 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
      weekdaysMin: 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'Aको h:mm बजे',
        LTS: 'Aको h:mm:ss बजे',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, Aको h:mm बजे',
        LLLL: 'dddd, D MMMM YYYY, Aको h:mm बजे',
      },
      preparse: function (string) {
        return string.replace(/[१२३४५६७८९०]/g, function (match) {
          return numberMap$c[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$d[match]
        })
      },
      meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          'राति' === meridiem
            ? hour < 4
              ? hour
              : hour + 12
            : 'बिहान' === meridiem
            ? hour
            : 'दिउँसो' === meridiem
            ? hour >= 10
              ? hour
              : hour + 12
            : 'साँझ' === meridiem
            ? hour + 12
            : void 0
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 3 ? 'राति' : hour < 12 ? 'बिहान' : hour < 16 ? 'दिउँसो' : hour < 20 ? 'साँझ' : 'राति'
      },
      calendar: {
        sameDay: '[आज] LT',
        nextDay: '[भोलि] LT',
        nextWeek: '[आउँदो] dddd[,] LT',
        lastDay: '[हिजो] LT',
        lastWeek: '[गएको] dddd[,] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%sमा',
        past: '%s अगाडि',
        s: 'केही क्षण',
        ss: '%d सेकेण्ड',
        m: 'एक मिनेट',
        mm: '%d मिनेट',
        h: 'एक घण्टा',
        hh: '%d घण्टा',
        d: 'एक दिन',
        dd: '%d दिन',
        M: 'एक महिना',
        MM: '%d महिना',
        y: 'एक बर्ष',
        yy: '%d बर्ष',
      },
      week: { dow: 0, doy: 6 },
    }) //! moment.js locale configuration
    var monthsShortWithDots$1 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
      monthsShortWithoutDots$1 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
      monthsParse$4 = [
        /^jan/i,
        /^feb/i,
        /^maart|mrt.?$/i,
        /^apr/i,
        /^mei$/i,
        /^jun[i.]?$/i,
        /^jul[i.]?$/i,
        /^aug/i,
        /^sep/i,
        /^okt/i,
        /^nov/i,
        /^dec/i,
      ],
      monthsRegex$5 =
        /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i
    hooks.defineLocale('nl-be', {
      months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
      monthsShort: function (m, format) {
        return m
          ? /-MMM-/.test(format)
            ? monthsShortWithoutDots$1[m.month()]
            : monthsShortWithDots$1[m.month()]
          : monthsShortWithDots$1
      },
      monthsRegex: monthsRegex$5,
      monthsShortRegex: monthsRegex$5,
      monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
      monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
      monthsParse: monthsParse$4,
      longMonthsParse: monthsParse$4,
      shortMonthsParse: monthsParse$4,
      weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
      weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
      weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'over %s',
        past: '%s geleden',
        s: 'een paar seconden',
        ss: '%d seconden',
        m: 'één minuut',
        mm: '%d minuten',
        h: 'één uur',
        hh: '%d uur',
        d: 'één dag',
        dd: '%d dagen',
        M: 'één maand',
        MM: '%d maanden',
        y: 'één jaar',
        yy: '%d jaar',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function (number) {
        return number + (1 === number || 8 === number || number >= 20 ? 'ste' : 'de')
      },
      week: { dow: 1, doy: 4 },
    }) //! moment.js locale configuration
    var monthsShortWithDots$2 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
      monthsShortWithoutDots$2 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
      monthsParse$5 = [
        /^jan/i,
        /^feb/i,
        /^maart|mrt.?$/i,
        /^apr/i,
        /^mei$/i,
        /^jun[i.]?$/i,
        /^jul[i.]?$/i,
        /^aug/i,
        /^sep/i,
        /^okt/i,
        /^nov/i,
        /^dec/i,
      ],
      monthsRegex$6 =
        /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i
    hooks.defineLocale('nl', {
      months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
      monthsShort: function (m, format) {
        return m
          ? /-MMM-/.test(format)
            ? monthsShortWithoutDots$2[m.month()]
            : monthsShortWithDots$2[m.month()]
          : monthsShortWithDots$2
      },
      monthsRegex: monthsRegex$6,
      monthsShortRegex: monthsRegex$6,
      monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
      monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
      monthsParse: monthsParse$5,
      longMonthsParse: monthsParse$5,
      shortMonthsParse: monthsParse$5,
      weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
      weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
      weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD-MM-YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'over %s',
        past: '%s geleden',
        s: 'een paar seconden',
        ss: '%d seconden',
        m: 'één minuut',
        mm: '%d minuten',
        h: 'één uur',
        hh: '%d uur',
        d: 'één dag',
        dd: '%d dagen',
        M: 'één maand',
        MM: '%d maanden',
        y: 'één jaar',
        yy: '%d jaar',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function (number) {
        return number + (1 === number || 8 === number || number >= 20 ? 'ste' : 'de')
      },
      week: { dow: 1, doy: 4 },
    }), //! moment.js locale configuration
      hooks.defineLocale('nn', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays: 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort: 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin: 'su_må_ty_on_to_fr_lø'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] H:mm',
          LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
          sameDay: '[I dag klokka] LT',
          nextDay: '[I morgon klokka] LT',
          nextWeek: 'dddd [klokka] LT',
          lastDay: '[I går klokka] LT',
          lastWeek: '[Føregåande] dddd [klokka] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'om %s',
          past: '%s sidan',
          s: 'nokre sekund',
          ss: '%d sekund',
          m: 'eit minutt',
          mm: '%d minutt',
          h: 'ein time',
          hh: '%d timar',
          d: 'ein dag',
          dd: '%d dagar',
          M: 'ein månad',
          MM: '%d månader',
          y: 'eit år',
          yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var symbolMap$e = { 1: '੧', 2: '੨', 3: '੩', 4: '੪', 5: '੫', 6: '੬', 7: '੭', 8: '੮', 9: '੯', 0: '੦' },
      numberMap$d = {
        '੧': '1',
        '੨': '2',
        '੩': '3',
        '੪': '4',
        '੫': '5',
        '੬': '6',
        '੭': '7',
        '੮': '8',
        '੯': '9',
        '੦': '0',
      }
    hooks.defineLocale('pa-in', {
      months: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
      monthsShort: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
      weekdays: 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
      weekdaysShort: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
      weekdaysMin: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
      longDateFormat: {
        LT: 'A h:mm ਵਜੇ',
        LTS: 'A h:mm:ss ਵਜੇ',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm ਵਜੇ',
        LLLL: 'dddd, D MMMM YYYY, A h:mm ਵਜੇ',
      },
      calendar: {
        sameDay: '[ਅਜ] LT',
        nextDay: '[ਕਲ] LT',
        nextWeek: '[ਅਗਲਾ] dddd, LT',
        lastDay: '[ਕਲ] LT',
        lastWeek: '[ਪਿਛਲੇ] dddd, LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s ਵਿੱਚ',
        past: '%s ਪਿਛਲੇ',
        s: 'ਕੁਝ ਸਕਿੰਟ',
        ss: '%d ਸਕਿੰਟ',
        m: 'ਇਕ ਮਿੰਟ',
        mm: '%d ਮਿੰਟ',
        h: 'ਇੱਕ ਘੰਟਾ',
        hh: '%d ਘੰਟੇ',
        d: 'ਇੱਕ ਦਿਨ',
        dd: '%d ਦਿਨ',
        M: 'ਇੱਕ ਮਹੀਨਾ',
        MM: '%d ਮਹੀਨੇ',
        y: 'ਇੱਕ ਸਾਲ',
        yy: '%d ਸਾਲ',
      },
      preparse: function (string) {
        return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
          return numberMap$d[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$e[match]
        })
      },
      meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          'ਰਾਤ' === meridiem
            ? hour < 4
              ? hour
              : hour + 12
            : 'ਸਵੇਰ' === meridiem
            ? hour
            : 'ਦੁਪਹਿਰ' === meridiem
            ? hour >= 10
              ? hour
              : hour + 12
            : 'ਸ਼ਾਮ' === meridiem
            ? hour + 12
            : void 0
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'ਰਾਤ' : hour < 10 ? 'ਸਵੇਰ' : hour < 17 ? 'ਦੁਪਹਿਰ' : hour < 20 ? 'ਸ਼ਾਮ' : 'ਰਾਤ'
      },
      week: { dow: 0, doy: 6 },
    }) //! moment.js locale configuration
    var monthsNominative =
        'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
      monthsSubjective =
        'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_')
    function plural$3(n) {
      return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 != 1
    }
    function translate$8(number, withoutSuffix, key) {
      var result = number + ' '
      switch (key) {
        case 'ss':
          return result + (plural$3(number) ? 'sekundy' : 'sekund')
        case 'm':
          return withoutSuffix ? 'minuta' : 'minutę'
        case 'mm':
          return result + (plural$3(number) ? 'minuty' : 'minut')
        case 'h':
          return withoutSuffix ? 'godzina' : 'godzinę'
        case 'hh':
          return result + (plural$3(number) ? 'godziny' : 'godzin')
        case 'MM':
          return result + (plural$3(number) ? 'miesiące' : 'miesięcy')
        case 'yy':
          return result + (plural$3(number) ? 'lata' : 'lat')
      }
    } //! moment.js locale configuration
    function relativeTimeWithPlural$2(number, withoutSuffix, key) {
      var separator = ' '
      return (
        (number % 100 >= 20 || (number >= 100 && number % 100 == 0)) && (separator = ' de '),
        number + separator + { ss: 'secunde', mm: 'minute', hh: 'ore', dd: 'zile', MM: 'luni', yy: 'ani' }[key]
      )
    }
    function relativeTimeWithPlural$3(number, withoutSuffix, key) {
      return 'm' === key
        ? withoutSuffix
          ? 'минута'
          : 'минуту'
        : number +
            ' ' + //! moment.js locale configuration
            (function (word, num) {
              var forms = word.split('_')
              return num % 10 == 1 && num % 100 != 11
                ? forms[0]
                : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
                ? forms[1]
                : forms[2]
            })(
              {
                ss: withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
                mm: withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
                hh: 'час_часа_часов',
                dd: 'день_дня_дней',
                MM: 'месяц_месяца_месяцев',
                yy: 'год_года_лет',
              }[key],
              +number,
            )
    }
    hooks.defineLocale('pl', {
      months: function (momentToFormat, format) {
        return momentToFormat
          ? '' === format
            ? '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')'
            : /D MMMM/.test(format)
            ? monthsSubjective[momentToFormat.month()]
            : monthsNominative[momentToFormat.month()]
          : monthsNominative
      },
      monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
      weekdays: 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
      weekdaysShort: 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
      weekdaysMin: 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[Dziś o] LT',
        nextDay: '[Jutro o] LT',
        nextWeek: function () {
          switch (this.day()) {
            case 0:
              return '[W niedzielę o] LT'
            case 2:
              return '[We wtorek o] LT'
            case 3:
              return '[W środę o] LT'
            case 6:
              return '[W sobotę o] LT'
            default:
              return '[W] dddd [o] LT'
          }
        },
        lastDay: '[Wczoraj o] LT',
        lastWeek: function () {
          switch (this.day()) {
            case 0:
              return '[W zeszłą niedzielę o] LT'
            case 3:
              return '[W zeszłą środę o] LT'
            case 6:
              return '[W zeszłą sobotę o] LT'
            default:
              return '[W zeszły] dddd [o] LT'
          }
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'za %s',
        past: '%s temu',
        s: 'kilka sekund',
        ss: translate$8,
        m: translate$8,
        mm: translate$8,
        h: translate$8,
        hh: translate$8,
        d: '1 dzień',
        dd: '%d dni',
        M: 'miesiąc',
        MM: translate$8,
        y: 'rok',
        yy: translate$8,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 4 },
    }), //! moment.js locale configuration
      hooks.defineLocale('pt-br', {
        months: 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
        weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY [às] HH:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY [às] HH:mm',
        },
        calendar: {
          sameDay: '[Hoje às] LT',
          nextDay: '[Amanhã às] LT',
          nextWeek: 'dddd [às] LT',
          lastDay: '[Ontem às] LT',
          lastWeek: function () {
            return 0 === this.day() || 6 === this.day() ? '[Último] dddd [às] LT' : '[Última] dddd [às] LT'
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'em %s',
          past: 'há %s',
          s: 'poucos segundos',
          ss: '%d segundos',
          m: 'um minuto',
          mm: '%d minutos',
          h: 'uma hora',
          hh: '%d horas',
          d: 'um dia',
          dd: '%d dias',
          M: 'um mês',
          MM: '%d meses',
          y: 'um ano',
          yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
      }), //! moment.js locale configuration
      hooks.defineLocale('pt', {
        months: 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
        weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY HH:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Hoje às] LT',
          nextDay: '[Amanhã às] LT',
          nextWeek: 'dddd [às] LT',
          lastDay: '[Ontem às] LT',
          lastWeek: function () {
            return 0 === this.day() || 6 === this.day() ? '[Último] dddd [às] LT' : '[Última] dddd [às] LT'
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'em %s',
          past: 'há %s',
          s: 'segundos',
          ss: '%d segundos',
          m: 'um minuto',
          mm: '%d minutos',
          h: 'uma hora',
          hh: '%d horas',
          d: 'um dia',
          dd: '%d dias',
          M: 'um mês',
          MM: '%d meses',
          y: 'um ano',
          yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: { dow: 1, doy: 4 },
      }),
      hooks.defineLocale('ro', {
        months:
          'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split(
            '_',
          ),
        monthsShort: 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
        weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
        weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
          sameDay: '[azi la] LT',
          nextDay: '[mâine la] LT',
          nextWeek: 'dddd [la] LT',
          lastDay: '[ieri la] LT',
          lastWeek: '[fosta] dddd [la] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'peste %s',
          past: '%s în urmă',
          s: 'câteva secunde',
          ss: relativeTimeWithPlural$2,
          m: 'un minut',
          mm: relativeTimeWithPlural$2,
          h: 'o oră',
          hh: relativeTimeWithPlural$2,
          d: 'o zi',
          dd: relativeTimeWithPlural$2,
          M: 'o lună',
          MM: relativeTimeWithPlural$2,
          y: 'un an',
          yy: relativeTimeWithPlural$2,
        },
        week: { dow: 1, doy: 7 },
      })
    var monthsParse$6 = [
      /^янв/i,
      /^фев/i,
      /^мар/i,
      /^апр/i,
      /^ма[йя]/i,
      /^июн/i,
      /^июл/i,
      /^авг/i,
      /^сен/i,
      /^окт/i,
      /^ноя/i,
      /^дек/i,
    ]
    hooks.defineLocale('ru', {
      months: {
        format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
        standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
      },
      monthsShort: {
        format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
        standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_'),
      },
      weekdays: {
        standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
        format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
        isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/,
      },
      weekdaysShort: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
      weekdaysMin: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
      monthsParse: monthsParse$6,
      longMonthsParse: monthsParse$6,
      shortMonthsParse: monthsParse$6,
      monthsRegex:
        /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
      monthsShortRegex:
        /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
      monthsStrictRegex:
        /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,
      monthsShortStrictRegex:
        /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY г.',
        LLL: 'D MMMM YYYY г., H:mm',
        LLLL: 'dddd, D MMMM YYYY г., H:mm',
      },
      calendar: {
        sameDay: '[Сегодня, в] LT',
        nextDay: '[Завтра, в] LT',
        lastDay: '[Вчера, в] LT',
        nextWeek: function (now) {
          if (now.week() === this.week()) return 2 === this.day() ? '[Во] dddd, [в] LT' : '[В] dddd, [в] LT'
          switch (this.day()) {
            case 0:
              return '[В следующее] dddd, [в] LT'
            case 1:
            case 2:
            case 4:
              return '[В следующий] dddd, [в] LT'
            case 3:
            case 5:
            case 6:
              return '[В следующую] dddd, [в] LT'
          }
        },
        lastWeek: function (now) {
          if (now.week() === this.week()) return 2 === this.day() ? '[Во] dddd, [в] LT' : '[В] dddd, [в] LT'
          switch (this.day()) {
            case 0:
              return '[В прошлое] dddd, [в] LT'
            case 1:
            case 2:
            case 4:
              return '[В прошлый] dddd, [в] LT'
            case 3:
            case 5:
            case 6:
              return '[В прошлую] dddd, [в] LT'
          }
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'через %s',
        past: '%s назад',
        s: 'несколько секунд',
        ss: relativeTimeWithPlural$3,
        m: relativeTimeWithPlural$3,
        mm: relativeTimeWithPlural$3,
        h: 'час',
        hh: relativeTimeWithPlural$3,
        d: 'день',
        dd: relativeTimeWithPlural$3,
        M: 'месяц',
        MM: relativeTimeWithPlural$3,
        y: 'год',
        yy: relativeTimeWithPlural$3,
      },
      meridiemParse: /ночи|утра|дня|вечера/i,
      isPM: function (input) {
        return /^(дня|вечера)$/.test(input)
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'ночи' : hour < 12 ? 'утра' : hour < 17 ? 'дня' : 'вечера'
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
      ordinal: function (number, period) {
        switch (period) {
          case 'M':
          case 'd':
          case 'DDD':
            return number + '-й'
          case 'D':
            return number + '-го'
          case 'w':
          case 'W':
            return number + '-я'
          default:
            return number
        }
      },
      week: { dow: 1, doy: 4 },
    }) //! moment.js locale configuration
    var months$8 = [
        'جنوري',
        'فيبروري',
        'مارچ',
        'اپريل',
        'مئي',
        'جون',
        'جولاءِ',
        'آگسٽ',
        'سيپٽمبر',
        'آڪٽوبر',
        'نومبر',
        'ڊسمبر',
      ],
      days$1 = ['آچر', 'سومر', 'اڱارو', 'اربع', 'خميس', 'جمع', 'ڇنڇر']
    hooks.defineLocale('sd', {
      months: months$8,
      monthsShort: months$8,
      weekdays: days$1,
      weekdaysShort: days$1,
      weekdaysMin: days$1,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd، D MMMM YYYY HH:mm',
      },
      meridiemParse: /صبح|شام/,
      isPM: function (input) {
        return 'شام' === input
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 12 ? 'صبح' : 'شام'
      },
      calendar: {
        sameDay: '[اڄ] LT',
        nextDay: '[سڀاڻي] LT',
        nextWeek: 'dddd [اڳين هفتي تي] LT',
        lastDay: '[ڪالهه] LT',
        lastWeek: '[گزريل هفتي] dddd [تي] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s پوء',
        past: '%s اڳ',
        s: 'چند سيڪنڊ',
        ss: '%d سيڪنڊ',
        m: 'هڪ منٽ',
        mm: '%d منٽ',
        h: 'هڪ ڪلاڪ',
        hh: '%d ڪلاڪ',
        d: 'هڪ ڏينهن',
        dd: '%d ڏينهن',
        M: 'هڪ مهينو',
        MM: '%d مهينا',
        y: 'هڪ سال',
        yy: '%d سال',
      },
      preparse: function (string) {
        return string.replace(/،/g, ',')
      },
      postformat: function (string) {
        return string.replace(/,/g, '،')
      },
      week: { dow: 1, doy: 4 },
    }), //! moment.js locale configuration
      hooks.defineLocale('se', {
        months:
          'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split(
            '_',
          ),
        monthsShort: 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
        weekdays: 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
        weekdaysShort: 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
        weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'MMMM D. [b.] YYYY',
          LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
          LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm',
        },
        calendar: {
          sameDay: '[otne ti] LT',
          nextDay: '[ihttin ti] LT',
          nextWeek: 'dddd [ti] LT',
          lastDay: '[ikte ti] LT',
          lastWeek: '[ovddit] dddd [ti] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s geažes',
          past: 'maŋit %s',
          s: 'moadde sekunddat',
          ss: '%d sekunddat',
          m: 'okta minuhta',
          mm: '%d minuhtat',
          h: 'okta diimmu',
          hh: '%d diimmut',
          d: 'okta beaivi',
          dd: '%d beaivvit',
          M: 'okta mánnu',
          MM: '%d mánut',
          y: 'okta jahki',
          yy: '%d jagit',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('si', {
        months: 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split(
          '_',
        ),
        monthsShort: 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
        weekdays: 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
        weekdaysShort: 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
        weekdaysMin: 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'a h:mm',
          LTS: 'a h:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY MMMM D',
          LLL: 'YYYY MMMM D, a h:mm',
          LLLL: 'YYYY MMMM D [වැනි] dddd, a h:mm:ss',
        },
        calendar: {
          sameDay: '[අද] LT[ට]',
          nextDay: '[හෙට] LT[ට]',
          nextWeek: 'dddd LT[ට]',
          lastDay: '[ඊයේ] LT[ට]',
          lastWeek: '[පසුගිය] dddd LT[ට]',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%sකින්',
          past: '%sකට පෙර',
          s: 'තත්පර කිහිපය',
          ss: 'තත්පර %d',
          m: 'මිනිත්තුව',
          mm: 'මිනිත්තු %d',
          h: 'පැය',
          hh: 'පැය %d',
          d: 'දිනය',
          dd: 'දින %d',
          M: 'මාසය',
          MM: 'මාස %d',
          y: 'වසර',
          yy: 'වසර %d',
        },
        dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
        ordinal: function (number) {
          return number + ' වැනි'
        },
        meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
        isPM: function (input) {
          return 'ප.ව.' === input || 'පස් වරු' === input
        },
        meridiem: function (hours, minutes, isLower) {
          return hours > 11 ? (isLower ? 'ප.ව.' : 'පස් වරු') : isLower ? 'පෙ.ව.' : 'පෙර වරු'
        },
      }) //! moment.js locale configuration
    var months$9 = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
      monthsShort$6 = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_')
    function plural$5(n) {
      return n > 1 && n < 5
    }
    function translate$9(number, withoutSuffix, key, isFuture) {
      var result = number + ' '
      switch (key) {
        case 's':
          return withoutSuffix || isFuture ? 'pár sekúnd' : 'pár sekundami'
        case 'ss':
          return withoutSuffix || isFuture ? result + (plural$5(number) ? 'sekundy' : 'sekúnd') : result + 'sekundami'
        case 'm':
          return withoutSuffix ? 'minúta' : isFuture ? 'minútu' : 'minútou'
        case 'mm':
          return withoutSuffix || isFuture ? result + (plural$5(number) ? 'minúty' : 'minút') : result + 'minútami'
        case 'h':
          return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou'
        case 'hh':
          return withoutSuffix || isFuture ? result + (plural$5(number) ? 'hodiny' : 'hodín') : result + 'hodinami'
        case 'd':
          return withoutSuffix || isFuture ? 'deň' : 'dňom'
        case 'dd':
          return withoutSuffix || isFuture ? result + (plural$5(number) ? 'dni' : 'dní') : result + 'dňami'
        case 'M':
          return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom'
        case 'MM':
          return withoutSuffix || isFuture ? result + (plural$5(number) ? 'mesiace' : 'mesiacov') : result + 'mesiacmi'
        case 'y':
          return withoutSuffix || isFuture ? 'rok' : 'rokom'
        case 'yy':
          return withoutSuffix || isFuture ? result + (plural$5(number) ? 'roky' : 'rokov') : result + 'rokmi'
      }
    } //! moment.js locale configuration
    function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
      var result = number + ' '
      switch (key) {
        case 's':
          return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami'
        case 'ss':
          return (result +=
            1 === number
              ? withoutSuffix
                ? 'sekundo'
                : 'sekundi'
              : 2 === number
              ? withoutSuffix || isFuture
                ? 'sekundi'
                : 'sekundah'
              : number < 5
              ? withoutSuffix || isFuture
                ? 'sekunde'
                : 'sekundah'
              : 'sekund')
        case 'm':
          return withoutSuffix ? 'ena minuta' : 'eno minuto'
        case 'mm':
          return (result +=
            1 === number
              ? withoutSuffix
                ? 'minuta'
                : 'minuto'
              : 2 === number
              ? withoutSuffix || isFuture
                ? 'minuti'
                : 'minutama'
              : number < 5
              ? withoutSuffix || isFuture
                ? 'minute'
                : 'minutami'
              : withoutSuffix || isFuture
              ? 'minut'
              : 'minutami')
        case 'h':
          return withoutSuffix ? 'ena ura' : 'eno uro'
        case 'hh':
          return (result +=
            1 === number
              ? withoutSuffix
                ? 'ura'
                : 'uro'
              : 2 === number
              ? withoutSuffix || isFuture
                ? 'uri'
                : 'urama'
              : number < 5
              ? withoutSuffix || isFuture
                ? 'ure'
                : 'urami'
              : withoutSuffix || isFuture
              ? 'ur'
              : 'urami')
        case 'd':
          return withoutSuffix || isFuture ? 'en dan' : 'enim dnem'
        case 'dd':
          return (result +=
            1 === number
              ? withoutSuffix || isFuture
                ? 'dan'
                : 'dnem'
              : 2 === number
              ? withoutSuffix || isFuture
                ? 'dni'
                : 'dnevoma'
              : withoutSuffix || isFuture
              ? 'dni'
              : 'dnevi')
        case 'M':
          return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem'
        case 'MM':
          return (result +=
            1 === number
              ? withoutSuffix || isFuture
                ? 'mesec'
                : 'mesecem'
              : 2 === number
              ? withoutSuffix || isFuture
                ? 'meseca'
                : 'mesecema'
              : number < 5
              ? withoutSuffix || isFuture
                ? 'mesece'
                : 'meseci'
              : withoutSuffix || isFuture
              ? 'mesecev'
              : 'meseci')
        case 'y':
          return withoutSuffix || isFuture ? 'eno leto' : 'enim letom'
        case 'yy':
          return (result +=
            1 === number
              ? withoutSuffix || isFuture
                ? 'leto'
                : 'letom'
              : 2 === number
              ? withoutSuffix || isFuture
                ? 'leti'
                : 'letoma'
              : number < 5
              ? withoutSuffix || isFuture
                ? 'leta'
                : 'leti'
              : withoutSuffix || isFuture
              ? 'let'
              : 'leti')
      }
    }
    hooks.defineLocale('sk', {
      months: months$9,
      monthsShort: monthsShort$6,
      weekdays: 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
      weekdaysShort: 'ne_po_ut_st_št_pi_so'.split('_'),
      weekdaysMin: 'ne_po_ut_st_št_pi_so'.split('_'),
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd D. MMMM YYYY H:mm',
      },
      calendar: {
        sameDay: '[dnes o] LT',
        nextDay: '[zajtra o] LT',
        nextWeek: function () {
          switch (this.day()) {
            case 0:
              return '[v nedeľu o] LT'
            case 1:
            case 2:
              return '[v] dddd [o] LT'
            case 3:
              return '[v stredu o] LT'
            case 4:
              return '[vo štvrtok o] LT'
            case 5:
              return '[v piatok o] LT'
            case 6:
              return '[v sobotu o] LT'
          }
        },
        lastDay: '[včera o] LT',
        lastWeek: function () {
          switch (this.day()) {
            case 0:
              return '[minulú nedeľu o] LT'
            case 1:
            case 2:
              return '[minulý] dddd [o] LT'
            case 3:
              return '[minulú stredu o] LT'
            case 4:
            case 5:
              return '[minulý] dddd [o] LT'
            case 6:
              return '[minulú sobotu o] LT'
          }
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'za %s',
        past: 'pred %s',
        s: translate$9,
        ss: translate$9,
        m: translate$9,
        mm: translate$9,
        h: translate$9,
        hh: translate$9,
        d: translate$9,
        dd: translate$9,
        M: translate$9,
        MM: translate$9,
        y: translate$9,
        yy: translate$9,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 4 },
    }),
      hooks.defineLocale('sl', {
        months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
        weekdaysShort: 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
        weekdaysMin: 'ne_po_to_sr_če_pe_so'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
          sameDay: '[danes ob] LT',
          nextDay: '[jutri ob] LT',
          nextWeek: function () {
            switch (this.day()) {
              case 0:
                return '[v] [nedeljo] [ob] LT'
              case 3:
                return '[v] [sredo] [ob] LT'
              case 6:
                return '[v] [soboto] [ob] LT'
              case 1:
              case 2:
              case 4:
              case 5:
                return '[v] dddd [ob] LT'
            }
          },
          lastDay: '[včeraj ob] LT',
          lastWeek: function () {
            switch (this.day()) {
              case 0:
                return '[prejšnjo] [nedeljo] [ob] LT'
              case 3:
                return '[prejšnjo] [sredo] [ob] LT'
              case 6:
                return '[prejšnjo] [soboto] [ob] LT'
              case 1:
              case 2:
              case 4:
              case 5:
                return '[prejšnji] dddd [ob] LT'
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'čez %s',
          past: 'pred %s',
          s: processRelativeTime$6,
          ss: processRelativeTime$6,
          m: processRelativeTime$6,
          mm: processRelativeTime$6,
          h: processRelativeTime$6,
          hh: processRelativeTime$6,
          d: processRelativeTime$6,
          dd: processRelativeTime$6,
          M: processRelativeTime$6,
          MM: processRelativeTime$6,
          y: processRelativeTime$6,
          yy: processRelativeTime$6,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('sq', {
        months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
        monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
        weekdays: 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
        weekdaysShort: 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
        weekdaysMin: 'D_H_Ma_Më_E_P_Sh'.split('_'),
        weekdaysParseExact: !0,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
          return 'M' === input.charAt(0)
        },
        meridiem: function (hours, minutes, isLower) {
          return hours < 12 ? 'PD' : 'MD'
        },
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Sot në] LT',
          nextDay: '[Nesër në] LT',
          nextWeek: 'dddd [në] LT',
          lastDay: '[Dje në] LT',
          lastWeek: 'dddd [e kaluar në] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'në %s',
          past: '%s më parë',
          s: 'disa sekonda',
          ss: '%d sekonda',
          m: 'një minutë',
          mm: '%d minuta',
          h: 'një orë',
          hh: '%d orë',
          d: 'një ditë',
          dd: '%d ditë',
          M: 'një muaj',
          MM: '%d muaj',
          y: 'një vit',
          yy: '%d vite',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var translator$1 = {
      words: {
        ss: ['секунда', 'секунде', 'секунди'],
        m: ['један минут', 'једне минуте'],
        mm: ['минут', 'минуте', 'минута'],
        h: ['један сат', 'једног сата'],
        hh: ['сат', 'сата', 'сати'],
        dd: ['дан', 'дана', 'дана'],
        MM: ['месец', 'месеца', 'месеци'],
        yy: ['година', 'године', 'година'],
      },
      correctGrammaticalCase: function (number, wordKey) {
        return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]
      },
      translate: function (number, withoutSuffix, key) {
        var wordKey = translator$1.words[key]
        return 1 === key.length
          ? withoutSuffix
            ? wordKey[0]
            : wordKey[1]
          : number + ' ' + translator$1.correctGrammaticalCase(number, wordKey)
      },
    }
    hooks.defineLocale('sr-cyrl', {
      months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
      monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
      monthsParseExact: !0,
      weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
      weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
      weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm',
      },
      calendar: {
        sameDay: '[данас у] LT',
        nextDay: '[сутра у] LT',
        nextWeek: function () {
          switch (this.day()) {
            case 0:
              return '[у] [недељу] [у] LT'
            case 3:
              return '[у] [среду] [у] LT'
            case 6:
              return '[у] [суботу] [у] LT'
            case 1:
            case 2:
            case 4:
            case 5:
              return '[у] dddd [у] LT'
          }
        },
        lastDay: '[јуче у] LT',
        lastWeek: function () {
          return [
            '[прошле] [недеље] [у] LT',
            '[прошлог] [понедељка] [у] LT',
            '[прошлог] [уторка] [у] LT',
            '[прошле] [среде] [у] LT',
            '[прошлог] [четвртка] [у] LT',
            '[прошлог] [петка] [у] LT',
            '[прошле] [суботе] [у] LT',
          ][this.day()]
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'за %s',
        past: 'пре %s',
        s: 'неколико секунди',
        ss: translator$1.translate,
        m: translator$1.translate,
        mm: translator$1.translate,
        h: translator$1.translate,
        hh: translator$1.translate,
        d: 'дан',
        dd: translator$1.translate,
        M: 'месец',
        MM: translator$1.translate,
        y: 'годину',
        yy: translator$1.translate,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 7 },
    }) //! moment.js locale configuration
    var translator$2 = {
      words: {
        ss: ['sekunda', 'sekunde', 'sekundi'],
        m: ['jedan minut', 'jedne minute'],
        mm: ['minut', 'minute', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mesec', 'meseca', 'meseci'],
        yy: ['godina', 'godine', 'godina'],
      },
      correctGrammaticalCase: function (number, wordKey) {
        return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]
      },
      translate: function (number, withoutSuffix, key) {
        var wordKey = translator$2.words[key]
        return 1 === key.length
          ? withoutSuffix
            ? wordKey[0]
            : wordKey[1]
          : number + ' ' + translator$2.correctGrammaticalCase(number, wordKey)
      },
    }
    hooks.defineLocale('sr', {
      months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
      monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
      monthsParseExact: !0,
      weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
      weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
      weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
      weekdaysParseExact: !0,
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm',
      },
      calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sutra u] LT',
        nextWeek: function () {
          switch (this.day()) {
            case 0:
              return '[u] [nedelju] [u] LT'
            case 3:
              return '[u] [sredu] [u] LT'
            case 6:
              return '[u] [subotu] [u] LT'
            case 1:
            case 2:
            case 4:
            case 5:
              return '[u] dddd [u] LT'
          }
        },
        lastDay: '[juče u] LT',
        lastWeek: function () {
          return [
            '[prošle] [nedelje] [u] LT',
            '[prošlog] [ponedeljka] [u] LT',
            '[prošlog] [utorka] [u] LT',
            '[prošle] [srede] [u] LT',
            '[prošlog] [četvrtka] [u] LT',
            '[prošlog] [petka] [u] LT',
            '[prošle] [subote] [u] LT',
          ][this.day()]
        },
        sameElse: 'L',
      },
      relativeTime: {
        future: 'za %s',
        past: 'pre %s',
        s: 'nekoliko sekundi',
        ss: translator$2.translate,
        m: translator$2.translate,
        mm: translator$2.translate,
        h: translator$2.translate,
        hh: translator$2.translate,
        d: 'dan',
        dd: translator$2.translate,
        M: 'mesec',
        MM: translator$2.translate,
        y: 'godinu',
        yy: translator$2.translate,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 7 },
    }), //! moment.js locale configuration
      hooks.defineLocale('ss', {
        months:
          "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split(
            '_',
          ),
        monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
          sameDay: '[Namuhla nga] LT',
          nextDay: '[Kusasa nga] LT',
          nextWeek: 'dddd [nga] LT',
          lastDay: '[Itolo nga] LT',
          lastWeek: 'dddd [leliphelile] [nga] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'nga %s',
          past: 'wenteka nga %s',
          s: 'emizuzwana lomcane',
          ss: '%d mzuzwana',
          m: 'umzuzu',
          mm: '%d emizuzu',
          h: 'lihora',
          hh: '%d emahora',
          d: 'lilanga',
          dd: '%d emalanga',
          M: 'inyanga',
          MM: '%d tinyanga',
          y: 'umnyaka',
          yy: '%d iminyaka',
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem: function (hours, minutes, isLower) {
          return hours < 11 ? 'ekuseni' : hours < 15 ? 'emini' : hours < 19 ? 'entsambama' : 'ebusuku'
        },
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            'ekuseni' === meridiem
              ? hour
              : 'emini' === meridiem
              ? hour >= 11
                ? hour
                : hour + 12
              : 'entsambama' === meridiem || 'ebusuku' === meridiem
              ? 0 === hour
                ? 0
                : hour + 12
              : void 0
          )
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('sv', {
        months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
        weekdaysShort: 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
        weekdaysMin: 'sö_må_ti_on_to_fr_lö'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [kl.] HH:mm',
          LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd D MMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Idag] LT',
          nextDay: '[Imorgon] LT',
          lastDay: '[Igår] LT',
          nextWeek: '[På] dddd LT',
          lastWeek: '[I] dddd[s] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'om %s',
          past: 'för %s sedan',
          s: 'några sekunder',
          ss: '%d sekunder',
          m: 'en minut',
          mm: '%d minuter',
          h: 'en timme',
          hh: '%d timmar',
          d: 'en dag',
          dd: '%d dagar',
          M: 'en månad',
          MM: '%d månader',
          y: 'ett år',
          yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
        ordinal: function (number) {
          var b = number % 10
          return number + (1 == ~~((number % 100) / 10) ? 'e' : 1 === b || 2 === b ? 'a' : 'e')
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('sw', {
        months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[leo saa] LT',
          nextDay: '[kesho saa] LT',
          nextWeek: '[wiki ijayo] dddd [saat] LT',
          lastDay: '[jana] LT',
          lastWeek: '[wiki iliyopita] dddd [saat] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s baadaye',
          past: 'tokea %s',
          s: 'hivi punde',
          ss: 'sekunde %d',
          m: 'dakika moja',
          mm: 'dakika %d',
          h: 'saa limoja',
          hh: 'masaa %d',
          d: 'siku moja',
          dd: 'masiku %d',
          M: 'mwezi mmoja',
          MM: 'miezi %d',
          y: 'mwaka mmoja',
          yy: 'miaka %d',
        },
        week: { dow: 1, doy: 7 },
      }) //! moment.js locale configuration
    var symbolMap$f = { 1: '௧', 2: '௨', 3: '௩', 4: '௪', 5: '௫', 6: '௬', 7: '௭', 8: '௮', 9: '௯', 0: '௦' },
      numberMap$e = {
        '௧': '1',
        '௨': '2',
        '௩': '3',
        '௪': '4',
        '௫': '5',
        '௬': '6',
        '௭': '7',
        '௮': '8',
        '௯': '9',
        '௦': '0',
      }
    hooks.defineLocale('ta', {
      months: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
      monthsShort: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
      weekdays: 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split(
        '_',
      ),
      weekdaysShort: 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
      weekdaysMin: 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, HH:mm',
        LLLL: 'dddd, D MMMM YYYY, HH:mm',
      },
      calendar: {
        sameDay: '[இன்று] LT',
        nextDay: '[நாளை] LT',
        nextWeek: 'dddd, LT',
        lastDay: '[நேற்று] LT',
        lastWeek: '[கடந்த வாரம்] dddd, LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s இல்',
        past: '%s முன்',
        s: 'ஒரு சில விநாடிகள்',
        ss: '%d விநாடிகள்',
        m: 'ஒரு நிமிடம்',
        mm: '%d நிமிடங்கள்',
        h: 'ஒரு மணி நேரம்',
        hh: '%d மணி நேரம்',
        d: 'ஒரு நாள்',
        dd: '%d நாட்கள்',
        M: 'ஒரு மாதம்',
        MM: '%d மாதங்கள்',
        y: 'ஒரு வருடம்',
        yy: '%d ஆண்டுகள்',
      },
      dayOfMonthOrdinalParse: /\d{1,2}வது/,
      ordinal: function (number) {
        return number + 'வது'
      },
      preparse: function (string) {
        return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
          return numberMap$e[match]
        })
      },
      postformat: function (string) {
        return string.replace(/\d/g, function (match) {
          return symbolMap$f[match]
        })
      },
      meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
      meridiem: function (hour, minute, isLower) {
        return hour < 2
          ? ' யாமம்'
          : hour < 6
          ? ' வைகறை'
          : hour < 10
          ? ' காலை'
          : hour < 14
          ? ' நண்பகல்'
          : hour < 18
          ? ' எற்பாடு'
          : hour < 22
          ? ' மாலை'
          : ' யாமம்'
      },
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          'யாமம்' === meridiem
            ? hour < 2
              ? hour
              : hour + 12
            : 'வைகறை' === meridiem || 'காலை' === meridiem || ('நண்பகல்' === meridiem && hour >= 10)
            ? hour
            : hour + 12
        )
      },
      week: { dow: 0, doy: 6 },
    }), //! moment.js locale configuration
      hooks.defineLocale('te', {
        months: 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
        monthsShort: 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
        weekdaysShort: 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
        weekdaysMin: 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
        longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm',
          LLLL: 'dddd, D MMMM YYYY, A h:mm',
        },
        calendar: {
          sameDay: '[నేడు] LT',
          nextDay: '[రేపు] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[నిన్న] LT',
          lastWeek: '[గత] dddd, LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s లో',
          past: '%s క్రితం',
          s: 'కొన్ని క్షణాలు',
          ss: '%d సెకన్లు',
          m: 'ఒక నిమిషం',
          mm: '%d నిమిషాలు',
          h: 'ఒక గంట',
          hh: '%d గంటలు',
          d: 'ఒక రోజు',
          dd: '%d రోజులు',
          M: 'ఒక నెల',
          MM: '%d నెలలు',
          y: 'ఒక సంవత్సరం',
          yy: '%d సంవత్సరాలు',
        },
        dayOfMonthOrdinalParse: /\d{1,2}వ/,
        ordinal: '%dవ',
        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            'రాత్రి' === meridiem
              ? hour < 4
                ? hour
                : hour + 12
              : 'ఉదయం' === meridiem
              ? hour
              : 'మధ్యాహ్నం' === meridiem
              ? hour >= 10
                ? hour
                : hour + 12
              : 'సాయంత్రం' === meridiem
              ? hour + 12
              : void 0
          )
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 4 ? 'రాత్రి' : hour < 10 ? 'ఉదయం' : hour < 17 ? 'మధ్యాహ్నం' : hour < 20 ? 'సాయంత్రం' : 'రాత్రి'
        },
        week: { dow: 0, doy: 6 },
      }), //! moment.js locale configuration
      hooks.defineLocale('tet', {
        months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
        weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
        weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Ohin iha] LT',
          nextDay: '[Aban iha] LT',
          nextWeek: 'dddd [iha] LT',
          lastDay: '[Horiseik iha] LT',
          lastWeek: 'dddd [semana kotuk] [iha] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'iha %s',
          past: '%s liuba',
          s: 'minutu balun',
          ss: 'minutu %d',
          m: 'minutu ida',
          mm: 'minutu %d',
          h: 'oras ida',
          hh: 'oras %d',
          d: 'loron ida',
          dd: 'loron %d',
          M: 'fulan ida',
          MM: 'fulan %d',
          y: 'tinan ida',
          yy: 'tinan %d',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var suffixes$3 = {
      0: '-ум',
      1: '-ум',
      2: '-юм',
      3: '-юм',
      4: '-ум',
      5: '-ум',
      6: '-ум',
      7: '-ум',
      8: '-ум',
      9: '-ум',
      10: '-ум',
      12: '-ум',
      13: '-ум',
      20: '-ум',
      30: '-юм',
      40: '-ум',
      50: '-ум',
      60: '-ум',
      70: '-ум',
      80: '-ум',
      90: '-ум',
      100: '-ум',
    }
    hooks.defineLocale('tg', {
      months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
      monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
      weekdays: 'якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе'.split('_'),
      weekdaysShort: 'яшб_дшб_сшб_чшб_пшб_ҷум_шнб'.split('_'),
      weekdaysMin: 'яш_дш_сш_чш_пш_ҷм_шб'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[Имрӯз соати] LT',
        nextDay: '[Пагоҳ соати] LT',
        lastDay: '[Дирӯз соати] LT',
        nextWeek: 'dddd[и] [ҳафтаи оянда соати] LT',
        lastWeek: 'dddd[и] [ҳафтаи гузашта соати] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: 'баъди %s',
        past: '%s пеш',
        s: 'якчанд сония',
        m: 'як дақиқа',
        mm: '%d дақиқа',
        h: 'як соат',
        hh: '%d соат',
        d: 'як рӯз',
        dd: '%d рӯз',
        M: 'як моҳ',
        MM: '%d моҳ',
        y: 'як сол',
        yy: '%d сол',
      },
      meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
      meridiemHour: function (hour, meridiem) {
        return (
          12 === hour && (hour = 0),
          'шаб' === meridiem
            ? hour < 4
              ? hour
              : hour + 12
            : 'субҳ' === meridiem
            ? hour
            : 'рӯз' === meridiem
            ? hour >= 11
              ? hour
              : hour + 12
            : 'бегоҳ' === meridiem
            ? hour + 12
            : void 0
        )
      },
      meridiem: function (hour, minute, isLower) {
        return hour < 4 ? 'шаб' : hour < 11 ? 'субҳ' : hour < 16 ? 'рӯз' : hour < 19 ? 'бегоҳ' : 'шаб'
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
      ordinal: function (number) {
        return number + (suffixes$3[number] || suffixes$3[number % 10] || suffixes$3[number >= 100 ? 100 : null])
      },
      week: { dow: 1, doy: 7 },
    }), //! moment.js locale configuration
      hooks.defineLocale('th', {
        months:
          'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split(
            '_',
          ),
        monthsShort: 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
        monthsParseExact: !0,
        weekdays: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
        weekdaysShort: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'),
        weekdaysMin: 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY เวลา H:mm',
          LLLL: 'วันddddที่ D MMMM YYYY เวลา H:mm',
        },
        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
        isPM: function (input) {
          return 'หลังเที่ยง' === input
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 12 ? 'ก่อนเที่ยง' : 'หลังเที่ยง'
        },
        calendar: {
          sameDay: '[วันนี้ เวลา] LT',
          nextDay: '[พรุ่งนี้ เวลา] LT',
          nextWeek: 'dddd[หน้า เวลา] LT',
          lastDay: '[เมื่อวานนี้ เวลา] LT',
          lastWeek: '[วัน]dddd[ที่แล้ว เวลา] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'อีก %s',
          past: '%sที่แล้ว',
          s: 'ไม่กี่วินาที',
          ss: '%d วินาที',
          m: '1 นาที',
          mm: '%d นาที',
          h: '1 ชั่วโมง',
          hh: '%d ชั่วโมง',
          d: '1 วัน',
          dd: '%d วัน',
          M: '1 เดือน',
          MM: '%d เดือน',
          y: '1 ปี',
          yy: '%d ปี',
        },
      }), //! moment.js locale configuration
      hooks.defineLocale('tl-ph', {
        months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'MM/D/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY HH:mm',
          LLLL: 'dddd, MMMM DD, YYYY HH:mm',
        },
        calendar: {
          sameDay: 'LT [ngayong araw]',
          nextDay: '[Bukas ng] LT',
          nextWeek: 'LT [sa susunod na] dddd',
          lastDay: 'LT [kahapon]',
          lastWeek: 'LT [noong nakaraang] dddd',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'sa loob ng %s',
          past: '%s ang nakalipas',
          s: 'ilang segundo',
          ss: '%d segundo',
          m: 'isang minuto',
          mm: '%d minuto',
          h: 'isang oras',
          hh: '%d oras',
          d: 'isang araw',
          dd: '%d araw',
          M: 'isang buwan',
          MM: '%d buwan',
          y: 'isang taon',
          yy: '%d taon',
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function (number) {
          return number
        },
        week: { dow: 1, doy: 4 },
      }) //! moment.js locale configuration
    var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_')
    function translate$a(number, withoutSuffix, string, isFuture) {
      var numberNoun = (function (number) {
        var hundred = Math.floor((number % 1e3) / 100),
          ten = Math.floor((number % 100) / 10),
          one = number % 10,
          word = ''
        hundred > 0 && (word += numbersNouns[hundred] + 'vatlh')
        ten > 0 && (word += ('' !== word ? ' ' : '') + numbersNouns[ten] + 'maH')
        one > 0 && (word += ('' !== word ? ' ' : '') + numbersNouns[one])
        return '' === word ? 'pagh' : word
      })(number)
      switch (string) {
        case 'ss':
          return numberNoun + ' lup'
        case 'mm':
          return numberNoun + ' tup'
        case 'hh':
          return numberNoun + ' rep'
        case 'dd':
          return numberNoun + ' jaj'
        case 'MM':
          return numberNoun + ' jar'
        case 'yy':
          return numberNoun + ' DIS'
      }
    }
    hooks.defineLocale('tlh', {
      months:
        'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split(
          '_',
        ),
      monthsShort:
        'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split(
          '_',
        ),
      monthsParseExact: !0,
      weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
      weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
      weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[DaHjaj] LT',
        nextDay: '[wa’leS] LT',
        nextWeek: 'LLL',
        lastDay: '[wa’Hu’] LT',
        lastWeek: 'LLL',
        sameElse: 'L',
      },
      relativeTime: {
        future: function (output) {
          var time = output
          return (time =
            -1 !== output.indexOf('jaj')
              ? time.slice(0, -3) + 'leS'
              : -1 !== output.indexOf('jar')
              ? time.slice(0, -3) + 'waQ'
              : -1 !== output.indexOf('DIS')
              ? time.slice(0, -3) + 'nem'
              : time + ' pIq')
        },
        past: function (output) {
          var time = output
          return (time =
            -1 !== output.indexOf('jaj')
              ? time.slice(0, -3) + 'Hu’'
              : -1 !== output.indexOf('jar')
              ? time.slice(0, -3) + 'wen'
              : -1 !== output.indexOf('DIS')
              ? time.slice(0, -3) + 'ben'
              : time + ' ret')
        },
        s: 'puS lup',
        ss: translate$a,
        m: 'wa’ tup',
        mm: translate$a,
        h: 'wa’ rep',
        hh: translate$a,
        d: 'wa’ jaj',
        dd: translate$a,
        M: 'wa’ jar',
        MM: translate$a,
        y: 'wa’ DIS',
        yy: translate$a,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: { dow: 1, doy: 4 },
    })
    var suffixes$4 = {
      1: "'inci",
      5: "'inci",
      8: "'inci",
      70: "'inci",
      80: "'inci",
      2: "'nci",
      7: "'nci",
      20: "'nci",
      50: "'nci",
      3: "'üncü",
      4: "'üncü",
      100: "'üncü",
      6: "'ncı",
      9: "'uncu",
      10: "'uncu",
      30: "'uncu",
      60: "'ıncı",
      90: "'ıncı",
    }
    function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
      var format = {
        s: ['viensas secunds', "'iensas secunds"],
        ss: [number + ' secunds', number + ' secunds'],
        m: ["'n míut", "'iens míut"],
        mm: [number + ' míuts', number + ' míuts'],
        h: ["'n þora", "'iensa þora"],
        hh: [number + ' þoras', number + ' þoras'],
        d: ["'n ziua", "'iensa ziua"],
        dd: [number + ' ziuas', number + ' ziuas'],
        M: ["'n mes", "'iens mes"],
        MM: [number + ' mesen', number + ' mesen'],
        y: ["'n ar", "'iens ar"],
        yy: [number + ' ars', number + ' ars'],
      }
      return isFuture || withoutSuffix ? format[key][0] : format[key][1]
    } //! moment.js locale configuration
    function relativeTimeWithPlural$4(number, withoutSuffix, key) {
      return 'm' === key
        ? withoutSuffix
          ? 'хвилина'
          : 'хвилину'
        : 'h' === key
        ? withoutSuffix
          ? 'година'
          : 'годину'
        : number +
          ' ' + //! moment.js locale configuration
          (function (word, num) {
            var forms = word.split('_')
            return num % 10 == 1 && num % 100 != 11
              ? forms[0]
              : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
              ? forms[1]
              : forms[2]
          })(
            {
              ss: withoutSuffix ? 'секунда_секунди_секунд' : 'секунду_секунди_секунд',
              mm: withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
              hh: withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
              dd: 'день_дні_днів',
              MM: 'місяць_місяці_місяців',
              yy: 'рік_роки_років',
            }[key],
            +number,
          )
    }
    function processHoursFunction(str) {
      return function () {
        return str + 'о' + (11 === this.hours() ? 'б' : '') + '] LT'
      }
    }
    hooks.defineLocale('tr', {
      months: 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
      monthsShort: 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
      weekdays: 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
      weekdaysShort: 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
      weekdaysMin: 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
        sameDay: '[bugün saat] LT',
        nextDay: '[yarın saat] LT',
        nextWeek: '[gelecek] dddd [saat] LT',
        lastDay: '[dün] LT',
        lastWeek: '[geçen] dddd [saat] LT',
        sameElse: 'L',
      },
      relativeTime: {
        future: '%s sonra',
        past: '%s önce',
        s: 'birkaç saniye',
        ss: '%d saniye',
        m: 'bir dakika',
        mm: '%d dakika',
        h: 'bir saat',
        hh: '%d saat',
        d: 'bir gün',
        dd: '%d gün',
        M: 'bir ay',
        MM: '%d ay',
        y: 'bir yıl',
        yy: '%d yıl',
      },
      ordinal: function (number, period) {
        switch (period) {
          case 'd':
          case 'D':
          case 'Do':
          case 'DD':
            return number
          default:
            if (0 === number) return number + "'ıncı"
            var a = number % 10
            return number + (suffixes$4[a] || suffixes$4[(number % 100) - a] || suffixes$4[number >= 100 ? 100 : null])
        }
      },
      week: { dow: 1, doy: 7 },
    }), //! moment.js locale configuration
      hooks.defineLocale('tzl', {
        months: 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays: 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
        weekdaysShort: 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
        weekdaysMin: 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM [dallas] YYYY',
          LLL: 'D. MMMM [dallas] YYYY HH.mm',
          LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm',
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM: function (input) {
          return "d'o" === input.toLowerCase()
        },
        meridiem: function (hours, minutes, isLower) {
          return hours > 11 ? (isLower ? "d'o" : "D'O") : isLower ? "d'a" : "D'A"
        },
        calendar: {
          sameDay: '[oxhi à] LT',
          nextDay: '[demà à] LT',
          nextWeek: 'dddd [à] LT',
          lastDay: '[ieiri à] LT',
          lastWeek: '[sür el] dddd [lasteu à] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'osprei %s',
          past: 'ja%s',
          s: processRelativeTime$7,
          ss: processRelativeTime$7,
          m: processRelativeTime$7,
          mm: processRelativeTime$7,
          h: processRelativeTime$7,
          hh: processRelativeTime$7,
          d: processRelativeTime$7,
          dd: processRelativeTime$7,
          M: processRelativeTime$7,
          MM: processRelativeTime$7,
          y: processRelativeTime$7,
          yy: processRelativeTime$7,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: { dow: 1, doy: 4 },
      }),
      hooks.defineLocale('tzm-latn', {
        months: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        monthsShort: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[asdkh g] LT',
          nextDay: '[aska g] LT',
          nextWeek: 'dddd [g] LT',
          lastDay: '[assant g] LT',
          lastWeek: 'dddd [g] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'dadkh s yan %s',
          past: 'yan %s',
          s: 'imik',
          ss: '%d imik',
          m: 'minuḍ',
          mm: '%d minuḍ',
          h: 'saɛa',
          hh: '%d tassaɛin',
          d: 'ass',
          dd: '%d ossan',
          M: 'ayowr',
          MM: '%d iyyirn',
          y: 'asgas',
          yy: '%d isgasn',
        },
        week: { dow: 6, doy: 12 },
      }), //! moment.js locale configuration
      hooks.defineLocale('tzm', {
        months: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        monthsShort: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        weekdays: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysShort: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysMin: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
          nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
          nextWeek: 'dddd [ⴴ] LT',
          lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
          lastWeek: 'dddd [ⴴ] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
          past: 'ⵢⴰⵏ %s',
          s: 'ⵉⵎⵉⴽ',
          ss: '%d ⵉⵎⵉⴽ',
          m: 'ⵎⵉⵏⵓⴺ',
          mm: '%d ⵎⵉⵏⵓⴺ',
          h: 'ⵙⴰⵄⴰ',
          hh: '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
          d: 'ⴰⵙⵙ',
          dd: '%d oⵙⵙⴰⵏ',
          M: 'ⴰⵢoⵓⵔ',
          MM: '%d ⵉⵢⵢⵉⵔⵏ',
          y: 'ⴰⵙⴳⴰⵙ',
          yy: '%d ⵉⵙⴳⴰⵙⵏ',
        },
        week: { dow: 6, doy: 12 },
      }), //! moment.js language configuration
      hooks.defineLocale('ug-cn', {
        months: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split('_'),
        monthsShort: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split('_'),
        weekdays: 'يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە'.split('_'),
        weekdaysShort: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
        weekdaysMin: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY-يىلىM-ئاينىڭD-كۈنى',
          LLL: 'YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
          LLLL: 'dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
        },
        meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            'يېرىم كېچە' === meridiem || 'سەھەر' === meridiem || 'چۈشتىن بۇرۇن' === meridiem
              ? hour
              : 'چۈشتىن كېيىن' === meridiem || 'كەچ' === meridiem
              ? hour + 12
              : hour >= 11
              ? hour
              : hour + 12
          )
        },
        meridiem: function (hour, minute, isLower) {
          var hm = 100 * hour + minute
          return hm < 600
            ? 'يېرىم كېچە'
            : hm < 900
            ? 'سەھەر'
            : hm < 1130
            ? 'چۈشتىن بۇرۇن'
            : hm < 1230
            ? 'چۈش'
            : hm < 1800
            ? 'چۈشتىن كېيىن'
            : 'كەچ'
        },
        calendar: {
          sameDay: '[بۈگۈن سائەت] LT',
          nextDay: '[ئەتە سائەت] LT',
          nextWeek: '[كېلەركى] dddd [سائەت] LT',
          lastDay: '[تۆنۈگۈن] LT',
          lastWeek: '[ئالدىنقى] dddd [سائەت] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s كېيىن',
          past: '%s بۇرۇن',
          s: 'نەچچە سېكونت',
          ss: '%d سېكونت',
          m: 'بىر مىنۇت',
          mm: '%d مىنۇت',
          h: 'بىر سائەت',
          hh: '%d سائەت',
          d: 'بىر كۈن',
          dd: '%d كۈن',
          M: 'بىر ئاي',
          MM: '%d ئاي',
          y: 'بىر يىل',
          yy: '%d يىل',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '-كۈنى'
            case 'w':
            case 'W':
              return number + '-ھەپتە'
            default:
              return number
          }
        },
        preparse: function (string) {
          return string.replace(/،/g, ',')
        },
        postformat: function (string) {
          return string.replace(/,/g, '،')
        },
        week: { dow: 1, doy: 7 },
      }),
      hooks.defineLocale('uk', {
        months: {
          format: 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
          standalone:
            'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_'),
        },
        monthsShort: 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
        weekdays: function (m, format) {
          var weekdays = {
            nominative: 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
            accusative: 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
            genitive: 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_'),
          }
          return !0 === m
            ? weekdays.nominative.slice(1, 7).concat(weekdays.nominative.slice(0, 1))
            : m
            ? weekdays[
                /(\[[ВвУу]\]) ?dddd/.test(format)
                  ? 'accusative'
                  : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format)
                  ? 'genitive'
                  : 'nominative'
              ][m.day()]
            : weekdays.nominative
        },
        weekdaysShort: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY р.',
          LLL: 'D MMMM YYYY р., HH:mm',
          LLLL: 'dddd, D MMMM YYYY р., HH:mm',
        },
        calendar: {
          sameDay: processHoursFunction('[Сьогодні '),
          nextDay: processHoursFunction('[Завтра '),
          lastDay: processHoursFunction('[Вчора '),
          nextWeek: processHoursFunction('[У] dddd ['),
          lastWeek: function () {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return processHoursFunction('[Минулої] dddd [').call(this)
              case 1:
              case 2:
              case 4:
                return processHoursFunction('[Минулого] dddd [').call(this)
            }
          },
          sameElse: 'L',
        },
        relativeTime: {
          future: 'за %s',
          past: '%s тому',
          s: 'декілька секунд',
          ss: relativeTimeWithPlural$4,
          m: relativeTimeWithPlural$4,
          mm: relativeTimeWithPlural$4,
          h: 'годину',
          hh: relativeTimeWithPlural$4,
          d: 'день',
          dd: relativeTimeWithPlural$4,
          M: 'місяць',
          MM: relativeTimeWithPlural$4,
          y: 'рік',
          yy: relativeTimeWithPlural$4,
        },
        meridiemParse: /ночі|ранку|дня|вечора/,
        isPM: function (input) {
          return /^(дня|вечора)$/.test(input)
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 4 ? 'ночі' : hour < 12 ? 'ранку' : hour < 17 ? 'дня' : 'вечора'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
              return number + '-й'
            case 'D':
              return number + '-го'
            default:
              return number
          }
        },
        week: { dow: 1, doy: 7 },
      }) //! moment.js locale configuration
    var months$a = [
        'جنوری',
        'فروری',
        'مارچ',
        'اپریل',
        'مئی',
        'جون',
        'جولائی',
        'اگست',
        'ستمبر',
        'اکتوبر',
        'نومبر',
        'دسمبر',
      ],
      days$2 = ['اتوار', 'پیر', 'منگل', 'بدھ', 'جمعرات', 'جمعہ', 'ہفتہ']
    return (
      hooks.defineLocale('ur', {
        months: months$a,
        monthsShort: months$a,
        weekdays: days$2,
        weekdaysShort: days$2,
        weekdaysMin: days$2,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd، D MMMM YYYY HH:mm',
        },
        meridiemParse: /صبح|شام/,
        isPM: function (input) {
          return 'شام' === input
        },
        meridiem: function (hour, minute, isLower) {
          return hour < 12 ? 'صبح' : 'شام'
        },
        calendar: {
          sameDay: '[آج بوقت] LT',
          nextDay: '[کل بوقت] LT',
          nextWeek: 'dddd [بوقت] LT',
          lastDay: '[گذشتہ روز بوقت] LT',
          lastWeek: '[گذشتہ] dddd [بوقت] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s بعد',
          past: '%s قبل',
          s: 'چند سیکنڈ',
          ss: '%d سیکنڈ',
          m: 'ایک منٹ',
          mm: '%d منٹ',
          h: 'ایک گھنٹہ',
          hh: '%d گھنٹے',
          d: 'ایک دن',
          dd: '%d دن',
          M: 'ایک ماہ',
          MM: '%d ماہ',
          y: 'ایک سال',
          yy: '%d سال',
        },
        preparse: function (string) {
          return string.replace(/،/g, ',')
        },
        postformat: function (string) {
          return string.replace(/,/g, '،')
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('uz-latn', {
        months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
        monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
        weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
        weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
        weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'D MMMM YYYY, dddd HH:mm',
        },
        calendar: {
          sameDay: '[Bugun soat] LT [da]',
          nextDay: '[Ertaga] LT [da]',
          nextWeek: 'dddd [kuni soat] LT [da]',
          lastDay: '[Kecha soat] LT [da]',
          lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
          sameElse: 'L',
        },
        relativeTime: {
          future: 'Yaqin %s ichida',
          past: 'Bir necha %s oldin',
          s: 'soniya',
          ss: '%d soniya',
          m: 'bir daqiqa',
          mm: '%d daqiqa',
          h: 'bir soat',
          hh: '%d soat',
          d: 'bir kun',
          dd: '%d kun',
          M: 'bir oy',
          MM: '%d oy',
          y: 'bir yil',
          yy: '%d yil',
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('uz', {
        months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
        monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays: 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
        weekdaysShort: 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
        weekdaysMin: 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'D MMMM YYYY, dddd HH:mm',
        },
        calendar: {
          sameDay: '[Бугун соат] LT [да]',
          nextDay: '[Эртага] LT [да]',
          nextWeek: 'dddd [куни соат] LT [да]',
          lastDay: '[Кеча соат] LT [да]',
          lastWeek: '[Утган] dddd [куни соат] LT [да]',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'Якин %s ичида',
          past: 'Бир неча %s олдин',
          s: 'фурсат',
          ss: '%d фурсат',
          m: 'бир дакика',
          mm: '%d дакика',
          h: 'бир соат',
          hh: '%d соат',
          d: 'бир кун',
          dd: '%d кун',
          M: 'бир ой',
          MM: '%d ой',
          y: 'бир йил',
          yy: '%d йил',
        },
        week: { dow: 1, doy: 7 },
      }), //! moment.js locale configuration
      hooks.defineLocale('vi', {
        months:
          'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split(
            '_',
          ),
        monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact: !0,
        weekdays: 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
        weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact: !0,
        meridiemParse: /sa|ch/i,
        isPM: function (input) {
          return /^ch$/i.test(input)
        },
        meridiem: function (hours, minutes, isLower) {
          return hours < 12 ? (isLower ? 'sa' : 'SA') : isLower ? 'ch' : 'CH'
        },
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM [năm] YYYY',
          LLL: 'D MMMM [năm] YYYY HH:mm',
          LLLL: 'dddd, D MMMM [năm] YYYY HH:mm',
          l: 'DD/M/YYYY',
          ll: 'D MMM YYYY',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd, D MMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[Hôm nay lúc] LT',
          nextDay: '[Ngày mai lúc] LT',
          nextWeek: 'dddd [tuần tới lúc] LT',
          lastDay: '[Hôm qua lúc] LT',
          lastWeek: 'dddd [tuần rồi lúc] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: '%s tới',
          past: '%s trước',
          s: 'vài giây',
          ss: '%d giây',
          m: 'một phút',
          mm: '%d phút',
          h: 'một giờ',
          hh: '%d giờ',
          d: 'một ngày',
          dd: '%d ngày',
          M: 'một tháng',
          MM: '%d tháng',
          y: 'một năm',
          yy: '%d năm',
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function (number) {
          return number
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('x-pseudo', {
        months:
          'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split(
            '_',
          ),
        monthsShort: 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
        monthsParseExact: !0,
        weekdays: 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
        weekdaysShort: 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
        weekdaysMin: 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
        weekdaysParseExact: !0,
        longDateFormat: {
          LT: 'HH:mm',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
          sameDay: '[T~ódá~ý át] LT',
          nextDay: '[T~ómó~rró~w át] LT',
          nextWeek: 'dddd [át] LT',
          lastDay: '[Ý~ést~érdá~ý át] LT',
          lastWeek: '[L~ást] dddd [át] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'í~ñ %s',
          past: '%s á~gó',
          s: 'á ~féw ~sécó~ñds',
          ss: '%d s~écóñ~ds',
          m: 'á ~míñ~úté',
          mm: '%d m~íñú~tés',
          h: 'á~ñ hó~úr',
          hh: '%d h~óúrs',
          d: 'á ~dáý',
          dd: '%d d~áýs',
          M: 'á ~móñ~th',
          MM: '%d m~óñt~hs',
          y: 'á ~ýéár',
          yy: '%d ý~éárs',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
          var b = number % 10
          return (
            number + (1 == ~~((number % 100) / 10) ? 'th' : 1 === b ? 'st' : 2 === b ? 'nd' : 3 === b ? 'rd' : 'th')
          )
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('yo', {
        months: 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split('_'),
        monthsShort: 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
        weekdays: 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
        weekdaysShort: 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
        weekdaysMin: 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
          sameDay: '[Ònì ni] LT',
          nextDay: '[Ọ̀la ni] LT',
          nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT",
          lastDay: '[Àna ni] LT',
          lastWeek: 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
          sameElse: 'L',
        },
        relativeTime: {
          future: 'ní %s',
          past: '%s kọjá',
          s: 'ìsẹjú aayá die',
          ss: 'aayá %d',
          m: 'ìsẹjú kan',
          mm: 'ìsẹjú %d',
          h: 'wákati kan',
          hh: 'wákati %d',
          d: 'ọjọ́ kan',
          dd: 'ọjọ́ %d',
          M: 'osù kan',
          MM: 'osù %d',
          y: 'ọdún kan',
          yy: 'ọdún %d',
        },
        dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
        ordinal: 'ọjọ́ %d',
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('zh-cn', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY年M月D日',
          LLL: 'YYYY年M月D日Ah点mm分',
          LLLL: 'YYYY年M月D日ddddAh点mm分',
          l: 'YYYY/M/D',
          ll: 'YYYY年M月D日',
          lll: 'YYYY年M月D日 HH:mm',
          llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            '凌晨' === meridiem || '早上' === meridiem || '上午' === meridiem
              ? hour
              : '下午' === meridiem || '晚上' === meridiem
              ? hour + 12
              : hour >= 11
              ? hour
              : hour + 12
          )
        },
        meridiem: function (hour, minute, isLower) {
          var hm = 100 * hour + minute
          return hm < 600
            ? '凌晨'
            : hm < 900
            ? '早上'
            : hm < 1130
            ? '上午'
            : hm < 1230
            ? '中午'
            : hm < 1800
            ? '下午'
            : '晚上'
        },
        calendar: {
          sameDay: '[今天]LT',
          nextDay: '[明天]LT',
          nextWeek: '[下]ddddLT',
          lastDay: '[昨天]LT',
          lastWeek: '[上]ddddLT',
          sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '日'
            case 'M':
              return number + '月'
            case 'w':
            case 'W':
              return number + '周'
            default:
              return number
          }
        },
        relativeTime: {
          future: '%s内',
          past: '%s前',
          s: '几秒',
          ss: '%d 秒',
          m: '1 分钟',
          mm: '%d 分钟',
          h: '1 小时',
          hh: '%d 小时',
          d: '1 天',
          dd: '%d 天',
          M: '1 个月',
          MM: '%d 个月',
          y: '1 年',
          yy: '%d 年',
        },
        week: { dow: 1, doy: 4 },
      }), //! moment.js locale configuration
      hooks.defineLocale('zh-hk', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY年M月D日',
          LLL: 'YYYY年M月D日 HH:mm',
          LLLL: 'YYYY年M月D日dddd HH:mm',
          l: 'YYYY/M/D',
          ll: 'YYYY年M月D日',
          lll: 'YYYY年M月D日 HH:mm',
          llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            '凌晨' === meridiem || '早上' === meridiem || '上午' === meridiem
              ? hour
              : '中午' === meridiem
              ? hour >= 11
                ? hour
                : hour + 12
              : '下午' === meridiem || '晚上' === meridiem
              ? hour + 12
              : void 0
          )
        },
        meridiem: function (hour, minute, isLower) {
          var hm = 100 * hour + minute
          return hm < 600
            ? '凌晨'
            : hm < 900
            ? '早上'
            : hm < 1130
            ? '上午'
            : hm < 1230
            ? '中午'
            : hm < 1800
            ? '下午'
            : '晚上'
        },
        calendar: {
          sameDay: '[今天]LT',
          nextDay: '[明天]LT',
          nextWeek: '[下]ddddLT',
          lastDay: '[昨天]LT',
          lastWeek: '[上]ddddLT',
          sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '日'
            case 'M':
              return number + '月'
            case 'w':
            case 'W':
              return number + '週'
            default:
              return number
          }
        },
        relativeTime: {
          future: '%s內',
          past: '%s前',
          s: '幾秒',
          ss: '%d 秒',
          m: '1 分鐘',
          mm: '%d 分鐘',
          h: '1 小時',
          hh: '%d 小時',
          d: '1 天',
          dd: '%d 天',
          M: '1 個月',
          MM: '%d 個月',
          y: '1 年',
          yy: '%d 年',
        },
      }), //! moment.js locale configuration
      hooks.defineLocale('zh-tw', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY年M月D日',
          LLL: 'YYYY年M月D日 HH:mm',
          LLLL: 'YYYY年M月D日dddd HH:mm',
          l: 'YYYY/M/D',
          ll: 'YYYY年M月D日',
          lll: 'YYYY年M月D日 HH:mm',
          llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
          return (
            12 === hour && (hour = 0),
            '凌晨' === meridiem || '早上' === meridiem || '上午' === meridiem
              ? hour
              : '中午' === meridiem
              ? hour >= 11
                ? hour
                : hour + 12
              : '下午' === meridiem || '晚上' === meridiem
              ? hour + 12
              : void 0
          )
        },
        meridiem: function (hour, minute, isLower) {
          var hm = 100 * hour + minute
          return hm < 600
            ? '凌晨'
            : hm < 900
            ? '早上'
            : hm < 1130
            ? '上午'
            : hm < 1230
            ? '中午'
            : hm < 1800
            ? '下午'
            : '晚上'
        },
        calendar: {
          sameDay: '[今天] LT',
          nextDay: '[明天] LT',
          nextWeek: '[下]dddd LT',
          lastDay: '[昨天] LT',
          lastWeek: '[上]dddd LT',
          sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function (number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '日'
            case 'M':
              return number + '月'
            case 'w':
            case 'W':
              return number + '週'
            default:
              return number
          }
        },
        relativeTime: {
          future: '%s內',
          past: '%s前',
          s: '幾秒',
          ss: '%d 秒',
          m: '1 分鐘',
          mm: '%d 分鐘',
          h: '1 小時',
          hh: '%d 小時',
          d: '1 天',
          dd: '%d 天',
          M: '1 個月',
          MM: '%d 個月',
          y: '1 年',
          yy: '%d 年',
        },
      }),
      hooks.locale('en'),
      hooks
    )
  }),
  (function (window) {
    var resourceTags,
      interfaces,
      roleScopes = { list: 'list', workspace: 'workspace', organization: 'organization', oauthClient: 'oauthClient' },
      permissions = {
        getList: 'getList',
        updateList: 'updateList',
        updateListVisibility: 'updateListVisibility',
        deprecateList: 'deprecateList',
        deleteList: 'deleteList',
        getListAccesses: 'getListAccesses',
        createListAccesses: 'createListAccesses',
        deprecateListAccesses: 'deprecateListAccesses',
        getListActivities: 'getListActivities',
        createListActivities: 'createListActivities',
        updateListActivities: 'updateListActivities',
        deprecateListActivities: 'deprecateListActivities',
        getListEntries: 'getListEntries',
        createListEntries: 'createListEntries',
        updateListEntries: 'updateListEntries',
        deprecateListEntries: 'deprecateListEntries',
        getListElements: 'getListElements',
        getDeprecatedListElements: 'getDeprecatedListElements',
        createListElements: 'createListElements',
        updateListElements: 'updateListElements',
        reorderListElements: 'reorderListElements',
        deprecateListElements: 'deprecateListElements',
        getListFilters: 'getListFilters',
        createListFilters: 'createListFilters',
        updateListFilters: 'updateListFilters',
        deprecateListFilters: 'deprecateListFilters',
        getListFiles: 'getListFiles',
        createListFiles: 'createListFiles',
        updateListFiles: 'updateListFiles',
        deprecateListFiles: 'deprecateListFiles',
        updateCategoriesSortOrder: 'updateCategoriesSortOrder',
        getListViews: 'getListViews',
        createListViews: 'createListViews',
        updateListViews: 'updateListViews',
        reorderListViews: 'reorderListViews',
        deprecateListViews: 'deprecateListViews',
        transferOwnershipOfList: 'transferOwnershipOfList',
        moveListToAnotherWorkspace: 'moveListToAnotherWorkspace',
        assignRolesInList: 'assignRolesInList',
        getWebhooksForList: 'getWebhooksForList',
        createWebhooksForList: 'createWebhooksForList',
        publishList: 'publishList',
        unpublishList: 'unpublishList',
        getWorkspace: 'getWorkspace',
        createListsInWorkspace: 'createListsInWorkspace',
        reorderListsInWorkspace: 'reorderListsInWorkspace',
        updateWorkspace: 'updateWorkspace',
        deprecateWorkspace: 'deprecateWorkspace',
        getWorkspaceAccesses: 'getWorkspaceAccesses',
        getListUsersOfWorkspace: 'getListUsersOfWorkspace',
        createWorkspaceAccesses: 'createWorkspaceAccesses',
        deprecateWorkspaceAccesses: 'deprecateWorkspaceAccesses',
        getWorkspaceActivities: 'getWorkspaceActivities',
        createWorkspaceActivities: 'createWorkspaceActivities',
        updateWorkspaceActivities: 'updateWorkspaceActivities',
        deprecateWorkspaceActivities: 'deprecateWorkspaceActivities',
        transferOwnershipOfWorkspace: 'transferOwnershipOfWorkspace',
        assignRolesInWorkspace: 'assignRolesInWorkspace',
        createWebhookForWorkspace: 'createWebhookForWorkspace',
        getOrganizationAccesses: 'getOrganizationAccesses',
        createOrganizationAccesses: 'createOrganizationAccesses',
        updateOrganizationAccesses: 'updateOrganizationAccesses',
        deprecateOrganizationAccesses: 'deprecateOrganizationAccesses',
        getOrganizationUsers: 'getOrganizationUsers',
        createOrganizationUsers: 'createOrganizationUsers',
        deleteOrganizationUsers: 'deleteOrganizationUsers',
        updateOrganizationUsers: 'updateOrganizationUsers',
        getOrganizationGroups: 'getOrganizationGroups',
        createOrganizationGroups: 'createOrganizationGroups',
        updateOrganizationGroups: 'updateOrganizationGroups',
        deleteOrganizationGroups: 'deleteOrganizationGroups',
        updateOrganizationGroupMemberships: 'updateOrganizationGroupMemberships',
        updateOrganization: 'updateOrganization',
        createOrganizationPlan: 'createOrganizationPlan',
        manageOrganizationPlan: 'manageOrganizationPlan',
        getOrganizationDetails: 'getOrganizationDetails',
        acquireOrganizationUsers: 'acquireOrganizationUsers',
        getOrganizationActivities: 'getOrganizationActivities',
        createChatInOrganization: 'createChatInOrganization',
        createWorkspaceInOrganization: 'createWorkspaceInOrganization',
        removeUsersFromWorkspacesAndListsOfOrganization: 'removeUsersFromWorkspacesAndListsOfOrganization',
        createUserViewInOrganization: 'createUserViewInOrganization',
        deprecateOrganizationResource: 'deprecateOrganizationResource',
        deprecateOrganizationResourceAccess: 'deprecateOrganizationResourceAccess',
        transferOwnershipOfOrganizationResource: 'transferOwnershipOfOrganizationResource',
      },
      readOnlyListUserPermissions = [
        permissions.getList,
        permissions.getListAccesses,
        permissions.getListEntries,
        permissions.getListElements,
        permissions.getListViews,
        permissions.getListActivities,
        permissions.getListFilters,
        permissions.getListFiles,
        permissions.updateListViews,
      ],
      commentOnlyListUserPermissions = readOnlyListUserPermissions.concat([
        permissions.createListActivities,
        permissions.updateListActivities,
        permissions.deprecateListActivities,
      ]),
      listUserPermissions = commentOnlyListUserPermissions.concat([
        permissions.getWebhooksForList,
        permissions.createWebhooksForList,
        permissions.createListEntries,
        permissions.updateListEntries,
        permissions.deprecateListEntries,
        permissions.updateCategoriesSortOrder,
        permissions.createListViews,
        permissions.reorderListViews,
        permissions.deprecateListViews,
        permissions.createListFilters,
        permissions.updateListFilters,
        permissions.deprecateListFilters,
        permissions.createListFiles,
        permissions.updateListFiles,
        permissions.deprecateListFiles,
      ]),
      listAdminPermission = listUserPermissions.concat([
        permissions.updateList,
        permissions.assignRolesInList,
        permissions.publishList,
        permissions.unpublishList,
        permissions.createListAccesses,
        permissions.deprecateListAccesses,
        permissions.getDeprecatedListElements,
        permissions.createListElements,
        permissions.updateListElements,
        permissions.reorderListElements,
        permissions.deprecateListElements,
      ]),
      listOwnerPermissions = listAdminPermission.concat([
        permissions.deprecateList,
        permissions.updateListVisibility,
        permissions.transferOwnershipOfList,
        permissions.moveListToAnotherWorkspace,
        permissions.deleteList,
      ]),
      readOnlyWorkspacePermissions = [
        permissions.getWorkspace,
        permissions.getWorkspaceAccesses,
        permissions.getWorkspaceActivities,
      ],
      readOnlyWorkspaceUserPermissions = readOnlyListUserPermissions.concat(readOnlyWorkspacePermissions),
      commentOnlyWorkspacePermissions = readOnlyWorkspacePermissions.concat([
        permissions.createWorkspaceActivities,
        permissions.updateWorkspaceActivities,
        permissions.deprecateWorkspaceActivities,
      ]),
      commentOnlyWorkspaceUserPermissions = commentOnlyListUserPermissions.concat(commentOnlyWorkspacePermissions),
      additionalPermissionsForWorkspaceUsers = commentOnlyWorkspacePermissions.concat([
        permissions.createWebhookForWorkspace,
      ]),
      workspaceUserPermissions = listUserPermissions.concat(additionalPermissionsForWorkspaceUsers),
      workspaceAdminPermissions = listAdminPermission
        .concat(additionalPermissionsForWorkspaceUsers)
        .concat([
          permissions.createListsInWorkspace,
          permissions.reorderListsInWorkspace,
          permissions.updateWorkspace,
          permissions.createWorkspaceAccesses,
          permissions.deprecateWorkspaceAccesses,
          permissions.assignRolesInWorkspace,
        ]),
      workspaceOwnerPermissions = workspaceAdminPermissions.concat([
        permissions.getListAccessesOfWorkspace,
        permissions.deprecateWorkspace,
        permissions.transferOwnershipOfWorkspace,
      ]),
      organizationEditorPermissions = [permissions.getOrganizationAccesses, permissions.createChatInOrganization],
      organizationUserPermissions = organizationEditorPermissions.concat([
        permissions.createWorkspaceInOrganization,
        permissions.createUserViewInOrganization,
      ]),
      organizationAdminPermissions = organizationUserPermissions.concat([
        permissions.createOrganizationAccesses,
        permissions.updateOrganizationAccesses,
        permissions.deprecateOrganizationAccesses,
        permissions.getOrganizationUsers,
        permissions.createOrganizationUsers,
        permissions.updateOrganizationUsers,
        permissions.deleteOrganizationUsers,
        permissions.getOrganizationGroups,
        permissions.createOrganizationGroups,
        permissions.updateOrganizationGroups,
        permissions.updateOrganizationGroupMemberships,
        permissions.deleteOrganizationGroups,
        permissions.getOrganizationActivities,
        permissions.updateOrganization,
        permissions.getOrganizationDetails,
        permissions.manageOrganizationPlan,
        permissions.acquireOrganizationUsers,
        permissions.removeUsersFromWorkspacesAndListsOfOrganization,
        permissions.deprecateOrganizationResource,
        permissions.deprecateOrganizationResourceAccess,
        permissions.transferOwnershipOfOrganizationResource,
      ]),
      organizationOwnerPermissions = organizationAdminPermissions.concat([permissions.createOrganizationPlan]),
      roles = {
        listOwner: {
          id: 'listOwner',
          scope: roleScopes.list,
          translateId: 'ROLES.LIST_OWNER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.LIST_OWNER',
          permissions: listOwnerPermissions,
          sortOrder: 1,
        },
        listAdmin: {
          id: 'listAdmin',
          scope: roleScopes.list,
          translateId: 'ROLES.LIST_ADMIN',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.LIST_ADMIN',
          permissions: listAdminPermission,
          sortOrder: 2,
        },
        listUser: {
          id: 'listUser',
          scope: roleScopes.list,
          translateId: 'ROLES.LIST_USER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.LIST_USER',
          permissions: listUserPermissions,
          sortOrder: 3,
        },
        commentOnlyListUser: {
          id: 'commentOnlyListUser',
          scope: roleScopes.list,
          translateId: 'ROLES.COMMENT_ONLY_LIST_USER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.COMMENT_ONLY_LIST_USER',
          permissions: commentOnlyListUserPermissions,
          sortOrder: 4,
        },
        readOnlyListUser: {
          id: 'readOnlyListUser',
          scope: roleScopes.list,
          translateId: 'ROLES.READ_ONLY_LIST_USER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.READ_ONLY_LIST_USER',
          permissions: readOnlyListUserPermissions,
          sortOrder: 5,
        },
        workspaceOwner: {
          id: 'workspaceOwner',
          scope: roleScopes.workspace,
          translateId: 'ROLES.WORKSPACE_OWNER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.WORKSPACE_OWNER',
          permissions: workspaceOwnerPermissions,
          sortOrder: 6,
        },
        workspaceAdmin: {
          id: 'workspaceAdmin',
          scope: roleScopes.workspace,
          translateId: 'ROLES.WORKSPACE_ADMIN',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.WORKSPACE_ADMIN',
          permissions: workspaceAdminPermissions,
          sortOrder: 7,
        },
        workspaceUser: {
          id: 'workspaceUser',
          scope: roleScopes.workspace,
          translateId: 'ROLES.WORKSPACE_USER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.WORKSPACE_USER',
          permissions: workspaceUserPermissions,
          sortOrder: 8,
        },
        commentOnlyWorkspaceUser: {
          id: 'commentOnlyWorkspaceUser',
          scope: roleScopes.workspace,
          translateId: 'ROLES.COMMENT_ONLY_WORKSPACE_USER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.COMMENT_ONLY_WORKSPACE_USER',
          permissions: commentOnlyWorkspaceUserPermissions,
          sortOrder: 9,
        },
        readOnlyWorkspaceUser: {
          id: 'readOnlyWorkspaceUser',
          scope: roleScopes.workspace,
          translateId: 'ROLES.READ_ONLY_WORKSPACE_USER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.READ_ONLY_WORKSPACE_USER',
          permissions: readOnlyWorkspaceUserPermissions,
          sortOrder: 10,
        },
        organizationOwner: {
          id: 'organizationOwner',
          scope: roleScopes.organization,
          translateId: 'ROLES.ORGANIZATION_OWNER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.ORGANIZATION_OWNER',
          permissions: organizationOwnerPermissions,
          sortOrder: 11,
        },
        organizationAdmin: {
          id: 'organizationAdmin',
          scope: roleScopes.organization,
          translateId: 'ROLES.ORGANIZATION_ADMIN',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.ORGANIZATION_ADMIN',
          permissions: organizationAdminPermissions,
          sortOrder: 12,
        },
        organizationUser: {
          id: 'organizationUser',
          scope: roleScopes.organization,
          translateId: 'ROLES.ORGANIZATION_USER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.ORGANIZATION_USER',
          permissions: organizationUserPermissions,
          sortOrder: 13,
        },
        organizationEditor: {
          id: 'organizationEditor',
          scope: roleScopes.organization,
          translateId: 'ROLES.ORGANIZATION_EDITOR',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.ORGANIZATION_EDITOR',
          permissions: organizationEditorPermissions,
          sortOrder: 14,
        },
        oauthClientOwner: {
          id: 'oauthClientOwner',
          scope: roleScopes.oauthClient,
          translateId: 'ROLES.OAUTH_CLIENT_OWNER',
          descriptionTranslateId: 'ROLE_DESCRIPTIONS.OAUTH_CLIENT_OWNER',
          permissions: [],
          sortOrder: 15,
        },
      },
      viewTypes = {
        TABLE: 0,
        GRAPH: 1,
        CALENDAR: 2,
        KANBAN: 3,
        BADGE: 4,
        LIST: 5,
        MINDMAP: 6,
        HIERARCHY: 10,
        MINDMAP_V2: 11,
        GANTT: 12,
        WIKI: 13,
        OUTLINE: 18,
        USER_CALENDAR: 7,
        USER_TAGS: 8,
        USER_ASSIGNMENTS: 9,
        USER_AGENDA: 14,
        USER_TODAY: 15,
        USER_ALL: 16,
        USER_DONE: 17,
        USER_KANBAN: 19,
        USER_RESOURCE_PLANNING: 20,
        USER_GROUPED_BAR_CHART: 21,
        USER_GROUPED_PIE_CHART: 22,
      },
      invoicePeriods = {
        MONTHLY: { id: 'monthly', name: 'Monthly', months: 1, hiddenInCheckout: !1 },
        QUARTERLY: { id: 'quarterly', name: 'Quarterly', months: 3, hiddenInCheckout: !0 },
        BIANNUALLY: { id: 'biannually', name: 'Biannually', months: 6, hiddenInCheckout: !0 },
        NINE_MONTHS: { id: 'nine-months', name: 'Every nine months', months: 9, hiddenInCheckout: !0 },
        YEARLY: { id: 'yearly', name: 'Annually', months: 12, hiddenInCheckout: !1 },
        TWO_YEARS: { id: 'two-years', name: 'Every two years', months: 24, hiddenInCheckout: !0 },
        THREE_YEARS: { id: 'three-years', name: 'Every three years', months: 36, hiddenInCheckout: !0 },
      },
      checkoutCurrencies = {
        EUR: { id: 'eur', name: 'Euro', iconClassNames: 'fa fa-euro', symbol: '€' },
        USD: { id: 'usd', name: 'US Dollar', iconClassNames: 'fa fa-dollar', symbol: '$' },
      },
      DEFAULT_MARKETING_PAGE_IDS = {
        home: 39427,
        pricing: 39865,
        features: 48325,
        apps: 17,
        integrations: 18,
        privacyPolicy: 38,
        termsOfService: 40,
        tutorials: 60903,
        bookDemo: 63119,
      },
      apps = {
        base:
          ((resourceTags = {
            workspaces: { workspace: 'workspace' },
            lists: { list: 'list', tasks: 'tasks' },
            listElements: { stage: 'stage' },
            categories: { todo: 'todo', done: 'done' },
            backgrounds: { visible: 'visible', darkDefault: 'dark-default', lightDefault: 'light-default' },
            userViews: { view: 'view' },
          }),
          (interfaces = {
            tasks: {},
            backgrounds: {
              visible: resourceTags.backgrounds.visible,
              darkDefault: resourceTags.backgrounds.darkDefault,
              lightDefault: resourceTags.backgrounds.lightDefault,
            },
            wunderlist: {
              folder: [resourceTags.workspaces.workspace],
              list: [resourceTags.lists.list, resourceTags.lists.tasks],
              stage: [resourceTags.listElements.stage],
              todo: [resourceTags.categories.todo],
              done: [resourceTags.categories.done],
            },
            trello: { board: [resourceTags.lists.list] },
            asana: {
              project: [resourceTags.lists.list, resourceTags.lists.tasks],
              state: [resourceTags.listElements.stage],
              todo: [resourceTags.categories.todo],
              done: [resourceTags.categories.done],
            },
            mstodo: {
              group: [resourceTags.workspaces.workspace],
              folder: [resourceTags.lists.list, resourceTags.lists.tasks],
              stage: [resourceTags.listElements.stage],
              todo: [resourceTags.categories.todo],
              done: [resourceTags.categories.done],
            },
          }),
          (interfaces.tasks[resourceTags.lists.tasks] = {
            listElement: resourceTags.listElements.stage,
            todo: resourceTags.categories.todo,
            done: resourceTags.categories.done,
          }),
          {
            name: 'Zenkit Base',
            shortName: 'Base',
            type: 'base',
            subdomain: 'base',
            iconClassNames: 'zi zi-base',
            resourceTags,
            interfaces,
            plans: {
              FREE: {
                id: 'free',
                name: 'Free',
                nameTranslateId: 'PLANS.FREE.NAME',
                descriptionTranslateId: 'PLANS.FREE.DESCRIPTION',
                colorHex: '#107fdc',
                sortOrder: 1,
                hiddenInCheckout: !0,
                isFreePlan: !0,
                chargebee: [],
              },
              PLUS: {
                id: 'plus',
                name: 'Plus',
                nameTranslateId: 'PLANS.PLUS.NAME',
                descriptionTranslateId: 'PLANS.PLUS.DESCRIPTION',
                colorHex: '#0163b8',
                sortOrder: 2,
                hiddenInCheckout: !1,
                chargebee: [
                  {
                    id: 'plus-monthly-usd',
                    name: 'Base - Plus - Monthly - USD',
                    invoicePeriodId: invoicePeriods.MONTHLY.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 9,
                  },
                  {
                    id: 'plus-quarterly-usd',
                    name: 'Base - Plus - Quarterly - USD',
                    invoicePeriodId: invoicePeriods.QUARTERLY.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 27,
                  },
                  {
                    id: 'plus-nine-months-usd',
                    name: 'Base - Plus - Nine Months - USD',
                    invoicePeriodId: invoicePeriods.NINE_MONTHS.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 81,
                  },
                  {
                    id: 'plus-biannually-usd',
                    name: 'Base - Plus - Biannually - USD',
                    invoicePeriodId: invoicePeriods.BIANNUALLY.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 54,
                  },
                  {
                    id: 'plus-yearly-usd',
                    name: 'Base - Plus - Annually - USD',
                    invoicePeriodId: invoicePeriods.YEARLY.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 96,
                  },
                  {
                    id: 'plus-two-years-usd',
                    name: 'Base - Plus - Two Years - USD',
                    invoicePeriodId: invoicePeriods.TWO_YEARS.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 192,
                  },
                  {
                    id: 'plus-three-years-usd',
                    name: 'Base - Plus - Three Years - USD',
                    invoicePeriodId: invoicePeriods.THREE_YEARS.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 288,
                  },
                  {
                    id: 'plus-monthly-eur',
                    name: 'Base - Plus - Monthly - EUR',
                    invoicePeriodId: invoicePeriods.MONTHLY.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 9,
                  },
                  {
                    id: 'plus-quarterly-eur',
                    name: 'Base - Plus - Quarterly - EUR',
                    invoicePeriodId: invoicePeriods.QUARTERLY.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 27,
                  },
                  {
                    id: 'plus-nine-months-eur',
                    name: 'Base - Plus - Nine Months - EUR',
                    invoicePeriodId: invoicePeriods.NINE_MONTHS.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 81,
                  },
                  {
                    id: 'plus-biannually-eur',
                    name: 'Base - Plus - Biannually - EUR',
                    invoicePeriodId: invoicePeriods.BIANNUALLY.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 54,
                  },
                  {
                    id: 'plus-yearly-eur',
                    name: 'Base - Plus - Annually - EUR',
                    invoicePeriodId: invoicePeriods.YEARLY.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 96,
                  },
                  {
                    id: 'plus-two-years-eur',
                    name: 'Base - Plus - Two Years - EUR',
                    invoicePeriodId: invoicePeriods.TWO_YEARS.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 192,
                  },
                  {
                    id: 'plus-three-years-eur',
                    name: 'Base - Plus - Three Years - EUR',
                    invoicePeriodId: invoicePeriods.THREE_YEARS.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 288,
                  },
                ],
                apple: {
                  production: [
                    { id: 'com.zenkit.base.subscriptions.plus.monthly', invoicePeriodId: invoicePeriods.MONTHLY.id },
                    { id: 'com.zenkit.base.subscriptions.plus.yearly', invoicePeriodId: invoicePeriods.YEARLY.id },
                  ],
                  staging: [
                    {
                      id: 'com.zenkit.staging.base.subscriptions.plus.monthly',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                    },
                    {
                      id: 'com.zenkit.staging.base.subscriptions.plus.yearly',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                    },
                  ],
                },
                google: {
                  production: [
                    { id: 'com.zenkit.base.subscriptions.plus.monthly', invoicePeriodId: invoicePeriods.MONTHLY.id },
                    { id: 'com.zenkit.base.subscriptions.plus.yearly', invoicePeriodId: invoicePeriods.YEARLY.id },
                  ],
                  staging: [
                    {
                      id: 'com.zenkit.staging.base.subscriptions.plus.monthly',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                    },
                    {
                      id: 'com.zenkit.staging.base.subscriptions.plus.yearly',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                    },
                  ],
                },
              },
              BUSINESS: {
                id: 'business',
                name: 'Business',
                nameTranslateId: 'PLANS.BUSINESS.NAME',
                descriptionTranslateId: 'PLANS.BUSINESS.DESCRIPTION',
                colorHex: '#084172',
                sortOrder: 3,
                hiddenInCheckout: !1,
                chargebee: [
                  {
                    id: 'business-monthly-usd',
                    name: 'Base - Business - Monthly - USD',
                    invoicePeriodId: invoicePeriods.MONTHLY.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 25,
                  },
                  {
                    id: 'business-quarterly-usd',
                    name: 'Base - Business - Quarterly - USD',
                    invoicePeriodId: invoicePeriods.QUARTERLY.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 75,
                  },
                  {
                    id: 'business-nine-months-usd',
                    name: 'Base - Business - Nine Months - USD',
                    invoicePeriodId: invoicePeriods.NINE_MONTHS.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 225,
                  },
                  {
                    id: 'business-yearly-usd',
                    name: 'Base - Business - Annually - USD',
                    invoicePeriodId: invoicePeriods.YEARLY.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 252,
                  },
                  {
                    id: 'business-two-years-usd',
                    name: 'Base - Business - Two Years - USD',
                    invoicePeriodId: invoicePeriods.TWO_YEARS.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 504,
                  },
                  {
                    id: 'business-three-years-usd',
                    name: 'Base - Business - Three Years - USD',
                    invoicePeriodId: invoicePeriods.THREE_YEARS.id,
                    currencyId: checkoutCurrencies.USD.id,
                    pricePerUser: 756,
                  },
                  {
                    id: 'business-monthly-eur',
                    name: 'Base - Business - Monthly - EUR',
                    invoicePeriodId: invoicePeriods.MONTHLY.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 25,
                  },
                  {
                    id: 'business-quarterly-eur',
                    name: 'Base - Business - Quarterly - EUR',
                    invoicePeriodId: invoicePeriods.QUARTERLY.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 75,
                  },
                  {
                    id: 'business-nine-months-eur',
                    name: 'Base - Business - Nine Months - EUR',
                    invoicePeriodId: invoicePeriods.NINE_MONTHS.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 225,
                  },
                  {
                    id: 'business-yearly-eur',
                    name: 'Base - Business - Annually - EUR',
                    invoicePeriodId: invoicePeriods.YEARLY.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 252,
                  },
                  {
                    id: 'business-two-years-eur',
                    name: 'Base - Business - Two Years - EUR',
                    invoicePeriodId: invoicePeriods.TWO_YEARS.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 504,
                  },
                  {
                    id: 'business-three-years-eur',
                    name: 'Base - Business - Three Years - EUR',
                    invoicePeriodId: invoicePeriods.THREE_YEARS.id,
                    currencyId: checkoutCurrencies.EUR.id,
                    pricePerUser: 756,
                  },
                ],
              },
              ENTERPRISE: {
                id: 'enterprise',
                name: 'Enterprise',
                nameTranslateId: 'PLANS.ENTERPRISE.NAME',
                descriptionTranslateId: 'PLANS.ENTERPRISE.DESCRIPTION',
                colorHex: '#000',
                sortOrder: 4,
                hiddenInCheckout: !0,
                chargebee: [],
              },
              INTERNAL: {
                id: 'internal',
                name: 'Internal',
                nameTranslateId: 'PLANS.INTERNAL.NAME',
                descriptionTranslateId: 'PLANS.INTERNAL.DESCRIPTION',
                colorHex: '#000',
                sortOrder: 5,
                hiddenInCheckout: !0,
                chargebee: [],
              },
            },
            marketingPageIds: _objectSpread(
              _objectSpread({}, DEFAULT_MARKETING_PAGE_IDS),
              {},
              { home: 41604, pricing: 40866, features: 48325, apps: 17 },
            ),
          }),
        todos: (function () {
          var resourceTags = {
              workspaces: { defaultFolder: 'defaultFolder', folder: 'folder' },
              lists: { inbox: 'inbox', list: 'list' },
              listElements: {
                title: 'title',
                stage: 'stage',
                notes: 'notes',
                dueDate: 'dueDate',
                assignments: 'assignments',
                files: 'files',
                tags: 'tags',
              },
              categories: { todo: 'todo', done: 'done' },
              backgrounds: { visible: 'visible', darkDefault: 'dark-default', lightDefault: 'light-default' },
              userViews: { view: 'view' },
            },
            interfaces = {
              tasks: {},
              iCal: {
                summary: resourceTags.listElements.title,
                date: resourceTags.listElements.dueDate,
                description: resourceTags.listElements.notes,
              },
              emailToList: {
                subject: resourceTags.listElements.title,
                body: resourceTags.listElements.notes,
                assignTo: resourceTags.listElements.assignments,
                attachments: resourceTags.listElements.files,
                sender: null,
                date: null,
              },
              backgrounds: {
                visible: resourceTags.backgrounds.visible,
                darkDefault: resourceTags.backgrounds.darkDefault,
                lightDefault: resourceTags.backgrounds.lightDefault,
              },
              wunderlist: {
                folder: [resourceTags.workspaces.folder],
                defaultFolder: resourceTags.workspaces.defaultFolder,
                list: [resourceTags.lists.list],
                title: [resourceTags.listElements.title],
                notes: [resourceTags.listElements.notes],
                dueDate: [resourceTags.listElements.dueDate],
                assignedTo: [resourceTags.listElements.assignments],
                files: [resourceTags.listElements.files],
                stage: [resourceTags.listElements.stage],
                todo: [resourceTags.categories.todo],
                done: [resourceTags.categories.done],
              },
              asana: {
                project: [resourceTags.lists.list],
                name: [resourceTags.listElements.title],
                notes: [resourceTags.listElements.notes],
                dueDate: [resourceTags.listElements.dueDate],
                assignedTo: [resourceTags.listElements.assignments],
                files: [resourceTags.listElements.files],
                state: [resourceTags.listElements.stage],
                todo: [resourceTags.categories.todo],
                done: [resourceTags.categories.done],
              },
              mstodo: {
                group: [resourceTags.workspaces.folder],
                folder: [resourceTags.lists.list],
                title: [resourceTags.listElements.title],
                notes: [resourceTags.listElements.notes],
                dueDate: [resourceTags.listElements.dueDate],
                assignedTo: [resourceTags.listElements.assignments],
                files: [resourceTags.listElements.files],
                stage: [resourceTags.listElements.stage],
                todo: [resourceTags.categories.todo],
                done: [resourceTags.categories.done],
              },
            }
          return (
            (interfaces.tasks[resourceTags.lists.inbox] = {
              listElement: resourceTags.listElements.stage,
              todo: resourceTags.categories.todo,
              done: resourceTags.categories.done,
            }),
            (interfaces.tasks[resourceTags.lists.list] = {
              listElement: resourceTags.listElements.stage,
              todo: resourceTags.categories.todo,
              done: resourceTags.categories.done,
            }),
            {
              name: 'Zenkit To Do',
              shortName: 'To Do',
              type: 'todos',
              subdomain: 'todo',
              iconClassNames: 'zi zi-to-do2',
              resourceTags,
              interfaces,
              plans: {
                FREE: {
                  id: 'free',
                  name: 'Free',
                  nameTranslateId: 'PLANS.FREE.NAME',
                  descriptionTranslateId: 'PLANS.FREE.DESCRIPTION',
                  colorHex: '#107fdc',
                  sortOrder: 1,
                  hiddenInCheckout: !0,
                  isFreePlan: !0,
                  chargebee: [],
                },
                PLUS: {
                  id: 'plus',
                  name: 'Plus',
                  nameTranslateId: 'PLANS.PLUS.NAME',
                  descriptionTranslateId: 'PLANS.PLUS.DESCRIPTION',
                  colorHex: '#0163b8',
                  sortOrder: 2,
                  hiddenInCheckout: !1,
                  chargebee: [
                    {
                      id: 'todos-plus-monthly-usd',
                      name: 'To Do - Plus - Monthly - USD',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 4,
                    },
                    {
                      id: 'todos-plus-quarterly-usd',
                      name: 'To Do - Plus - Quarterly - USD',
                      invoicePeriodId: invoicePeriods.QUARTERLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 12,
                    },
                    {
                      id: 'todos-plus-biannually-usd',
                      name: 'To Do - Plus - Biannually - USD',
                      invoicePeriodId: invoicePeriods.BIANNUALLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 24,
                    },
                    {
                      id: 'todos-plus-yearly-usd',
                      name: 'To Do - Plus - Annually - USD',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 36,
                    },
                    {
                      id: 'todos-plus-two-years-usd',
                      name: 'To Do - Plus - Two Years - USD',
                      invoicePeriodId: invoicePeriods.TWO_YEARS.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 72,
                    },
                    {
                      id: 'todos-plus-three-years-usd',
                      name: 'To Do - Plus - Three Years - USD',
                      invoicePeriodId: invoicePeriods.THREE_YEARS.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 108,
                    },
                    {
                      id: 'todos-plus-monthly-eur',
                      name: 'To Do - Plus - Monthly - EUR',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 4,
                    },
                    {
                      id: 'todos-plus-quarterly-eur',
                      name: 'To Do - Plus - Quarterly - EUR',
                      invoicePeriodId: invoicePeriods.QUARTERLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 12,
                    },
                    {
                      id: 'todos-plus-biannually-eur',
                      name: 'To Do - Plus - Biannually - EUR',
                      invoicePeriodId: invoicePeriods.BIANNUALLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 24,
                    },
                    {
                      id: 'todos-plus-yearly-eur',
                      name: 'To Do - Plus - Annually - EUR',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 36,
                    },
                    {
                      id: 'todos-plus-two-years-eur',
                      name: 'To Do - Plus - Two Years - EUR',
                      invoicePeriodId: invoicePeriods.TWO_YEARS.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 72,
                    },
                    {
                      id: 'todos-plus-three-years-eur',
                      name: 'To Do - Plus - Three Years - EUR',
                      invoicePeriodId: invoicePeriods.THREE_YEARS.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 108,
                    },
                  ],
                  apple: {
                    production: [
                      { id: 'com.zenkit.todos.subscriptions.plus.monthly', invoicePeriodId: invoicePeriods.MONTHLY.id },
                      { id: 'com.zenkit.todos.subscriptions.plus.yearly', invoicePeriodId: invoicePeriods.YEARLY.id },
                    ],
                    staging: [
                      {
                        id: 'com.zenkit.staging.todos.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.staging.todos.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                  },
                  google: {
                    production: [
                      { id: 'com.zenkit.todos.subscriptions.plus.monthly', invoicePeriodId: invoicePeriods.MONTHLY.id },
                      { id: 'com.zenkit.todos.subscriptions.plus.yearly', invoicePeriodId: invoicePeriods.YEARLY.id },
                    ],
                    staging: [
                      {
                        id: 'com.zenkit.staging.todos.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.staging.todos.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                  },
                },
                BUSINESS: {
                  id: 'business',
                  name: 'Business',
                  nameTranslateId: 'PLANS.BUSINESS.NAME',
                  descriptionTranslateId: 'PLANS.BUSINESS.DESCRIPTION',
                  colorHex: '#084172',
                  sortOrder: 3,
                  hiddenInCheckout: !1,
                  chargebee: [
                    {
                      id: 'todos-business-monthly-usd',
                      name: 'To Do - Business - Monthly - USD',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 19,
                    },
                    {
                      id: 'todos-business-yearly-usd',
                      name: 'To Do - Business - Annually - USD',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 180,
                    },
                    {
                      id: 'todos-business-two-years-usd',
                      name: 'To Do - Business - Two Years - USD',
                      invoicePeriodId: invoicePeriods.TWO_YEARS.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 360,
                    },
                    {
                      id: 'todos-business-three-years-usd',
                      name: 'To Do - Business - Three Years - USD',
                      invoicePeriodId: invoicePeriods.THREE_YEARS.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 540,
                    },
                    {
                      id: 'todos-business-monthly-eur',
                      name: 'To Do - Business - Monthly - EUR',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 19,
                    },
                    {
                      id: 'todos-business-yearly-eur',
                      name: 'To Do - Business - Annually - EUR',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 180,
                    },
                    {
                      id: 'todos-business-two-years-eur',
                      name: 'To Do - Business - Two Years - EUR',
                      invoicePeriodId: invoicePeriods.TWO_YEARS.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 360,
                    },
                    {
                      id: 'todos-business-three-years-eur',
                      name: 'To Do - Business - Three Years - EUR',
                      invoicePeriodId: invoicePeriods.THREE_YEARS.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 540,
                    },
                  ],
                },
                ENTERPRISE: {
                  id: 'enterprise',
                  name: 'Enterprise',
                  nameTranslateId: 'PLANS.ENTERPRISE.NAME',
                  descriptionTranslateId: 'PLANS.ENTERPRISE.DESCRIPTION',
                  colorHex: '#000',
                  sortOrder: 4,
                  hiddenInCheckout: !0,
                  chargebee: [],
                },
                INTERNAL: {
                  id: 'internal',
                  name: 'Internal',
                  nameTranslateId: 'PLANS.INTERNAL.NAME',
                  descriptionTranslateId: 'PLANS.INTERNAL.DESCRIPTION',
                  colorHex: '#000',
                  sortOrder: 5,
                  hiddenInCheckout: !0,
                  chargebee: [],
                },
              },
              marketingPageIds: _objectSpread(
                _objectSpread({}, DEFAULT_MARKETING_PAGE_IDS),
                {},
                { home: 40012, pricing: 39286, features: 39289, apps: 38612 },
              ),
            }
          )
        })(),
        projects: (function () {
          var resourceTags = {
              workspaces: { folder: 'folder' },
              lists: { project: 'project' },
              listElements: {
                title: 'title',
                stage: 'stage',
                notes: 'notes',
                dueDate: 'dueDate',
                assignments: 'assignments',
                files: 'files',
                workload: 'workload',
                tags: 'tags',
                subtasks: 'subtasks',
                dependencies: 'dependencies',
              },
              categories: { todo: 'todo', inProgress: 'inProgress', done: 'done' },
              backgrounds: { visible: 'visible', darkDefault: 'dark-default', lightDefault: 'light-default' },
              userViews: { view: 'view' },
            },
            interfaces = {
              tasks: {},
              iCal: {
                summary: resourceTags.listElements.title,
                date: resourceTags.listElements.dueDate,
                description: resourceTags.listElements.notes,
              },
              emailToList: {
                subject: resourceTags.listElements.title,
                body: resourceTags.listElements.notes,
                assignTo: resourceTags.listElements.assignments,
                attachments: resourceTags.listElements.files,
                sender: null,
                date: null,
              },
              backgrounds: {
                visible: resourceTags.backgrounds.visible,
                darkDefault: resourceTags.backgrounds.darkDefault,
                lightDefault: resourceTags.backgrounds.lightDefault,
              },
              wunderlist: {
                folder: [resourceTags.workspaces.folder],
                defaultFolder: null,
                list: [resourceTags.lists.project],
                title: [resourceTags.listElements.title],
                notes: [resourceTags.listElements.notes],
                dueDate: [resourceTags.listElements.dueDate],
                assignedTo: [resourceTags.listElements.assignments],
                files: [resourceTags.listElements.files],
                stage: [resourceTags.listElements.stage],
                todo: [resourceTags.categories.todo],
                done: [resourceTags.categories.done],
              },
              asana: {
                project: [resourceTags.lists.project],
                name: [resourceTags.listElements.title],
                notes: [resourceTags.listElements.notes],
                dueDate: [resourceTags.listElements.dueDate],
                assignedTo: [resourceTags.listElements.assignments],
                files: [resourceTags.listElements.files],
                state: [resourceTags.listElements.stage],
                todo: [resourceTags.categories.todo],
                done: [resourceTags.categories.done],
              },
              mstodo: {
                group: [resourceTags.workspaces.folder],
                folder: [resourceTags.lists.project],
                title: [resourceTags.listElements.title],
                notes: [resourceTags.listElements.notes],
                dueDate: [resourceTags.listElements.dueDate],
                assignedTo: [resourceTags.listElements.assignments],
                files: [resourceTags.listElements.files],
                stage: [resourceTags.listElements.stage],
                todo: [resourceTags.categories.todo],
                done: [resourceTags.categories.done],
              },
            }
          return (
            (interfaces.tasks[resourceTags.lists.project] = {
              listElement: resourceTags.listElements.stage,
              todo: resourceTags.categories.todo,
              done: resourceTags.categories.done,
            }),
            {
              name: 'Zenkit Projects',
              shortName: 'Projects',
              type: 'projects',
              subdomain: 'projects',
              iconClassNames: 'zi zi-gantt-sf',
              resourceTags,
              interfaces,
              plans: {
                FREE: {
                  id: 'free',
                  name: 'Free',
                  nameTranslateId: 'PLANS.FREE.NAME',
                  descriptionTranslateId: 'PLANS.FREE.DESCRIPTION',
                  colorHex: '#107fdc',
                  sortOrder: 1,
                  hiddenInCheckout: !0,
                  isFreePlan: !0,
                  chargebee: [],
                },
                PLUS: {
                  id: 'plus',
                  name: 'Plus',
                  nameTranslateId: 'PLANS.PLUS.NAME',
                  descriptionTranslateId: 'PLANS.PLUS.DESCRIPTION',
                  colorHex: '#0163b8',
                  sortOrder: 2,
                  hiddenInCheckout: !1,
                  chargebee: [
                    {
                      id: 'projects-plus-monthly-eur',
                      name: 'Projects - Plus - Monthly - EUR',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 9,
                    },
                    {
                      id: 'projects-plus-monthly-usd',
                      name: 'Projects - Plus - Monthly - USD',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 9,
                    },
                    {
                      id: 'projects-plus-yearly-eur',
                      name: 'Projects - Plus - Yearly - EUR',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 96,
                    },
                    {
                      id: 'projects-plus-yearly-usd',
                      name: 'Projects - Plus - Yearly - USD',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 96,
                    },
                  ],
                  apple: {
                    production: [
                      {
                        id: 'com.zenkit.projects.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.projects.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                    staging: [
                      {
                        id: 'com.zenkit.staging.projects.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.staging.projects.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                  },
                  google: {
                    production: [
                      {
                        id: 'com.zenkit.projects.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.projects.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                    staging: [
                      {
                        id: 'com.zenkit.staging.projects.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.staging.projects.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                  },
                },
                BUSINESS: {
                  id: 'business',
                  name: 'Business',
                  nameTranslateId: 'PLANS.BUSINESS.NAME',
                  descriptionTranslateId: 'PLANS.BUSINESS.DESCRIPTION',
                  colorHex: '#084172',
                  sortOrder: 3,
                  hiddenInCheckout: !1,
                  chargebee: [
                    {
                      id: 'projects-business-monthly-eur',
                      name: 'Projects - Business - Monthly - EUR',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 25,
                    },
                    {
                      id: 'projects-business-monthly-usd',
                      name: 'Projects - Business - Monthly - USD',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 25,
                    },
                    {
                      id: 'projects-business-yearly-eur',
                      name: 'Projects - Business - Yearly - EUR',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 252,
                    },
                    {
                      id: 'projects-business-yearly-usd',
                      name: 'Projects - Business - Yearly - USD',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 252,
                    },
                  ],
                },
                ENTERPRISE: {
                  id: 'enterprise',
                  name: 'Enterprise',
                  nameTranslateId: 'PLANS.ENTERPRISE.NAME',
                  descriptionTranslateId: 'PLANS.ENTERPRISE.DESCRIPTION',
                  colorHex: '#000',
                  sortOrder: 4,
                  hiddenInCheckout: !0,
                  chargebee: [],
                },
                INTERNAL: {
                  id: 'internal',
                  name: 'Internal',
                  nameTranslateId: 'PLANS.INTERNAL.NAME',
                  descriptionTranslateId: 'PLANS.INTERNAL.DESCRIPTION',
                  colorHex: '#000',
                  sortOrder: 5,
                  hiddenInCheckout: !0,
                  chargebee: [],
                },
              },
              marketingPageIds: _objectSpread(
                _objectSpread({}, DEFAULT_MARKETING_PAGE_IDS),
                {},
                { home: 38862, pricing: 62407, features: 53121, apps: 62403 },
              ),
            }
          )
        })(),
        chat: (function () {
          var resourceTags = {
              backgrounds: { visible: 'visible', darkDefault: 'dark-default', lightDefault: 'light-default' },
              workspaces: {
                privateChat: 'privateChat',
                organizationGroupChat: 'organizationGroupChat',
                groupChat: 'groupChat',
              },
              lists: { chat: 'chat', tasks: 'tasks', list: 'list' },
              listElements: {
                title: 'title',
                stage: 'stage',
                notes: 'notes',
                dueDate: 'dueDate',
                assignments: 'assignments',
                files: 'files',
              },
              categories: { todo: 'todo', done: 'done' },
            },
            interfaces = {
              tasks: {},
              backgrounds: {
                visible: resourceTags.backgrounds.visible,
                darkDefault: resourceTags.backgrounds.darkDefault,
                lightDefault: resourceTags.backgrounds.lightDefault,
              },
            }
          return (
            (interfaces.tasks[resourceTags.lists.tasks] = {
              listElement: resourceTags.listElements.stage,
              todo: resourceTags.categories.todo,
              done: resourceTags.categories.done,
            }),
            {
              name: 'Zenchat',
              type: 'chat',
              subdomain: 'chat',
              iconClassNames: 'zi zi-zenchat',
              resourceTags,
              interfaces,
              plans: {
                FREE: {
                  id: 'free',
                  name: 'Free',
                  nameTranslateId: 'PLANS.FREE.NAME',
                  descriptionTranslateId: 'PLANS.FREE.DESCRIPTION',
                  colorHex: '#107fdc',
                  sortOrder: 1,
                  hiddenInCheckout: !0,
                  isFreePlan: !0,
                  chargebee: [],
                },
                PLUS: {
                  id: 'plus',
                  name: 'Plus',
                  nameTranslateId: 'PLANS.PLUS.NAME',
                  descriptionTranslateId: 'PLANS.PLUS.DESCRIPTION',
                  colorHex: '#0163b8',
                  sortOrder: 2,
                  hiddenInCheckout: !1,
                  chargebee: [
                    {
                      id: 'chat-plus-monthly-usd',
                      name: 'Zenchat - Plus - Monthly - USD',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 5,
                    },
                    {
                      id: 'chat-plus-biannually-usd',
                      name: 'Zenchat - Plus - Biannually - USD',
                      invoicePeriodId: invoicePeriods.BIANNUALLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 30,
                    },
                    {
                      id: 'chat-plus-yearly-usd',
                      name: 'Zenchat - Plus - Annually - USD',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 48,
                    },
                    {
                      id: 'chat-plus-monthly-eur',
                      name: 'Zenchat - Plus - Monthly - EUR',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 5,
                    },
                    {
                      id: 'chat-plus-biannually-eur',
                      name: 'Zenchat - Plus - Biannually - EUR',
                      invoicePeriodId: invoicePeriods.BIANNUALLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 30,
                    },
                    {
                      id: 'chat-plus-yearly-eur',
                      name: 'Zenchat - Plus - Annually - EUR',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 48,
                    },
                  ],
                  apple: {
                    production: [
                      { id: 'com.zenkit.chat.subscriptions.plus.monthly', invoicePeriodId: invoicePeriods.MONTHLY.id },
                      { id: 'com.zenkit.chat.subscriptions.plus.yearly', invoicePeriodId: invoicePeriods.YEARLY.id },
                    ],
                    staging: [
                      {
                        id: 'com.zenkit.staging.chat.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.staging.chat.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                  },
                  google: {
                    production: [
                      { id: 'com.zenkit.chat.subscriptions.plus.monthly', invoicePeriodId: invoicePeriods.MONTHLY.id },
                      { id: 'com.zenkit.chat.subscriptions.plus.yearly', invoicePeriodId: invoicePeriods.YEARLY.id },
                    ],
                    staging: [
                      {
                        id: 'com.zenkit.staging.chat.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.staging.chat.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                  },
                },
                BUSINESS: {
                  id: 'business',
                  name: 'Business',
                  nameTranslateId: 'PLANS.BUSINESS.NAME',
                  descriptionTranslateId: 'PLANS.BUSINESS.DESCRIPTION',
                  colorHex: '#084172',
                  sortOrder: 3,
                  hiddenInCheckout: !1,
                  chargebee: [
                    {
                      id: 'chat-business-monthly-usd',
                      name: 'Zenchat - Business - Monthly - USD',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 19,
                    },
                    {
                      id: 'chat-business-yearly-usd',
                      name: 'Zenchat - Business - Annually - USD',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 180,
                    },
                    {
                      id: 'chat-business-monthly-eur',
                      name: 'Zenchat - Business - Monthly - EUR',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 19,
                    },
                    {
                      id: 'chat-business-yearly-eur',
                      name: 'Zenchat - Business - Annually - EUR',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 180,
                    },
                  ],
                },
                ENTERPRISE: {
                  id: 'enterprise',
                  name: 'Enterprise',
                  nameTranslateId: 'PLANS.ENTERPRISE.NAME',
                  descriptionTranslateId: 'PLANS.ENTERPRISE.DESCRIPTION',
                  colorHex: '#000',
                  sortOrder: 4,
                  hiddenInCheckout: !0,
                  chargebee: [],
                },
                INTERNAL: {
                  id: 'internal',
                  name: 'Internal',
                  nameTranslateId: 'PLANS.INTERNAL.NAME',
                  descriptionTranslateId: 'PLANS.INTERNAL.DESCRIPTION',
                  colorHex: '#000',
                  sortOrder: 5,
                  hiddenInCheckout: !0,
                  chargebee: [],
                },
              },
              marketingPageIds: _objectSpread(
                _objectSpread({}, DEFAULT_MARKETING_PAGE_IDS),
                {},
                { home: 45439, pricing: 48284, features: 40864, apps: 52888 },
              ),
            }
          )
        })(),
        hypernotes: (function () {
          var resourceTags = {
              workspaces: { notebook: 'notebook' },
              lists: { notes: 'notes', tasks: 'tasks' },
              listElements: {
                title: 'title',
                files: 'files',
                description: 'description',
                subpages: 'subpages',
                mentions: 'mentions',
                mentionsMirror: 'mentionsMirror',
                attachedTasks: 'attachedTasks',
                diaryDate: 'diaryDate',
                stage: 'stage',
                dueDate: 'dueDate',
                assignments: 'assignments',
                notes: 'notes',
                attachedTasksMirror: 'attachedTasksMirror',
              },
              backgrounds: { visible: 'visible', darkDefault: 'dark-default', lightDefault: 'light-default' },
              categories: { todo: 'todo', done: 'done' },
            },
            interfaces = {
              backgrounds: {
                visible: resourceTags.backgrounds.visible,
                darkDefault: resourceTags.backgrounds.darkDefault,
                lightDefault: resourceTags.backgrounds.lightDefault,
              },
              tasks: {},
            }
          return (
            (interfaces.tasks[resourceTags.lists.tasks] = {
              listElement: resourceTags.listElements.stage,
              todo: resourceTags.categories.todo,
              done: resourceTags.categories.done,
            }),
            {
              name: 'Hypernotes',
              type: 'hypernotes',
              subdomain: 'hypernotes',
              iconClassNames: 'zi zi-hypernotes',
              plans: {
                FREE: {
                  id: 'free',
                  name: 'Free',
                  nameTranslateId: 'PLANS.FREE.NAME',
                  descriptionTranslateId: 'PLANS.FREE.DESCRIPTION',
                  colorHex: '#107fdc',
                  sortOrder: 1,
                  hiddenInCheckout: !0,
                  isFreePlan: !0,
                  chargebee: [],
                },
                PLUS: {
                  id: 'plus',
                  name: 'Plus',
                  nameTranslateId: 'PLANS.PLUS.NAME',
                  descriptionTranslateId: 'PLANS.PLUS.DESCRIPTION',
                  colorHex: '#0163b8',
                  sortOrder: 2,
                  hiddenInCheckout: !1,
                  chargebee: [
                    {
                      id: 'hypernotes-plus-monthly-usd',
                      name: 'Hypernotes - Plus - Monthly - USD',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 8,
                    },
                    {
                      id: 'hypernotes-plus-yearly-usd',
                      name: 'Hypernotes - Plus - Annually - USD',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 60,
                    },
                    {
                      id: 'hypernotes-plus-monthly-eur',
                      name: 'Hypernotes - Plus - Monthly - EUR',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 8,
                    },
                    {
                      id: 'hypernotes-plus-yearly-eur',
                      name: 'Hypernotes - Plus - Annually - EUR',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 60,
                    },
                  ],
                  apple: {
                    production: [
                      {
                        id: 'com.zenkit.hypernotes.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.hypernotes.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                    staging: [
                      {
                        id: 'com.zenkit.staging.hypernotes.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.staging.hypernotes.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                  },
                  google: {
                    production: [
                      {
                        id: 'com.zenkit.hypernotes.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.hypernotes.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                    staging: [
                      {
                        id: 'com.zenkit.staging.hypernotes.subscriptions.plus.monthly',
                        invoicePeriodId: invoicePeriods.MONTHLY.id,
                      },
                      {
                        id: 'com.zenkit.staging.hypernotes.subscriptions.plus.yearly',
                        invoicePeriodId: invoicePeriods.YEARLY.id,
                      },
                    ],
                  },
                },
                BUSINESS: {
                  id: 'business',
                  name: 'Business',
                  nameTranslateId: 'PLANS.BUSINESS.NAME',
                  descriptionTranslateId: 'PLANS.BUSINESS.DESCRIPTION',
                  colorHex: '#084172',
                  sortOrder: 3,
                  hiddenInCheckout: !1,
                  chargebee: [
                    {
                      id: 'hypernotes-business-monthly-usd',
                      name: 'Hypernotes - Business - Monthly - USD',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 19,
                    },
                    {
                      id: 'hypernotes-business-yearly-usd',
                      name: 'Hypernotes - Business - Annually - USD',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.USD.id,
                      pricePerUser: 180,
                    },
                    {
                      id: 'hypernotes-business-monthly-eur',
                      name: 'Hypernotes - Business - Monthly - EUR',
                      invoicePeriodId: invoicePeriods.MONTHLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 19,
                    },
                    {
                      id: 'hypernotes-business-yearly-eur',
                      name: 'Hypernotes - Business - Annually - EUR',
                      invoicePeriodId: invoicePeriods.YEARLY.id,
                      currencyId: checkoutCurrencies.EUR.id,
                      pricePerUser: 180,
                    },
                  ],
                },
                ENTERPRISE: {
                  id: 'enterprise',
                  name: 'Enterprise',
                  nameTranslateId: 'PLANS.ENTERPRISE.NAME',
                  descriptionTranslateId: 'PLANS.ENTERPRISE.DESCRIPTION',
                  colorHex: '#000',
                  sortOrder: 4,
                  hiddenInCheckout: !0,
                  chargebee: [],
                },
                INTERNAL: {
                  id: 'internal',
                  name: 'Internal',
                  nameTranslateId: 'PLANS.INTERNAL.NAME',
                  descriptionTranslateId: 'PLANS.INTERNAL.DESCRIPTION',
                  colorHex: '#000',
                  sortOrder: 5,
                  hiddenInCheckout: !0,
                  chargebee: [],
                },
              },
              resourceTags,
              interfaces,
              marketingPageIds: _objectSpread(
                _objectSpread({}, DEFAULT_MARKETING_PAGE_IDS),
                {},
                { home: 48855, pricing: 48862, features: 48860, apps: 56946 },
              ),
            }
          )
        })(),
      },
      ZenkitControlsShared = {
        apps,
        defaultApp: apps.base,
        publicSubdomain: 'public',
        roles,
        roleScopes,
        permissions,
        dateElementBusinessDataNow: 'now',
        baseLengthOfHierarchyValue: 8,
        dateFormats: { MDY_SLASH: 'MM/DD/YYYY', DMY_DOT: 'DD.MM.YYYY', DMY_SLASH: 'DD/MM/YYYY', ISO: 'YYYY-MM-DD' },
        timeFormats: { CLOCK_12: 'h:mm A', CLOCK_24: 'HH:mm' },
        filterTermModi: {
          EMPTY: 'isEmpty',
          NOT_EMPTY: 'isNotEmpty',
          CONTAINS: 'contains',
          NOT_CONTAINS: 'notContains',
          EQUALS: 'equals',
          NOT_EQUALS: 'notEquals',
          STARTS_WITH: 'startsWith',
          NOT_STARTS_WITH: 'notStartsWith',
          ENDS_WITH: 'endsWith',
          NOT_ENDS_WITH: 'notEndsWith',
          IN_RANGE: 'inRange',
          NOT_IN_RANGE: 'notInRange',
          GREATER_OR_EQUAL: 'greaterOrEqual',
          LESS_OR_EQUAL: 'lessOrEqual',
        },
        allElementsFilterId: 'ALL_ELEMENTS',
        filterOperators: {
          AND: { serverName: 'AND', translateId: 'FILTERS.OPERATORS.AND' },
          OR: { serverName: 'OR', translateId: 'FILTERS.OPERATORS.OR' },
        },
        activityTypes: {
          CREATED_IN: { WORKSPACE: 0, LIST: 1, LIST_ENTRY: 2, LIST_ELEMENT: 3, ORGANIZATION: 4 },
          TYPE: {
            COMMENT: 0,
            CREATED_AT: 1,
            UPDATED_AT: 2,
            DEPRECATED_AT: 3,
            IMPORTED_AT: 4,
            COPIED_AT: 5,
            RESTORED_AT: 6,
            BULK_COUNT: 7,
            DELETED_AT: 8,
            CREATED_ORGANIZATION_USER: 9,
            CREATED_ORGANIZATION_GROUP: 10,
            ADDED_USER_TO_GROUP: 11,
            ADDED_SUBGROUP_TO_GROUP: 12,
            DEPRECATED_ORGANIZATION_USER: 13,
            DEPRECATED_ORGANIZATION_GROUP: 14,
            REMOVED_USER_FROM_GROUP: 15,
            REMOVED_SUBGROUP_FROM_GROUP: 16,
            ALL_DEPENDENCIES_ARE_DONE: 17,
            PUBLISHED_LIST: 18,
            UNPUBLISHED_LIST: 19,
            REACTION: 20,
            ADDED_USER_TO_WORKSPACE: 21,
            ADDED_GROUP_TO_WORKSPACE: 22,
            ADDED_USER_TO_LIST: 23,
            ADDED_GROUP_TO_LIST: 24,
            REMOVED_USER_FROM_WORKSPACE: 25,
            REMOVED_GROUP_FROM_WORKSPACE: 26,
            REMOVED_USER_FROM_LIST: 27,
            REMOVED_GROUP_FROM_LIST: 28,
            ADDED_CHECKLIST: 29,
            CHANGED_CHECKLIST_NAME: 30,
            REMOVED_CHECKLIST: 31,
            ADDED_CHECKLIST_ITEM: 32,
            CHANGED_CHECKLIST_ITEM_TEXT: 33,
            CHECKED_CHECKLIST_ITEM: 34,
            UNCHECKED_CHECKLIST_ITEM: 35,
            REMOVED_CHECKLIST_ITEM: 36,
            ADDED_USER_TO_ORGANIZATION: 37,
            REMOVED_USER_FROM_ORGANIZATION: 38,
            DELETED_ENTRIES: 39,
          },
          FILTER: { NONE: 0, SYSTEM_MESSAGES: 1, COMMENTS: 2, DELETED_AT: 3 },
          BULK_ACTIONS: { ADD: 0, SET: 1, REMOVE: 2, REPLACE: 3 },
        },
        activityModes: { USER: 'USER', WORKSPACE: 'WORKSPACE', LIST: 'LIST', LIST_ENTRY: 'LIST_ENTRY' },
        enrichmentTypes: { LIST_ENTRY: 'ListEntry', FILE: 'File', LINK: 'Link' },
        resourceTypes: {
          LIST: 'List',
          WORKSPACE: 'Workspace',
          LIST_ELEMENT: 'ListElement',
          CATEGORY: 'Category',
          BACKGROUND: 'Background',
          USER_VIEW: 'UserView',
        },
        accessTypes: {
          LIST: 'List',
          WORKSPACE: 'Workspace',
          ORGANIZATION: 'Organization',
          OAUTH_CLIENT: 'OAuthClient',
        },
        updateActionTypes: { REPLACE: 'replace', APPEND: 'append', REMOVE: 'remove' },
        triggerTypes: {
          NEW_ENTRIES: 0,
          NEW_ACTIVITIES: 1,
          NEW_NOTIFICATIONS: 2,
          NEW_ACTIVITIES_WITH_FILTER_SYSTEM_MESSAGES: 3,
          NEW_ACTIVITIES_WITH_FILTER_COMMENTS: 4,
          ENTRIES_CHANGED_FOR_ELEMENT: 5,
        },
        broadcastTypes: { TYPING_COMMENT: 'TYPING_COMMENT', RECORDING_AUDIO: 'RECORDING_AUDIO' },
        dependencyTypes: {
          sf: {
            type: 'sf',
            iconClassNames: 'zi zi-gantt-sf',
            titleTranslateId: 'DEPENDENCIES.FINISH_TO_START',
            explanationTranslateId: 'DEPENDENCIES.START_TO_FINISH_EXPLANATION',
          },
          ss: {
            type: 'ss',
            iconClassNames: 'zi zi-gantt-ss',
            titleTranslateId: 'DEPENDENCIES.START_TO_START',
            explanationTranslateId: 'DEPENDENCIES.START_TO_START_EXPLANATION',
          },
          fs: {
            type: 'fs',
            iconClassNames: 'zi zi-gantt-fs',
            titleTranslateId: 'DEPENDENCIES.START_TO_FINISH',
            explanationTranslateId: 'DEPENDENCIES.FINISH_TO_START_EXPLANATION',
          },
          ff: {
            type: 'ff',
            iconClassNames: 'zi zi-gantt-ff',
            titleTranslateId: 'DEPENDENCIES.FINISH_TO_FINISH',
            explanationTranslateId: 'DEPENDENCIES.FINISH_TO_FINISH_EXPLANATION',
          },
        },
        availableMigrations: {
          Textfield: ['Textfield', 'Number', 'Date', 'Link', 'Checkbox', 'Categories', 'References'],
          Number: ['Textfield', 'Number', 'Date', 'Checkbox', 'Categories'],
          Date: ['Textfield', 'Number', 'Date'],
          Link: ['Textfield', 'Link', 'Categories'],
          Checkbox: ['Textfield', 'Number', 'Checkbox', 'Categories'],
          Categories: ['Textfield', 'Checkbox', 'Categories', 'References'],
          Formula: ['Textfield', 'Number', 'Formula'],
          Persons: ['Textfield', 'Categories', 'Persons', 'References'],
          Files: ['Textfield', 'Files'],
          References: ['Textfield', 'References'],
          Hierarchy: ['Hierarchy'],
        },
        backgroundTypes: {
          ADMIN_COLOR: 0,
          ADMIN_IMAGE: 1,
          ADMIN_TEXTURE: 2,
          USER_IMAGE: 3,
          WORKSPACE_IMAGE: 4,
          LIST_IMAGE: 5,
          ADMIN_THEMES: 6,
        },
        backgroundRoles: { USERDEFAULT: 0 },
        backgroundStyles: { COVER: 0, TILE: 1 },
        backgroundThemes: {
          DARK: 0,
          LIGHT: 1,
          TRON: 2,
          DARK_TRANSPARENT: 3,
          LIGHT_TRANSPARENT: 4,
          MATRIX: 5,
          IRON_MAN: 6,
        },
        startOfTheWeekValues: { MONDAY: 'Mon', SUNDAY: 'Sun' },
        listVisibilityTypes: { LIST_MEMBERS: 0, LIST_AND_WORKSPACE_MEMBERS: 1 },
        thirdPartyFileProviders: {
          LINK: 'Link',
          BOX: 'Box',
          DROPBOX: 'Dropbox',
          GOOGLE_DRIVE: 'Google Drive',
          ONE_DRIVE: 'OneDrive',
        },
        webhookProviders: {
          zapier: { id: 'zapier', name: 'Zapier', iconClassNames: 'zi zi-zapier' },
          msteams: { id: 'msteams', name: 'Microsoft Teams', iconClassNames: 'zi zi-msteams' },
        },
        originProviders: { scim: { id: 'scim', name: 'SCIM' }, saml: { id: 'saml', name: 'SAML' } },
        textTypes: { PLAIN: 'plain', HTML: 'html', MARKDOWN: 'markdown' },
        reasonsToCloseDialog: {
          submitButtonClicked: 'submit button clicked',
          submitShortcut: 'submit shortcut',
          cancelButtonClicked: 'cancel button clicked',
          backButtonClicked: 'back button clicked',
          clickOutside: 'click outside',
          escKeyPress: 'escape key press',
          stateChange: 'state change',
          toggleButtonClicked: 'toggle button clicked',
          toggleButtonDestroyed: 'toggle button destroyed',
          replacedDetailsDialogs: 'replaced details dialogs',
          scrollPositionChanged: 'scroll position changed',
          wizardHasBeenSubmitted: 'wizard has been submitted',
          inlineContainerDestroyed: 'inline container destroyed',
        },
        dateTimeFilterModi: {
          EVERYTIME: 0,
          THIS_YEAR: 1,
          THIS_MONTH: 2,
          THIS_WEEK: 3,
          YESTERDAY: 4,
          TODAY: 5,
          TOMORROW: 6,
          NEXT_WEEK: 7,
          NEXT_MONTH: 8,
          NEXT_YEAR: 9,
          CUSTOM: 10,
          LAST_WEEK: 11,
          LAST_MONTH: 12,
          LAST_YEAR: 13,
          EMPTY: 14,
          FILLED: 15,
          OVERDUE: 16,
        },
        internalDateFormat: 'YYYY-MM-DD',
        graphIntervals: { DAYS: 0, WEEKS: 1, MONTHS: 2, YEARS: 3 },
        aggegrateModi: { SUM: 0, AVG: 1, MIN: 2, MAX: 3 },
        tableViewNumberAggregations: {
          SUM: { id: 'sum', sortOrder: 1, iconClass: 'zi zi-sum fa-fw', translateId: 'AGGREGATION_MODI.SUM' },
          MIN: { id: 'min', sortOrder: 2, iconClass: 'zi zi-min fa-fw', translateId: 'AGGREGATION_MODI.MIN' },
          MAX: { id: 'max', sortOrder: 3, iconClass: 'zi zi-max fa-fw', translateId: 'AGGREGATION_MODI.MAX' },
          AVG: { id: 'avg', sortOrder: 4, iconClass: 'zi zi-average fa-fw', translateId: 'AGGREGATION_MODI.AVG' },
        },
        tableViewAggregations: {
          NOT_EMPTY: { id: 'not_empty', sortOrder: 1, iconClass: '', translateId: 'AGGREGATION_MODI.NOT_EMPTY' },
          EMPTY: { id: 'empty', sortOrder: 2, iconClass: '', translateId: 'AGGREGATION_MODI.EMPTY' },
        },
        notificationTriggers: {
          GENERAL: { id: 'general', name: 'General', translateID: 'NOTIFICATIONS.SETTINGS.TRIGGERS.GENERAL' },
          ACTIVITIES: {
            id: 'activities',
            name: 'Activities',
            translateID: 'NOTIFICATIONS.SETTINGS.TRIGGERS.ACTIVITIES',
          },
          COMMENTS: { id: 'comments', name: 'Comments', translateID: 'NOTIFICATIONS.SETTINGS.TRIGGERS.COMMENTS' },
          REMINDERS: { id: 'reminders', name: 'Reminders', translateID: 'NOTIFICATIONS.SETTINGS.TRIGGERS.REMINDERS' },
          MENTIONS: { id: 'mentions', name: '@Mentions', translateID: 'NOTIFICATIONS.SETTINGS.TRIGGERS.MENTIONS' },
        },
        notificationUiTypes: {
          EMAIL: {
            id: 'email',
            name: 'Email',
            translateID: 'NOTIFICATIONS.SETTINGS.TYPES.EMAIL',
            iconClassNames: 'zi zi-mail',
          },
          TOAST: {
            id: 'toast',
            name: 'Toast',
            translateID: 'NOTIFICATIONS.SETTINGS.TYPES.TOAST',
            iconClassNames: 'zi zi-dummy-template2',
          },
          NOTIFICATION: {
            id: 'notification',
            name: 'Notification',
            translateID: 'NOTIFICATIONS.SETTINGS.TYPES.NOTIFICATION',
            iconClassNames: 'zi zi-notifications-o',
          },
          DESKTOP_NOTIFICATION: {
            id: 'desktopNotification',
            name: 'Desktop',
            translateID: 'NOTIFICATIONS.SETTINGS.TYPES.DESKTOP_NOTIFICATION',
            iconClassNames: 'fa fa-desktop',
          },
          PUSH_NOTIFICATION: {
            id: 'pushNotification',
            name: 'Mobile',
            translateID: 'NOTIFICATIONS.SETTINGS.TYPES.PUSH_NOTIFICATION',
            iconClassNames: 'fa fa-mobile',
          },
        },
        notificationTypes: {
          PERSON_ADDED: 'personAdded',
          LIST_SHARE: 'listShare',
          WORKSPACE_SHARE: 'workspaceShare',
          SUBSCRIPTION: 'subscription',
          REMINDER: 'reminder',
          MENTION: 'mention',
          PRIVATE_CHAT: 'privateChat',
          GROUP_CHAT: 'groupChat',
        },
        minimalNewNotificationColumns: [
          'id',
          'shortId',
          'uuid',
          'listId',
          'workspaceId',
          'listEntryId',
          'elementId',
          'activityId',
          'isMuted',
          'updated_at',
          'activityType',
        ],
        recurrence: {
          types: { auto: 'auto', task: 'task' },
          states: { taskDone: 'taskDone' },
          frequencies: {
            daily: { frequency: 'daily', unit: 'day' },
            weekly: { frequency: 'weekly', unit: 'week' },
            monthly: { frequency: 'monthly', unit: 'month' },
            yearly: { frequency: 'yearly', unit: 'year' },
          },
          weekdays: { MO: 'MO', TU: 'TU', WE: 'WE', TH: 'TH', FR: 'FR', SA: 'SA', SU: 'SU' },
        },
        categoryColors: [
          { colorHex: '#43bfff' },
          { colorHex: '#0089d1', taskAddonTodoColor: !0 },
          { colorHex: '#007aff' },
          { colorHex: '#00336d' },
          { colorHex: '#4c064a' },
          { colorHex: '#a70fa3' },
          { colorHex: '#92278f', taskAddonInProgressColor: !0 },
          { colorHex: '#ed008a' },
          { colorHex: '#ff6ebf' },
          { colorHex: '#ffb2ee' },
          { colorHex: '#6e40e2' },
          { colorHex: '#0652a7' },
          { colorHex: '#00404e' },
          { colorHex: '#005b61' },
          { colorHex: '#439ba1' },
          { colorHex: '#34c77c' },
          { colorHex: '#80e079' },
          { colorHex: '#036e14' },
          { colorHex: '#3ba744', taskAddonDoneColor: !0 },
          { colorHex: '#58bb89' },
          { colorHex: '#a7d43d' },
          { colorHex: '#ffc600' },
          { colorHex: '#ffb900' },
          { colorHex: '#fb7125' },
          { colorHex: '#fa8b1d' },
          { colorHex: '#fcb183' },
          { colorHex: '#ff92a0' },
          { colorHex: '#ff2540' },
          { colorHex: '#f33149' },
          { colorHex: '#9d0013' },
          { colorHex: '#d8c48d' },
          { colorHex: '#7f7f7f' },
          { colorHex: '#181716', showOnlyInExtendedPicker: !0 },
          { colorHex: '#ffffff', showOnlyInExtendedPicker: !0 },
          { colorHex: '#000000', showOnlyInExtendedPicker: !0 },
        ],
        viewTypes,
        mobileViewTypes: viewTypes,
        listViewModi: {
          TABLE: viewTypes.TABLE,
          CALENDAR: viewTypes.CALENDAR,
          KANBAN: viewTypes.KANBAN,
          LIST: viewTypes.LIST,
          MINDMAP: viewTypes.MINDMAP,
          HIERARCHY: viewTypes.HIERARCHY,
          MINDMAP_V2: viewTypes.MINDMAP_V2,
          GANTT: viewTypes.GANTT,
          WIKI: viewTypes.WIKI,
          OUTLINE: viewTypes.OUTLINE,
        },
        userViewModi: {
          USER_CALENDAR: viewTypes.USER_CALENDAR,
          USER_TAGS: viewTypes.USER_TAGS,
          USER_ASSIGNMENTS: viewTypes.USER_ASSIGNMENTS,
          USER_TODAY: viewTypes.USER_TODAY,
          USER_AGENDA: viewTypes.USER_AGENDA,
          USER_DONE: viewTypes.USER_DONE,
          USER_ALL: viewTypes.USER_ALL,
          USER_KANBAN: viewTypes.USER_KANBAN,
          USER_RESOURCE_PLANNING: viewTypes.USER_RESOURCE_PLANNING,
          USER_GROUPED_BAR_CHART: viewTypes.USER_GROUPED_BAR_CHART,
          USER_GROUPED_PIE_CHART: viewTypes.USER_GROUPED_PIE_CHART,
        },
        detailsViewModi: { POPUP: 0, SIDE_PANEL: 1 },
        currencies: [
          {
            symbol: '$',
            name: 'US Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'USD',
            name_plural: 'US dollars',
          },
          {
            symbol: 'CA$',
            name: 'Canadian Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'CAD',
            name_plural: 'Canadian dollars',
          },
          {
            symbol: '€',
            name: 'Euro',
            symbol_native: '€',
            decimal_digits: 2,
            rounding: 0,
            code: 'EUR',
            name_plural: 'euros',
          },
          {
            symbol: 'AED',
            name: 'United Arab Emirates Dirham',
            symbol_native: 'د.إ.‏',
            decimal_digits: 2,
            rounding: 0,
            code: 'AED',
            name_plural: 'UAE dirhams',
          },
          {
            symbol: 'Af',
            name: 'Afghan Afghani',
            symbol_native: '؋',
            decimal_digits: 0,
            rounding: 0,
            code: 'AFN',
            name_plural: 'Afghan Afghanis',
          },
          {
            symbol: 'ALL',
            name: 'Albanian Lek',
            symbol_native: 'Lek',
            decimal_digits: 0,
            rounding: 0,
            code: 'ALL',
            name_plural: 'Albanian lekë',
          },
          {
            symbol: 'AMD',
            name: 'Armenian Dram',
            symbol_native: 'դր.',
            decimal_digits: 0,
            rounding: 0,
            code: 'AMD',
            name_plural: 'Armenian drams',
          },
          {
            symbol: 'AR$',
            name: 'Argentine Peso',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'ARS',
            name_plural: 'Argentine pesos',
          },
          {
            symbol: 'AU$',
            name: 'Australian Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'AUD',
            name_plural: 'Australian dollars',
          },
          {
            symbol: 'man.',
            name: 'Azerbaijani Manat',
            symbol_native: 'ман.',
            decimal_digits: 2,
            rounding: 0,
            code: 'AZN',
            name_plural: 'Azerbaijani manats',
          },
          {
            symbol: 'KM',
            name: 'Bosnia-Herzegovina Convertible Mark',
            symbol_native: 'KM',
            decimal_digits: 2,
            rounding: 0,
            code: 'BAM',
            name_plural: 'Bosnia-Herzegovina convertible marks',
          },
          {
            symbol: 'Tk',
            name: 'Bangladeshi Taka',
            symbol_native: '৳',
            decimal_digits: 2,
            rounding: 0,
            code: 'BDT',
            name_plural: 'Bangladeshi takas',
          },
          {
            symbol: 'BGN',
            name: 'Bulgarian Lev',
            symbol_native: 'лв.',
            decimal_digits: 2,
            rounding: 0,
            code: 'BGN',
            name_plural: 'Bulgarian leva',
          },
          {
            symbol: 'BD',
            name: 'Bahraini Dinar',
            symbol_native: 'د.ب.‏',
            decimal_digits: 3,
            rounding: 0,
            code: 'BHD',
            name_plural: 'Bahraini dinars',
          },
          {
            symbol: 'FBu',
            name: 'Burundian Franc',
            symbol_native: 'FBu',
            decimal_digits: 0,
            rounding: 0,
            code: 'BIF',
            name_plural: 'Burundian francs',
          },
          {
            symbol: 'BN$',
            name: 'Brunei Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'BND',
            name_plural: 'Brunei dollars',
          },
          {
            symbol: 'Bs',
            name: 'Bolivian Boliviano',
            symbol_native: 'Bs',
            decimal_digits: 2,
            rounding: 0,
            code: 'BOB',
            name_plural: 'Bolivian bolivianos',
          },
          {
            symbol: 'R$',
            name: 'Brazilian Real',
            symbol_native: 'R$',
            decimal_digits: 2,
            rounding: 0,
            code: 'BRL',
            name_plural: 'Brazilian reals',
          },
          {
            symbol: 'BWP',
            name: 'Botswanan Pula',
            symbol_native: 'P',
            decimal_digits: 2,
            rounding: 0,
            code: 'BWP',
            name_plural: 'Botswanan pulas',
          },
          {
            symbol: 'BYR',
            name: 'Belarusian Ruble',
            symbol_native: 'BYR',
            decimal_digits: 0,
            rounding: 0,
            code: 'BYR',
            name_plural: 'Belarusian rubles',
          },
          {
            symbol: 'BZ$',
            name: 'Belize Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'BZD',
            name_plural: 'Belize dollars',
          },
          {
            symbol: 'CDF',
            name: 'Congolese Franc',
            symbol_native: 'FrCD',
            decimal_digits: 2,
            rounding: 0,
            code: 'CDF',
            name_plural: 'Congolese francs',
          },
          {
            symbol: 'CHF',
            name: 'Swiss Franc',
            symbol_native: 'CHF',
            decimal_digits: 2,
            rounding: 0.05,
            code: 'CHF',
            name_plural: 'Swiss francs',
          },
          {
            symbol: 'CL$',
            name: 'Chilean Peso',
            symbol_native: '$',
            decimal_digits: 0,
            rounding: 0,
            code: 'CLP',
            name_plural: 'Chilean pesos',
          },
          {
            symbol: 'CN¥',
            name: 'Chinese Yuan',
            symbol_native: 'CN¥',
            decimal_digits: 2,
            rounding: 0,
            code: 'CNY',
            name_plural: 'Chinese yuan',
          },
          {
            symbol: 'CO$',
            name: 'Colombian Peso',
            symbol_native: '$',
            decimal_digits: 0,
            rounding: 0,
            code: 'COP',
            name_plural: 'Colombian pesos',
          },
          {
            symbol: '₡',
            name: 'Costa Rican Colón',
            symbol_native: '₡',
            decimal_digits: 0,
            rounding: 0,
            code: 'CRC',
            name_plural: 'Costa Rican colóns',
          },
          {
            symbol: 'CV$',
            name: 'Cape Verdean Escudo',
            symbol_native: 'CV$',
            decimal_digits: 2,
            rounding: 0,
            code: 'CVE',
            name_plural: 'Cape Verdean escudos',
          },
          {
            symbol: 'Kč',
            name: 'Czech Republic Koruna',
            symbol_native: 'Kč',
            decimal_digits: 2,
            rounding: 0,
            code: 'CZK',
            name_plural: 'Czech Republic korunas',
          },
          {
            symbol: 'Fdj',
            name: 'Djiboutian Franc',
            symbol_native: 'Fdj',
            decimal_digits: 0,
            rounding: 0,
            code: 'DJF',
            name_plural: 'Djiboutian francs',
          },
          {
            symbol: 'Dkr',
            name: 'Danish Krone',
            symbol_native: 'kr',
            decimal_digits: 2,
            rounding: 0,
            code: 'DKK',
            name_plural: 'Danish kroner',
          },
          {
            symbol: 'RD$',
            name: 'Dominican Peso',
            symbol_native: 'RD$',
            decimal_digits: 2,
            rounding: 0,
            code: 'DOP',
            name_plural: 'Dominican pesos',
          },
          {
            symbol: 'DA',
            name: 'Algerian Dinar',
            symbol_native: 'د.ج.‏',
            decimal_digits: 2,
            rounding: 0,
            code: 'DZD',
            name_plural: 'Algerian dinars',
          },
          {
            symbol: 'Ekr',
            name: 'Estonian Kroon',
            symbol_native: 'kr',
            decimal_digits: 2,
            rounding: 0,
            code: 'EEK',
            name_plural: 'Estonian kroons',
          },
          {
            symbol: 'EGP',
            name: 'Egyptian Pound',
            symbol_native: 'ج.م.‏',
            decimal_digits: 2,
            rounding: 0,
            code: 'EGP',
            name_plural: 'Egyptian pounds',
          },
          {
            symbol: 'Nfk',
            name: 'Eritrean Nakfa',
            symbol_native: 'Nfk',
            decimal_digits: 2,
            rounding: 0,
            code: 'ERN',
            name_plural: 'Eritrean nakfas',
          },
          {
            symbol: 'Br',
            name: 'Ethiopian Birr',
            symbol_native: 'Br',
            decimal_digits: 2,
            rounding: 0,
            code: 'ETB',
            name_plural: 'Ethiopian birrs',
          },
          {
            symbol: '£',
            name: 'British Pound Sterling',
            symbol_native: '£',
            decimal_digits: 2,
            rounding: 0,
            code: 'GBP',
            name_plural: 'British pounds sterling',
          },
          {
            symbol: 'GEL',
            name: 'Georgian Lari',
            symbol_native: 'GEL',
            decimal_digits: 2,
            rounding: 0,
            code: 'GEL',
            name_plural: 'Georgian laris',
          },
          {
            symbol: 'GH₵',
            name: 'Ghanaian Cedi',
            symbol_native: 'GH₵',
            decimal_digits: 2,
            rounding: 0,
            code: 'GHS',
            name_plural: 'Ghanaian cedis',
          },
          {
            symbol: 'FG',
            name: 'Guinean Franc',
            symbol_native: 'FG',
            decimal_digits: 0,
            rounding: 0,
            code: 'GNF',
            name_plural: 'Guinean francs',
          },
          {
            symbol: 'GTQ',
            name: 'Guatemalan Quetzal',
            symbol_native: 'Q',
            decimal_digits: 2,
            rounding: 0,
            code: 'GTQ',
            name_plural: 'Guatemalan quetzals',
          },
          {
            symbol: 'HK$',
            name: 'Hong Kong Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'HKD',
            name_plural: 'Hong Kong dollars',
          },
          {
            symbol: 'HNL',
            name: 'Honduran Lempira',
            symbol_native: 'L',
            decimal_digits: 2,
            rounding: 0,
            code: 'HNL',
            name_plural: 'Honduran lempiras',
          },
          {
            symbol: 'kn',
            name: 'Croatian Kuna',
            symbol_native: 'kn',
            decimal_digits: 2,
            rounding: 0,
            code: 'HRK',
            name_plural: 'Croatian kunas',
          },
          {
            symbol: 'Ft',
            name: 'Hungarian Forint',
            symbol_native: 'Ft',
            decimal_digits: 0,
            rounding: 0,
            code: 'HUF',
            name_plural: 'Hungarian forints',
          },
          {
            symbol: 'Rp',
            name: 'Indonesian Rupiah',
            symbol_native: 'Rp',
            decimal_digits: 0,
            rounding: 0,
            code: 'IDR',
            name_plural: 'Indonesian rupiahs',
          },
          {
            symbol: '₪',
            name: 'Israeli New Sheqel',
            symbol_native: '₪',
            decimal_digits: 2,
            rounding: 0,
            code: 'ILS',
            name_plural: 'Israeli new sheqels',
          },
          {
            symbol: 'Rs',
            name: 'Indian Rupee',
            symbol_native: 'টকা',
            decimal_digits: 2,
            rounding: 0,
            code: 'INR',
            name_plural: 'Indian rupees',
          },
          {
            symbol: 'IQD',
            name: 'Iraqi Dinar',
            symbol_native: 'د.ع.‏',
            decimal_digits: 0,
            rounding: 0,
            code: 'IQD',
            name_plural: 'Iraqi dinars',
          },
          {
            symbol: 'IRR',
            name: 'Iranian Rial',
            symbol_native: '﷼',
            decimal_digits: 0,
            rounding: 0,
            code: 'IRR',
            name_plural: 'Iranian rials',
          },
          {
            symbol: 'Ikr',
            name: 'Icelandic Króna',
            symbol_native: 'kr',
            decimal_digits: 0,
            rounding: 0,
            code: 'ISK',
            name_plural: 'Icelandic krónur',
          },
          {
            symbol: 'J$',
            name: 'Jamaican Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'JMD',
            name_plural: 'Jamaican dollars',
          },
          {
            symbol: 'JD',
            name: 'Jordanian Dinar',
            symbol_native: 'د.أ.‏',
            decimal_digits: 3,
            rounding: 0,
            code: 'JOD',
            name_plural: 'Jordanian dinars',
          },
          {
            symbol: '¥',
            name: 'Japanese Yen',
            symbol_native: '￥',
            decimal_digits: 0,
            rounding: 0,
            code: 'JPY',
            name_plural: 'Japanese yen',
          },
          {
            symbol: 'Ksh',
            name: 'Kenyan Shilling',
            symbol_native: 'Ksh',
            decimal_digits: 2,
            rounding: 0,
            code: 'KES',
            name_plural: 'Kenyan shillings',
          },
          {
            symbol: 'KHR',
            name: 'Cambodian Riel',
            symbol_native: '៛',
            decimal_digits: 2,
            rounding: 0,
            code: 'KHR',
            name_plural: 'Cambodian riels',
          },
          {
            symbol: 'CF',
            name: 'Comorian Franc',
            symbol_native: 'FC',
            decimal_digits: 0,
            rounding: 0,
            code: 'KMF',
            name_plural: 'Comorian francs',
          },
          {
            symbol: '₩',
            name: 'South Korean Won',
            symbol_native: '₩',
            decimal_digits: 0,
            rounding: 0,
            code: 'KRW',
            name_plural: 'South Korean won',
          },
          {
            symbol: 'KD',
            name: 'Kuwaiti Dinar',
            symbol_native: 'د.ك.‏',
            decimal_digits: 3,
            rounding: 0,
            code: 'KWD',
            name_plural: 'Kuwaiti dinars',
          },
          {
            symbol: 'KZT',
            name: 'Kazakhstani Tenge',
            symbol_native: 'тңг.',
            decimal_digits: 2,
            rounding: 0,
            code: 'KZT',
            name_plural: 'Kazakhstani tenges',
          },
          {
            symbol: 'LB£',
            name: 'Lebanese Pound',
            symbol_native: 'ل.ل.‏',
            decimal_digits: 0,
            rounding: 0,
            code: 'LBP',
            name_plural: 'Lebanese pounds',
          },
          {
            symbol: 'SLRs',
            name: 'Sri Lankan Rupee',
            symbol_native: 'SL Re',
            decimal_digits: 2,
            rounding: 0,
            code: 'LKR',
            name_plural: 'Sri Lankan rupees',
          },
          {
            symbol: 'Lt',
            name: 'Lithuanian Litas',
            symbol_native: 'Lt',
            decimal_digits: 2,
            rounding: 0,
            code: 'LTL',
            name_plural: 'Lithuanian litai',
          },
          {
            symbol: 'Ls',
            name: 'Latvian Lats',
            symbol_native: 'Ls',
            decimal_digits: 2,
            rounding: 0,
            code: 'LVL',
            name_plural: 'Latvian lati',
          },
          {
            symbol: 'LD',
            name: 'Libyan Dinar',
            symbol_native: 'د.ل.‏',
            decimal_digits: 3,
            rounding: 0,
            code: 'LYD',
            name_plural: 'Libyan dinars',
          },
          {
            symbol: 'MAD',
            name: 'Moroccan Dirham',
            symbol_native: 'د.م.‏',
            decimal_digits: 2,
            rounding: 0,
            code: 'MAD',
            name_plural: 'Moroccan dirhams',
          },
          {
            symbol: 'MDL',
            name: 'Moldovan Leu',
            symbol_native: 'MDL',
            decimal_digits: 2,
            rounding: 0,
            code: 'MDL',
            name_plural: 'Moldovan lei',
          },
          {
            symbol: 'MGA',
            name: 'Malagasy Ariary',
            symbol_native: 'MGA',
            decimal_digits: 0,
            rounding: 0,
            code: 'MGA',
            name_plural: 'Malagasy Ariaries',
          },
          {
            symbol: 'MKD',
            name: 'Macedonian Denar',
            symbol_native: 'MKD',
            decimal_digits: 2,
            rounding: 0,
            code: 'MKD',
            name_plural: 'Macedonian denari',
          },
          {
            symbol: 'MMK',
            name: 'Myanma Kyat',
            symbol_native: 'K',
            decimal_digits: 0,
            rounding: 0,
            code: 'MMK',
            name_plural: 'Myanma kyats',
          },
          {
            symbol: 'MOP$',
            name: 'Macanese Pataca',
            symbol_native: 'MOP$',
            decimal_digits: 2,
            rounding: 0,
            code: 'MOP',
            name_plural: 'Macanese patacas',
          },
          {
            symbol: 'MURs',
            name: 'Mauritian Rupee',
            symbol_native: 'MURs',
            decimal_digits: 0,
            rounding: 0,
            code: 'MUR',
            name_plural: 'Mauritian rupees',
          },
          {
            symbol: 'MX$',
            name: 'Mexican Peso',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'MXN',
            name_plural: 'Mexican pesos',
          },
          {
            symbol: 'RM',
            name: 'Malaysian Ringgit',
            symbol_native: 'RM',
            decimal_digits: 2,
            rounding: 0,
            code: 'MYR',
            name_plural: 'Malaysian ringgits',
          },
          {
            symbol: 'MTn',
            name: 'Mozambican Metical',
            symbol_native: 'MTn',
            decimal_digits: 2,
            rounding: 0,
            code: 'MZN',
            name_plural: 'Mozambican meticals',
          },
          {
            symbol: 'N$',
            name: 'Namibian Dollar',
            symbol_native: 'N$',
            decimal_digits: 2,
            rounding: 0,
            code: 'NAD',
            name_plural: 'Namibian dollars',
          },
          {
            symbol: '₦',
            name: 'Nigerian Naira',
            symbol_native: '₦',
            decimal_digits: 2,
            rounding: 0,
            code: 'NGN',
            name_plural: 'Nigerian nairas',
          },
          {
            symbol: 'C$',
            name: 'Nicaraguan Córdoba',
            symbol_native: 'C$',
            decimal_digits: 2,
            rounding: 0,
            code: 'NIO',
            name_plural: 'Nicaraguan córdobas',
          },
          {
            symbol: 'Nkr',
            name: 'Norwegian Krone',
            symbol_native: 'kr',
            decimal_digits: 2,
            rounding: 0,
            code: 'NOK',
            name_plural: 'Norwegian kroner',
          },
          {
            symbol: 'NPRs',
            name: 'Nepalese Rupee',
            symbol_native: 'नेरू',
            decimal_digits: 2,
            rounding: 0,
            code: 'NPR',
            name_plural: 'Nepalese rupees',
          },
          {
            symbol: 'NZ$',
            name: 'New Zealand Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'NZD',
            name_plural: 'New Zealand dollars',
          },
          {
            symbol: 'OMR',
            name: 'Omani Rial',
            symbol_native: 'ر.ع.‏',
            decimal_digits: 3,
            rounding: 0,
            code: 'OMR',
            name_plural: 'Omani rials',
          },
          {
            symbol: 'B/.',
            name: 'Panamanian Balboa',
            symbol_native: 'B/.',
            decimal_digits: 2,
            rounding: 0,
            code: 'PAB',
            name_plural: 'Panamanian balboas',
          },
          {
            symbol: 'S/.',
            name: 'Peruvian Nuevo Sol',
            symbol_native: 'S/.',
            decimal_digits: 2,
            rounding: 0,
            code: 'PEN',
            name_plural: 'Peruvian nuevos soles',
          },
          {
            symbol: '₱',
            name: 'Philippine Peso',
            symbol_native: '₱',
            decimal_digits: 2,
            rounding: 0,
            code: 'PHP',
            name_plural: 'Philippine pesos',
          },
          {
            symbol: 'PKRs',
            name: 'Pakistani Rupee',
            symbol_native: '₨',
            decimal_digits: 0,
            rounding: 0,
            code: 'PKR',
            name_plural: 'Pakistani rupees',
          },
          {
            symbol: 'zł',
            name: 'Polish Zloty',
            symbol_native: 'zł',
            decimal_digits: 2,
            rounding: 0,
            code: 'PLN',
            name_plural: 'Polish zlotys',
          },
          {
            symbol: '₲',
            name: 'Paraguayan Guarani',
            symbol_native: '₲',
            decimal_digits: 0,
            rounding: 0,
            code: 'PYG',
            name_plural: 'Paraguayan guaranis',
          },
          {
            symbol: 'QR',
            name: 'Qatari Rial',
            symbol_native: 'ر.ق.‏',
            decimal_digits: 2,
            rounding: 0,
            code: 'QAR',
            name_plural: 'Qatari rials',
          },
          {
            symbol: 'RON',
            name: 'Romanian Leu',
            symbol_native: 'RON',
            decimal_digits: 2,
            rounding: 0,
            code: 'RON',
            name_plural: 'Romanian lei',
          },
          {
            symbol: 'din.',
            name: 'Serbian Dinar',
            symbol_native: 'дин.',
            decimal_digits: 0,
            rounding: 0,
            code: 'RSD',
            name_plural: 'Serbian dinars',
          },
          {
            symbol: 'RUB',
            name: 'Russian Ruble',
            symbol_native: 'руб.',
            decimal_digits: 2,
            rounding: 0,
            code: 'RUB',
            name_plural: 'Russian rubles',
          },
          {
            symbol: 'RWF',
            name: 'Rwandan Franc',
            symbol_native: 'FR',
            decimal_digits: 0,
            rounding: 0,
            code: 'RWF',
            name_plural: 'Rwandan francs',
          },
          {
            symbol: 'SR',
            name: 'Saudi Riyal',
            symbol_native: 'ر.س.‏',
            decimal_digits: 2,
            rounding: 0,
            code: 'SAR',
            name_plural: 'Saudi riyals',
          },
          {
            symbol: 'SDG',
            name: 'Sudanese Pound',
            symbol_native: 'SDG',
            decimal_digits: 2,
            rounding: 0,
            code: 'SDG',
            name_plural: 'Sudanese pounds',
          },
          {
            symbol: 'Skr',
            name: 'Swedish Krona',
            symbol_native: 'kr',
            decimal_digits: 2,
            rounding: 0,
            code: 'SEK',
            name_plural: 'Swedish kronor',
          },
          {
            symbol: 'S$',
            name: 'Singapore Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'SGD',
            name_plural: 'Singapore dollars',
          },
          {
            symbol: 'Ssh',
            name: 'Somali Shilling',
            symbol_native: 'Ssh',
            decimal_digits: 0,
            rounding: 0,
            code: 'SOS',
            name_plural: 'Somali shillings',
          },
          {
            symbol: 'SY£',
            name: 'Syrian Pound',
            symbol_native: 'ل.س.‏',
            decimal_digits: 0,
            rounding: 0,
            code: 'SYP',
            name_plural: 'Syrian pounds',
          },
          {
            symbol: '฿',
            name: 'Thai Baht',
            symbol_native: '฿',
            decimal_digits: 2,
            rounding: 0,
            code: 'THB',
            name_plural: 'Thai baht',
          },
          {
            symbol: 'DT',
            name: 'Tunisian Dinar',
            symbol_native: 'د.ت.‏',
            decimal_digits: 3,
            rounding: 0,
            code: 'TND',
            name_plural: 'Tunisian dinars',
          },
          {
            symbol: 'T$',
            name: 'Tongan Paʻanga',
            symbol_native: 'T$',
            decimal_digits: 2,
            rounding: 0,
            code: 'TOP',
            name_plural: 'Tongan paʻanga',
          },
          {
            symbol: 'TL',
            name: 'Turkish Lira',
            symbol_native: 'TL',
            decimal_digits: 2,
            rounding: 0,
            code: 'TRY',
            name_plural: 'Turkish Lira',
          },
          {
            symbol: 'TT$',
            name: 'Trinidad and Tobago Dollar',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'TTD',
            name_plural: 'Trinidad and Tobago dollars',
          },
          {
            symbol: 'NT$',
            name: 'New Taiwan Dollar',
            symbol_native: 'NT$',
            decimal_digits: 2,
            rounding: 0,
            code: 'TWD',
            name_plural: 'New Taiwan dollars',
          },
          {
            symbol: 'TSh',
            name: 'Tanzanian Shilling',
            symbol_native: 'TSh',
            decimal_digits: 0,
            rounding: 0,
            code: 'TZS',
            name_plural: 'Tanzanian shillings',
          },
          {
            symbol: '₴',
            name: 'Ukrainian Hryvnia',
            symbol_native: '₴',
            decimal_digits: 2,
            rounding: 0,
            code: 'UAH',
            name_plural: 'Ukrainian hryvnias',
          },
          {
            symbol: 'USh',
            name: 'Ugandan Shilling',
            symbol_native: 'USh',
            decimal_digits: 0,
            rounding: 0,
            code: 'UGX',
            name_plural: 'Ugandan shillings',
          },
          {
            symbol: '$U',
            name: 'Uruguayan Peso',
            symbol_native: '$',
            decimal_digits: 2,
            rounding: 0,
            code: 'UYU',
            name_plural: 'Uruguayan pesos',
          },
          {
            symbol: 'UZS',
            name: 'Uzbekistan Som',
            symbol_native: 'UZS',
            decimal_digits: 0,
            rounding: 0,
            code: 'UZS',
            name_plural: 'Uzbekistan som',
          },
          {
            symbol: 'Bs.F.',
            name: 'Venezuelan Bolívar',
            symbol_native: 'Bs.F.',
            decimal_digits: 2,
            rounding: 0,
            code: 'VEF',
            name_plural: 'Venezuelan bolívars',
          },
          {
            symbol: '₫',
            name: 'Vietnamese Dong',
            symbol_native: '₫',
            decimal_digits: 0,
            rounding: 0,
            code: 'VND',
            name_plural: 'Vietnamese dong',
          },
          {
            symbol: 'FCFA',
            name: 'CFA Franc BEAC',
            symbol_native: 'FCFA',
            decimal_digits: 0,
            rounding: 0,
            code: 'XAF',
            name_plural: 'CFA francs BEAC',
          },
          {
            symbol: 'CFA',
            name: 'CFA Franc BCEAO',
            symbol_native: 'CFA',
            decimal_digits: 0,
            rounding: 0,
            code: 'XOF',
            name_plural: 'CFA francs BCEAO',
          },
          {
            symbol: 'YR',
            name: 'Yemeni Rial',
            symbol_native: 'ر.ي.‏',
            decimal_digits: 0,
            rounding: 0,
            code: 'YER',
            name_plural: 'Yemeni rials',
          },
          {
            symbol: 'R',
            name: 'South African Rand',
            symbol_native: 'R',
            decimal_digits: 2,
            rounding: 0,
            code: 'ZAR',
            name_plural: 'South African rand',
          },
          {
            symbol: 'ZK',
            name: 'Zambian Kwacha',
            symbol_native: 'ZK',
            decimal_digits: 0,
            rounding: 0,
            code: 'ZMK',
            name_plural: 'Zambian kwachas',
          },
        ],
        countries: [
          { name: 'Afghanistan', code: 'AF' },
          { name: 'Åland Islands', code: 'AX' },
          { name: 'Albania', code: 'AL' },
          { name: 'Algeria', code: 'DZ' },
          { name: 'American Samoa', code: 'AS' },
          { name: 'Andorra', code: 'AD' },
          { name: 'Angola', code: 'AO' },
          { name: 'Anguilla', code: 'AI' },
          { name: 'Antarctica', code: 'AQ' },
          { name: 'Antigua and Barbuda', code: 'AG' },
          { name: 'Argentina', code: 'AR' },
          { name: 'Armenia', code: 'AM' },
          { name: 'Aruba', code: 'AW' },
          { name: 'Australia', code: 'AU' },
          { name: 'Austria', code: 'AT' },
          { name: 'Azerbaijan', code: 'AZ' },
          { name: 'Bahamas', code: 'BS' },
          { name: 'Bahrain', code: 'BH' },
          { name: 'Bangladesh', code: 'BD' },
          { name: 'Barbados', code: 'BB' },
          { name: 'Belarus', code: 'BY' },
          { name: 'Belgium', code: 'BE' },
          { name: 'Belize', code: 'BZ' },
          { name: 'Benin', code: 'BJ' },
          { name: 'Bermuda', code: 'BM' },
          { name: 'Bhutan', code: 'BT' },
          { name: 'Bolivia', code: 'BO' },
          { name: 'Bosnia and Herzegovina', code: 'BA' },
          { name: 'Botswana', code: 'BW' },
          { name: 'Bouvet Island', code: 'BV' },
          { name: 'Brazil', code: 'BR' },
          { name: 'British Indian Ocean Territory', code: 'IO' },
          { name: 'Brunei Darussalam', code: 'BN' },
          { name: 'Bulgaria', code: 'BG' },
          { name: 'Burkina Faso', code: 'BF' },
          { name: 'Burundi', code: 'BI' },
          { name: 'Cambodia', code: 'KH' },
          { name: 'Cameroon', code: 'CM' },
          { name: 'Canada', code: 'CA' },
          { name: 'Cape Verde', code: 'CV' },
          { name: 'Cayman Islands', code: 'KY' },
          { name: 'Central African Republic', code: 'CF' },
          { name: 'Chad', code: 'TD' },
          { name: 'Chile', code: 'CL' },
          { name: 'China', code: 'CN' },
          { name: 'Christmas Island', code: 'CX' },
          { name: 'Cocos (Keeling) Islands', code: 'CC' },
          { name: 'Colombia', code: 'CO' },
          { name: 'Comoros', code: 'KM' },
          { name: 'Congo', code: 'CG' },
          { name: 'Congo, The Democratic Republic of the', code: 'CD' },
          { name: 'Cook Islands', code: 'CK' },
          { name: 'Costa Rica', code: 'CR' },
          { name: "Cote D'Ivoire", code: 'CI' },
          { name: 'Croatia', code: 'HR' },
          { name: 'Cuba', code: 'CU' },
          { name: 'Cyprus', code: 'CY' },
          { name: 'Czech Republic', code: 'CZ' },
          { name: 'Denmark', code: 'DK' },
          { name: 'Djibouti', code: 'DJ' },
          { name: 'Dominica', code: 'DM' },
          { name: 'Dominican Republic', code: 'DO' },
          { name: 'Ecuador', code: 'EC' },
          { name: 'Egypt', code: 'EG' },
          { name: 'El Salvador', code: 'SV' },
          { name: 'Equatorial Guinea', code: 'GQ' },
          { name: 'Eritrea', code: 'ER' },
          { name: 'Estonia', code: 'EE' },
          { name: 'Ethiopia', code: 'ET' },
          { name: 'Falkland Islands (Malvinas)', code: 'FK' },
          { name: 'Faroe Islands', code: 'FO' },
          { name: 'Fiji', code: 'FJ' },
          { name: 'Finland', code: 'FI' },
          { name: 'France', code: 'FR' },
          { name: 'French Guiana', code: 'GF' },
          { name: 'French Polynesia', code: 'PF' },
          { name: 'French Southern Territories', code: 'TF' },
          { name: 'Gabon', code: 'GA' },
          { name: 'Gambia', code: 'GM' },
          { name: 'Georgia', code: 'GE' },
          { name: 'Germany', code: 'DE' },
          { name: 'Ghana', code: 'GH' },
          { name: 'Gibraltar', code: 'GI' },
          { name: 'Greece', code: 'GR' },
          { name: 'Greenland', code: 'GL' },
          { name: 'Grenada', code: 'GD' },
          { name: 'Guadeloupe', code: 'GP' },
          { name: 'Guam', code: 'GU' },
          { name: 'Guatemala', code: 'GT' },
          { name: 'Guernsey', code: 'GG' },
          { name: 'Guinea', code: 'GN' },
          { name: 'Guinea-Bissau', code: 'GW' },
          { name: 'Guyana', code: 'GY' },
          { name: 'Haiti', code: 'HT' },
          { name: 'Heard Island and Mcdonald Islands', code: 'HM' },
          { name: 'Holy See (Vatican City State)', code: 'VA' },
          { name: 'Honduras', code: 'HN' },
          { name: 'Hong Kong', code: 'HK' },
          { name: 'Hungary', code: 'HU' },
          { name: 'Iceland', code: 'IS' },
          { name: 'India', code: 'IN' },
          { name: 'Indonesia', code: 'ID' },
          { name: 'Iran, Islamic Republic Of', code: 'IR' },
          { name: 'Iraq', code: 'IQ' },
          { name: 'Ireland', code: 'IE' },
          { name: 'Isle of Man', code: 'IM' },
          { name: 'Israel', code: 'IL' },
          { name: 'Italy', code: 'IT' },
          { name: 'Jamaica', code: 'JM' },
          { name: 'Japan', code: 'JP' },
          { name: 'Jersey', code: 'JE' },
          { name: 'Jordan', code: 'JO' },
          { name: 'Kazakhstan', code: 'KZ' },
          { name: 'Kenya', code: 'KE' },
          { name: 'Kiribati', code: 'KI' },
          { name: "Korea, Democratic People'S Republic of", code: 'KP' },
          { name: 'Korea, Republic of', code: 'KR' },
          { name: 'Kuwait', code: 'KW' },
          { name: 'Kyrgyzstan', code: 'KG' },
          { name: "Lao People'S Democratic Republic", code: 'LA' },
          { name: 'Latvia', code: 'LV' },
          { name: 'Lebanon', code: 'LB' },
          { name: 'Lesotho', code: 'LS' },
          { name: 'Liberia', code: 'LR' },
          { name: 'Libyan Arab Jamahiriya', code: 'LY' },
          { name: 'Liechtenstein', code: 'LI' },
          { name: 'Lithuania', code: 'LT' },
          { name: 'Luxembourg', code: 'LU' },
          { name: 'Macao', code: 'MO' },
          { name: 'Macedonia, The Former Yugoslav Republic of', code: 'MK' },
          { name: 'Madagascar', code: 'MG' },
          { name: 'Malawi', code: 'MW' },
          { name: 'Malaysia', code: 'MY' },
          { name: 'Maldives', code: 'MV' },
          { name: 'Mali', code: 'ML' },
          { name: 'Malta', code: 'MT' },
          { name: 'Marshall Islands', code: 'MH' },
          { name: 'Martinique', code: 'MQ' },
          { name: 'Mauritania', code: 'MR' },
          { name: 'Mauritius', code: 'MU' },
          { name: 'Mayotte', code: 'YT' },
          { name: 'Mexico', code: 'MX' },
          { name: 'Micronesia, Federated States of', code: 'FM' },
          { name: 'Moldova, Republic of', code: 'MD' },
          { name: 'Monaco', code: 'MC' },
          { name: 'Mongolia', code: 'MN' },
          { name: 'Montserrat', code: 'MS' },
          { name: 'Morocco', code: 'MA' },
          { name: 'Mozambique', code: 'MZ' },
          { name: 'Myanmar', code: 'MM' },
          { name: 'Namibia', code: 'NA' },
          { name: 'Nauru', code: 'NR' },
          { name: 'Nepal', code: 'NP' },
          { name: 'Netherlands', code: 'NL' },
          { name: 'Netherlands Antilles', code: 'AN' },
          { name: 'New Caledonia', code: 'NC' },
          { name: 'New Zealand', code: 'NZ' },
          { name: 'Nicaragua', code: 'NI' },
          { name: 'Niger', code: 'NE' },
          { name: 'Nigeria', code: 'NG' },
          { name: 'Niue', code: 'NU' },
          { name: 'Norfolk Island', code: 'NF' },
          { name: 'Northern Mariana Islands', code: 'MP' },
          { name: 'Norway', code: 'NO' },
          { name: 'Oman', code: 'OM' },
          { name: 'Pakistan', code: 'PK' },
          { name: 'Palau', code: 'PW' },
          { name: 'Palestinian Territory, Occupied', code: 'PS' },
          { name: 'Panama', code: 'PA' },
          { name: 'Papua New Guinea', code: 'PG' },
          { name: 'Paraguay', code: 'PY' },
          { name: 'Peru', code: 'PE' },
          { name: 'Philippines', code: 'PH' },
          { name: 'Pitcairn', code: 'PN' },
          { name: 'Poland', code: 'PL' },
          { name: 'Portugal', code: 'PT' },
          { name: 'Puerto Rico', code: 'PR' },
          { name: 'Qatar', code: 'QA' },
          { name: 'Reunion', code: 'RE' },
          { name: 'Romania', code: 'RO' },
          { name: 'Russian Federation', code: 'RU' },
          { name: 'RWANDA', code: 'RW' },
          { name: 'Saint Helena', code: 'SH' },
          { name: 'Saint Kitts and Nevis', code: 'KN' },
          { name: 'Saint Lucia', code: 'LC' },
          { name: 'Saint Pierre and Miquelon', code: 'PM' },
          { name: 'Saint Vincent and the Grenadines', code: 'VC' },
          { name: 'Samoa', code: 'WS' },
          { name: 'San Marino', code: 'SM' },
          { name: 'Sao Tome and Principe', code: 'ST' },
          { name: 'Saudi Arabia', code: 'SA' },
          { name: 'Senegal', code: 'SN' },
          { name: 'Serbia and Montenegro', code: 'CS' },
          { name: 'Seychelles', code: 'SC' },
          { name: 'Sierra Leone', code: 'SL' },
          { name: 'Singapore', code: 'SG' },
          { name: 'Slovakia', code: 'SK' },
          { name: 'Slovenia', code: 'SI' },
          { name: 'Solomon Islands', code: 'SB' },
          { name: 'Somalia', code: 'SO' },
          { name: 'South Africa', code: 'ZA' },
          { name: 'South Georgia and the South Sandwich Islands', code: 'GS' },
          { name: 'Spain', code: 'ES' },
          { name: 'Sri Lanka', code: 'LK' },
          { name: 'Sudan', code: 'SD' },
          { name: 'Suriname', code: 'SR' },
          { name: 'Svalbard and Jan Mayen', code: 'SJ' },
          { name: 'Swaziland', code: 'SZ' },
          { name: 'Sweden', code: 'SE' },
          { name: 'Switzerland', code: 'CH' },
          { name: 'Syrian Arab Republic', code: 'SY' },
          { name: 'Taiwan, Province of China', code: 'TW' },
          { name: 'Tajikistan', code: 'TJ' },
          { name: 'Tanzania, United Republic of', code: 'TZ' },
          { name: 'Thailand', code: 'TH' },
          { name: 'Timor-Leste', code: 'TL' },
          { name: 'Togo', code: 'TG' },
          { name: 'Tokelau', code: 'TK' },
          { name: 'Tonga', code: 'TO' },
          { name: 'Trinidad and Tobago', code: 'TT' },
          { name: 'Tunisia', code: 'TN' },
          { name: 'Turkey', code: 'TR' },
          { name: 'Turkmenistan', code: 'TM' },
          { name: 'Turks and Caicos Islands', code: 'TC' },
          { name: 'Tuvalu', code: 'TV' },
          { name: 'Uganda', code: 'UG' },
          { name: 'Ukraine', code: 'UA' },
          { name: 'United Arab Emirates', code: 'AE' },
          { name: 'United Kingdom', code: 'GB' },
          { name: 'United States', code: 'US' },
          { name: 'United States Minor Outlying Islands', code: 'UM' },
          { name: 'Uruguay', code: 'UY' },
          { name: 'Uzbekistan', code: 'UZ' },
          { name: 'Vanuatu', code: 'VU' },
          { name: 'Venezuela', code: 'VE' },
          { name: 'Viet Nam', code: 'VN' },
          { name: 'Virgin Islands, British', code: 'VG' },
          { name: 'Virgin Islands, U.S.', code: 'VI' },
          { name: 'Wallis and Futuna', code: 'WF' },
          { name: 'Western Sahara', code: 'EH' },
          { name: 'Yemen', code: 'YE' },
          { name: 'Zambia', code: 'ZM' },
          { name: 'Zimbabwe', code: 'ZW' },
        ],
        numberFormats: [
          { name: 'integer', translateId: 'NUMBER_FORMATS.INTEGER' },
          { name: 'decimal', translateId: 'NUMBER_FORMATS.DECIMAL' },
          { name: 'currency', translateId: 'NUMBER_FORMATS.CURRENCY' },
        ],
        decimalFormats: { DECIMAL_COMMA: 0, DECIMAL_POINT: 1 },
        decimalPatterns: {
          COMMA: /^(?:[+-](?=[\d,.]))?(?:\d*|\d{1,3}(?:\.\d{3})+)?(?:,(\d+))?(?:e[+-]\d+)?$/i,
          POINT: /^(?:[+-](?=[\d,.]))?(?:\d*|\d{1,3}(?:,\d{3})+)?(?:\.(\d+))?(?:e[+-]\d+)?$/i,
        },
        emailFields: {
          SUBJECT: 'subject',
          BODY: 'body',
          SENDER: 'sender',
          DATE: 'date',
          ASSIGN_TO: 'assignTo',
          ATTACHMENTS: 'attachments',
        },
        languages: {
          de: { key: 'de', name: 'Deutsch', alias: 'de_*', momentKey: 'de' },
          en: { key: 'en', name: 'English', alias: 'en_*', momentKey: 'en' },
          es: { key: 'es', name: 'Español', alias: 'es_*', momentKey: 'es' },
          fr: { key: 'fr', name: 'Français', alias: 'fr_*', momentKey: 'fr' },
          it: { key: 'it', name: 'Italiano', alias: 'it_*', momentKey: 'it' },
          ko: { key: 'ko', name: '한국어', alias: 'ko_*', momentKey: 'ko' },
          pt: { key: 'pt', name: 'Português', alias: 'pt-*', momentKey: 'pt' },
          ru: { key: 'ru', name: 'Pусский', alias: 'ru_*', momentKey: 'ru' },
          zh: { key: 'zh', name: '繁體中文', alias: 'zh-hant', momentKey: 'zh-cn' },
        },
        defaultListIconClassNames: 'zi zi-collection-two-ios',
        listAddons: {
          TASKS: {
            id: 'tasks',
            key: 'tasks',
            iconClassNames: 'zi zi-box-main-checked',
            iconContainerClassNames: 'zenkit-list-addon-tasks',
            name: 'LIST_ADD_ONS.TASKS.NAME',
            description: 'LIST_ADD_ONS.TASKS.DESCRIPTION',
          },
          THEMES: {
            id: 'themes',
            iconClassNames: 'fa fa-paint-brush',
            iconContainerClassNames: 'zenkit-list-addon-themes',
            name: 'LIST_ADD_ONS.THEMES.NAME',
            description: 'LIST_ADD_ONS.THEMES.DESCRIPTION',
          },
          CALENDAR_SYNC: {
            id: 'calendar-sync',
            key: 'calendarSync',
            iconClassNames: 'zi zi-updated',
            iconContainerClassNames: 'zenkit-list-addon-calendar-sync',
            name: 'LIST_ADD_ONS.CALENDAR_SYNC.NAME',
            description: 'LIST_ADD_ONS.CALENDAR_SYNC.DESCRIPTION',
          },
          ICAL_LINK: {
            id: 'ical-link',
            key: 'icalLink',
            iconClassNames: 'zi zi-calendar',
            iconContainerClassNames: 'zenkit-list-addon-ical-link',
            name: 'LIST_ADD_ONS.ICAL_LINK.NAME',
            description: 'LIST_ADD_ONS.ICAL_LINK.DESCRIPTION',
          },
          EMAILS: {
            id: 'emails',
            key: 'emails',
            iconClassNames: 'zi zi-mail',
            iconContainerClassNames: 'zenkit-list-addon-emails',
            name: 'LIST_ADD_ONS.EMAIL_TO_LIST.NAME',
            description: 'LIST_ADD_ONS.EMAIL_TO_LIST.DESCRIPTION',
          },
          COLORFUL_ENTRIES: {
            id: 'colorfulEntries',
            key: 'colorfulEntries',
            iconClassNames: 'zi zi-labels',
            iconContainerClassNames: 'zenkit-list-addon-colorful-entries',
            name: 'LIST_ADD_ONS.COLORFUL_ENTRIES.NAME',
            description: 'LIST_ADD_ONS.COLORFUL_ENTRIES.DESCRIPTION',
          },
          PUBLISH: {
            id: 'publish',
            iconClassNames: 'fa fa-globe',
            iconContainerClassNames: 'zenkit-list-addon-publish',
            name: 'LIST_ADD_ONS.PUBLISH.NAME',
            description: 'LIST_ADD_ONS.PUBLISH.DESCRIPTION',
          },
        },
        userAddons: {
          RECENT_LISTS: {
            id: 'recent-lists',
            key: 'recentListsSettings',
            iconClassNames: 'zi zi-folder-closed-recent',
            iconContainerClassNames: 'zenkit-user-addon-recent-lists',
            name: 'USER_ADD_ONS.RECENT_LISTS.NAME',
            description: 'USER_ADD_ONS.RECENT_LISTS.DESCRIPTION',
          },
          USER_CALENDAR: {
            id: 'user-calendar',
            key: 'userCalendarSettings',
            iconClassNames: 'zi zi-mode-calendar-number',
            iconContainerClassNames: 'zenkit-user-addon-calendar',
            name: 'USER_ADD_ONS.USER_CALENDAR.NAME',
            description: 'USER_ADD_ONS.USER_CALENDAR.DESCRIPTION',
          },
          USER_TAGS: {
            id: 'favorites',
            key: 'userTagsSettings',
            iconClassNames: 'zi zi-favorites-o',
            iconContainerClassNames: 'zenkit-user-addon-favorites',
            name: 'USER_ADD_ONS.USER_TAGS.NAME',
            description: 'USER_ADD_ONS.USER_TAGS.DESCRIPTION',
          },
          USER_ASSIGNMENTS: {
            id: 'assignments',
            key: 'assignmentsViewSettings',
            iconClassNames: 'zi zi-members',
            iconContainerClassNames: 'zenkit-user-addon-assignments',
            name: 'USER_ADD_ONS.USER_ASSIGNMENTS.NAME',
            description: 'USER_ADD_ONS.USER_ASSIGNMENTS.DESCRIPTION',
          },
          TWO_FACTOR_AUTHENTICATION: {
            id: 'two-fa',
            iconClassNames: 'zi zi-private',
            iconContainerClassNames: 'zenkit-user-addon-two-factor-authentication',
            name: '2FA.TITLE',
            description: '2FA.DESCRIPTION',
          },
        },
        escalationLevels: { NONE: 'none', WARNING: 'warning', READ_ONLY: 'read-only', BLOCKED: 'blocked' },
        maxExceededDays: 15,
        paymentProviders: { MANUAL: 'manual', CHARGEBEE: 'chargebee', APPLE: 'apple', GOOGLE: 'google' },
        listEntryReorderConfig: { step: 1e-6, defaultStart: 1, maxLength: 50 },
      },
      quotaScopes = { ORGANIZATION: 'organization', LIST: 'list', UNIVERSE: 'universe' },
      quotas = [
        { id: 'users', name: 'QUOTAS.MEMBERS', iconClassNames: 'zi zi-members', scope: quotaScopes.ORGANIZATION },
        {
          id: 'workspaces',
          name: 'QUOTAS.WORKSPACES',
          iconClassNames: 'zi zi-folder-open-ios',
          scope: quotaScopes.ORGANIZATION,
        },
        { id: 'lists', name: 'QUOTAS.LISTS', iconClassNames: 'zi zi-collection', scope: quotaScopes.ORGANIZATION },
        {
          id: 'entries',
          name: 'QUOTAS.ENTRIES',
          iconClassNames: 'zi zi-collection-three',
          scope: quotaScopes.ORGANIZATION,
        },
        { id: 'elements', name: 'QUOTAS.ELEMENTS', iconClassNames: 'zi zi-text', scope: quotaScopes.ORGANIZATION },
        { id: 'files', name: 'QUOTAS.FILES', iconClassNames: 'zi zi-attachment', scope: quotaScopes.ORGANIZATION },
        { id: 'comments', name: 'QUOTAS.COMMENTS', iconClassNames: 'zi zi-comments', scope: quotaScopes.ORGANIZATION },
        {
          id: 'aggregatedFileSize',
          name: 'QUOTAS.AGGREGATED_FILE_SIZE',
          iconClassNames: 'zi zi-attachment',
          scope: quotaScopes.ORGANIZATION,
        },
        {
          id: 'maxFileSizeInList',
          name: 'QUOTAS.MAX_FILE_SIZE',
          iconClassNames: 'zi zi-attachment',
          scope: quotaScopes.ORGANIZATION,
        },
        {
          id: 'maxFilesInList',
          name: 'QUOTAS.MAX_FILES_IN_LIST',
          iconClassNames: 'zi zi-attachment',
          scope: quotaScopes.LIST,
        },
        {
          id: 'maxAggregatedFileSizeInList',
          name: 'QUOTAS.MAX_AGGREGATED_FILE_SIZE_IN_LIST',
          iconClassNames: 'zi zi-attachment',
          scope: quotaScopes.LIST,
        },
        {
          id: 'maxEntriesInList',
          name: 'QUOTAS.MAX_ENTRIES_IN_LIST',
          iconClassNames: 'zi zi-collection-three',
          scope: quotaScopes.LIST,
        },
        {
          id: 'maxCommentsInList',
          name: 'QUOTAS.MAX_COMMENTS_IN_LIST',
          iconClassNames: 'zi zi-comments',
          scope: quotaScopes.LIST,
        },
        {
          id: 'maxElementsInList',
          name: 'QUOTAS.MAX_ELEMENTS_IN_LIST',
          iconClassNames: 'zi zi-text',
          scope: quotaScopes.LIST,
        },
        {
          id: 'connectedLists',
          name: 'QUOTAS.CONNECTED_LISTS',
          iconClassNames: 'zi zi-collection',
          scope: quotaScopes.UNIVERSE,
        },
      ]
    ;(ZenkitControlsShared.quotaScopes = quotaScopes),
      (ZenkitControlsShared.quotas = quotas),
      (ZenkitControlsShared.invoicePeriods = invoicePeriods),
      (ZenkitControlsShared.checkoutCurrencies = checkoutCurrencies),
      (ZenkitControlsShared.abTests = {
        homeScreenOnboarding: {
          key: 'homeScreenOnboarding',
          groups: {
            hideVideo: { key: 'hideVideo', percentage: 10 },
            hideBackgrounds: { key: 'hideBackgrounds', percentage: 10 },
            hideVideoAndBackgrounds: { key: 'hideVideoAndBackgrounds', percentage: 10 },
            noChange: { key: 'noChange', percentage: 10 },
          },
        },
      }),
      'object' == typeof module && 'object' == typeof module.exports
        ? (module.exports = ZenkitControlsShared)
        : ((window.ZenkitControlsShared = ZenkitControlsShared),
          'function' == typeof define &&
            define.amd &&
            define('ZenkitControlsShared', [], function () {
              return ZenkitControlsShared
            }))
  })(this),
  (function (a, i) {
    'use strict'
    'object' == typeof module && module.exports
      ? (module.exports = i(require('moment')))
      : 'function' == typeof define && define.amd
      ? define(['moment'], i)
      : i(a.moment)
  })(this, function (c) {
    'use strict'
    var i,
      A = {},
      n = {},
      s = {},
      u = {}
    ;(c && 'string' == typeof c.version) ||
      C('Moment Timezone requires Moment.js. See https://momentjs.com/timezone/docs/#/use-it/browser/')
    var a = c.version.split('.'),
      e = +a[0],
      r = +a[1]
    function t(a) {
      return 96 < a ? a - 87 : 64 < a ? a - 29 : a - 48
    }
    function o(a) {
      var i = 0,
        e = a.split('.'),
        r = e[0],
        o = e[1] || '',
        c = 1,
        A = 0,
        n = 1
      for (45 === a.charCodeAt(0) && (n = -(i = 1)); i < r.length; i++) A = 60 * A + t(r.charCodeAt(i))
      for (i = 0; i < o.length; i++) (c /= 60), (A += t(o.charCodeAt(i)) * c)
      return A * n
    }
    function m(a) {
      for (var i = 0; i < a.length; i++) a[i] = o(a[i])
    }
    function f(a, i) {
      var e,
        r = []
      for (e = 0; e < i.length; e++) r[e] = a[i[e]]
      return r
    }
    function l(a) {
      var i = a.split('|'),
        e = i[2].split(' '),
        r = i[3].split(''),
        o = i[4].split(' ')
      return (
        m(e),
        m(r),
        m(o),
        (function (a, i) {
          for (var e = 0; e < i; e++) a[e] = Math.round((a[e - 1] || 0) + 6e4 * a[e])
          a[i - 1] = 1 / 0
        })(o, r.length),
        { name: i[0], abbrs: f(i[1].split(' '), r), offsets: f(e, r), untils: o, population: 0 | i[5] }
      )
    }
    function p(a) {
      a && this._set(l(a))
    }
    function b(a) {
      var i = a.toTimeString(),
        e = i.match(/\([a-z ]+\)/i)
      'GMT' ===
        (e =
          e && e[0]
            ? (e = e[0].match(/[A-Z]/g))
              ? e.join('')
              : void 0
            : (e = i.match(/[A-Z]{3,5}/g))
            ? e[0]
            : void 0) && (e = void 0),
        (this.at = +a),
        (this.abbr = e),
        (this.offset = a.getTimezoneOffset())
    }
    function M(a) {
      ;(this.zone = a), (this.offsetScore = 0), (this.abbrScore = 0)
    }
    function d(a, i) {
      for (var e, r; (r = 6e4 * (((i.at - a.at) / 12e4) | 0)); )
        (e = new b(new Date(a.at + r))).offset === a.offset ? (a = e) : (i = e)
      return a
    }
    function h(a, i) {
      return a.offsetScore !== i.offsetScore
        ? a.offsetScore - i.offsetScore
        : a.abbrScore !== i.abbrScore
        ? a.abbrScore - i.abbrScore
        : i.zone.population - a.zone.population
    }
    function z(a, i) {
      var e, r
      for (m(i), e = 0; e < i.length; e++) (r = i[e]), (u[r] = u[r] || {}), (u[r][a] = !0)
    }
    function g(a) {
      return (a || '').toLowerCase().replace(/\//g, '_')
    }
    function T(a) {
      var i, e, r, o
      for ('string' == typeof a && (a = [a]), i = 0; i < a.length; i++)
        (o = g((e = (r = a[i].split('|'))[0]))), (A[o] = a[i]), (s[o] = e), z(o, r[2].split(' '))
    }
    function P(a, i) {
      a = g(a)
      var e,
        r = A[a]
      return r instanceof p
        ? r
        : 'string' == typeof r
        ? ((r = new p(r)), (A[a] = r))
        : n[a] && i !== P && (e = P(n[a], P))
        ? ((r = A[a] = new p())._set(e), (r.name = s[a]), r)
        : null
    }
    function S(a) {
      var i, e, r, o
      for ('string' == typeof a && (a = [a]), i = 0; i < a.length; i++)
        (r = g((e = a[i].split('|'))[0])), (o = g(e[1])), (n[r] = o), (s[r] = e[0]), (n[o] = r), (s[o] = e[1])
    }
    function _(a) {
      T(a.zones), S(a.links), (N.dataVersion = a.version)
    }
    function k(a) {
      var i = 'X' === a._f || 'x' === a._f
      return !(!a._a || void 0 !== a._tzm || i)
    }
    function C(a) {
      'undefined' != typeof console && 'function' == typeof console.error && console.error(a)
    }
    function N(a) {
      var i = Array.prototype.slice.call(arguments, 0, -1),
        e = arguments[arguments.length - 1],
        r = P(e),
        o = c.utc.apply(null, i)
      return r && !c.isMoment(a) && k(o) && o.add(r.parse(o), 'minutes'), o.tz(e), o
    }
    ;(e < 2 || (2 == e && r < 6)) &&
      C('Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js ' + c.version + '. See momentjs.com'),
      (p.prototype = {
        _set: function (a) {
          ;(this.name = a.name),
            (this.abbrs = a.abbrs),
            (this.untils = a.untils),
            (this.offsets = a.offsets),
            (this.population = a.population)
        },
        _index: function (a) {
          var i,
            e = +a,
            r = this.untils
          for (i = 0; i < r.length; i++) if (e < r[i]) return i
        },
        parse: function (a) {
          var i,
            e,
            r,
            o,
            c = +a,
            A = this.offsets,
            n = this.untils,
            t = n.length - 1
          for (o = 0; o < t; o++)
            if (
              ((i = A[o]),
              (e = A[o + 1]),
              (r = A[o ? o - 1 : o]),
              i < e && N.moveAmbiguousForward ? (i = e) : r < i && N.moveInvalidForward && (i = r),
              c < n[o] - 6e4 * i)
            )
              return A[o]
          return A[t]
        },
        abbr: function (a) {
          return this.abbrs[this._index(a)]
        },
        offset: function (a) {
          return C('zone.offset has been deprecated in favor of zone.utcOffset'), this.offsets[this._index(a)]
        },
        utcOffset: function (a) {
          return this.offsets[this._index(a)]
        },
      }),
      (M.prototype.scoreOffsetAt = function (a) {
        ;(this.offsetScore += Math.abs(this.zone.utcOffset(a.at) - a.offset)),
          this.zone.abbr(a.at).replace(/[^A-Z]/g, '') !== a.abbr && this.abbrScore++
      }),
      (N.version = '0.5.26'),
      (N.dataVersion = ''),
      (N._zones = A),
      (N._links = n),
      (N._names = s),
      (N.add = T),
      (N.link = S),
      (N.load = _),
      (N.zone = P),
      (N.zoneExists = function a(i) {
        return (
          a.didShowError ||
            ((a.didShowError = !0),
            C("moment.tz.zoneExists('" + i + "') has been deprecated in favor of !moment.tz.zone('" + i + "')")),
          !!P(i)
        )
      }),
      (N.guess = function (a) {
        return (
          (i && !a) ||
            (i = (function () {
              try {
                var a = Intl.DateTimeFormat().resolvedOptions().timeZone
                if (a && 3 < a.length) {
                  var i = s[g(a)]
                  if (i) return i
                  C('Moment Timezone found ' + a + ' from the Intl api, but did not have that data loaded.')
                }
              } catch (a) {}
              var e,
                r,
                o,
                c = (function () {
                  var a,
                    i,
                    e,
                    r = new Date().getFullYear() - 2,
                    o = new b(new Date(r, 0, 1)),
                    c = [o]
                  for (e = 1; e < 48; e++)
                    (i = new b(new Date(r, e, 1))).offset !== o.offset &&
                      ((a = d(o, i)), c.push(a), c.push(new b(new Date(a.at + 6e4)))),
                      (o = i)
                  for (e = 0; e < 4; e++) c.push(new b(new Date(r + e, 0, 1))), c.push(new b(new Date(r + e, 6, 1)))
                  return c
                })(),
                A = c.length,
                n = (function (a) {
                  var i,
                    e,
                    r,
                    o = a.length,
                    c = {},
                    A = []
                  for (i = 0; i < o; i++) for (e in (r = u[a[i].offset] || {})) r.hasOwnProperty(e) && (c[e] = !0)
                  for (i in c) c.hasOwnProperty(i) && A.push(s[i])
                  return A
                })(c),
                t = []
              for (r = 0; r < n.length; r++) {
                for (e = new M(P(n[r]), A), o = 0; o < A; o++) e.scoreOffsetAt(c[o])
                t.push(e)
              }
              return t.sort(h), 0 < t.length ? t[0].zone.name : void 0
            })()),
          i
        )
      }),
      (N.names = function () {
        var a,
          i = []
        for (a in s) s.hasOwnProperty(a) && (A[a] || A[n[a]]) && s[a] && i.push(s[a])
        return i.sort()
      }),
      (N.Zone = p),
      (N.unpack = l),
      (N.unpackBase60 = o),
      (N.needsOffset = k),
      (N.moveInvalidForward = !0),
      (N.moveAmbiguousForward = !1)
    var O,
      B = c.fn
    function G(a) {
      return function () {
        return this._z ? this._z.abbr(this) : a.call(this)
      }
    }
    function D(a) {
      return function () {
        return (this._z = null), a.apply(this, arguments)
      }
    }
    ;(c.tz = N),
      (c.defaultZone = null),
      (c.updateOffset = function (a, i) {
        var e,
          r = c.defaultZone
        if (
          (void 0 === a._z &&
            (r && k(a) && !a._isUTC && ((a._d = c.utc(a._a)._d), a.utc().add(r.parse(a), 'minutes')), (a._z = r)),
          a._z)
        )
          if (((e = a._z.utcOffset(a)), Math.abs(e) < 16 && (e /= 60), void 0 !== a.utcOffset)) {
            var o = a._z
            a.utcOffset(-e, i), (a._z = o)
          } else a.zone(e, i)
      }),
      (B.tz = function (a, i) {
        if (a) {
          if ('string' != typeof a) throw new Error('Time zone name must be a string, got ' + a + ' [' + typeof a + ']')
          return (
            (this._z = P(a)),
            this._z
              ? c.updateOffset(this, i)
              : C('Moment Timezone has no data for ' + a + '. See http://momentjs.com/timezone/docs/#/data-loading/.'),
            this
          )
        }
        if (this._z) return this._z.name
      }),
      (B.zoneName = G(B.zoneName)),
      (B.zoneAbbr = G(B.zoneAbbr)),
      (B.utc = D(B.utc)),
      (B.local = D(B.local)),
      (B.utcOffset =
        ((O = B.utcOffset),
        function () {
          return 0 < arguments.length && (this._z = null), O.apply(this, arguments)
        })),
      (c.tz.setDefault = function (a) {
        return (
          (e < 2 || (2 == e && r < 9)) &&
            C('Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js ' + c.version + '.'),
          (c.defaultZone = a ? P(a) : null),
          c
        )
      })
    var y = c.momentProperties
    return (
      '[object Array]' === Object.prototype.toString.call(y) ? (y.push('_z'), y.push('_a')) : y && (y._z = null),
      _({
        version: '2019b',
        zones: [
          'Africa/Abidjan|GMT|0|0||48e5',
          'Africa/Nairobi|EAT|-30|0||47e5',
          'Africa/Algiers|CET|-10|0||26e5',
          'Africa/Lagos|WAT|-10|0||17e6',
          'Africa/Maputo|CAT|-20|0||26e5',
          'Africa/Cairo|EET EEST|-20 -30|01010|1M2m0 gL0 e10 mn0|15e6',
          'Africa/Casablanca|+00 +01|0 -10|010101010101010101010101010101010101|1H3C0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 e00 28M0 e00 2600 gM0|32e5',
          'Europe/Paris|CET CEST|-10 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|11e6',
          'Africa/Johannesburg|SAST|-20|0||84e5',
          'Africa/Khartoum|EAT CAT|-30 -20|01|1Usl0|51e5',
          'Africa/Sao_Tome|GMT WAT|0 -10|010|1UQN0 2q00',
          'Africa/Tripoli|EET CET CEST|-20 -10 -20|0120|1IlA0 TA0 1o00|11e5',
          'Africa/Windhoek|CAT WAT|-20 -10|0101010101010|1GQo0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|32e4',
          'America/Adak|HST HDT|a0 90|01010101010101010101010|1GIc0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|326',
          'America/Anchorage|AKST AKDT|90 80|01010101010101010101010|1GIb0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|30e4',
          'America/Santo_Domingo|AST|40|0||29e5',
          'America/Araguaina|-03 -02|30 20|010|1IdD0 Lz0|14e4',
          'America/Fortaleza|-03|30|0||34e5',
          'America/Asuncion|-03 -04|30 40|01010101010101010101010|1GTf0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0|28e5',
          'America/Panama|EST|50|0||15e5',
          'America/Mexico_City|CST CDT|60 50|01010101010101010101010|1GQw0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|20e6',
          'America/Bahia|-02 -03|20 30|01|1GCq0|27e5',
          'America/Managua|CST|60|0||22e5',
          'America/La_Paz|-04|40|0||19e5',
          'America/Lima|-05|50|0||11e6',
          'America/Denver|MST MDT|70 60|01010101010101010101010|1GI90 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|26e5',
          'America/Campo_Grande|-03 -04|30 40|0101010101010101|1GCr0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|77e4',
          'America/Cancun|CST CDT EST|60 50 50|01010102|1GQw0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4',
          'America/Caracas|-0430 -04|4u 40|01|1QMT0|29e5',
          'America/Chicago|CST CDT|60 50|01010101010101010101010|1GI80 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|92e5',
          'America/Chihuahua|MST MDT|70 60|01010101010101010101010|1GQx0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|81e4',
          'America/Phoenix|MST|70|0||42e5',
          'America/Los_Angeles|PST PDT|80 70|01010101010101010101010|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|15e6',
          'America/New_York|EST EDT|50 40|01010101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|21e6',
          'America/Rio_Branco|-04 -05|40 50|01|1KLE0|31e4',
          'America/Fort_Nelson|PST PDT MST|80 70 70|01010102|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2',
          'America/Halifax|AST ADT|40 30|01010101010101010101010|1GI60 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|39e4',
          'America/Godthab|-03 -02|30 20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|17e3',
          'America/Grand_Turk|EST EDT AST|50 40 40|0101010121010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 5Ip0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|37e2',
          'America/Havana|CST CDT|50 40|01010101010101010101010|1GQt0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0|21e5',
          'America/Metlakatla|PST AKST AKDT|80 90 80|01212120121212121|1PAa0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 uM0 jB0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|14e2',
          'America/Miquelon|-03 -02|30 20|01010101010101010101010|1GI50 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|61e2',
          'America/Montevideo|-02 -03|20 30|01010101|1GI40 1o10 11z0 1o10 11z0 1o10 11z0|17e5',
          'America/Noronha|-02|20|0||30e2',
          'America/Port-au-Prince|EST EDT|50 40|010101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|23e5',
          'Antarctica/Palmer|-03 -04|30 40|010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|40',
          'America/Santiago|-03 -04|30 40|010101010101010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|62e5',
          'America/Sao_Paulo|-02 -03|20 30|0101010101010101|1GCq0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|20e6',
          'Atlantic/Azores|-01 +00|10 0|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|25e4',
          'America/St_Johns|NST NDT|3u 2u|01010101010101010101010|1GI5u 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|11e4',
          'Antarctica/Casey|+11 +08|-b0 -80|0101|1GAF0 blz0 3m10|10',
          'Antarctica/Davis|+05 +07|-50 -70|01|1GAI0|70',
          'Pacific/Port_Moresby|+10|-a0|0||25e4',
          'Pacific/Guadalcanal|+11|-b0|0||11e4',
          'Asia/Tashkent|+05|-50|0||23e5',
          'Pacific/Auckland|NZDT NZST|-d0 -c0|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|14e5',
          'Asia/Baghdad|+03|-30|0||66e5',
          'Antarctica/Troll|+00 +02|0 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|40',
          'Asia/Dhaka|+06|-60|0||16e6',
          'Asia/Amman|EET EEST|-20 -30|010101010101010101010|1GPy0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00|25e5',
          'Asia/Kamchatka|+12|-c0|0||18e4',
          'Asia/Baku|+04 +05|-40 -50|010101010|1GNA0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5',
          'Asia/Bangkok|+07|-70|0||15e6',
          'Asia/Barnaul|+07 +06|-70 -60|010|1N7v0 3rd0',
          'Asia/Beirut|EET EEST|-20 -30|01010101010101010101010|1GNy0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0|22e5',
          'Asia/Kuala_Lumpur|+08|-80|0||71e5',
          'Asia/Kolkata|IST|-5u|0||15e6',
          'Asia/Chita|+10 +08 +09|-a0 -80 -90|012|1N7s0 3re0|33e4',
          'Asia/Ulaanbaatar|+08 +09|-80 -90|01010|1O8G0 1cJ0 1cP0 1cJ0|12e5',
          'Asia/Shanghai|CST|-80|0||23e6',
          'Asia/Colombo|+0530|-5u|0||22e5',
          'Asia/Damascus|EET EEST|-20 -30|01010101010101010101010|1GPy0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0|26e5',
          'Asia/Dili|+09|-90|0||19e4',
          'Asia/Dubai|+04|-40|0||39e5',
          'Asia/Famagusta|EET EEST +03|-20 -30 -30|0101010101201010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0 2Ks0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0',
          'Asia/Gaza|EET EEST|-20 -30|01010101010101010101010|1GPy0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 WN0 1qL0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 Wo0 1rc0|18e5',
          'Asia/Hong_Kong|HKT|-80|0||73e5',
          'Asia/Hovd|+07 +08|-70 -80|01010|1O8H0 1cJ0 1cP0 1cJ0|81e3',
          'Asia/Irkutsk|+09 +08|-90 -80|01|1N7t0|60e4',
          'Europe/Istanbul|EET EEST +03|-20 -30 -30|01010101012|1GNB0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6',
          'Asia/Jakarta|WIB|-70|0||31e6',
          'Asia/Jayapura|WIT|-90|0||26e4',
          'Asia/Jerusalem|IST IDT|-20 -30|01010101010101010101010|1GPA0 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0|81e4',
          'Asia/Kabul|+0430|-4u|0||46e5',
          'Asia/Karachi|PKT|-50|0||24e6',
          'Asia/Kathmandu|+0545|-5J|0||12e5',
          'Asia/Yakutsk|+10 +09|-a0 -90|01|1N7s0|28e4',
          'Asia/Krasnoyarsk|+08 +07|-80 -70|01|1N7u0|10e5',
          'Asia/Magadan|+12 +10 +11|-c0 -a0 -b0|012|1N7q0 3Cq0|95e3',
          'Asia/Makassar|WITA|-80|0||15e5',
          'Asia/Manila|PST|-80|0||24e6',
          'Europe/Athens|EET EEST|-20 -30|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|35e5',
          'Asia/Novosibirsk|+07 +06|-70 -60|010|1N7v0 4eN0|15e5',
          'Asia/Omsk|+07 +06|-70 -60|01|1N7v0|12e5',
          'Asia/Pyongyang|KST KST|-90 -8u|010|1P4D0 6BA0|29e5',
          'Asia/Qyzylorda|+06 +05|-60 -50|01|1Xei0|73e4',
          'Asia/Rangoon|+0630|-6u|0||48e5',
          'Asia/Sakhalin|+11 +10|-b0 -a0|010|1N7r0 3rd0|58e4',
          'Asia/Seoul|KST|-90|0||23e6',
          'Asia/Srednekolymsk|+12 +11|-c0 -b0|01|1N7q0|35e2',
          'Asia/Tehran|+0330 +0430|-3u -4u|01010101010101010101010|1GLUu 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0|14e6',
          'Asia/Tokyo|JST|-90|0||38e6',
          'Asia/Tomsk|+07 +06|-70 -60|010|1N7v0 3Qp0|10e5',
          'Asia/Vladivostok|+11 +10|-b0 -a0|01|1N7r0|60e4',
          'Asia/Yekaterinburg|+06 +05|-60 -50|01|1N7w0|14e5',
          'Europe/Lisbon|WET WEST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|27e5',
          'Atlantic/Cape_Verde|-01|10|0||50e4',
          'Australia/Sydney|AEDT AEST|-b0 -a0|01010101010101010101010|1GQg0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|40e5',
          'Australia/Adelaide|ACDT ACST|-au -9u|01010101010101010101010|1GQgu 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|11e5',
          'Australia/Brisbane|AEST|-a0|0||20e5',
          'Australia/Darwin|ACST|-9u|0||12e4',
          'Australia/Eucla|+0845|-8J|0||368',
          'Australia/Lord_Howe|+11 +1030|-b0 -au|01010101010101010101010|1GQf0 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu|347',
          'Australia/Perth|AWST|-80|0||18e5',
          'Pacific/Easter|-05 -06|50 60|010101010101010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|30e2',
          'Europe/Dublin|GMT IST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|12e5',
          'Etc/GMT-1|+01|-10|0|',
          'Pacific/Fakaofo|+13|-d0|0||483',
          'Pacific/Kiritimati|+14|-e0|0||51e2',
          'Etc/GMT-2|+02|-20|0|',
          'Pacific/Tahiti|-10|a0|0||18e4',
          'Pacific/Niue|-11|b0|0||12e2',
          'Etc/GMT+12|-12|c0|0|',
          'Pacific/Galapagos|-06|60|0||25e3',
          'Etc/GMT+7|-07|70|0|',
          'Pacific/Pitcairn|-08|80|0||56',
          'Pacific/Gambier|-09|90|0||125',
          'Etc/UTC|UTC|0|0|',
          'Europe/Ulyanovsk|+04 +03|-40 -30|010|1N7y0 3rd0|13e5',
          'Europe/London|GMT BST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|10e6',
          'Europe/Chisinau|EET EEST|-20 -30|01010101010101010101010|1GNA0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|67e4',
          'Europe/Kaliningrad|+03 EET|-30 -20|01|1N7z0|44e4',
          'Europe/Kirov|+04 +03|-40 -30|01|1N7y0|48e4',
          'Europe/Moscow|MSK MSK|-40 -30|01|1N7y0|16e6',
          'Europe/Saratov|+04 +03|-40 -30|010|1N7y0 5810',
          'Europe/Simferopol|EET EEST MSK MSK|-20 -30 -40 -30|0101023|1GNB0 1qM0 11A0 1o00 11z0 1nW0|33e4',
          'Europe/Volgograd|+04 +03|-40 -30|010|1N7y0 9Jd0|10e5',
          'Pacific/Honolulu|HST|a0|0||37e4',
          'MET|MET MEST|-10 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0',
          'Pacific/Chatham|+1345 +1245|-dJ -cJ|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|600',
          'Pacific/Apia|+14 +13|-e0 -d0|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|37e3',
          'Pacific/Bougainville|+10 +11|-a0 -b0|01|1NwE0|18e4',
          'Pacific/Fiji|+13 +12|-d0 -c0|01010101010101010101010|1Goe0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 s00 1VA0 uM0 1SM0 uM0 1VA0 s00 1VA0|88e4',
          'Pacific/Guam|ChST|-a0|0||17e4',
          'Pacific/Marquesas|-0930|9u|0||86e2',
          'Pacific/Pago_Pago|SST|b0|0||37e2',
          'Pacific/Norfolk|+1130 +11|-bu -b0|01|1PoCu|25e4',
          'Pacific/Tongatapu|+13 +14|-d0 -e0|010|1S4d0 s00|75e3',
        ],
        links: [
          'Africa/Abidjan|Africa/Accra',
          'Africa/Abidjan|Africa/Bamako',
          'Africa/Abidjan|Africa/Banjul',
          'Africa/Abidjan|Africa/Bissau',
          'Africa/Abidjan|Africa/Conakry',
          'Africa/Abidjan|Africa/Dakar',
          'Africa/Abidjan|Africa/Freetown',
          'Africa/Abidjan|Africa/Lome',
          'Africa/Abidjan|Africa/Monrovia',
          'Africa/Abidjan|Africa/Nouakchott',
          'Africa/Abidjan|Africa/Ouagadougou',
          'Africa/Abidjan|Africa/Timbuktu',
          'Africa/Abidjan|America/Danmarkshavn',
          'Africa/Abidjan|Atlantic/Reykjavik',
          'Africa/Abidjan|Atlantic/St_Helena',
          'Africa/Abidjan|Etc/GMT',
          'Africa/Abidjan|Etc/GMT+0',
          'Africa/Abidjan|Etc/GMT-0',
          'Africa/Abidjan|Etc/GMT0',
          'Africa/Abidjan|Etc/Greenwich',
          'Africa/Abidjan|GMT',
          'Africa/Abidjan|GMT+0',
          'Africa/Abidjan|GMT-0',
          'Africa/Abidjan|GMT0',
          'Africa/Abidjan|Greenwich',
          'Africa/Abidjan|Iceland',
          'Africa/Algiers|Africa/Tunis',
          'Africa/Cairo|Egypt',
          'Africa/Casablanca|Africa/El_Aaiun',
          'Africa/Johannesburg|Africa/Maseru',
          'Africa/Johannesburg|Africa/Mbabane',
          'Africa/Lagos|Africa/Bangui',
          'Africa/Lagos|Africa/Brazzaville',
          'Africa/Lagos|Africa/Douala',
          'Africa/Lagos|Africa/Kinshasa',
          'Africa/Lagos|Africa/Libreville',
          'Africa/Lagos|Africa/Luanda',
          'Africa/Lagos|Africa/Malabo',
          'Africa/Lagos|Africa/Ndjamena',
          'Africa/Lagos|Africa/Niamey',
          'Africa/Lagos|Africa/Porto-Novo',
          'Africa/Maputo|Africa/Blantyre',
          'Africa/Maputo|Africa/Bujumbura',
          'Africa/Maputo|Africa/Gaborone',
          'Africa/Maputo|Africa/Harare',
          'Africa/Maputo|Africa/Kigali',
          'Africa/Maputo|Africa/Lubumbashi',
          'Africa/Maputo|Africa/Lusaka',
          'Africa/Nairobi|Africa/Addis_Ababa',
          'Africa/Nairobi|Africa/Asmara',
          'Africa/Nairobi|Africa/Asmera',
          'Africa/Nairobi|Africa/Dar_es_Salaam',
          'Africa/Nairobi|Africa/Djibouti',
          'Africa/Nairobi|Africa/Juba',
          'Africa/Nairobi|Africa/Kampala',
          'Africa/Nairobi|Africa/Mogadishu',
          'Africa/Nairobi|Indian/Antananarivo',
          'Africa/Nairobi|Indian/Comoro',
          'Africa/Nairobi|Indian/Mayotte',
          'Africa/Tripoli|Libya',
          'America/Adak|America/Atka',
          'America/Adak|US/Aleutian',
          'America/Anchorage|America/Juneau',
          'America/Anchorage|America/Nome',
          'America/Anchorage|America/Sitka',
          'America/Anchorage|America/Yakutat',
          'America/Anchorage|US/Alaska',
          'America/Campo_Grande|America/Cuiaba',
          'America/Chicago|America/Indiana/Knox',
          'America/Chicago|America/Indiana/Tell_City',
          'America/Chicago|America/Knox_IN',
          'America/Chicago|America/Matamoros',
          'America/Chicago|America/Menominee',
          'America/Chicago|America/North_Dakota/Beulah',
          'America/Chicago|America/North_Dakota/Center',
          'America/Chicago|America/North_Dakota/New_Salem',
          'America/Chicago|America/Rainy_River',
          'America/Chicago|America/Rankin_Inlet',
          'America/Chicago|America/Resolute',
          'America/Chicago|America/Winnipeg',
          'America/Chicago|CST6CDT',
          'America/Chicago|Canada/Central',
          'America/Chicago|US/Central',
          'America/Chicago|US/Indiana-Starke',
          'America/Chihuahua|America/Mazatlan',
          'America/Chihuahua|Mexico/BajaSur',
          'America/Denver|America/Boise',
          'America/Denver|America/Cambridge_Bay',
          'America/Denver|America/Edmonton',
          'America/Denver|America/Inuvik',
          'America/Denver|America/Ojinaga',
          'America/Denver|America/Shiprock',
          'America/Denver|America/Yellowknife',
          'America/Denver|Canada/Mountain',
          'America/Denver|MST7MDT',
          'America/Denver|Navajo',
          'America/Denver|US/Mountain',
          'America/Fortaleza|America/Argentina/Buenos_Aires',
          'America/Fortaleza|America/Argentina/Catamarca',
          'America/Fortaleza|America/Argentina/ComodRivadavia',
          'America/Fortaleza|America/Argentina/Cordoba',
          'America/Fortaleza|America/Argentina/Jujuy',
          'America/Fortaleza|America/Argentina/La_Rioja',
          'America/Fortaleza|America/Argentina/Mendoza',
          'America/Fortaleza|America/Argentina/Rio_Gallegos',
          'America/Fortaleza|America/Argentina/Salta',
          'America/Fortaleza|America/Argentina/San_Juan',
          'America/Fortaleza|America/Argentina/San_Luis',
          'America/Fortaleza|America/Argentina/Tucuman',
          'America/Fortaleza|America/Argentina/Ushuaia',
          'America/Fortaleza|America/Belem',
          'America/Fortaleza|America/Buenos_Aires',
          'America/Fortaleza|America/Catamarca',
          'America/Fortaleza|America/Cayenne',
          'America/Fortaleza|America/Cordoba',
          'America/Fortaleza|America/Jujuy',
          'America/Fortaleza|America/Maceio',
          'America/Fortaleza|America/Mendoza',
          'America/Fortaleza|America/Paramaribo',
          'America/Fortaleza|America/Recife',
          'America/Fortaleza|America/Rosario',
          'America/Fortaleza|America/Santarem',
          'America/Fortaleza|Antarctica/Rothera',
          'America/Fortaleza|Atlantic/Stanley',
          'America/Fortaleza|Etc/GMT+3',
          'America/Halifax|America/Glace_Bay',
          'America/Halifax|America/Goose_Bay',
          'America/Halifax|America/Moncton',
          'America/Halifax|America/Thule',
          'America/Halifax|Atlantic/Bermuda',
          'America/Halifax|Canada/Atlantic',
          'America/Havana|Cuba',
          'America/La_Paz|America/Boa_Vista',
          'America/La_Paz|America/Guyana',
          'America/La_Paz|America/Manaus',
          'America/La_Paz|America/Porto_Velho',
          'America/La_Paz|Brazil/West',
          'America/La_Paz|Etc/GMT+4',
          'America/Lima|America/Bogota',
          'America/Lima|America/Guayaquil',
          'America/Lima|Etc/GMT+5',
          'America/Los_Angeles|America/Dawson',
          'America/Los_Angeles|America/Ensenada',
          'America/Los_Angeles|America/Santa_Isabel',
          'America/Los_Angeles|America/Tijuana',
          'America/Los_Angeles|America/Vancouver',
          'America/Los_Angeles|America/Whitehorse',
          'America/Los_Angeles|Canada/Pacific',
          'America/Los_Angeles|Canada/Yukon',
          'America/Los_Angeles|Mexico/BajaNorte',
          'America/Los_Angeles|PST8PDT',
          'America/Los_Angeles|US/Pacific',
          'America/Los_Angeles|US/Pacific-New',
          'America/Managua|America/Belize',
          'America/Managua|America/Costa_Rica',
          'America/Managua|America/El_Salvador',
          'America/Managua|America/Guatemala',
          'America/Managua|America/Regina',
          'America/Managua|America/Swift_Current',
          'America/Managua|America/Tegucigalpa',
          'America/Managua|Canada/Saskatchewan',
          'America/Mexico_City|America/Bahia_Banderas',
          'America/Mexico_City|America/Merida',
          'America/Mexico_City|America/Monterrey',
          'America/Mexico_City|Mexico/General',
          'America/New_York|America/Detroit',
          'America/New_York|America/Fort_Wayne',
          'America/New_York|America/Indiana/Indianapolis',
          'America/New_York|America/Indiana/Marengo',
          'America/New_York|America/Indiana/Petersburg',
          'America/New_York|America/Indiana/Vevay',
          'America/New_York|America/Indiana/Vincennes',
          'America/New_York|America/Indiana/Winamac',
          'America/New_York|America/Indianapolis',
          'America/New_York|America/Iqaluit',
          'America/New_York|America/Kentucky/Louisville',
          'America/New_York|America/Kentucky/Monticello',
          'America/New_York|America/Louisville',
          'America/New_York|America/Montreal',
          'America/New_York|America/Nassau',
          'America/New_York|America/Nipigon',
          'America/New_York|America/Pangnirtung',
          'America/New_York|America/Thunder_Bay',
          'America/New_York|America/Toronto',
          'America/New_York|Canada/Eastern',
          'America/New_York|EST5EDT',
          'America/New_York|US/East-Indiana',
          'America/New_York|US/Eastern',
          'America/New_York|US/Michigan',
          'America/Noronha|Atlantic/South_Georgia',
          'America/Noronha|Brazil/DeNoronha',
          'America/Noronha|Etc/GMT+2',
          'America/Panama|America/Atikokan',
          'America/Panama|America/Cayman',
          'America/Panama|America/Coral_Harbour',
          'America/Panama|America/Jamaica',
          'America/Panama|EST',
          'America/Panama|Jamaica',
          'America/Phoenix|America/Creston',
          'America/Phoenix|America/Dawson_Creek',
          'America/Phoenix|America/Hermosillo',
          'America/Phoenix|MST',
          'America/Phoenix|US/Arizona',
          'America/Rio_Branco|America/Eirunepe',
          'America/Rio_Branco|America/Porto_Acre',
          'America/Rio_Branco|Brazil/Acre',
          'America/Santiago|Chile/Continental',
          'America/Santo_Domingo|America/Anguilla',
          'America/Santo_Domingo|America/Antigua',
          'America/Santo_Domingo|America/Aruba',
          'America/Santo_Domingo|America/Barbados',
          'America/Santo_Domingo|America/Blanc-Sablon',
          'America/Santo_Domingo|America/Curacao',
          'America/Santo_Domingo|America/Dominica',
          'America/Santo_Domingo|America/Grenada',
          'America/Santo_Domingo|America/Guadeloupe',
          'America/Santo_Domingo|America/Kralendijk',
          'America/Santo_Domingo|America/Lower_Princes',
          'America/Santo_Domingo|America/Marigot',
          'America/Santo_Domingo|America/Martinique',
          'America/Santo_Domingo|America/Montserrat',
          'America/Santo_Domingo|America/Port_of_Spain',
          'America/Santo_Domingo|America/Puerto_Rico',
          'America/Santo_Domingo|America/St_Barthelemy',
          'America/Santo_Domingo|America/St_Kitts',
          'America/Santo_Domingo|America/St_Lucia',
          'America/Santo_Domingo|America/St_Thomas',
          'America/Santo_Domingo|America/St_Vincent',
          'America/Santo_Domingo|America/Tortola',
          'America/Santo_Domingo|America/Virgin',
          'America/Sao_Paulo|Brazil/East',
          'America/St_Johns|Canada/Newfoundland',
          'Antarctica/Palmer|America/Punta_Arenas',
          'Asia/Baghdad|Antarctica/Syowa',
          'Asia/Baghdad|Asia/Aden',
          'Asia/Baghdad|Asia/Bahrain',
          'Asia/Baghdad|Asia/Kuwait',
          'Asia/Baghdad|Asia/Qatar',
          'Asia/Baghdad|Asia/Riyadh',
          'Asia/Baghdad|Etc/GMT-3',
          'Asia/Baghdad|Europe/Minsk',
          'Asia/Bangkok|Asia/Ho_Chi_Minh',
          'Asia/Bangkok|Asia/Novokuznetsk',
          'Asia/Bangkok|Asia/Phnom_Penh',
          'Asia/Bangkok|Asia/Saigon',
          'Asia/Bangkok|Asia/Vientiane',
          'Asia/Bangkok|Etc/GMT-7',
          'Asia/Bangkok|Indian/Christmas',
          'Asia/Dhaka|Antarctica/Vostok',
          'Asia/Dhaka|Asia/Almaty',
          'Asia/Dhaka|Asia/Bishkek',
          'Asia/Dhaka|Asia/Dacca',
          'Asia/Dhaka|Asia/Kashgar',
          'Asia/Dhaka|Asia/Qostanay',
          'Asia/Dhaka|Asia/Thimbu',
          'Asia/Dhaka|Asia/Thimphu',
          'Asia/Dhaka|Asia/Urumqi',
          'Asia/Dhaka|Etc/GMT-6',
          'Asia/Dhaka|Indian/Chagos',
          'Asia/Dili|Etc/GMT-9',
          'Asia/Dili|Pacific/Palau',
          'Asia/Dubai|Asia/Muscat',
          'Asia/Dubai|Asia/Tbilisi',
          'Asia/Dubai|Asia/Yerevan',
          'Asia/Dubai|Etc/GMT-4',
          'Asia/Dubai|Europe/Samara',
          'Asia/Dubai|Indian/Mahe',
          'Asia/Dubai|Indian/Mauritius',
          'Asia/Dubai|Indian/Reunion',
          'Asia/Gaza|Asia/Hebron',
          'Asia/Hong_Kong|Hongkong',
          'Asia/Jakarta|Asia/Pontianak',
          'Asia/Jerusalem|Asia/Tel_Aviv',
          'Asia/Jerusalem|Israel',
          'Asia/Kamchatka|Asia/Anadyr',
          'Asia/Kamchatka|Etc/GMT-12',
          'Asia/Kamchatka|Kwajalein',
          'Asia/Kamchatka|Pacific/Funafuti',
          'Asia/Kamchatka|Pacific/Kwajalein',
          'Asia/Kamchatka|Pacific/Majuro',
          'Asia/Kamchatka|Pacific/Nauru',
          'Asia/Kamchatka|Pacific/Tarawa',
          'Asia/Kamchatka|Pacific/Wake',
          'Asia/Kamchatka|Pacific/Wallis',
          'Asia/Kathmandu|Asia/Katmandu',
          'Asia/Kolkata|Asia/Calcutta',
          'Asia/Kuala_Lumpur|Asia/Brunei',
          'Asia/Kuala_Lumpur|Asia/Kuching',
          'Asia/Kuala_Lumpur|Asia/Singapore',
          'Asia/Kuala_Lumpur|Etc/GMT-8',
          'Asia/Kuala_Lumpur|Singapore',
          'Asia/Makassar|Asia/Ujung_Pandang',
          'Asia/Rangoon|Asia/Yangon',
          'Asia/Rangoon|Indian/Cocos',
          'Asia/Seoul|ROK',
          'Asia/Shanghai|Asia/Chongqing',
          'Asia/Shanghai|Asia/Chungking',
          'Asia/Shanghai|Asia/Harbin',
          'Asia/Shanghai|Asia/Macao',
          'Asia/Shanghai|Asia/Macau',
          'Asia/Shanghai|Asia/Taipei',
          'Asia/Shanghai|PRC',
          'Asia/Shanghai|ROC',
          'Asia/Tashkent|Antarctica/Mawson',
          'Asia/Tashkent|Asia/Aqtau',
          'Asia/Tashkent|Asia/Aqtobe',
          'Asia/Tashkent|Asia/Ashgabat',
          'Asia/Tashkent|Asia/Ashkhabad',
          'Asia/Tashkent|Asia/Atyrau',
          'Asia/Tashkent|Asia/Dushanbe',
          'Asia/Tashkent|Asia/Oral',
          'Asia/Tashkent|Asia/Samarkand',
          'Asia/Tashkent|Etc/GMT-5',
          'Asia/Tashkent|Indian/Kerguelen',
          'Asia/Tashkent|Indian/Maldives',
          'Asia/Tehran|Iran',
          'Asia/Tokyo|Japan',
          'Asia/Ulaanbaatar|Asia/Choibalsan',
          'Asia/Ulaanbaatar|Asia/Ulan_Bator',
          'Asia/Vladivostok|Asia/Ust-Nera',
          'Asia/Yakutsk|Asia/Khandyga',
          'Atlantic/Azores|America/Scoresbysund',
          'Atlantic/Cape_Verde|Etc/GMT+1',
          'Australia/Adelaide|Australia/Broken_Hill',
          'Australia/Adelaide|Australia/South',
          'Australia/Adelaide|Australia/Yancowinna',
          'Australia/Brisbane|Australia/Lindeman',
          'Australia/Brisbane|Australia/Queensland',
          'Australia/Darwin|Australia/North',
          'Australia/Lord_Howe|Australia/LHI',
          'Australia/Perth|Australia/West',
          'Australia/Sydney|Australia/ACT',
          'Australia/Sydney|Australia/Canberra',
          'Australia/Sydney|Australia/Currie',
          'Australia/Sydney|Australia/Hobart',
          'Australia/Sydney|Australia/Melbourne',
          'Australia/Sydney|Australia/NSW',
          'Australia/Sydney|Australia/Tasmania',
          'Australia/Sydney|Australia/Victoria',
          'Etc/UTC|Etc/UCT',
          'Etc/UTC|Etc/Universal',
          'Etc/UTC|Etc/Zulu',
          'Etc/UTC|UCT',
          'Etc/UTC|UTC',
          'Etc/UTC|Universal',
          'Etc/UTC|Zulu',
          'Europe/Athens|Asia/Nicosia',
          'Europe/Athens|EET',
          'Europe/Athens|Europe/Bucharest',
          'Europe/Athens|Europe/Helsinki',
          'Europe/Athens|Europe/Kiev',
          'Europe/Athens|Europe/Mariehamn',
          'Europe/Athens|Europe/Nicosia',
          'Europe/Athens|Europe/Riga',
          'Europe/Athens|Europe/Sofia',
          'Europe/Athens|Europe/Tallinn',
          'Europe/Athens|Europe/Uzhgorod',
          'Europe/Athens|Europe/Vilnius',
          'Europe/Athens|Europe/Zaporozhye',
          'Europe/Chisinau|Europe/Tiraspol',
          'Europe/Dublin|Eire',
          'Europe/Istanbul|Asia/Istanbul',
          'Europe/Istanbul|Turkey',
          'Europe/Lisbon|Atlantic/Canary',
          'Europe/Lisbon|Atlantic/Faeroe',
          'Europe/Lisbon|Atlantic/Faroe',
          'Europe/Lisbon|Atlantic/Madeira',
          'Europe/Lisbon|Portugal',
          'Europe/Lisbon|WET',
          'Europe/London|Europe/Belfast',
          'Europe/London|Europe/Guernsey',
          'Europe/London|Europe/Isle_of_Man',
          'Europe/London|Europe/Jersey',
          'Europe/London|GB',
          'Europe/London|GB-Eire',
          'Europe/Moscow|W-SU',
          'Europe/Paris|Africa/Ceuta',
          'Europe/Paris|Arctic/Longyearbyen',
          'Europe/Paris|Atlantic/Jan_Mayen',
          'Europe/Paris|CET',
          'Europe/Paris|Europe/Amsterdam',
          'Europe/Paris|Europe/Andorra',
          'Europe/Paris|Europe/Belgrade',
          'Europe/Paris|Europe/Berlin',
          'Europe/Paris|Europe/Bratislava',
          'Europe/Paris|Europe/Brussels',
          'Europe/Paris|Europe/Budapest',
          'Europe/Paris|Europe/Busingen',
          'Europe/Paris|Europe/Copenhagen',
          'Europe/Paris|Europe/Gibraltar',
          'Europe/Paris|Europe/Ljubljana',
          'Europe/Paris|Europe/Luxembourg',
          'Europe/Paris|Europe/Madrid',
          'Europe/Paris|Europe/Malta',
          'Europe/Paris|Europe/Monaco',
          'Europe/Paris|Europe/Oslo',
          'Europe/Paris|Europe/Podgorica',
          'Europe/Paris|Europe/Prague',
          'Europe/Paris|Europe/Rome',
          'Europe/Paris|Europe/San_Marino',
          'Europe/Paris|Europe/Sarajevo',
          'Europe/Paris|Europe/Skopje',
          'Europe/Paris|Europe/Stockholm',
          'Europe/Paris|Europe/Tirane',
          'Europe/Paris|Europe/Vaduz',
          'Europe/Paris|Europe/Vatican',
          'Europe/Paris|Europe/Vienna',
          'Europe/Paris|Europe/Warsaw',
          'Europe/Paris|Europe/Zagreb',
          'Europe/Paris|Europe/Zurich',
          'Europe/Paris|Poland',
          'Europe/Ulyanovsk|Europe/Astrakhan',
          'Pacific/Auckland|Antarctica/McMurdo',
          'Pacific/Auckland|Antarctica/South_Pole',
          'Pacific/Auckland|NZ',
          'Pacific/Chatham|NZ-CHAT',
          'Pacific/Easter|Chile/EasterIsland',
          'Pacific/Fakaofo|Etc/GMT-13',
          'Pacific/Fakaofo|Pacific/Enderbury',
          'Pacific/Galapagos|Etc/GMT+6',
          'Pacific/Gambier|Etc/GMT+9',
          'Pacific/Guadalcanal|Antarctica/Macquarie',
          'Pacific/Guadalcanal|Etc/GMT-11',
          'Pacific/Guadalcanal|Pacific/Efate',
          'Pacific/Guadalcanal|Pacific/Kosrae',
          'Pacific/Guadalcanal|Pacific/Noumea',
          'Pacific/Guadalcanal|Pacific/Pohnpei',
          'Pacific/Guadalcanal|Pacific/Ponape',
          'Pacific/Guam|Pacific/Saipan',
          'Pacific/Honolulu|HST',
          'Pacific/Honolulu|Pacific/Johnston',
          'Pacific/Honolulu|US/Hawaii',
          'Pacific/Kiritimati|Etc/GMT-14',
          'Pacific/Niue|Etc/GMT+11',
          'Pacific/Pago_Pago|Pacific/Midway',
          'Pacific/Pago_Pago|Pacific/Samoa',
          'Pacific/Pago_Pago|US/Samoa',
          'Pacific/Pitcairn|Etc/GMT+8',
          'Pacific/Port_Moresby|Antarctica/DumontDUrville',
          'Pacific/Port_Moresby|Etc/GMT-10',
          'Pacific/Port_Moresby|Pacific/Chuuk',
          'Pacific/Port_Moresby|Pacific/Truk',
          'Pacific/Port_Moresby|Pacific/Yap',
          'Pacific/Tahiti|Etc/GMT+10',
          'Pacific/Tahiti|Pacific/Rarotonga',
        ],
      }),
      c
    )
  }),
  (function (window) {
    var ZenkitErrorCodes = {
      UNKNOWN_ERROR: {
        code: 'S1',
        statusCode: 500,
        name: 'Unknown Error',
        nameTranslateId: 'ERRORS.UNKNOWN_ERROR.NAME',
        description: 'Something went wrong, sorry about that.',
        descriptionTranslateId: 'ERRORS.UNKNOWN_ERROR.DESCRIPTION',
      },
      NO_SESSION: {
        code: 'S2',
        statusCode: 500,
        name: 'No session',
        description: 'No session found, please refresh your browser window.',
      },
      RESOURCE_CHANGE_FAILED: {
        code: 'S3',
        statusCode: 500,
        name: 'Resource could not be changed',
        description: 'Resource could not be changed.',
      },
      GUEST: {
        code: 'S4',
        statusCode: 500,
        name: 'You need to be logged in to view this content.',
        description: 'You need to be logged in to view this content.',
      },
      NOT_AVAILABLE_OFFLINE: {
        code: 'S6',
        statusCode: 500,
        name: 'Not available offline',
        nameTranslateId: 'ERRORS.NOT_AVAILABLE_OFFLINE.NAME',
        description: 'This feature is not available in offline mode.',
        descriptionTranslateId: 'ERRORS.NOT_AVAILABLE_OFFLINE.DESCRIPTION',
      },
      TIMEOUT: {
        code: 'S7',
        statusCode: 500,
        name: 'Operation timed out',
        description: 'The request took too long to complete. Please try again.',
      },
      MAINTENANCE: {
        code: 'S8',
        statusCode: 503,
        name: 'Maintenance',
        nameTranslateId: 'ERRORS.MAINTENANCE.NAME',
        description: 'Zenkit is currently unavailable due to scheduled maintenance. Please try again later.',
        descriptionTranslateId: 'ERRORS.MAINTENANCE.DESCRIPTION',
      },
      BAD_REQUEST: { code: 'C1', statusCode: 400, name: 'Bad Request', description: 'The request was malformed.' },
      MISSING_PARAMETERS: {
        code: 'C5',
        statusCode: 400,
        name: 'Missing parameters',
        nameTranslateId: 'ERRORS.MISSING_PARAMETERS.NAME',
        description: 'Some required parameters are missing from this request.',
        descriptionTranslateId: 'ERRORS.MISSING_PARAMETERS.DESCRIPTION',
      },
      SPREADSHEET_PARSING_ERROR: {
        code: 'C6',
        statusCode: 400,
        name: 'spreadsheet parsing failed',
        description: 'We were not able to parse this spreadsheet.',
      },
      MIGRATION_NOT_AVAILABLE: {
        code: 'C7',
        statusCode: 400,
        name: 'Conversion not available',
        description: 'This conversion is not offered, yet.',
      },
      MIGRATION_FAILED: {
        code: 'C8',
        statusCode: 400,
        name: 'Conversion failed',
        description: 'Your data might have the wrong format.',
      },
      LIST_IS_MIGRATING: {
        code: 'C9',
        statusCode: 400,
        name: 'Collection is converting',
        description: 'This collection is converting, please try again in a moment.',
      },
      LIST_IS_DEPRECATED: {
        code: 'C10',
        statusCode: 400,
        name: 'Collection is archived',
        description: 'This collection has been archived.',
      },
      DATABASE_IS_MIGRATING: {
        code: 'C11',
        statusCode: 400,
        name: 'Maintenance in progress',
        description:
          'We are doing some maintainance work right now. Sorry for the inconvenience, please check back again soon.',
      },
      LIST_IS_UPGRADING: {
        code: 'C12',
        statusCode: 400,
        name: 'Collection is upgrading',
        description:
          'The collection you are trying to access is currently being updated to the newest version of Zenkit. Please try again in a few minutes',
      },
      LIST_HAS_NO_TASK_ELEMENT: {
        code: 'C13',
        statusCode: 400,
        name: 'There is no task field',
        description:
          'The collection needs to have at least one label field with 2 or more labels in order to be a task collection',
      },
      RESOURCE_ALREADY_EXISTS: {
        code: 'C14',
        statusCode: 400,
        name: 'It seems like this resource has already been created.',
        description: 'There is already a resource that matches the given identifiers.',
      },
      LIST_ELEMENT_DESCRIPTION_TOO_LONG: {
        code: 'C15',
        statusCode: 400,
        name: 'Field description is too long.',
        description: "The field description can't be longer than 65535 characters.",
      },
      CANNOT_UPDATE_STATIC_LIST_ELEMENT: {
        code: 'C17',
        statusCode: 400,
        name: 'Field is static.',
        description: "You can't update static fields.",
      },
      LIST_HAS_NO_CALENDAR_SYNC_SETTINGS: {
        code: 'C18',
        statusCode: 400,
        name: 'Collection not synchronized',
        description: 'The collection has no calendar synchronization settings.',
      },
      CANT_DELETE_USER_WITH_PAID_PLAN: {
        code: 'C19',
        statusCode: 400,
        name: 'Accounts with an active subscription cannot be deleted.',
        description: 'Please cancel your Zenkit subscription before you delete your account.',
      },
      RESOURCE_ALREADY_DEPRECATED: {
        code: 'C20',
        statusCode: 400,
        name: 'It seems like this resource has already been deprecated.',
        description: 'It seems like this resource has already been deprecated.',
      },
      API_VALIDATION_FAILED: {
        code: 'C21',
        statusCode: 400,
        name: 'Invalid parameters',
        nameTranslateId: 'ERRORS.API_VALIDATION_FAILED.NAME',
        description: 'Some parameters were missing or invalid. Please check our documentation.',
        descriptionTranslateId: 'ERRORS.API_VALIDATION_FAILED.DESCRIPTION',
      },
      ACTIVITY_ALREADY_HAS_ENTRY_ENRICHMENT: {
        code: 'C22',
        statusCode: 400,
        name: 'Activity already has an attached entry for the target list.',
        description: 'This probably means that the activity has already been converted to an entry.',
      },
      NOT_FOUND: {
        code: 'C2',
        statusCode: 404,
        name: 'Resource not found',
        nameTranslateId: 'ERRORS.NOT_FOUND.NAME',
        description: 'The requested resource could not be found.',
        descriptionTranslateId: 'ERRORS.NOT_FOUND.DESCRIPTION',
      },
      NO_PUBLIC_VIEW_FOUND: {
        code: 'C3',
        statusCode: 404,
        name: 'No public view found',
        description: 'There is no public view for this collection.',
      },
      LIST_ELEMENT_NOT_FOUND: {
        code: 'C16',
        statusCode: 404,
        name: 'Field not found.',
        description: 'We could not find the field.',
      },
      QUOTA_EXCEEDED: {
        code: 'D1',
        statusCode: 400,
        name: 'Quota exceeded',
        description: 'You have reached the limit of your current plan. Please upgrade to continue.',
      },
      API_LIMIT_EXCEEDED: {
        code: 'D2',
        statusCode: 400,
        name: 'Limit reached',
        description: 'You have reached a fixed limit of the API (spam protection).',
      },
      TIMESTAMP_INVALID: {
        code: 'E1',
        statusCode: 400,
        name: 'Timestamp invalid',
        nameTranslateId: 'ERRORS.TIMESTAMP_INVALID.NAME',
        description: 'This link has expired. Please request a new link.',
        descriptionTranslateId: 'ERRORS.TIMESTAMP_INVALID.DESCRIPTION',
      },
      HASH_INVALID: {
        code: 'E2',
        statusCode: 400,
        name: 'Hash invalid',
        description: 'This link might have been disabled or was used already.',
      },
      NOT_ELIGIBLE: {
        code: 'E3',
        statusCode: 400,
        name: 'Not eligible',
        description: 'This resource is not eligible.',
      },
      SESSION_EXPIRED: {
        code: 'A1',
        statusCode: 401,
        name: 'Session not valid',
        description: 'Your session is not valid anymore, it might have expired. Please refresh your browser window.',
      },
      PASSWORD_CHECK_FAILED: {
        code: 'A3',
        statusCode: 400,
        name: 'Password was not accepted',
        nameTranslateId: 'ERRORS.PASSWORD_CHECK_FAILED.NAME',
        description:
          'Your password does not conform to the minimum requirements. Please use 8 characters or more and include at least one number.',
        descriptionTranslateId: 'ERRORS.PASSWORD_CHECK_FAILED.DESCRIPTION',
      },
      FORBIDDEN: {
        code: 'A5',
        statusCode: 403,
        name: 'Access denied',
        nameTranslateId: 'ERRORS.FORBIDDEN.NAME',
        description: 'Access denied',
        descriptionTranslateId: 'ERRORS.FORBIDDEN.DESCRIPTION',
      },
      API_KEY_INVALID: {
        code: 'A6',
        statusCode: 401,
        name: 'API key invalid',
        description: 'Your API key is not valid.',
      },
      MISSING_PERMISSIONS: {
        code: 'A7',
        statusCode: 403,
        name: 'Missing Permissions',
        nameTranslateId: 'ERRORS.MISSING_PERMISSIONS.NAME',
        description: 'Missing Permissions.',
        descriptionTranslateId: 'ERRORS.MISSING_PERMISSIONS.NAME',
      },
      PASSWORD_BLACKLISTED: {
        code: 'A8',
        statusCode: 400,
        name: 'Password is known',
        nameTranslateId: 'ERRORS.PASSWORD_BLACKLISTED.NAME',
        description: 'Your password is blacklisted because it is too commonly used. Please use a different one.',
        descriptionTranslateId: 'ERRORS.PASSWORD_BLACKLISTED.DESCRIPTION',
      },
      PASSWORD_MISMATCH: {
        code: 'A9',
        statusCode: 400,
        name: 'Password was not accepted',
        description: 'Incorrect password. Please try again.',
        descriptionTranslateId: 'ERRORS.PASSWORD_MISMATCH.DESCRIPTION',
      },
      SAML_LOGIN_REQUIRED: {
        code: 'A10',
        statusCode: 403,
        name: 'SSO Login',
        description: 'Login through SSO is required.',
      },
      SAML_INVALID_FORMAT: {
        code: 'A11',
        statusCode: 403,
        name: 'SSO Login',
        description: 'The name identifier format must be an email address.',
      },
      SAML_INVALID_EMAIL: {
        code: 'A12',
        statusCode: 403,
        name: 'SSO Login',
        description: 'The name identifier value must be a valid email address.',
      },
      SAML_EMAIL_CLAIM: {
        code: 'A13',
        statusCode: 403,
        name: 'SSO Login',
        description: 'The name identifier value did not match the email address claim.',
      },
      FILETYPE_NOT_SUPPORTED: {
        code: 'FT1',
        statusCode: 400,
        name: 'Filetype not supported',
        description: 'The filetype is not supported',
      },
      FILEPROCESSING_GETAWS_ERROR: {
        code: 'FP1',
        statusCode: 400,
        name: 'Jimp read file error',
        description: 'Jimp can nit read the give file',
      },
      FILEPROCESSING_RESIZE_ERROR: {
        code: 'FP2',
        statusCode: 400,
        name: 'Jimp resize error',
        description: 'Jimp can not resize given image',
      },
      FILEPROCESSING_CROP_ERROR: {
        code: 'FP3',
        statusCode: 400,
        name: 'Jimp crop error',
        description: 'Jimp can not crop given image',
      },
      FORMULA_CYCLIC: {
        code: 'FORM1',
        statusCode: 400,
        name: 'Cyclic formula',
        description:
          'Cyclic formula detected. Please remove any self-references or references to formulas that use this field.',
      },
      FORMULA_UNKNOWN_CHARACTER: {
        code: 'FORM2',
        statusCode: 400,
        name: 'Unexpected character',
        description: "Syntax error: Character '$2' is not allowed at position $1.",
      },
      FORMULA_UNKNOWN_ELEMENT: {
        code: 'FORM3',
        statusCode: 400,
        name: 'Unknown element',
        description: 'Field $1 does not exist in this collection.',
      },
      FORMULA_UNKNOWN_REFERENCE: {
        code: 'FORM4',
        statusCode: 400,
        name: 'Unknown reference',
        description: 'There is no reference field $1.',
      },
      FORMULA_UNKNOWN_ELEMENT_IN_REFERENCE: {
        code: 'FORM5',
        statusCode: 400,
        name: 'Unknown element in reference',
        description: 'Field $1 does not exist in entries referenced by $2.',
      },
      FORMULA_DEPRECATED_LIST: {
        code: 'FORM6',
        statusCode: 400,
        name: 'Deprecated Collection',
        description: 'Field $1 is pointing to a collection that has been deleted.',
      },
      FORMULA_DIVISION_BY_ZERO: {
        code: 'FORM7',
        statusCode: 400,
        name: 'Division by zero',
        description: 'You are attempting to perform a division by zero.',
      },
      DEPENDENCIES_CYCLE: {
        code: 'DEPENDENCIES_CYCLE',
        statusCode: 400,
        name: 'Cyclic dependencies',
        description: 'Cyclic dependencies detected.',
      },
      FORBIDDEN_BY_ORGANIZATION: {
        code: 'FORBIDDEN_BY_ORGANIZATION',
        statusCode: 400,
        name: 'Not allowed in organization',
        description: 'The organization does not allow this action.',
      },
      CAMPAIGN_MONITOR_INVALID_ADDRESS: {
        code: 'CAMPMON1',
        statusCode: 400,
        name: 'Invalid email address',
        description: 'Email address is missing or incorrectly formatted.',
      },
      CAMPAIGN_MONITOR_SUBSCRIBER_NOT_IN_LIST: {
        code: 'CAMPMON2',
        statusCode: 400,
        name: 'No such subscriber',
        description: "Couldn't find a subscriber with this email in the list.",
      },
      CAMPAIGN_MONITOR_UNKNOWN_PARAMETER: {
        code: 'CAMPMON3',
        statusCode: 400,
        name: 'Unknown parameter',
        description: 'The request contained an unknown parameter.',
      },
      CAMPAIGN_MONITOR_INVALID_REQUEST: {
        code: 'CAMPMON4',
        statusCode: 400,
        name: 'Failed to deserialize request',
        description: 'Could not deserialize the request. Check CampaignMonitor API Documentation.',
      },
      CAMPAIGN_MONITOR_SUBSCRIBER_NOT_CONFIRMED: {
        code: 'CAMPMON5',
        statusCode: 400,
        name: 'Subscriber not confirmed',
        description: 'The subscriber has not confirmed their subscription yet.',
      },
      CAMPAIGN_MONITOR_SUBSCRIBER_IN_SUPPRESSION_LIST: {
        code: 'CAMPMON6',
        statusCode: 400,
        name: 'Subscriber in exists suppression list',
        description:
          'Email Address has existed in the selected list before, and currently exists in suppression list. Subscriber is not added.',
      },
      CAMPAIGN_MONITOR_SUBSCRIBER_IN_DELETED_LIST: {
        code: 'CAMPMON7',
        statusCode: 400,
        name: 'Subscriber in exists deleted list',
        description: 'Email Address exists in deleted list. Subscriber is not added.',
      },
      CAMPAIGN_MONITOR_SUBSCRIBER_IN_UNSUBSCRIBED_LIST: {
        code: 'CAMPMON8',
        statusCode: 400,
        name: 'Subscriber in exists unsubscribed list',
        description: 'Email Address exists in unsubscribed list. Subscriber is not added.',
      },
      CAMPAIGN_MONITOR_SUBSCRIBER_IN_BOUNCED_LIST: {
        code: 'CAMPMON9',
        statusCode: 400,
        name: 'Subscriber in exists bounced list',
        description: 'Email Address exists in bounced list. Subscriber is not added.',
      },
      CAMPAIGN_MONITOR_ALREADY_SUBSCRIBED: {
        code: 'CAMPMON10',
        statusCode: 400,
        name: 'Email is already subscribed',
        description: 'New Email Address is already subscribed to the list. Subscriber not updated.',
      },
      CAMPAIGN_MONITOR_ALREADY_CONFIRMED: {
        code: 'CAMPMON11',
        statusCode: 400,
        name: 'Subscription is already confirmed',
        description: 'This subscription has already been confirmed.',
      },
      CAMPAIGN_MONITOR_UNKNOWN_WEBHOOK_TYPE: {
        code: 'CAMPMON12',
        statusCode: 400,
        name: 'Unknown webhook type',
        description: 'This type of webhook could not be handled.',
      },
      REMINDER_ALARM_DATE_IN_PAST: {
        code: 'REM1',
        statusCode: 400,
        name: 'Alarm date is in the past',
        description: 'Cannot create a reminder that is set to a time in the past.',
      },
      LIST_EMAIL_ADDRESS_INVALID: {
        code: 'EMAIL1',
        statusCode: 400,
        name: 'Email address invalid',
        description:
          'This email address is not a collection email address. Please go to your Email to Collection settings to find the right email address.',
      },
      LIST_EMAIL_HASH_INVALID: {
        code: 'EMAIL2',
        statusCode: 400,
        name: 'Email address hash does not match',
        description: 'The address hash does not match the collection hash.',
      },
      LIST_EMAIL_NO_FIELDS_MATCHED: {
        code: 'EMAIL3',
        statusCode: 400,
        name: 'Email data not matched to fields',
        description:
          'Email data has not been matched to Zenkit fields for this collection. Please go to your Email to Collection settings to match fields to email content.',
      },
      LIST_EMAIL_USER_NOT_FOUND: {
        code: 'EMAIL4',
        statusCode: 400,
        name: "User doesn't exist",
        description: 'This user does not exist.',
      },
      LIST_EMAIL_USER_NO_ACCESS: {
        code: 'EMAIL5',
        statusCode: 403,
        name: "User doesn't have access",
        description: 'This user does not have access to this collection.',
      },
      LIST_EMAIL_NOT_FOUND: {
        code: 'EMAIL6',
        statusCode: 404,
        name: 'Collection not found',
        description: "This collection or it's workspace doesn't exist or has been deleted.",
      },
      LIST_EMAIL_ATTACHMENT_CREATION_FAILED: {
        code: 'EMAIL7',
        statusCode: 500,
        name: 'Failed to create attachments',
        description: 'Something went wrong when creating attachment files.',
      },
      LIST_EMAIL_QUOTA_EXCEEDED: {
        code: 'EMAIL8',
        statusCode: 400,
        name: 'You quota has been exceeded',
        description: 'You have exceeded the maximum number of emails that can be sent per hour to this collection.',
      },
      TWO_FA_SECRET_EXPIRED: {
        code: '2FA1',
        statusCode: 400,
        name: 'Your 2FA secret expired',
        description: 'Your two factor secret expired.',
      },
      TWO_FA_INVALID_TOKEN: {
        code: '2FA2',
        statusCode: 400,
        name: 'Invalid 2FA token',
        nameTranslateId: 'ERRORS.TWO_FA_INVALID_TOKEN.NAME',
        description: 'Your code could not be verified.',
        descriptionTranslateId: 'ERRORS.TWO_FA_INVALID_TOKEN.DESCRIPTION',
      },
      TWO_FA_NO_TOKEN: {
        code: '2FA3',
        statusCode: 401,
        name: 'No 2FA token provided',
        description: 'Two Factor Authentication is enabled but no security code was provided.',
      },
      OAUTH_REQUEST_EXPIRED: {
        code: 'OAUTH1',
        statusCode: 400,
        name: 'Authorization Request Expired',
        description: 'Your authorization request expired.',
      },
      OAUTH_MISSING_EMAIL: {
        code: 'OAUTH2',
        statusCode: 400,
        name: 'Profile requires email',
        nameTranslateId: 'ERRORS.OAUTH_MISSING_EMAIL.NAME',
        description:
          'This OAuth account does not have a valid email address associated with it. Please add one to it or use a different login option.',
        descriptionTranslateId: 'ERRORS.OAUTH_MISSING_EMAIL.DESCRIPTION',
      },
      MS_TEAMS_INVALID_JWT: {
        code: 'TEAMS1',
        statusCode: 401,
        name: 'Invalid jwt received for MSTeams connector action callback.',
        description: 'Could not verify the authenticity of the connector action callback message.',
      },
      MS_TEAMS_UNKNOWN_USER: {
        code: 'TEAMS2',
        statusCode: 401,
        name: 'Could not find user for the provided MSTeams providerId.',
        description: 'You are not logged in to Zenkit. Please connect to Zenkit using the **/login** command.',
      },
    }
    'object' == typeof module && module && 'object' == typeof module.exports
      ? (module.exports = ZenkitErrorCodes)
      : ((window.ZenkitErrorCodes = ZenkitErrorCodes),
        'function' == typeof define &&
          define.amd &&
          define('ZenkitErrorCodes', [], function () {
            return ZenkitErrorCodes
          }))
  })(this),
  (function (window) {
    var _,
      ZenkitControlsShared,
      logger,
      moment,
      RRule,
      produceState,
      weAreOnTheClient = 'undefined' == typeof module,
      weAreOnTheServer = !weAreOnTheClient
    weAreOnTheServer
      ? ((_ = require('lodash')),
        (ZenkitControlsShared = require('../SharedServer/ZenkitControlsShared')),
        (logger = { log: _.noop, info: _.noop, warn: _.noop, error: _.noop }),
        (moment = require('moment-timezone')),
        (RRule = require('rrule').RRule),
        (produceState = require('immer').default))
      : ((_ = window._),
        (ZenkitControlsShared = window.ZenkitControlsShared),
        (logger = console),
        (moment = window.moment),
        (RRule = window.rrule && window.rrule.RRule),
        (produceState = window.immer.default))
    var typeChecks,
      getLoggableValue,
      ValidationError,
      ZenkitSharedUtils = {
        ChangeCallbackMixin: function (config) {
          var onChangeCallbacks = new Set()
          config = config || {}
          var hasOnFirstSubscriptionCallback = _.isFunction(config.onFirstSubscription),
            hasOnLastSubscriptionRemovedCallback = _.isFunction(config.onLastSubscriptionRemoved)
          return {
            getSubscriptionCount: function () {
              return onChangeCallbacks.size
            },
            onChange: function (callback) {
              return !1 === _.isFunction(callback)
                ? (console.warn('ZenkitChangeCallbackMixin: passed callback was not a function', callback), _.noop)
                : (onChangeCallbacks.add(callback),
                  hasOnFirstSubscriptionCallback && 1 === onChangeCallbacks.size && config.onFirstSubscription(),
                  function () {
                    onChangeCallbacks.delete(callback),
                      hasOnLastSubscriptionRemovedCallback &&
                        0 === onChangeCallbacks.size &&
                        config.onLastSubscriptionRemoved(),
                      (callback = void 0)
                  })
            },
            triggerChange: function (input) {
              var currentSubscribers = new Set(onChangeCallbacks)
              for (var subscriber of currentSubscribers)
                try {
                  subscriber(input)
                } catch (err) {
                  logger.error(err)
                }
              return input
            },
          }
        },
        isValidEmail: function (mail) {
          return !(
            !mail ||
            !/[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/.test(
              _.toLower(mail),
            )
          )
        },
        moveInArray: function (array, fromIndex, toIndex) {
          return fromIndex !== toIndex && array.splice(toIndex, 0, array.splice(fromIndex, 1)[0]), array
        },
        stringContainsOnlyNumbers: function (string) {
          return /^\d+$/.test(string)
        },
        diffArrayWithObjects: function (newArray, oldArray, getIdentifier) {
          if (void 0 === getIdentifier)
            getIdentifier = function (obj) {
              return _.get(obj, ['id'])
            }
          else if (_.isString(getIdentifier)) {
            var identifier = getIdentifier
            getIdentifier = function (obj) {
              return _.get(obj, [identifier])
            }
          }
          var newArrayIds = _.compact(_.map(newArray, getIdentifier)),
            oldArrayIds = _.compact(_.map(oldArray, getIdentifier)),
            removedArrayIds = _.difference(oldArrayIds, newArrayIds),
            addedArrayIds = _.difference(newArrayIds, oldArrayIds),
            removedArrayElements = _.filter(oldArray, function (oldArrayElement) {
              return oldArrayElement && _.includes(removedArrayIds, getIdentifier(oldArrayElement))
            }),
            addedArrayElements = _.filter(newArray, function (newArrayElement) {
              return newArrayElement && _.includes(addedArrayIds, getIdentifier(newArrayElement))
            }),
            changedPositionMap = {}
          return (
            _.forEach(oldArray, function (oldSameElement, index) {
              if (!_.isNil(oldSameElement)) {
                var newSameElementIndex = _.findIndex(newArray, function (obj) {
                  return getIdentifier(obj) === getIdentifier(oldSameElement)
                })
                newSameElementIndex < 0 ||
                  (index !== newSameElementIndex &&
                    (changedPositionMap[getIdentifier(oldSameElement)] = {
                      fromIndex: index,
                      toIndex: newSameElementIndex,
                    }))
              }
            }),
            { addedArrayElements, removedArrayElements, changedPositionMap }
          )
        },
        shorten: function (string, maxLength) {
          return (
            (maxLength = maxLength || 50),
            (string = string || '') &&
              string.length > maxLength &&
              (string = string.substr(0, Math.max(maxLength - 3, 0)) + '...'),
            string
          )
        },
        moveObjectInArrayInFrontOfAnchor: function (array, objectToSortIdentifier, beforeAnchorIdentifier, identifier) {
          var findHelperObject = {},
            findHelperAnchor = {}
          ;(findHelperObject[(identifier = identifier || 'id')] = objectToSortIdentifier),
            (findHelperAnchor[identifier] = beforeAnchorIdentifier)
          var indexOfObjectToSort = _.findIndex(array, findHelperObject),
            indexOfAnchor = -1,
            objectToSort = array[indexOfObjectToSort]
          ;-1 !== indexOfObjectToSort &&
            (array.splice(indexOfObjectToSort, 1),
            -1 !== beforeAnchorIdentifier && (indexOfAnchor = _.findIndex(array, findHelperAnchor)),
            array.splice(indexOfAnchor + 1, 0, objectToSort))
        },
        getListEntryNameForList: function (parameters) {
          var params = ZenkitSharedUtils.validateParameters(parameters, {
            list: { type: ['object', 'null'], default: null },
            amount: { type: 'number', default: 1 },
            plural: { type: 'boolean', default: !1 },
            defaultName: { type: 'string', default: 'Item' },
            defaultNamePlural: { type: 'string', default: 'Items' },
          })
          return params.plural || params.amount > 1
            ? _.get(params.list, ['itemNamePlural']) || params.defaultNamePlural
            : _.get(params.list, ['itemName']) || params.defaultName
        },
        getDisplayStringForHierarchyValue: function (value) {
          var parts = _.split(value, '.')
          return _.isNil(value) || _.isEmpty(parts)
            ? '-'
            : 1 === parts.length
            ? 'Root'
            : _.map(parts.slice(1), Number).join('.')
        },
      },
      mentionRegExp = /(?:^|\s)(@[^\s]+)/g
    ;(ZenkitSharedUtils.getMentionUsernameRegex = _.constant(mentionRegExp)),
      (ZenkitSharedUtils.parseMentionUsernames = function (message) {
        if (!1 === _.isString(message)) return []
        var matches = message.match(mentionRegExp),
          usernames = _.map(matches, function (mention) {
            return _.replace(mention, /^\s*@/, '')
          })
        return _.uniq(usernames)
      }),
      (ZenkitSharedUtils.validateParameters =
        ((typeChecks = {
          number: _.isFinite,
          NaN: _.isNaN,
          string: _.isString,
          object: _.isObject,
          array: _.isArray,
          function: _.isFunction,
          boolean: _.isBoolean,
          date: _.isDate,
          undefined: _.isUndefined,
          null: _.isNull,
          any: _.constant(!0),
        }),
        (getLoggableValue = function (key, value) {
          return 'password' === key && _.isString(value)
            ? 'Password cleared out by validateParameters'
            : 'req' === key && _.isObject(value)
            ? 'request object (logging prevented by validateParameters)'
            : value
        }),
        (ValidationError = function (errorMessage) {
          return (errorMessage = 'ZenkitSharedUtils.validateParameters: ' + errorMessage), new Error(errorMessage)
        }),
        function (paramsToCheck, paramDescriptions) {
          if (((paramsToCheck = paramsToCheck || {}), !1 === _.isObject(paramDescriptions)))
            throw ValidationError('paramDescriptions is required')
          _.forEach(_.keys(paramsToCheck), function (nameOfParam) {
            if (!paramDescriptions[nameOfParam]) {
              if ('$$hashKey' === nameOfParam) return
              logger.warn('You passed an unexpected parameter:', nameOfParam)
            }
          })
          var params,
            paramNames = _.keys(paramDescriptions),
            errorMessages = _.compact(
              _.map(paramNames, function (nameOfParam) {
                var description = paramDescriptions[nameOfParam],
                  value = paramsToCheck[nameOfParam]
                if (!description) return 'Invalid description of parameter. ' + nameOfParam + ':' + description
                if (
                  ((description = _.defaults(description || {}, { type: void 0, customCheck: void 0 })),
                  _.isString(description.type) && (description.type = [].concat(_.toLower(description.type))),
                  void 0 === value)
                )
                  if (description.hasOwnProperty('default'))
                    (paramsToCheck = produceState(paramsToCheck, function (params) {
                      params[nameOfParam] = description.default
                    })),
                      (value = description.default)
                  else if (!1 === _.includes(description.type, 'undefined')) return nameOfParam + ' is required'
                if (description.type) {
                  var isValueOfRightType = _.some(description.type, function (typeString) {
                    return void 0 === typeChecks[typeString]
                      ? (logger.error(
                          'error validating',
                          nameOfParam,
                          'with value:',
                          getLoggableValue(nameOfParam, value),
                        ),
                        'Unsupported type: ' + typeString)
                      : typeChecks[typeString](value)
                  })
                  if (_.isString(isValueOfRightType)) return isValueOfRightType
                  if (!1 === isValueOfRightType)
                    return (
                      logger.error(
                        'error validating',
                        nameOfParam,
                        'with value:',
                        getLoggableValue(nameOfParam, value),
                      ),
                      nameOfParam +
                        ' is not of type ' +
                        description.type.join(' or ') +
                        '. Got value: ' +
                        getLoggableValue(nameOfParam, value) +
                        ' of type ' +
                        typeof value
                    )
                }
                return description.customCheck && !1 === description.customCheck(value)
                  ? nameOfParam + ' did not pass custom check. Got value: ' + getLoggableValue(nameOfParam, value)
                  : void 0
              }),
            )
          if (!1 === _.isEmpty(errorMessages))
            throw (
              (logger.error(
                'invalid parameters',
                ((params = paramsToCheck),
                _.reduce(
                  params,
                  function (loggableParams, value, key) {
                    return (loggableParams[key] = getLoggableValue(key, value)), loggableParams
                  },
                  {},
                )),
                'validation: ',
                paramDescriptions,
              ),
              ValidationError(errorMessages.join(', ')))
            )
          return paramsToCheck
        })),
      (ZenkitSharedUtils.isPositiveInteger = function (number) {
        return _.isInteger(number) && number >= 0
      }),
      (ZenkitSharedUtils.replaceDiacriticsWithAsciiCharacters = function (str) {
        for (
          var defaultDiacriticsRemovalMap = [
              {
                base: 'A',
                letters:
                  /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g,
              },
              { base: 'AA', letters: /[\uA732]/g },
              { base: 'AE', letters: /[\u00C6\u01FC\u01E2]/g },
              { base: 'AO', letters: /[\uA734]/g },
              { base: 'AU', letters: /[\uA736]/g },
              { base: 'AV', letters: /[\uA738\uA73A]/g },
              { base: 'AY', letters: /[\uA73C]/g },
              { base: 'B', letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g },
              { base: 'C', letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g },
              {
                base: 'D',
                letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g,
              },
              { base: 'DZ', letters: /[\u01F1\u01C4]/g },
              { base: 'Dz', letters: /[\u01F2\u01C5]/g },
              {
                base: 'E',
                letters:
                  /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g,
              },
              { base: 'F', letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g },
              {
                base: 'G',
                letters:
                  /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g,
              },
              {
                base: 'H',
                letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g,
              },
              {
                base: 'I',
                letters:
                  /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g,
              },
              { base: 'J', letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g },
              {
                base: 'K',
                letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g,
              },
              {
                base: 'L',
                letters:
                  /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g,
              },
              { base: 'LJ', letters: /[\u01C7]/g },
              { base: 'Lj', letters: /[\u01C8]/g },
              { base: 'M', letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g },
              {
                base: 'N',
                letters:
                  /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g,
              },
              { base: 'NJ', letters: /[\u01CA]/g },
              { base: 'Nj', letters: /[\u01CB]/g },
              {
                base: 'O',
                letters:
                  /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g,
              },
              { base: 'OI', letters: /[\u01A2]/g },
              { base: 'OO', letters: /[\uA74E]/g },
              { base: 'OU', letters: /[\u0222]/g },
              { base: 'P', letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g },
              { base: 'Q', letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g },
              {
                base: 'R',
                letters:
                  /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g,
              },
              {
                base: 'S',
                letters:
                  /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g,
              },
              {
                base: 'T',
                letters:
                  /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g,
              },
              { base: 'TZ', letters: /[\uA728]/g },
              {
                base: 'U',
                letters:
                  /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g,
              },
              { base: 'V', letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g },
              { base: 'VY', letters: /[\uA760]/g },
              { base: 'W', letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g },
              { base: 'X', letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g },
              {
                base: 'Y',
                letters:
                  /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g,
              },
              {
                base: 'Z',
                letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g,
              },
              {
                base: 'a',
                letters:
                  /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g,
              },
              { base: 'aa', letters: /[\uA733]/g },
              { base: 'ae', letters: /[\u00E6\u01FD\u01E3]/g },
              { base: 'ao', letters: /[\uA735]/g },
              { base: 'au', letters: /[\uA737]/g },
              { base: 'av', letters: /[\uA739\uA73B]/g },
              { base: 'ay', letters: /[\uA73D]/g },
              { base: 'b', letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g },
              {
                base: 'c',
                letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g,
              },
              {
                base: 'd',
                letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g,
              },
              { base: 'dz', letters: /[\u01F3\u01C6]/g },
              {
                base: 'e',
                letters:
                  /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g,
              },
              { base: 'f', letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g },
              {
                base: 'g',
                letters:
                  /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g,
              },
              {
                base: 'h',
                letters:
                  /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g,
              },
              { base: 'hv', letters: /[\u0195]/g },
              {
                base: 'i',
                letters:
                  /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g,
              },
              { base: 'j', letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g },
              {
                base: 'k',
                letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g,
              },
              {
                base: 'l',
                letters:
                  /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g,
              },
              { base: 'lj', letters: /[\u01C9]/g },
              { base: 'm', letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g },
              {
                base: 'n',
                letters:
                  /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g,
              },
              { base: 'nj', letters: /[\u01CC]/g },
              {
                base: 'o',
                letters:
                  /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g,
              },
              { base: 'oi', letters: /[\u01A3]/g },
              { base: 'ou', letters: /[\u0223]/g },
              { base: 'oo', letters: /[\uA74F]/g },
              { base: 'p', letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g },
              { base: 'q', letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g },
              {
                base: 'r',
                letters:
                  /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g,
              },
              {
                base: 's',
                letters:
                  /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g,
              },
              {
                base: 't',
                letters:
                  /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g,
              },
              { base: 'tz', letters: /[\uA729]/g },
              {
                base: 'u',
                letters:
                  /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g,
              },
              { base: 'v', letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g },
              { base: 'vy', letters: /[\uA761]/g },
              { base: 'w', letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g },
              { base: 'x', letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g },
              {
                base: 'y',
                letters:
                  /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g,
              },
              {
                base: 'z',
                letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g,
              },
            ],
            i = 0;
          i < defaultDiacriticsRemovalMap.length;
          i++
        )
          str = _.replace(str, defaultDiacriticsRemovalMap[i].letters, defaultDiacriticsRemovalMap[i].base)
        return str
      }),
      (ZenkitSharedUtils.getLocaleForDecimalFormat = decimalFormat =>
        decimalFormat === ZenkitControlsShared.decimalFormats.DECIMAL_COMMA ? 'de-DE' : 'en-GB'),
      (ZenkitSharedUtils.getFormattedNumberText = function (params) {
        try {
          params = ZenkitSharedUtils.validateParameters(params, {
            decimalFormat: { type: 'number' },
            number: { type: ['number', 'string', 'null', 'NaN'], default: null },
            listElement: { type: 'object' },
          })
        } catch (e) {
          return console.error(e), ''
        }
        var number = params.number
        if ((_.isString(number) && (number = parseFloat(number)), _.isNaN(number) || _.isNil(number))) return ''
        var elementFormat = _.get(params, ['listElement', 'elementData', 'format', 'name']),
          locale = ZenkitSharedUtils.getLocaleForDecimalFormat(params.decimalFormat),
          numberText = number.toLocaleString(locale, {
            minimumFractionDigits: 'integer' === elementFormat ? 0 : 2,
            maximumFractionDigits: 2,
          })
        return (
          'currency' === elementFormat &&
            (numberText = params.listElement.elementData.currencyFormat.symbol + ' ' + numberText),
          numberText
        )
      }),
      (ZenkitSharedUtils.parseNumberFromInput = function (params) {
        try {
          params = ZenkitSharedUtils.validateParameters(params, {
            decimalFormat: { type: 'number' },
            numberInput: { type: ['number', 'string'] },
            listElement: { type: 'object' },
          })
        } catch (e) {
          return console.error(e), null
        }
        _.isNumber(params.numberInput) && (params.numberInput = params.numberInput.toString())
        var elementFormat = _.get(params, ['listElement', 'elementData', 'format', 'name'])
        'currency' === elementFormat &&
          ((params.numberInput = _.replace(
            params.numberInput,
            params.listElement.elementData.currencyFormat.symbol,
            '',
          )),
          (params.numberInput = _.trim(params.numberInput)))
        var patternComma = ZenkitSharedUtils.getDecimalPattern(ZenkitControlsShared.decimalFormats.DECIMAL_COMMA),
          patternPoint = ZenkitSharedUtils.getDecimalPattern(ZenkitControlsShared.decimalFormats.DECIMAL_POINT)
        if (params.decimalFormat === ZenkitControlsShared.decimalFormats.DECIMAL_COMMA)
          if (patternComma.test(params.numberInput))
            (params.numberInput = _.replace(params.numberInput, /\./g, '')),
              (params.numberInput = _.replace(params.numberInput, ',', '.'))
          else {
            if (!patternPoint.test(params.numberInput))
              return console.error('Input ' + params.numberInput + ' did not match any decimal format'), null
            params.numberInput = _.replace(params.numberInput, /,/g, '')
          }
        else if (patternPoint.test(params.numberInput)) params.numberInput = _.replace(params.numberInput, /,/g, '')
        else {
          if (!patternComma.test(params.numberInput))
            return console.error('Input ' + params.numberInput + ' did not match any decimal format'), null
          ;(params.numberInput = _.replace(params.numberInput, /\./g, '')),
            (params.numberInput = _.replace(params.numberInput, ',', '.'))
        }
        var number = Number['integer' === elementFormat ? 'parseInt' : 'parseFloat'](params.numberInput)
        return isNaN(number) ? null : number
      }),
      (ZenkitSharedUtils.getDecimalPattern = function (format) {
        switch (format) {
          case ZenkitControlsShared.decimalFormats.DECIMAL_COMMA:
            return ZenkitControlsShared.decimalPatterns.COMMA
          case ZenkitControlsShared.decimalFormats.DECIMAL_POINT:
            return ZenkitControlsShared.decimalPatterns.POINT
          default:
            var patternComma = ZenkitControlsShared.decimalPatterns.COMMA,
              patternPoint = ZenkitControlsShared.decimalPatterns.POINT
            return new RegExp('(?:' + patternComma.source + '|' + patternPoint.source + ')', 'i')
        }
      }),
      (ZenkitSharedUtils.isDayDate = function (date) {
        var isDayDate = !1
        return (
          _.isString(date) && (isDayDate = moment(date, ZenkitControlsShared.internalDateFormat, !0).isValid()),
          isDayDate
        )
      }),
      (ZenkitSharedUtils.toDayString = function (date) {
        return moment(date).format(ZenkitControlsShared.internalDateFormat)
      }),
      (ZenkitSharedUtils.fromDayString = function (dateString) {
        return moment.utc(dateString, ZenkitControlsShared.internalDateFormat).toDate()
      }),
      (ZenkitSharedUtils.toDayDate = function (date) {
        var dateString = ZenkitSharedUtils.toDayString(date)
        return ZenkitSharedUtils.fromDayString(dateString)
      }),
      (ZenkitSharedUtils.hasDateChanged = function (first, second, unit) {
        var firstDate = moment(first),
          secondDate = moment(second)
        return (!1 !== firstDate.isValid() || !1 !== secondDate.isValid()) && !1 === firstDate.isSame(secondDate, unit)
      })
    var durationFormats = ['year', 'week', 'day', 'hour', 'minute'],
      smallestFormat = _.last(durationFormats)
    ;(ZenkitSharedUtils.formatDuration = function (value, unit) {
      var duration = moment.duration(value, unit)
      if (!1 === duration.isValid() || 0 === _.round(duration.as(smallestFormat))) return '0 ' + smallestFormat
      var format = _.find(durationFormats, function (format) {
        return duration.as(format) % 1 == 0
      })
      _.isEmpty(format) && (format = smallestFormat)
      var durationInFromat = _.round(duration.as(format))
      return _.toString(durationInFromat) + ' ' + format
    }),
      (ZenkitSharedUtils.getOffsetBetweenDates = function (from, to) {
        var diff = moment.utc(from).diff(to, smallestFormat)
        return ZenkitSharedUtils.formatDuration(diff, smallestFormat)
      }),
      (ZenkitSharedUtils.getDateFormat = function (type, userSettings) {
        switch (type) {
          case 'date':
            return userSettings.dateFormat
          case 'time':
            return userSettings.timeFormat
          case 'full':
          default:
            return userSettings.dateFormat + ' ' + userSettings.timeFormat
        }
      }),
      (ZenkitSharedUtils.getDateDisplayString = function (params) {
        if (!_.isNil(params.startDate)) {
          params = _.defaults(params, { timeOnly: !1 })
          var startDateDisplayFormat,
            m = moment
          _.isFunction(moment.tz) && !1 === _.isEmpty(params.timezone)
            ? (m = _.partialRight(moment.tz, params.timezone))
            : weAreOnTheServer && (m = moment.utc),
            (startDateDisplayFormat =
              params.hasTime && params.timeOnly
                ? ZenkitSharedUtils.getDateFormat('time', params.userSettings)
                : params.hasTime
                ? ZenkitSharedUtils.getDateFormat('full', params.userSettings)
                : params.timeOnly
                ? ' '
                : ZenkitSharedUtils.getDateFormat('date', params.userSettings))
          var startDate = m(params.startDate),
            displayText = startDate.format(startDateDisplayFormat),
            duration = params.duration
          if (!1 !== _.isNil(params.endDate) || (!params.hasTime && !1 !== params.timeOnly))
            _.isString(duration) &&
              '' !== duration &&
              !1 === params.timeOnly &&
              ((displayText += ' for ' + duration),
              1 !== parseInt(ZenkitSharedUtils.getPartOfDurationString(duration, 'number')) &&
                !1 === _.endsWith(duration, 's') &&
                (displayText += 's'))
          else {
            var formatToUse = params.hasTime ? 'full' : 'date',
              endDate = m(params.endDate)
            params.hasTime && endDate.isSame(startDate, 'day') && (formatToUse = 'time'),
              (displayText += ' - ' + endDate.format(ZenkitSharedUtils.getDateFormat(formatToUse, params.userSettings)))
          }
          return (displayText = _.trim(displayText)), (displayText = _.upperFirst(displayText))
        }
      }),
      (ZenkitSharedUtils.splitDurationString = function (durationString) {
        var match = _.invoke(durationString, ['match'], /([\s-]*)(\d+)\s*(\w+)/i)
        if (_.isNil(match)) return []
        var number = parseInt(match[2])
        if (_.isNaN(number)) return []
        var unit = moment.normalizeUnits(match[3])
        if (_.isEmpty(unit)) return []
        var negate = _.replace(match[1], /\s/g, '').length % 2 != 0
        return 0 !== number && negate && (number *= -1), [number, unit]
      }),
      (ZenkitSharedUtils.normalizeDurationString = function (durationString) {
        var parts = ZenkitSharedUtils.splitDurationString(durationString)
        if (_.isEmpty(parts)) return ''
        var number = parts[0],
          unit = parts[1]
        return _.toString(number) + ' ' + unit
      }),
      (ZenkitSharedUtils.getPartOfDurationString = function (durationString, part) {
        var durationParts = ZenkitSharedUtils.splitDurationString(durationString)
        return _.isEmpty(durationParts)
          ? ''
          : 'number' === part
          ? _.toString(durationParts[0])
          : 'unit' === part
          ? durationParts[1] || null
          : durationString
      }),
      (ZenkitSharedUtils.getEndDate = function (params) {
        var uuid = (params = ZenkitSharedUtils.validateParameters(params, {
            listEntry: { type: 'object' },
            listElement: { type: 'object' },
          })).listElement.uuid,
          startDate = params.listEntry[uuid + '_date'],
          duration = params.listEntry[uuid + '_duration'],
          endDate = params.listEntry[uuid + '_endDate']
        if (_.isNil(startDate) && _.isNil(endDate)) return moment.invalid()
        var endDateAsMoment = moment(startDate)
        return (
          !1 === _.isEmpty(duration)
            ? (endDateAsMoment = moment(startDate).add(
                ZenkitSharedUtils.getPartOfDurationString(duration, 'number'),
                ZenkitSharedUtils.getPartOfDurationString(duration, 'unit'),
              ))
            : !1 === _.isNil(endDate) && (endDateAsMoment = moment(endDate)),
          endDateAsMoment
        )
      }),
      (ZenkitSharedUtils.getDurationDiff = function (params) {
        var uuid = (params = ZenkitSharedUtils.validateParameters(params, {
            listEntry: { type: 'object' },
            listElement: { type: 'object' },
            unit: { type: 'string', default: 'ms' },
          })).listElement.uuid,
          startDate = params.listEntry[uuid + '_date']
        return ZenkitSharedUtils.getEndDate({ listEntry: params.listEntry, listElement: params.listElement }).diff(
          startDate,
          params.unit,
        )
      }),
      (ZenkitSharedUtils.isAllDay = function (params) {
        var uuid = (params = ZenkitSharedUtils.validateParameters(params, {
          listEntry: { type: 'object' },
          listElement: { type: 'object' },
        })).listElement.uuid
        return !params.listEntry[uuid + '_hasTime'] && !_.isNil(params.listEntry[uuid + '_endDate'])
      }),
      (ZenkitSharedUtils.getSortByValueEntriesInCalendar = function (params) {
        var durationInDays = ZenkitSharedUtils.getDurationDiff({
            listEntry: params.listEntry,
            listElement: params.listElement,
            unit: 'days',
          }),
          hasTime = !!params.listEntry[params.listElement.uuid + '_hasTime']
        return durationInDays > 0 ? -1 * durationInDays : hasTime ? 0 : 1
      }),
      (ZenkitSharedUtils.getDefaultDependencyTag = function () {
        return { type: 'sf', lag: '0 day', text: '' }
      }),
      (ZenkitSharedUtils.getMinDiffForDependencyType = function (type) {
        return 'ss' === type || 'ff' === type ? 0 : 1
      }),
      (ZenkitSharedUtils.getTimeSpanInDays = function (params) {
        var m = moment
        weAreOnTheServer && (m = moment.utc)
        var dateKey = params.listElement.uuid + '_date'
        if (_.isNil(params.listEntry[dateKey])) return { start: null, end: null }
        var start = m(params.listEntry[dateKey]).startOf('day'),
          durationInDays = ZenkitSharedUtils.getDurationDiff({
            listEntry: params.listEntry,
            listElement: params.listElement,
            unit: 'days',
          }),
          daysToAdd = Math.max(durationInDays, 0)
        params.listEntry[params.listElement.uuid + '_duration'] && daysToAdd > 0 && (daysToAdd -= 1)
        var end = start.clone().add(daysToAdd, 'days')
        return { start, end }
      })
    var getInterfaceMatching = function (list, appType) {
      var app = ZenkitControlsShared.apps[appType],
        taskInterface = _.get(app, ['interfaces', 'tasks']) || {},
        resourceTag = _.find(list.resourceTags, function (resourceTag) {
          return resourceTag.appType === appType && taskInterface[resourceTag.tag]
        })
      return resourceTag ? taskInterface[resourceTag.tag] : null
    }
    ;(ZenkitSharedUtils.isTaskList = function (params) {
      return !1 === _.isNil(getInterfaceMatching(params.list, params.appType))
    }),
      (ZenkitSharedUtils.isTaskListInAnyApp = function (params) {
        return _.some(params.list.resourceTags, function (resourceTag) {
          return ZenkitSharedUtils.isTaskList({ list: params.list, appType: resourceTag.appType })
        })
      }),
      (ZenkitSharedUtils.findByResourceTag = function (collection, resourceTag) {
        return _.find(collection, function (resource) {
          return _.some(resource.resourceTags, resourceTag)
        })
      }),
      (ZenkitSharedUtils.keyByResourceTag = function (collection, findParams) {
        return _.reduce(
          collection,
          function (keyed, resource) {
            var tag = _.find(resource.resourceTags, findParams)
            return tag && (keyed[tag.tag] = resource), keyed
          },
          {},
        )
      }),
      (ZenkitSharedUtils.getPossibleTaskElements = function (params) {
        params = ZenkitSharedUtils.validateParameters(params, {
          elementcategories: { type: 'array' },
          listElements: { type: 'array' },
        })
        var categoryEc = _.find(params.elementcategories, { name: 'Categories' })
        return _.filter(params.listElements, function (listElement) {
          return (
            listElement.elementcategory === categoryEc.id &&
            _.get(listElement, ['elementData', 'predefinedCategories', 'length'], 0) >= 2
          )
        })
      }),
      (ZenkitSharedUtils.getTaskData = function (params) {
        params = ZenkitSharedUtils.validateParameters(params, {
          list: { type: 'object' },
          elementcategories: { type: 'array' },
          listElements: { type: 'array' },
          appType: { type: 'string' },
        })
        var app = ZenkitControlsShared.apps[params.appType],
          interfaceMatching = getInterfaceMatching(params.list, params.appType)
        if (_.isNil(interfaceMatching)) return null
        var taskElement = _.find(params.listElements, function (listElement) {
          return _.some(listElement.resourceTags, { appType: app.type, tag: interfaceMatching.listElement })
        })
        if (_.isNil(taskElement)) return null
        var elementKey = taskElement.uuid + '_categories',
          categories = _.get(taskElement, ['elementData', 'predefinedCategories'], [])
        return {
          listElement: taskElement,
          listElementKey: elementKey,
          todo: ZenkitSharedUtils.findByResourceTag(categories, { appType: app.type, tag: interfaceMatching.todo }),
          done: ZenkitSharedUtils.findByResourceTag(categories, { appType: app.type, tag: interfaceMatching.done }),
        }
      }),
      (ZenkitSharedUtils.getTaskProgress = function (params) {
        var taskData = params.taskData,
          listEntries = params.listEntries
        if (_.isNil(taskData)) return { all: 0, done: 0, percentage: 0 }
        var listEntriesDone = _.filter(listEntries, function (listEntry) {
            return _.isEqual(listEntry[taskData.listElementKey], [taskData.done.id])
          }),
          all = _.size(listEntries),
          done = _.size(listEntriesDone)
        return { all, done, percentage: 0 === all ? 0 : Math.round((done / all) * 100) }
      }),
      (ZenkitSharedUtils.buildListEmailAddress = function (params) {
        var email = params.creator + '+'
        params.assignee && (email += params.assignee + '+')
        var domain = {
          development: 'dev-collections.zenkitz.com',
          staging: 'collections.zenkitz.com',
          production: 'collections.zenkit.com',
        }[params.env || 'development']
        return email + params.listId + '+' + params.hash + '@' + domain
      }),
      (function () {
        var ensureString = function (string) {
            return (
              _.isNil(string) && (string = ''),
              !1 === _.isString(string) &&
                (console.warn('ZenkitControlsShared: Expected argument to be a string. Got', typeof string),
                (string = '')),
              string
            )
          },
          htmlEscapeEntityMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '/': '&#x2F;',
            ';': '&#59;',
          },
          htmlUnescapeEntityMap = _.invert(htmlEscapeEntityMap)
        ;(ZenkitSharedUtils.unescapeHtml = function (string) {
          string = ensureString(string)
          var regex = new RegExp(_.join(_.values(htmlEscapeEntityMap), '|'), 'g')
          return string.replace(regex, function (s) {
            return htmlUnescapeEntityMap[s]
          })
        }),
          (ZenkitSharedUtils.escapeHtml = function (string) {
            return (
              (string = ensureString(string)),
              ZenkitSharedUtils.unescapeHtml(string).replace(/[&<>]/g, function (s) {
                return htmlEscapeEntityMap[s]
              })
            )
          }),
          (ZenkitSharedUtils.escapeHtmlAndAngular = function (string) {
            return ZenkitSharedUtils.escapeHtml(
              (function (string) {
                return ensureString(string).replace(/{{/g, '[[').replace(/}}/g, ']]')
              })(string),
            )
          }),
          (ZenkitSharedUtils.escapeRegExpReplacement = function (string) {
            return _.replace(string, /\$/g, '$$$$')
          })
        var ECMA_SIZES_STRING, ECMA_SIZES_BOOLEAN, ECMA_SIZES_NUMBER
        ;(ZenkitSharedUtils.normalizeStringForLink = function (string) {
          return _.chain(string)
            .toLower()
            .replace(
              /[^\s\da-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]+/g,
              '',
            )
            .trim()
            .replace(/\s+/g, '-')
            .value()
            .substring(0, 128)
        }),
          (ZenkitSharedUtils.sizeOfObjectInBytes =
            ((ECMA_SIZES_STRING = 2),
            (ECMA_SIZES_BOOLEAN = 4),
            (ECMA_SIZES_NUMBER = 8),
            function sizeof(object) {
              if (null !== object && 'object' == typeof object) {
                var bytes = 0
                for (var key in object)
                  if (Object.hasOwnProperty.call(object, key)) {
                    bytes += sizeof(key)
                    try {
                      bytes += sizeof(object[key])
                    } catch (ex) {
                      ex instanceof RangeError && (bytes = 0)
                    }
                  }
                return bytes
              }
              return 'string' == typeof object
                ? object.length * ECMA_SIZES_STRING
                : 'boolean' == typeof object
                ? ECMA_SIZES_BOOLEAN
                : 'number' == typeof object
                ? ECMA_SIZES_NUMBER
                : 0
            }))
      })(),
      (ZenkitSharedUtils.buildDateRange = function (params) {
        if (
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.EVERYTIME ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.EMPTY ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.FILLED
        )
          return { from: null, to: null }
        var timezone = _.get(params, ['user', 'timezone']) || 'UTC',
          momentFn = moment.tz ? _.partialRight(moment.tz, timezone) : moment
        if (params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.CUSTOM) {
          var dateFrom = null
          !1 === _.isNil(params.dateFrom) && (dateFrom = momentFn(params.dateFrom))
          var dateTo = null
          return !1 === _.isNil(params.dateTo) && (dateTo = momentFn(params.dateTo)), { from: dateFrom, to: dateTo }
        }
        var now = momentFn()
        if (params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.OVERDUE)
          return { from: null, to: now.clone().subtract(1, 'day').endOf('day') }
        if (
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.YESTERDAY ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.TODAY ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.TOMORROW
        ) {
          var startOfDay = now.clone().startOf('day'),
            endOfDay = now.clone().endOf('day')
          return (
            params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.YESTERDAY
              ? (startOfDay.subtract(1, 'day'), endOfDay.subtract(1, 'day'))
              : params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.TOMORROW &&
                (startOfDay.add(1, 'day'), endOfDay.add(1, 'day')),
            { from: startOfDay, to: endOfDay }
          )
        }
        if (
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.LAST_WEEK ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.THIS_WEEK ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.NEXT_WEEK
        ) {
          var localeWeek = 'isoWeek'
          _.get(params, ['user', 'settings', 'startOfTheWeek']) !== ZenkitControlsShared.startOfTheWeekValues.MONDAY &&
            (localeWeek = 'week')
          var startOfWeek = now.clone().startOf(localeWeek),
            endOfWeek = now.clone().endOf(localeWeek)
          return (
            params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.LAST_WEEK
              ? (startOfWeek.subtract(1, 'week'), endOfWeek.subtract(1, 'week'))
              : params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.NEXT_WEEK &&
                (startOfWeek.add(1, 'week'), endOfWeek.add(1, 'week')),
            { from: startOfWeek, to: endOfWeek }
          )
        }
        if (
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.LAST_MONTH ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.THIS_MONTH ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.NEXT_MONTH
        ) {
          var startOfMonth = now.clone().startOf('month'),
            endOfMonth = now.clone().endOf('month')
          return (
            params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.LAST_MONTH
              ? (startOfMonth.subtract(1, 'month').startOf('month'), endOfMonth.subtract(1, 'month').endOf('month'))
              : params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.NEXT_MONTH &&
                (startOfMonth.add(1, 'month').startOf('month'), endOfMonth.add(1, 'month').endOf('month')),
            { from: startOfMonth, to: endOfMonth }
          )
        }
        if (
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.LAST_YEAR ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.THIS_YEAR ||
          params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.NEXT_YEAR
        ) {
          var startOfYear = now.clone().startOf('year'),
            endOfYear = now.clone().endOf('year')
          return (
            params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.LAST_YEAR
              ? (startOfYear.subtract(1, 'year'), endOfYear.subtract(1, 'year'))
              : params.dateFilterType === ZenkitControlsShared.dateTimeFilterModi.NEXT_YEAR &&
                (startOfYear.add(1, 'year'), endOfYear.add(1, 'year')),
            { from: startOfYear, to: endOfYear }
          )
        }
        return console.error('Unsupported date filter type', params.dateFilterType), null
      }),
      (ZenkitSharedUtils.isDateBetween = function (_ref) {
        var { date, from, to, unit, inclusive = !1 } = _ref,
          inclusivityString = inclusive ? '[]' : '()'
        return date.isBetween(from, to, unit, inclusivityString)
      })
    var units,
      subscriptionQuantityToUserQuota = function (quantity, freeUsers) {
        if (null !== quantity) return _.max([quantity, freeUsers]) || 0
      },
      oneMegaByte = Math.pow(1024, 2),
      oneGigaByte = Math.pow(1024, 3),
      free_plan_v1_valid_until = moment.tz('2018-04-23', 'Europe/Berlin'),
      free_plan_v2_valid_until = moment.tz('2019-07-05', 'Europe/Berlin'),
      buildAppQuotas = function (params) {
        var apps = ZenkitControlsShared.apps
        return params.appType === apps.base.type
          ? (function (params) {
              var plans = ZenkitControlsShared.apps.base.plans,
                plan = _.find(plans, { id: params.planId }) || plans.FREE,
                quotasOfFreePlan = moment(params.contracted_at).isBefore(free_plan_v1_valid_until)
                  ? {
                      users: 5,
                      workspaces: 20,
                      connectedLists: 3,
                      maxEntriesInList: 5e3,
                      maxFilesInList: 2e3,
                      maxFileSizeInList: 20 * oneMegaByte,
                      maxAggregatedFileSizeInList: oneGigaByte,
                      aggregatedFileSize: 3 * oneGigaByte,
                    }
                  : moment(params.contracted_at).isBefore(free_plan_v2_valid_until)
                  ? {
                      users: 5,
                      workspaces: 5,
                      connectedLists: 3,
                      entries: 5e3,
                      files: 5e3,
                      maxFileSizeInList: 20 * oneMegaByte,
                      aggregatedFileSize: 3 * oneGigaByte,
                    }
                  : {
                      users: 3,
                      workspaces: 5,
                      connectedLists: 3,
                      entries: 500,
                      files: 500,
                      maxFileSizeInList: 20 * oneMegaByte,
                      aggregatedFileSize: oneGigaByte,
                    }
              if (plan.id === plans.FREE.id) return quotasOfFreePlan
              var users = subscriptionQuantityToUserQuota(params.subscriptionQuantity, quotasOfFreePlan.users)
              return plan.id === plans.PLUS.id
                ? {
                    users,
                    workspaces: 20,
                    connectedLists: 30,
                    entries: 5e4,
                    files: 1e4,
                    maxFileSizeInList: 100 * oneMegaByte,
                    aggregatedFileSize: 6 * oneGigaByte,
                  }
                : plan.id === plans.BUSINESS.id
                ? {
                    users,
                    workspaces: 500,
                    connectedLists: 300,
                    entries: 15e4,
                    files: 5e4,
                    maxFileSizeInList: oneGigaByte,
                    aggregatedFileSize: 50 * oneGigaByte,
                  }
                : plan.id === plans.ENTERPRISE.id
                ? {
                    users,
                    entries: 1e6,
                    connectedLists: 3e3,
                    files: 5e4,
                    maxFileSizeInList: 5 * oneGigaByte,
                    aggregatedFileSize: 200 * oneGigaByte,
                  }
                : (plan.id === plans.INTERNAL.id || console.error('Unknown plan', plan.id, 'for base app quotas.'), {})
            })(params)
          : params.appType === apps.todos.type
          ? (function (params) {
              var plans = ZenkitControlsShared.apps.todos.plans,
                plan = _.find(plans, { id: params.planId }) || plans.FREE
              if (plan.id === plans.FREE.id)
                return {
                  users: 8,
                  workspaces: 20,
                  connectedLists: 10,
                  lists: 100,
                  entries: 1e4,
                  maxFileSizeInList: 20 * oneMegaByte,
                  aggregatedFileSize: oneGigaByte / 2,
                }
              var users = subscriptionQuantityToUserQuota(params.subscriptionQuantity, 8)
              return plan.id === plans.PLUS.id
                ? {
                    users,
                    workspaces: 200,
                    connectedLists: 30,
                    lists: 800,
                    entries: 8e4,
                    maxFileSizeInList: 100 * oneMegaByte,
                    aggregatedFileSize: 6 * oneGigaByte,
                  }
                : plan.id === plans.BUSINESS.id || plan.id === plans.ENTERPRISE.id
                ? {
                    users,
                    workspaces: 1e3,
                    connectedLists: 300,
                    lists: 1e4,
                    entries: 1e6,
                    maxFileSizeInList: oneGigaByte,
                    aggregatedFileSize: 50 * oneGigaByte,
                  }
                : (plan.id === plans.INTERNAL.id || console.error('Unknown plan', plan.id, 'for todo app quotas.'), {})
            })(params)
          : params.appType === apps.chat.type
          ? (function (params) {
              var plans = ZenkitControlsShared.apps.chat.plans,
                plan = _.find(plans, { id: params.planId }) || plans.FREE
              if (plan.id === plans.FREE.id)
                return {
                  users: 5,
                  workspaces: 5,
                  connectedLists: 3,
                  entries: 1e4,
                  maxFileSizeInList: 20 * oneMegaByte,
                  aggregatedFileSize: oneGigaByte / 2,
                }
              var users = subscriptionQuantityToUserQuota(params.subscriptionQuantity, 5)
              return plan.id === plans.PLUS.id
                ? {
                    users,
                    workspaces: 50,
                    connectedLists: 30,
                    entries: 8e4,
                    maxFileSizeInList: 100 * oneMegaByte,
                    aggregatedFileSize: 6 * oneGigaByte,
                  }
                : plan.id === plans.BUSINESS.id
                ? {
                    users,
                    connectedLists: 300,
                    entries: 1e6,
                    maxFileSizeInList: oneGigaByte,
                    aggregatedFileSize: 600 * oneGigaByte,
                  }
                : plan.id === plans.ENTERPRISE.id
                ? {
                    users,
                    connectedLists: 3e3,
                    maxFileSizeInList: 5 * oneGigaByte,
                    aggregatedFileSize: 600 * oneGigaByte,
                  }
                : (plan.id === plans.INTERNAL.id || console.error('Unknown plan', plan.id, 'for chat app quotas.'), {})
            })(params)
          : params.appType === apps.hypernotes.type
          ? (function (params) {
              var plans = ZenkitControlsShared.apps.hypernotes.plans,
                plan = _.find(plans, { id: params.planId }) || plans.FREE
              if (plan.id === plans.FREE.id)
                return {
                  users: 2,
                  workspaces: 2,
                  connectedLists: 3,
                  entries: 1e4,
                  maxFileSizeInList: 20 * oneMegaByte,
                  aggregatedFileSize: 600 * oneMegaByte,
                }
              var users = subscriptionQuantityToUserQuota(params.subscriptionQuantity, 2)
              return plan.id === plans.PLUS.id
                ? {
                    users,
                    workspaces: 30,
                    connectedLists: 30,
                    entries: 8e4,
                    maxFileSizeInList: 100 * oneMegaByte,
                    aggregatedFileSize: 6 * oneGigaByte,
                  }
                : plan.id === plans.BUSINESS.id
                ? {
                    users,
                    connectedLists: 300,
                    entries: 1e6,
                    maxFileSizeInList: oneGigaByte,
                    aggregatedFileSize: 60 * oneGigaByte,
                  }
                : plan.id === plans.ENTERPRISE.id
                ? {
                    users,
                    connectedLists: 3e3,
                    maxFileSizeInList: 5 * oneGigaByte,
                    aggregatedFileSize: 600 * oneGigaByte,
                  }
                : (plan.id === plans.INTERNAL.id || console.error('Unknown plan', plan.id, 'for chat app quotas.'), {})
            })(params)
          : params.appType === apps.projects.type
          ? (function (params) {
              var plans = ZenkitControlsShared.apps.projects.plans,
                plan = _.find(plans, { id: params.planId }) || plans.FREE
              if (plan.id === plans.FREE.id)
                return {
                  users: 3,
                  lists: 3,
                  workspaces: 2,
                  connectedLists: 3,
                  entries: 1e4,
                  maxFileSizeInList: 20 * oneMegaByte,
                  aggregatedFileSize: 600 * oneMegaByte,
                }
              var users = subscriptionQuantityToUserQuota(params.subscriptionQuantity, 3)
              return plan.id === plans.PLUS.id
                ? {
                    users,
                    workspaces: 30,
                    lists: 80,
                    connectedLists: 30,
                    entries: 8e4,
                    maxFileSizeInList: 100 * oneMegaByte,
                    aggregatedFileSize: 6 * oneGigaByte,
                  }
                : plan.id === plans.BUSINESS.id
                ? {
                    users,
                    connectedLists: 300,
                    entries: 1e6,
                    maxFileSizeInList: oneGigaByte,
                    aggregatedFileSize: 60 * oneGigaByte,
                  }
                : plan.id === plans.ENTERPRISE.id
                ? {
                    users,
                    connectedLists: 3e3,
                    maxFileSizeInList: 5 * oneGigaByte,
                    aggregatedFileSize: 600 * oneGigaByte,
                  }
                : (plan.id === plans.INTERNAL.id || console.error('Unknown plan', plan.id, 'for projects app quotas.'),
                  {})
            })(params)
          : {}
      }
    ;(ZenkitSharedUtils.buildQuotas = function (params) {
      var manualQuotas =
          null ===
            (params = ZenkitSharedUtils.validateParameters(params, {
              appType: { type: 'string' },
              planId: { type: 'string' },
              contracted_at: {
                type: ['object', 'string'],
                customCheck: function (contracted_at) {
                  return moment(contracted_at).isValid()
                },
              },
              subscriptionQuantity: {
                type: ['number', 'null'],
                customCheck: function (subscriptionQuantity) {
                  return (
                    null === subscriptionQuantity || (_.isInteger(subscriptionQuantity) && subscriptionQuantity > 0)
                  )
                },
              },
              manualQuotas: { type: ['object', 'null'], default: null },
              subscription_valid_until: {
                type: ['object', 'string', 'null'],
                customCheck: function (subscription_valid_until) {
                  return null === subscription_valid_until || moment(subscription_valid_until).isValid()
                },
              },
            })).subscription_valid_until || moment(params.subscription_valid_until).isAfter(moment())
            ? params.manualQuotas
            : {},
        appQuotas = buildAppQuotas(params)
      return _.defaults({}, manualQuotas, appQuotas)
    }),
      (ZenkitSharedUtils.buildDeltaOfVolumeAndQuotas = function (volume, quotas) {
        return _.reduce(
          volume,
          function (delta, value, key) {
            return (delta[key] = { value, maxValue: quotas[key] }), delta
          },
          {},
        )
      }),
      (ZenkitSharedUtils.areQuotasExceededForDelta = function (delta) {
        var exceededDelta = _.find(delta, function (x) {
          return x.value > x.maxValue
        })
        return !1 === _.isNil(exceededDelta)
      }),
      (ZenkitSharedUtils.getReadableFileSize =
        ((units = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']),
        function (bytes, precision) {
          if (isNaN(parseFloat(bytes))) return '-'
          if (bytes < 1) return '0 B'
          isNaN(precision) && (precision = 1)
          var unitIndex = Math.floor(Math.log(bytes) / Math.log(1e3))
          return (bytes / Math.pow(1e3, unitIndex)).toFixed(precision) + ' ' + units[unitIndex]
        }))
    var getTextForDeltaValue = function (quotaId, value) {
      return _.includes(['aggregatedFileSize', 'maxAggregatedFileSizeInList', 'maxFileSizeInList'], quotaId)
        ? ZenkitSharedUtils.getReadableFileSize(value)
        : _.toString(value)
    }
    ZenkitSharedUtils.getQuotaDisplayString = function (params) {
      if (_.isNil(params.delta[params.quotaId])) return ''
      var text = getTextForDeltaValue(params.quotaId, params.delta[params.quotaId].value)
      return (
        void 0 !== params.delta[params.quotaId].maxValue &&
          (text += ' / ' + getTextForDeltaValue(params.quotaId, params.delta[params.quotaId].maxValue)),
        text
      )
    }
    var toUTCDate,
      fromUTCDate,
      rruleWeekday,
      AND,
      OR,
      filterTermsReducer,
      LANGUAGES_WITH_DECIMAL_COMMA = ['de', 'es', 'fr', 'it', 'pt', 'ru'],
      START_OF_WEEK = [
        ZenkitControlsShared.startOfTheWeekValues.SUNDAY,
        ZenkitControlsShared.startOfTheWeekValues.MONDAY,
      ]
    ;(ZenkitSharedUtils.getLocalizedUserSettings = function (language) {
      var settings = { language },
        locale = moment.localeData(language),
        localeDateFormat = locale.longDateFormat('L')
      _.includes(ZenkitControlsShared.dateFormats, localeDateFormat) && (settings.dateFormat = localeDateFormat)
      var localeTimeFormat = locale.longDateFormat('LT')
      _.includes(ZenkitControlsShared.timeFormats, localeTimeFormat) && (settings.timeFormat = localeTimeFormat)
      var startOfTheWeek = START_OF_WEEK[locale.firstDayOfWeek()]
      return (
        !1 === _.isNil(startOfTheWeek) && (settings.startOfTheWeek = startOfTheWeek),
        _.includes(LANGUAGES_WITH_DECIMAL_COMMA, language) &&
          (settings.decimalFormat = ZenkitControlsShared.decimalFormats.DECIMAL_COMMA),
        settings
      )
    }),
      (ZenkitSharedUtils.getDefaultChatSettings = function () {
        return {
          muted_at: null,
          pinned_at: null,
          hidden_at: null,
          marked_as_unread_at: null,
          task_feature_hidden_at: null,
          chatNotifications: 'all',
          topicNotifications: 'all',
          includeTopicMessages: !0,
          includeActivities: !1,
        }
      }),
      (ZenkitSharedUtils.getNotificationTriggerTypeId = function (_ref2) {
        var { notificationType, activityType } = _ref2,
          TYPES = ZenkitControlsShared.notificationTypes,
          TRIGGERS = ZenkitControlsShared.notificationTriggers
        return notificationType === TYPES.REMINDER
          ? TRIGGERS.REMINDERS.id
          : notificationType === TYPES.MENTION
          ? TRIGGERS.MENTIONS.id
          : notificationType === TYPES.SUBSCRIPTION
          ? activityType === ZenkitControlsShared.activityTypes.TYPE.COMMENT
            ? TRIGGERS.COMMENTS.id
            : TRIGGERS.ACTIVITIES.id
          : TRIGGERS.GENERAL.id
      }),
      (ZenkitSharedUtils.getAppSettingsWithDefaults = function (params) {
        var apps = ZenkitControlsShared.apps,
          appType = params.appType,
          settings = params.appSettings || {},
          defaultAppSettings = {
            soundEnabled: !0,
            createEntrySubscriptionWhenAssigned: !0,
            navigationBarListsMenuWorkspaceVisibilityMap: { 'recent-lists': !0 },
            recentListShortIds: [],
            defaultSortOrderForNewEntries: 'lowest',
            recentListEntries: [],
            recentGlobalSearchQueries: [],
            workspaceActivityFilter: ZenkitControlsShared.activityTypes.FILTER.NONE,
            listActivityFilter: ZenkitControlsShared.activityTypes.FILTER.NONE,
            userActivityFilter: ZenkitControlsShared.activityTypes.FILTER.NONE,
            listEntryActivityFilter: ZenkitControlsShared.activityTypes.FILTER.NONE,
            notificationSettings: {
              general: { email: !0, toast: !1, notification: !0, desktopNotification: !1, pushNotification: !0 },
              activities: { email: !1, toast: !1, notification: !0, desktopNotification: !1, pushNotification: !1 },
              comments: { email: !1, toast: !1, notification: !0, desktopNotification: !0, pushNotification: !0 },
              mentions: { email: !0, toast: !0, notification: !0, desktopNotification: !0, pushNotification: !0 },
              reminders: { email: !0, toast: !0, notification: !1, desktopNotification: !0, pushNotification: !0 },
            },
            textfieldInfoDismissed: !1,
            listElementSettingsInfoDismissed: !1,
            workspaceOnboardingVideoDismissed: !1,
            themeOnboardingDismissed: !1,
            addElementExampleInDetailsViewDismissed: !1,
            taskAddonInfoDismissed: !1,
            userAssignmentsInfoDismissed: !1,
            userTagsInfoDismissed: !1,
            welcomeDialogDismissed: !0,
            recentListsSettings: { navigationBarListsMenu: !0, homeScreen: !1 },
            userCalendarSettings: null,
            userTagsSettings: null,
            assignmentsViewSettings: null,
          }
        if (appType === apps.todos.type || appType === apps.projects.type) {
          ;(defaultAppSettings.navigationBarListsMenuWorkspaceVisibilityMap = {}),
            _.assign(defaultAppSettings, {
              textfieldInfoDismissed: !1,
              listElementSettingsInfoDismissed: !0,
              workspaceOnboardingVideoDismissed: !0,
              themeOnboardingDismissed: !0,
              addElementExampleInDetailsViewDismissed: !0,
              taskAddonInfoDismissed: !0,
              userAssignmentsInfoDismissed: !0,
              userTagsInfoDismissed: !0,
            })
          var userViewModi = ZenkitControlsShared.userViewModi,
            smartListsDefaultSettings = {}
          ;(smartListsDefaultSettings[userViewModi.USER_ASSIGNMENTS] = 'auto'),
            (smartListsDefaultSettings[userViewModi.USER_CALENDAR] = 'auto'),
            (smartListsDefaultSettings[userViewModi.USER_TAGS] = 'auto'),
            (smartListsDefaultSettings[userViewModi.USER_TODAY] = 'auto'),
            (smartListsDefaultSettings[userViewModi.USER_AGENDA] = 'auto'),
            (smartListsDefaultSettings[userViewModi.USER_ALL] = 'hidden'),
            (smartListsDefaultSettings[userViewModi.USER_DONE] = 'hidden'),
            (defaultAppSettings.smartListsVisibility = smartListsDefaultSettings),
            (defaultAppSettings.listEntryActivityFilter = ZenkitControlsShared.activityTypes.FILTER.COMMENTS)
        }
        return (
          appType === apps.chat.type &&
            ((defaultAppSettings.workspaceActivityFilter = ZenkitControlsShared.activityTypes.FILTER.COMMENTS),
            (defaultAppSettings.listActivityFilter = ZenkitControlsShared.activityTypes.FILTER.COMMENTS),
            (defaultAppSettings.listEntryActivityFilter = ZenkitControlsShared.activityTypes.FILTER.COMMENTS),
            (defaultAppSettings.notificationSettings = _.mapValues(
              defaultAppSettings.notificationSettings,
              function (notificationUiTypeSettings) {
                return _.defaults(
                  { email: !1, pushNotification: !0, desktopNotification: !0 },
                  notificationUiTypeSettings,
                )
              },
            ))),
          appType === apps.hypernotes.type &&
            ((defaultAppSettings.hypernotesLibraryWorkspaceIds = []),
            (defaultAppSettings.hypernotesNewBlockOnEnter = !1)),
          appType === apps.projects.type &&
            ((defaultAppSettings.notificationSettingsPerList = {}),
            _.assign(defaultAppSettings, {
              workspaceActivityFilter: ZenkitControlsShared.activityTypes.FILTER.COMMENTS,
              listActivityFilter: ZenkitControlsShared.activityTypes.FILTER.COMMENTS,
              userActivityFilter: ZenkitControlsShared.activityTypes.FILTER.COMMENTS,
            })),
          (settings = _.defaultsDeep(settings, defaultAppSettings)),
          appType === apps.todos.type &&
            ((settings[ZenkitControlsShared.userAddons.USER_TAGS.key] = {}),
            _.assign(settings, {
              workspaceActivityFilter: ZenkitControlsShared.activityTypes.FILTER.COMMENTS,
              listActivityFilter: ZenkitControlsShared.activityTypes.FILTER.COMMENTS,
              userActivityFilter: ZenkitControlsShared.activityTypes.FILTER.COMMENTS,
            })),
          appType === apps.chat.type &&
            ((settings.notificationSettings = _.mapValues(
              settings.notificationSettings,
              function (notificationUiTypeSettings) {
                return _.defaults({ toast: !1, notification: !0 }, notificationUiTypeSettings)
              },
            )),
            (settings.chats = _.map(settings.chats, function (chat) {
              return _.assign(ZenkitSharedUtils.getDefaultChatSettings(), chat)
            })),
            (settings.createEntrySubscriptionWhenAssigned = !1)),
          appType === apps.hypernotes.type && (settings[ZenkitControlsShared.userAddons.USER_TAGS.key] = {}),
          settings
        )
      }),
      (ZenkitSharedUtils.getUserSettingsWithDefaults = function (params) {
        var settings = params.userSettings || {}
        return (
          _.isUndefined(settings.timeFormat) &&
            (settings.timeFormat =
              settings.dateFormat === ZenkitControlsShared.dateFormats.DMY_DOT
                ? ZenkitControlsShared.timeFormats.CLOCK_24
                : ZenkitControlsShared.timeFormats.CLOCK_12),
          (settings = _.defaults(settings, {
            dateFormat: ZenkitControlsShared.dateFormats.MDY_SLASH,
            timeFormat: ZenkitControlsShared.dateFormats.CLOCK_12,
            decimalFormat: ZenkitControlsShared.decimalFormats.DECIMAL_POINT,
            startOfTheWeek: ZenkitControlsShared.startOfTheWeekValues.MONDAY,
          }))
        )
      }),
      (ZenkitSharedUtils.getUserSettingsForAppWithDefaults = function (params) {
        return _.defaults(
          {},
          params.userSettings,
          ZenkitSharedUtils.getAppSettingsWithDefaults({ appSettings: params.appSettings, appType: params.appType }),
          ZenkitSharedUtils.getUserSettingsWithDefaults({ userSettings: params.userSettings, appType: params.appType }),
        )
      }),
      (ZenkitSharedUtils.createRRule =
        ((toUTCDate = function (date, timezone) {
          return moment.tz(date, timezone).utc(!0).toDate()
        }),
        (fromUTCDate = function (date, timezone) {
          return _.isNil(date) ? null : moment.utc(date).tz(timezone, !0)
        }),
        (rruleWeekday = function (day) {
          var weekday = RRule[day.weekday]
          return !1 === _.isInteger(day.nth) ? weekday : weekday.nth(day.nth)
        }),
        function (rule) {
          var frequency,
            interval = rule.interval,
            freq = ((frequency = rule.frequency), RRule[_.toUpper(frequency)]),
            timezone = rule.timezone || 'UTC',
            dtstart = toUTCDate(rule.dateTimeStart, timezone),
            until = (function (until, timezone) {
              return _.isNil(until) ? null : moment.utc(toUTCDate(until, timezone)).endOf('day').toDate()
            })(rule.until, timezone),
            count = _.isNil(rule.count) ? null : rule.count,
            byweekday = _.isEmpty(rule.byDay) ? null : _.map(rule.byDay, rruleWeekday),
            bymonthday = _.isEmpty(rule.byMonthDay) ? null : rule.byMonthDay,
            rrule = new RRule({ dtstart, freq, interval, count, until, byweekday, bymonthday })
          return {
            after: function (dt, inc) {
              var date = rrule.after(toUTCDate(dt, timezone), inc)
              return fromUTCDate(date, timezone)
            },
            before: function (dt, inc) {
              var date = rrule.before(toUTCDate(dt, timezone), inc)
              return fromUTCDate(date, timezone)
            },
            between: function (after, before, inc) {
              var dates = rrule.between(toUTCDate(after, timezone), toUTCDate(before, timezone), inc)
              return _.map(dates, function (date) {
                return fromUTCDate(date, timezone)
              })
            },
          }
        })),
      (ZenkitSharedUtils.getFilterKeyForTerm = function (term, elementsByUuid, elementcategories) {
        var element = _.find(elementsByUuid, { id: term.elementId }),
          elementcategory = _.find(elementcategories, { id: element.elementcategory }),
          filterKey = _.head(elementcategory.filterKeys),
          modusServerName = term.modus || ZenkitControlsShared.filterTermModi.EQUALS
        return (
          _.includes(['Number', 'Formula'], elementcategory.name) &&
            (filterKey =
              modusServerName === ZenkitControlsShared.filterTermModi.LESS_OR_EQUAL ? 'numberTo' : 'numberFrom'),
          filterKey
        )
      }),
      (ZenkitSharedUtils.makeFilterTreeBuilder = function (data) {
        data = ZenkitSharedUtils.validateParameters(data, {
          listElements: { type: 'array' },
          elementcategories: { type: 'array' },
        })
        var elementsByUuid = _.keyBy(data.listElements, 'uuid')
        return {
          term: function (params) {
            var term = {
              elementId: (params = ZenkitSharedUtils.validateParameters(params, {
                elementId: { type: 'number' },
                modus: { type: 'string', default: ZenkitControlsShared.filterTermModi.CONTAINS },
                negated: { type: 'boolean', default: !1 },
                value: { type: ['any', 'undefined'] },
              })).elementId,
              modus: params.modus,
              negated: params.negated,
            }
            return (
              (term[ZenkitSharedUtils.getFilterKeyForTerm(term, elementsByUuid, data.elementcategories)] =
                params.value),
              term
            )
          },
          dateTerm: function (params) {
            return {
              elementId: (params = ZenkitSharedUtils.validateParameters(params, {
                elementId: { type: 'number' },
                dateType: { type: 'number', default: ZenkitControlsShared.dateTimeFilterModi.EVERYTIME },
                dateFrom: { type: ['string', 'object', 'undefined'] },
                dateTo: { type: ['string', 'object', 'undefined'] },
              })).elementId,
              modus: null,
              negated: !1,
              dateType: params.dateType,
              dateFrom: params.dateFrom,
              dateTo: params.dateTo,
            }
          },
          subentryTerm: function (params) {
            return {
              elementId: (params = ZenkitSharedUtils.validateParameters(params, {
                elementId: { type: 'number' },
                lower: { type: ['number', 'undefined'] },
                upper: { type: ['number', 'undefined'] },
                connected: { type: ['boolean', 'null'], default: null },
                ancestorUuid: { type: ['string', 'null'], default: null },
                negated: { type: 'boolean', default: !1 },
              })).elementId,
              modus: ZenkitControlsShared.filterTermModi.EQUALS,
              lower: params.lower,
              upper: params.upper,
              connected: params.connected,
              ancestorUuid: params.ancestorUuid,
              negated: params.negated,
            }
          },
          filterTree: function (params) {
            params = ZenkitSharedUtils.validateParameters(params, {
              terms: { type: 'array' },
              operator: { type: 'string', default: ZenkitControlsShared.filterOperators.AND.serverName },
              baseTree: { type: 'object', default: {} },
            })
            var filterTree = {},
              baseTree = ZenkitSharedUtils.isFilterEmpty(params.baseTree) ? {} : params.baseTree
            return (filterTree[params.operator] = _.defaults({ TERMS: params.terms }, baseTree)), filterTree
          },
        }
      }),
      (ZenkitSharedUtils.parseFullname = function (fullname) {
        var firstName = '',
          lastName = '',
          partials = _.split(fullname, ' '),
          numberOfPartials = _.size(partials)
        return (
          1 === numberOfPartials
            ? (firstName = _.head(partials))
            : numberOfPartials >= 2 &&
              ((firstName = _.join(partials.slice(0, -1), ' ')), (lastName = _.last(partials))),
          { firstName, lastName }
        )
      }),
      (ZenkitSharedUtils.getAllFilterTerms =
        ((AND = ZenkitControlsShared.filterOperators.AND.serverName),
        (OR = ZenkitControlsShared.filterOperators.OR.serverName),
        (filterTermsReducer = function filterTermsReducer(terms, treeOrTerms, key) {
          return key === AND || key === OR
            ? _.reduce(treeOrTerms, filterTermsReducer, terms)
            : 'TERMS' === key
            ? _.concat(terms, treeOrTerms)
            : (console.warn('Unexpected key: ', key), terms)
        }),
        function (filter) {
          return _.reduce(filter, filterTermsReducer, [])
        })),
      (ZenkitSharedUtils.isFilterEmpty = function (filter) {
        return _.isEmpty(ZenkitSharedUtils.getAllFilterTerms(filter))
      }),
      (ZenkitSharedUtils.sortUsersByRole = function (users) {
        return _.orderBy(users, [
          function (user) {
            var roleId = user.access ? user.access.roleId : user.roleId,
              role = ZenkitControlsShared.roles[roleId]
            return role ? role.sortOrder : 1 / 0
          },
          function (user) {
            return _.toLower(user.fullname)
          },
          'id',
        ])
      }),
      (ZenkitSharedUtils.sortGroupsByRole = function (groups) {
        return _.orderBy(
          groups,
          [
            'isAllUsers',
            function (group) {
              var roleId = group.access && group.access.roleId,
                role = ZenkitControlsShared.roles[roleId]
              return role ? role.sortOrder : 1 / 0
            },
            function (group) {
              return _.toLower(group.name)
            },
            'id',
          ],
          ['desc'],
        )
      }),
      (ZenkitSharedUtils.formatSubentryPath = function (path) {
        return _.replace(path, /(^|\.)0+/g, '$1') + '.'
      }),
      (ZenkitSharedUtils.subentryPathToDepth = function (path) {
        return _.size(_.split(path, '.')) - 1
      })
    ZenkitSharedUtils.buildInitialsFromFullname = function (fullname) {
      return _.chain(fullname)
        .trim()
        .split(/\s+/)
        .map(function (word) {
          var char = _.trim(word).substring(0, 1)
          return _.toUpper(char)
        })
        .join('')
        .value()
        .substring(0, 4)
    }
    var pad = function (num, totalChars) {
        for (num += ''; num.length < totalChars; ) num = '0' + num
        return num
      },
      changeColor = function (color, ratio, darker) {
        ;(color = _.replace(color, /^\s*|\s*$/, '')),
          (color = _.replace(color, /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i, '#$1$1$2$2$3$3'))
        var difference = Math.round(256 * ratio) * (darker ? -1 : 1),
          rgb = color.match(
            new RegExp(
              '^rgba?\\(\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])\\s*,\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])\\s*,\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])(?:\\s*,\\s*(0|1|0?\\.\\d+))?\\s*\\)$',
              'i',
            ),
          ),
          alpha = rgb && null != rgb[4] ? rgb[4] : null,
          decimal = rgb
            ? [rgb[1], rgb[2], rgb[3]]
            : _.chain(color)
                .replace(/^#?([a-f0-9][a-f0-9])([a-f0-9][a-f0-9])([a-f0-9][a-f0-9])/i, function () {
                  return (
                    parseInt(arguments[1], 16) + ',' + parseInt(arguments[2], 16) + ',' + parseInt(arguments[3], 16)
                  )
                })
                .split(/,/)
                .value()
        return rgb
          ? 'rgb' +
              (null !== alpha ? 'a' : '') +
              '(' +
              Math[darker ? 'max' : 'min'](parseInt(decimal[0], 10) + difference, darker ? 0 : 255) +
              ', ' +
              Math[darker ? 'max' : 'min'](parseInt(decimal[1], 10) + difference, darker ? 0 : 255) +
              ', ' +
              Math[darker ? 'max' : 'min'](parseInt(decimal[2], 10) + difference, darker ? 0 : 255) +
              (null !== alpha ? ', ' + alpha : '') +
              ')'
          : [
              '#',
              pad(
                Math[darker ? 'max' : 'min'](parseInt(decimal[0], 10) + difference, darker ? 0 : 255).toString(16),
                2,
              ),
              pad(
                Math[darker ? 'max' : 'min'](parseInt(decimal[1], 10) + difference, darker ? 0 : 255).toString(16),
                2,
              ),
              pad(
                Math[darker ? 'max' : 'min'](parseInt(decimal[2], 10) + difference, darker ? 0 : 255).toString(16),
                2,
              ),
            ].join('')
      }
    ;(ZenkitSharedUtils.getLighterColor = function (color, ratio) {
      return changeColor(color, ratio, !1)
    }),
      (ZenkitSharedUtils.getDarkerColor = function (color, ratio) {
        return changeColor(color, ratio, !0)
      })
    var rgbRegex = /^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i
    ;(ZenkitSharedUtils.getColorBetween = _ref3 => {
      var { from, to, percentage } = _ref3,
        fromMatch = from.match(rgbRegex),
        toMatch = to.match(rgbRegex),
        fromRGB = _.map(fromMatch.slice(1), Number),
        toRGB = _.map(toMatch.slice(1), Number),
        finalRGB = _.map(fromRGB, (value, index) => {
          var adjustBy = (toRGB[index] - fromRGB[index]) * percentage
          return Math.round(value + adjustBy)
        })
      return 'rgb('.concat(finalRGB[0], ', ').concat(finalRGB[1], ', ').concat(finalRGB[2], ')')
    }),
      (ZenkitSharedUtils.getAppProtocolFromHostname = hostname =>
        _.chain(hostname)
          .toLower()
          .replace(/\.(?:(?!\.)[\s\S])+$/, '')
          .replace(/(?:(?![a-z])[\s\S])+/g, '')
          .value())
    var findPathsToMatches = _ref4 => {
      var { input, condition, path = [] } = _ref4,
        isMatch = condition(input)
      return (
        !1 === _.isBoolean(isMatch) &&
          console.warn('findPathsToMatches: Expected condition to return a boolean. Got', isMatch),
        isMatch
          ? [path]
          : _.isPlainObject(input) || _.isArray(input)
          ? _.reduce(
              input,
              (paths, value, key) =>
                _.concat(paths, findPathsToMatches({ input: value, condition, path: _.concat(path, [key]) })),
              [],
            )
          : []
      )
    }
    ;(ZenkitSharedUtils.replaceValuesThatMatchRecursively = _ref5 => {
      var { input, condition, replace } = _ref5,
        paths = findPathsToMatches({ input, condition })
      return produceState(input, output => {
        for (var path of paths) _.set(output, path, replace(_.get(input, path)))
      })
    }),
      (ZenkitSharedUtils.asyncReplaceValuesThatMatchRecursively = _ref6 => {
        var { Promise, input, condition, replace } = _ref6,
          paths = findPathsToMatches({ input, condition })
        return _.isEmpty(paths)
          ? Promise.resolve(input)
          : Promise.map(paths, path => replace(_.get(input, path))).then(replacementValues => {
              var numberOfPaths = _.size(paths)
              return produceState(input, output => {
                for (var index = 0; index < numberOfPaths; index++) {
                  var path = paths[index],
                    value = replacementValues[index]
                  _.set(output, path, value)
                }
                return output
              })
            })
      }),
      weAreOnTheClient ? (window.ZenkitSharedUtils = ZenkitSharedUtils) : (module.exports = ZenkitSharedUtils)
  })(this),
  (function (window) {
    var _,
      moment,
      ZenkitControlsShared,
      ZenkitSharedUtils,
      weAreOnTheClient = 'undefined' == typeof module
    !weAreOnTheClient
      ? ((_ = require('lodash')),
        (moment = require('moment')),
        (ZenkitControlsShared = require('../SharedServer/ZenkitControlsShared')),
        (ZenkitSharedUtils = require('../SharedUtils/ZenkitSharedUtils.js')))
      : ((_ = window._),
        (moment = window.moment),
        (ZenkitControlsShared = window.ZenkitControlsShared),
        (ZenkitSharedUtils = window.ZenkitSharedUtils))
    var ZenkitSharedWorkerUtils = {
        isQuotaExceededError: function (err) {
          return _.includes(
            ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR', 'NS_ERROR_DOM_QUOTA_REACHED'],
            _.get(err, ['name']),
          )
        },
      },
      ensureCaseInsensitivity = function ensureCaseInsensitivity(maybeAString) {
        return _.isArray(maybeAString)
          ? _.map(maybeAString, ensureCaseInsensitivity)
          : !1 === _.isString(maybeAString)
          ? maybeAString
          : _.toLower(maybeAString)
      }
    ;(ZenkitSharedWorkerUtils.matchesInModus = function (params) {
      return (
        (params.query = ensureCaseInsensitivity(params.query)),
        (params.value = ensureCaseInsensitivity(params.value)),
        (params.treatNilAsZero = !1 !== params.treatNilAsZero),
        params.modusServerName === ZenkitControlsShared.filterTermModi.EQUALS
          ? 'array' === params.primaryType
            ? _.isEqual(params.value, params.query)
            : params.value === params.query
          : params.modusServerName === ZenkitControlsShared.filterTermModi.CONTAINS
          ? 'array' === params.primaryType
            ? _.intersection(params.value, params.query).length > 0
            : _.includes(params.value, params.query)
          : params.modusServerName === ZenkitControlsShared.filterTermModi.STARTS_WITH
          ? 'array' === params.primaryType || _.startsWith(params.value, params.query)
          : params.modusServerName === ZenkitControlsShared.filterTermModi.ENDS_WITH
          ? 'array' === params.primaryType || _.endsWith(params.value, params.query)
          : params.modusServerName === ZenkitControlsShared.filterTermModi.GREATER_OR_EQUAL
          ? 'float' !== params.primaryType ||
            ((!1 !== params.treatNilAsZero || !_.isNil(params.value)) &&
              (parseFloat(params.value) || 0) >= parseFloat(params.query))
          : params.modusServerName === ZenkitControlsShared.filterTermModi.LESS_OR_EQUAL
          ? 'float' !== params.primaryType ||
            ((!1 !== params.treatNilAsZero || !_.isNil(params.value)) &&
              (parseFloat(params.value) || 0) <= parseFloat(params.query))
          : params.modusServerName === ZenkitControlsShared.filterTermModi.EMPTY
          ? _.isEmpty(_.toString(params.value))
          : params.modusServerName !== ZenkitControlsShared.filterTermModi.FILLED ||
            !1 === _.isEmpty(_.toString(params.value))
      )
    }),
      (ZenkitSharedWorkerUtils.matchesSearchQuery = function (
        listEntry,
        query,
        modusServerName,
        listElementsByUuid,
        elementcategories,
      ) {
        var elementcategoriesById = _.keyBy(elementcategories, 'id')
        return _.isNil(listElementsByUuid)
          ? (console.warn('Fields not cached.', listEntry.listId), true)
          : _.some(listElementsByUuid, function (listElement) {
              var ecName = elementcategoriesById[listElement.elementcategory].name,
                uuid = listElement.uuid,
                value = '',
                type = 'text'
              return (
                'Textfield' === ecName
                  ? ((value = _.toString(listEntry[uuid + '_text'])), (type = 'text'))
                  : 'Number' === ecName
                  ? ((value = _.toString(listEntry[uuid + '_number'])), (type = 'text'))
                  : 'Formula' === ecName
                  ? ((value = _.toString(listEntry[uuid + '_value'])), (type = 'text'))
                  : 'Link' === ecName
                  ? ((value = _.toString(listEntry[uuid + '_link'])), (type = 'text'))
                  : 'Categories' === ecName
                  ? ((value = _.map(listEntry[uuid + '_categories_sort'], 'name')), (type = 'array'))
                  : 'References' === ecName
                  ? ((value = _.map(listEntry[uuid + '_references_sort'], 'displayString')), (type = 'array'))
                  : 'Persons' === ecName
                  ? ((value = _.flatMap(listEntry[uuid + '_persons_sort'], function (user) {
                      return [user.username, user.displayname, user.initials]
                    })),
                    (type = 'array'))
                  : 'Files' === ecName &&
                    ((value = _.map(listEntry[uuid + '_filesData'], 'fileName')), (type = 'array')),
                'array' === type
                  ? _.some(value, function (stringValue) {
                      if (!1 !== _.isString(stringValue))
                        return ZenkitSharedWorkerUtils.matchesInModus({
                          value: stringValue,
                          query,
                          primaryType: 'text',
                          modusServerName,
                        })
                    })
                  : ZenkitSharedWorkerUtils.matchesInModus({ value, query, primaryType: type, modusServerName })
              )
            })
      })
    var doesEntryMatchTerm = function (listEntry, term, elementsMap, elementcategories, currentUser) {
      var matchesTerm = !1,
        element = _.find(elementsMap, { id: term.elementId }),
        elementcategory = _.find(elementcategories, { id: element.elementcategory }),
        modusServerName = term.modus || ZenkitControlsShared.filterTermModi.EQUALS,
        ecName = elementcategory.name
      if ('Subentries' === elementcategory.name)
        return (function (listEntry, term, element, modusServerName) {
          if (_.isBoolean(term.connected) && term.connected !== listEntry[element.uuid + '_connected']) return !1
          var parentsKey = element.uuid + '_parents',
            path = listEntry[element.uuid + '_path'],
            depth = _.size(_.split(path, '.')) - 1
          return (
            !(_.isFinite(term.lower) && depth < term.lower) &&
            !(_.isFinite(term.upper) && depth > term.upper) &&
            (_.isString(term.ancestorUuid)
              ? _.includes(listEntry[parentsKey], term.ancestorUuid)
              : !1 !== _.isNil(term.path) ||
                ZenkitSharedWorkerUtils.matchesInModus({
                  value: path,
                  query: term.path,
                  primaryType: 'text',
                  modusServerName,
                  treatNilAsZero: !1,
                }))
          )
        })(listEntry, term, element, modusServerName)
      var primaryKey = _.findKey(elementcategory.businessDataDefinition, { primary: !0 }),
        staticDateEcs = ['Created_at', 'Updated_at', 'Deprecated_at'],
        staticPersonEcs = ['Created_by', 'Updated_by', 'Deprecated_by'],
        primaryType = _.includes(staticDateEcs, ecName)
          ? 'datetime'
          : _.includes(staticPersonEcs, ecName)
          ? 'array'
          : 'Files' === ecName
          ? 'text'
          : _.get(elementcategory.businessDataDefinition, [primaryKey, 'type'], 'text'),
        value = _.includes(staticDateEcs, ecName)
          ? listEntry[_.toLower(ecName)]
          : _.includes(staticPersonEcs, ecName)
          ? [listEntry[_.toLower(ecName)]]
          : 'Files' === elementcategory.name
          ? _.join(_.map(listEntry[element.uuid + '_filesData'], 'fileName'), ' ')
          : listEntry[element.uuid + '_' + primaryKey],
        filterKey = ZenkitSharedUtils.getFilterKeyForTerm(term, elementsMap, elementcategories)
      if (_.includes(['Number', 'Formula'], elementcategory.name))
        matchesTerm = ZenkitSharedWorkerUtils.matchesInModus({
          value,
          query: parseFloat(term[filterKey]),
          primaryType,
          modusServerName,
        })
      else if (_.includes(['Date', 'Created_at', 'Updated_at'], elementcategory.name)) {
        var dateFilterType = term.dateType || ZenkitControlsShared.dateTimeFilterModi.EVERYTIME
        if (dateFilterType === ZenkitControlsShared.dateTimeFilterModi.EVERYTIME) return !0
        if (
          dateFilterType === ZenkitControlsShared.dateTimeFilterModi.EMPTY ||
          dateFilterType === ZenkitControlsShared.dateTimeFilterModi.FILLED
        )
          (matchesTerm = ZenkitSharedWorkerUtils.matchesInModus({
            value,
            query: term[filterKey],
            primaryType,
            modusServerName: ZenkitControlsShared.filterTermModi.EMPTY,
          })),
            dateFilterType === ZenkitControlsShared.dateTimeFilterModi.FILLED && (matchesTerm = !matchesTerm)
        else {
          var range = ZenkitSharedUtils.buildDateRange({
              user: currentUser,
              dateFilterType,
              dateFrom: term.dateFrom,
              dateTo: term.dateTo,
            }),
            dateFromIsValid = _.result(range, ['from', 'isValid'], !1),
            dateToIsValid = _.result(range, ['to', 'isValid'], !1),
            startDate = value,
            endDate = elementcategory.isStatic
              ? startDate
              : ZenkitSharedUtils.getEndDate({ listEntry, listElement: element })
          !1 === dateFromIsValid && !1 === dateToIsValid
            ? (matchesTerm = !1)
            : dateFromIsValid
            ? ((matchesTerm = moment(endDate, moment.ISO_8601).unix() >= range.from.unix()),
              dateToIsValid &&
                (matchesTerm = matchesTerm && moment(startDate, moment.ISO_8601).unix() <= range.to.unix()))
            : dateToIsValid && (matchesTerm = moment(startDate, moment.ISO_8601).unix() <= range.to.unix())
        }
      } else
        _.includes(['Hierarchy'], elementcategory.name)
          ? (modusServerName === ZenkitControlsShared.filterTermModi.EMPTY &&
              (matchesTerm = ZenkitSharedWorkerUtils.matchesInModus({
                value,
                query: term.level,
                primaryType: 'text',
                modusServerName: ZenkitControlsShared.filterTermModi.EMPTY,
              })),
            (matchesTerm = (function (term, value, modusServerName) {
              var level = parseInt(term.level)
              if (_.isNaN(term.level)) throw new Error('Hierarchy Filter: level is required.')
              var lengthOfString = ZenkitControlsShared.baseLengthOfHierarchyValue * (level + 1)
              return (
                level >= 1 && (lengthOfString += level),
                ZenkitSharedWorkerUtils.matchesInModus({
                  value: _.size(value),
                  query: lengthOfString,
                  primaryType: 'float',
                  modusServerName,
                  treatNilAsZero: !1,
                })
              )
            })(term, value, modusServerName)))
          : (matchesTerm = _.includes(['Checkbox'], elementcategory.name)
              ? 'selected' === term[filterKey]
                ? value
                : !value
              : ZenkitSharedWorkerUtils.matchesInModus({ value, query: term[filterKey], primaryType, modusServerName }))
      return matchesTerm
    }
    ;(ZenkitSharedWorkerUtils.filterListEntries = function (params) {
      var listEntries = (params = ZenkitSharedUtils.validateParameters(params, {
          listEntries: { type: 'array' },
          filter: { type: ['object', 'null'] },
          listElementsByUuid: { type: 'object' },
          elementcategories: { type: 'array' },
          currentUser: { type: ['object', 'null'] },
          userTagAssignments: { type: ['array', 'null'], default: null },
        })).listEntries,
        filter = params.filter,
        listElementsByUuid = params.listElementsByUuid,
        elementcategories = params.elementcategories,
        currentUser = params.currentUser,
        userTagAssignments = params.userTagAssignments
      if (_.isNil(filter) || ZenkitSharedUtils.isFilterEmpty(filter)) return listEntries
      var AND = ZenkitControlsShared.filterOperators.AND.serverName,
        OR = ZenkitControlsShared.filterOperators.OR.serverName,
        doesEntryMatchFilterTree = function doesEntryMatchFilterTree(listEntry, filterTree, parentOperator) {
          return _.reduce(
            filterTree,
            function (matchesFilter, treeOrTerms, nodeKey) {
              return (
                (parentOperator !== AND || !1 !== matchesFilter) &&
                ((parentOperator === OR && !0 === matchesFilter) ||
                  (nodeKey === AND || nodeKey === OR
                    ? doesEntryMatchFilterTree(listEntry, treeOrTerms, nodeKey)
                    : 'TERMS' === nodeKey
                    ? (function (listEntry, terms, parentOperator) {
                        return _.reduce(
                          terms,
                          function (matchesFilter, term) {
                            if (parentOperator === AND && !1 === matchesFilter) return !1
                            if (parentOperator === OR && !0 === matchesFilter) return !0
                            var matchesTerm,
                              modusServerName = term.modus || ZenkitControlsShared.filterTermModi.EQUALS
                            if ('userTags' === term.type) {
                              if (_.isNil(userTagAssignments))
                                throw new Error(
                                  'ZenkitSharedWorkerUtils.filterListEntries: userTagAssignments are required if the filter contains a userTags term.',
                                )
                              matchesTerm = ZenkitSharedWorkerUtils.matchesInModus({
                                value: _.get(
                                  _.find(userTagAssignments, { listId: listEntry.listId, listEntryId: listEntry.id }),
                                  ['tagIds'],
                                  [],
                                ),
                                query: term.tagIds,
                                primaryType: 'array',
                                modusServerName,
                              })
                            } else
                              matchesTerm =
                                term.elementId === ZenkitControlsShared.allElementsFilterId
                                  ? ZenkitSharedWorkerUtils.matchesSearchQuery(
                                      listEntry,
                                      term.text,
                                      modusServerName,
                                      listElementsByUuid,
                                      elementcategories,
                                    )
                                  : doesEntryMatchTerm(
                                      listEntry,
                                      term,
                                      listElementsByUuid,
                                      elementcategories,
                                      currentUser,
                                    )
                            return (
                              term.negated && (matchesTerm = !matchesTerm),
                              parentOperator === AND ? matchesFilter && matchesTerm : matchesFilter || matchesTerm
                            )
                          },
                          parentOperator === AND,
                        )
                      })(listEntry, treeOrTerms, parentOperator)
                    : (console.warn('Unexpected key:', nodeKey), matchesFilter)))
              )
            },
            _.isNil(parentOperator) || parentOperator === AND,
          )
        }
      return _.filter(listEntries, function (listEntry) {
        return doesEntryMatchFilterTree(listEntry, filter)
      })
    }),
      (ZenkitSharedWorkerUtils.getEntryDefaultsForElement = function (element) {
        return _.reduce(
          element.businessData,
          function (defaults, defaultValue, propertyName) {
            return (
              'date' === propertyName &&
                defaultValue === ZenkitControlsShared.dateElementBusinessDataNow &&
                (defaultValue = Date.now()),
              (defaults[element.uuid + '_' + propertyName] = _.cloneDeep(defaultValue)),
              defaults
            )
          },
          {},
        )
      }),
      (ZenkitSharedWorkerUtils.getListEntrySortingHandler = function (params) {
        var orderByArray,
          orderBy = params.orderBy,
          listElementsById = _.keyBy(params.listElements, 'id'),
          listElementsByShortId = _.keyBy(params.listElements, 'shortId'),
          ecMap = _.keyBy(params.elementcategories, 'id')
        orderByArray = _.isArray(orderBy)
          ? orderBy
          : _.isObject(orderBy)
          ? [orderBy]
          : [{ column: 'sortOrder', direction: 'asc' }]
        var sortFns = [],
          directions = []
        return (
          _.forEach(orderByArray, function (orderObject) {
            var listElement,
              elementcategory,
              column = orderObject.column,
              defaultValuesOfListElement = {},
              isColumnOfListElement = _.isFinite(orderObject.elementId) || _.has(orderObject, ['elementShortId'])
            if (isColumnOfListElement) {
              if (
                ((listElement =
                  listElementsById[orderObject.elementId] || listElementsByShortId[orderObject.elementShortId]),
                _.isNil(listElement))
              )
                return void console.warn('Field not found.', orderObject)
              elementcategory = ecMap[listElement.elementcategory]
              var sortKey = ecMap[listElement.elementcategory].sortKey
              elementcategory.isStatic
                ? (column = sortKey)
                : ((column = listElement.uuid + '_' + sortKey),
                  (defaultValuesOfListElement = _.reduce(
                    _.get(listElement, ['businessData']),
                    function (defaults, value, key) {
                      return (defaults[listElement.uuid + '_' + key] = value), defaults
                    },
                    {},
                  )))
            }
            var ecName = _.get(elementcategory, ['name']),
              predefinedCategories =
                ('Categories' === ecName && _.get(listElement, ['elementData', 'predefinedCategories'])) || [],
              categoryIdToIndex = _.reduce(
                predefinedCategories,
                (map, category, index) => ((map[category.id] = index), map),
                {},
              ),
              getIndexOfCategoryId = categoryId => _.get(categoryIdToIndex, categoryId, -1),
              sortDirection = _.toLower(orderObject.direction)
            directions.push(sortDirection),
              sortFns.push(function (listEntry) {
                if ('taskIsDone' === column)
                  return _.isNil(params.taskData)
                    ? (console.warn(
                        'Ordering by column "taskIsDone" requires taskData to be passed to getListEntrySortingHandler.',
                      ),
                      !1)
                    : _.isEqual(listEntry[params.taskData.listElementKey], [params.taskData.done.id])
                if ('sourceIndex' === column)
                  return (
                    _.isNil(params.sourceIndex) &&
                      console.error(
                        'Ordering by column "sourceIndex" requires sourceIndex to be passed to getListEntrySortingHandler.',
                      ),
                    params.sourceIndex
                  )
                var value = listEntry[column]
                if (isColumnOfListElement)
                  if (
                    (void 0 === value && (value = defaultValuesOfListElement[column]),
                    'Created_at' === ecName && listEntry.origin_created_at && (value = listEntry.origin_created_at),
                    _.includes(['Number', 'Formula', 'Date', 'Created_at', 'Updated_at'], ecName))
                  ) {
                    if (_.isNil(value)) return 'desc' === sortDirection ? -1 / 0 : 1 / 0
                  } else if (_.includes(['Categories', 'Persons', 'Files'], ecName)) {
                    if (_.isEmpty(value)) return 'desc' === sortDirection ? -1 / 0 : 1 / 0
                  } else if (_.isEmpty(value)) return 'desc' === sortDirection ? '' : String.fromCharCode(65535)
                return (
                  'Categories' === ecName
                    ? (value = _.map(value, getIndexOfCategoryId))
                    : _.includes(['Date', 'Created_at', 'Updated_at'], ecName) &&
                      (value = value ? new Date(value).valueOf() : null),
                  'sortOrder' === column && _.isString(value) && (value = parseFloat(value)),
                  _.isArray(value)
                    ? (value =
                        !1 === _.isEmpty(value) && _.every(value, _.isNumber)
                          ? _.chain(value)
                              .sortBy()
                              .reverse()
                              .reduce(function (total, number, index) {
                                return total + number / Math.pow(100, index)
                              }, 0)
                              .value()
                          : _.join(_.sortBy(value)))
                    : _.isString(value) && (value = _.toLower(value)),
                  value
                )
              })
          }),
          { functions: sortFns, directions }
        )
      }),
      (ZenkitSharedWorkerUtils.getListEntrySortingHandlerForSources = function (params) {
        if (_.isEmpty(params.sources)) return { functions: [], directions: [] }
        var sortingHandlerPerList = _.reduce(
            params.sources,
            function (map, source, sourceIndex) {
              var sortingHandler = ZenkitSharedWorkerUtils.getListEntrySortingHandler({
                sourceIndex,
                orderBy: source.orderBy,
                listElements: params.listElementsByListId[source.listId],
                elementcategories: params.elementcategories,
                taskData: params.taskDataByListId[source.listId],
              })
              return (map[source.listId] = sortingHandler), map
            },
            {},
          ),
          sourceWithMaxNumberOfOrderByStatements = _.maxBy(params.sources, source => _.size(source.orderBy)),
          directionsToUse = sortingHandlerPerList[sourceWithMaxNumberOfOrderByStatements.listId].directions
        return {
          functions: _.map(sourceWithMaxNumberOfOrderByStatements.orderBy, function (orderObj, index) {
            return function (listEntry) {
              var handler = _.get(sortingHandlerPerList, [listEntry.listId, 'functions', index])
              return handler ? handler(listEntry) : -1
            }
          }),
          directions: directionsToUse,
        }
      }),
      (ZenkitSharedWorkerUtils.getPrimaryColumn = function (params) {
        var listElement = params.listElement,
          elementcategory = params.elementcategory
        if (!0 === elementcategory.isStatic) return elementcategory.sortKey
        var primaryKey = _.findKey(elementcategory.businessDataDefinition, { primary: !0 })
        if (_.isNil(primaryKey)) throw new Error('Primary key not found')
        return listElement.uuid + '_' + primaryKey
      }),
      (ZenkitSharedWorkerUtils.getValidationForActivityLoader = _.constant({
        filter: {
          type: 'number',
          default: ZenkitControlsShared.activityTypes.FILTER.NONE,
          customCheck: function (filter) {
            return _.includes(_.values(ZenkitControlsShared.activityTypes.FILTER), filter)
          },
        },
        skip: { type: 'number', default: 0 },
        limit: { type: 'number', default: 25 },
        loadFromCache: { type: 'boolean', default: !1 },
      })),
      (ZenkitSharedWorkerUtils.evaluateSubentryPathsForElement = function (params) {
        var listElement = params.listElement,
          markListEntryAsUpdated = params.markListEntryAsUpdated,
          listEntriesByUuid = _.omitBy(params.listEntriesByUuid, 'deprecated_at'),
          publishTypes_ADDED = 'ADDED',
          publishTypes_CHANGED = 'CHANGED',
          publishTypes_REMOVED = 'REMOVED',
          topLevelOrderWasAffected = params.topLevelOrderWasAffected,
          referencesKey = listElement.uuid + '_references',
          parentsKey = listElement.uuid + '_parents',
          pathKey = listElement.uuid + '_path',
          connectedKey = listElement.uuid + '_connected',
          sortOrderKey = listElement.uuid + '_sortOrder',
          trail = {},
          uuidsOfEntriesWithParents = _.flatMap(listEntriesByUuid, function (listEntry) {
            return listEntry[referencesKey] || []
          })
        return (
          (function updateChildrenOfParent(children, parent) {
            var child,
              index,
              numberOfChildren = children.length
            for (index = 0; index < numberOfChildren; index++)
              if (((child = children[index]), !_.isNil(child))) {
                if (trail[child.uuid]) throw new Error('Cyclic hierarchy detected')
                trail[child.uuid] = !0
                var publishType,
                  updateParams = {},
                  pathTail = index + 1 + '',
                  filledPathTail = _.padStart(pathTail, ZenkitControlsShared.baseLengthOfHierarchyValue, '0')
                parent
                  ? (parent.deprecated_at
                      ? ((updateParams.deprecated_at = child.deprecated_at || parent.deprecated_at),
                        (updateParams[pathKey] = null),
                        (updateParams[parentsKey] = null),
                        (publishType = publishTypes_REMOVED))
                      : _.isNil(parent.deprecated_at) && child.deprecated_at
                      ? ((updateParams.deprecated_at = null), (publishType = publishTypes_ADDED))
                      : (publishType = publishTypes_CHANGED),
                    (updateParams[pathKey] = parent[pathKey] + '.' + filledPathTail),
                    (updateParams[connectedKey] = parent[connectedKey]),
                    (updateParams[sortOrderKey] = null),
                    (updateParams[parentsKey] = _.concat(parent[parentsKey], parent.uuid)))
                  : topLevelOrderWasAffected &&
                    ((publishType = publishTypes_CHANGED),
                    (updateParams[pathKey] = filledPathTail),
                    (updateParams[parentsKey] = []),
                    (updateParams[sortOrderKey] = child[sortOrderKey] || child.id || 1e6 + index))
                var updatedKeys = _.keys(updateParams)
                markListEntryAsUpdated &&
                  !1 === _.isEqual(_.pick(child, updatedKeys), updateParams) &&
                  (_.assign(child, updateParams), markListEntryAsUpdated(child, publishType)),
                  updateChildrenOfParent(
                    _.map(child[referencesKey], function (uuid) {
                      return listEntriesByUuid[uuid]
                    }),
                    child,
                  )
              }
          })(
            _.chain(listEntriesByUuid)
              .omit(uuidsOfEntriesWithParents)
              .orderBy([connectedKey, sortOrderKey, 'id'], ['desc', 'asc', 'asc'])
              .value(),
            null,
          ),
          listEntriesByUuid
        )
      }),
      weAreOnTheClient
        ? (window.ZenkitSharedWorkerUtils = ZenkitSharedWorkerUtils)
        : (module.exports = ZenkitSharedWorkerUtils)
  })(this),
  (self.zenkitSDKConstants = {
    messageTypes: {
      loadRequest: 'loadRequest',
      loadResponse: 'loadResponse',
      dispatchRequest: 'dispatchRequest',
      dispatchResponse: 'dispatchResponse',
      commandRequest: 'commandRequest',
      commandResponse: 'commandResponse',
      broadcastRequest: 'broadcastRequest',
      broadcastResponse: 'broadcastResponse',
      event: 'event',
      disconnect: 'disconnect',
    },
    events: {
      syncStatusChanged: 'syncStatusChanged',
      listSynchronizationChanged: 'listSynchronizationChanged',
      workspaceSynchronizationChanged: 'workspaceSynchronizationChanged',
      onlineStatusChanged: 'onlineStatusChanged',
      queueChanged: 'queueChanged',
      reconnectFailed: 'reconnectFailed',
      reconnectSucceeded: 'reconnectSucceeded',
      resourceChanged: 'resourceChanged',
      workerError: 'workerError',
      legacyEvent: 'legacyEvent',
      broadcastMessage: 'broadcastMessage',
    },
    workerErrors: {
      QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',
      SOCKET_ERROR: 'SOCKET_ERROR',
      INDEXED_DB_INVALID_STATE: 'INDEXED_DB_INVALID_STATE',
      SHARED_WORKER_ALIVE_REQUEST_FAILED: 'SHARED_WORKER_ALIVE_REQUEST_FAILED',
    },
    resources: {
      NO_RESOURCE: 'NO_RESOURCE',
      ACCESS: 'ACCESS',
      ACCESSES: 'ACCESSES',
      LIST_ENTRY: 'LIST_ENTRY',
      LIST_ENTRIES: 'LIST_ENTRIES',
      LIST_ELEMENT: 'LIST_ELEMENT',
      LIST_ELEMENTS: 'LIST_ELEMENTS',
      GLOBAL_ENTRIES: 'GLOBAL_ENTRIES',
      USER: 'USER',
      USERS: 'USERS',
      GROUP: 'GROUP',
      GROUPS: 'GROUPS',
      CURRENT_USER: 'CURRENT_USER',
      ACCESSES_PER_LIST: 'ACCESSES_PER_LIST',
      ACCESSES_PER_WORKSPACE: 'ACCESSES_PER_WORKSPACE',
      WORKSPACES_WITH_LISTS: 'WORKSPACES_WITH_LISTS',
      ACCESSES_PER_ORGANIZATION: 'ACCESSES_PER_ORGANIZATION',
      LIST: 'LIST',
      WORKSPACE: 'WORKSPACE',
      LIST_ENTRY_ACTIVITY: 'LIST_ENTRY_ACTIVITY',
      LIST_ACTIVITY: 'LIST_ACTIVITY',
      WORKSPACE_ACTIVITY: 'WORKSPACE_ACTIVITY',
      ACTIVITIES: 'ACTIVITIES',
      ACTIVITIES_PER_WORKSPACE: 'ACTIVITIES_PER_WORKSPACE',
      USER_RESOURCES_SYNC_TIMESTAMPS: 'USER_RESOURCES_SYNC_TIMESTAMPS',
      ELEMENTCATEGORIES: 'ELEMENTCATEGORIES',
      BACKGROUNDS: 'BACKGROUNDS',
      BACKGROUND: 'BACKGROUND',
      VIEW: 'VIEW',
      VIEWS: 'VIEWS',
      USER_VIEW: 'USER_VIEW',
      USER_VIEWS: 'USER_VIEWS',
      LIST_FILTER: 'LIST_FILTER',
      LIST_FILTERS: 'LIST_FILTERS',
      LIST_FILE: 'LIST_FILE',
      LAST_USED_VIEW_UUID_PER_LIST: 'LAST_USED_VIEW_UUID_PER_LIST',
      CATEGORY_SORT_ORDERS_PER_LIST: 'CATEGORY_SORT_ORDERS_PER_LIST',
      CATEGORY_SORT_ORDER: 'CATEGORY_SORT_ORDER',
      LIST_SYNCHRONIZATIONS: 'LIST_SYNCHRONIZATIONS',
      LIST_SYNCHRONIZATION: 'LIST_SYNCHRONIZATION',
      WORKSPACE_SYNCHRONIZATIONS: 'WORKSPACE_SYNCHRONIZATIONS',
      WORKSPACE_SYNCHRONIZATION: 'WORKSPACE_SYNCHRONIZATION',
      ORGANIZATION: 'ORGANIZATION',
      ORGANIZATIONS: 'ORGANIZATIONS',
      DB_VERSION: 'DB_VERSION',
      ACCESS_TOKEN: 'ACCESS_TOKEN',
      REMINDER: 'REMINDER',
      REMINDERS: 'REMINDERS',
      RECURRENCE_RULE: 'RECURRENCE_RULE',
      RECURRENCE_RULES: 'RECURRENCE_RULES',
      USER_TAGS: 'USER_TAGS',
      USER_TAG_ASSIGNMENTS: 'USER_TAG_ASSIGNMENTS',
      MINIMAL_NEW_NOTIFICATIONS: 'MINIMAL_NEW_NOTIFICATIONS',
    },
    actions: {
      INSTALL_APP: 'INSTALL_APP',
      UNINSTALL_APP: 'UNINSTALL_APP',
      UPDATE_CURRENT_USER: 'UPDATE_CURRENT_USER',
      UPLOAD_USER_FILE: 'UPLOAD_USER_FILE',
      UPLOAD_PROFILE_IMAGE: 'UPLOAD_PROFILE_IMAGE',
      UPDATE_CURRENT_USER_BACKGROUND: 'UPDATE_CURRENT_USER_BACKGROUND',
      DELETE_CURRENT_USER: 'DELETE_CURRENT_USER',
      UPDATE_USER_SETTINGS: 'UPDATE_USER_SETTINGS',
      ACCEPT_TERMS: 'ACCEPT_TERMS',
      ACCEPT_PRIVACY_POLICY: 'ACCEPT_PRIVACY_POLICY',
      CREATE_EMAIL: 'CREATE_EMAIL',
      DEPRECATE_EMAIL: 'DEPRECATE_EMAIL',
      CHANGE_API_KEY: 'CHANGE_API_KEY',
      FINISH_2FA_SETUP: 'FINISH_2FA_SETUP',
      DISABLE_2FA: 'DISABLE_2FA',
      DEPRECATE_PROVIDER: 'DEPRECATE_PROVIDER',
      RESET_ONBOARDING: 'RESET_ONBOARDING',
      CREATE_LIST_ENTRY: 'CREATE_LIST_ENTRY',
      CREATE_SUBENTRY: 'CREATE_SUBENTRY',
      CREATE_LIST_ENTRIES_BULK: 'CREATE_LIST_ENTRIES_BULK',
      CREATE_SUBENTRIES_BULK: 'CREATE_SUBENTRIES_BULK',
      UPDATE_LIST_ENTRY: 'UPDATE_LIST_ENTRY',
      UPDATE_CHECKLISTS_OF_LIST_ENTRY: 'UPDATE_CHECKLISTS_OF_LIST_ENTRY',
      CONVERT_CHECKLIST_OF_LIST_ENTRY_TO_SUBENTRIES: 'CONVERT_CHECKLIST_OF_LIST_ENTRY_TO_SUBENTRIES',
      DELETE_LIST_ENTRY: 'DELETE_LIST_ENTRY',
      DEPRECATE_LIST_ENTRY: 'DEPRECATE_LIST_ENTRY',
      RESTORE_LIST_ENTRY: 'RESTORE_LIST_ENTRY',
      REORDER_LIST_ENTRY: 'REORDER_LIST_ENTRY',
      SAVE_VOLATILE_LIST_SORT_ORDER: 'SAVE_VOLATILE_LIST_SORT_ORDER',
      UPDATE_PATH_OF_LIST_ENTRY: 'UPDATE_PATH_OF_LIST_ENTRY',
      ADD_FILES_TO_LIST_ENTRY: 'ADD_FILES_TO_LIST_ENTRY',
      UPDATE_LIST_ENTRY_FILE: 'UPDATE_LIST_ENTRY_FILE',
      UPLOAD_FILE_FOR_LIST_ENTRY: 'UPLOAD_FILE_FOR_LIST_ENTRY',
      DEPRECATE_LIST_ENTRY_FILE: 'DEPRECATE_LIST_ENTRY_FILE',
      CREATE_LIST_ENTRY_COMMENT: 'CREATE_LIST_ENTRY_COMMENT',
      CREATE_LIST_COMMENT: 'CREATE_LIST_COMMENT',
      CREATE_WORKSPACE_COMMENT: 'CREATE_WORKSPACE_COMMENT',
      COPY_LIST_ENTRY_COMMENT_FROM_ACTIVITY: 'COPY_LIST_ENTRY_COMMENT_FROM_ACTIVITY',
      COPY_LIST_COMMENT_FROM_ACTIVITY: 'COPY_LIST_COMMENT_FROM_ACTIVITY',
      COPY_WORKSPACE_COMMENT_FROM_ACTIVITY: 'COPY_WORKSPACE_COMMENT_FROM_ACTIVITY',
      UPDATE_LIST_COMMENT: 'UPDATE_LIST_COMMENT',
      ADD_LIST_COMMENT_REACTION: 'ADD_LIST_COMMENT_REACTION',
      DEPRECATE_LIST_COMMENT_REACTION: 'DEPRECATE_LIST_COMMENT_REACTION',
      DEPRECATE_LIST_COMMENT: 'DEPRECATE_LIST_COMMENT',
      UPDATE_WORKSPACE_COMMENT: 'UPDATE_WORKSPACE_COMMENT',
      ADD_WORKSPACE_COMMENT_REACTION: 'ADD_WORKSPACE_COMMENT_REACTION',
      DEPRECATE_WORKSPACE_COMMENT_REACTION: 'DEPRECATE_WORKSPACE_COMMENT_REACTION',
      DEPRECATE_WORKSPACE_COMMENT: 'DEPRECATE_WORKSPACE_COMMENT',
      DEPRECATE_LIST_ENTRIES: 'DEPRECATE_LIST_ENTRIES',
      DELETE_LIST_ENTRIES: 'DELETE_LIST_ENTRIES',
      RESTORE_LIST_ENTRIES: 'RESTORE_LIST_ENTRIES',
      COPY_LIST_ENTRIES: 'COPY_LIST_ENTRIES',
      MOVE_LIST_ENTRIES_TO_LIST: 'MOVE_LIST_ENTRIES_TO_LIST',
      BULK_ACTION_LIST_ENTRIES: 'BULK_ACTION_LIST_ENTRIES',
      ADJUST_DATES_FOR_DEPENDENCIES: 'ADJUST_DATES_FOR_DEPENDENCIES',
      CREATE_LIST_VIEW: 'CREATE_LIST_VIEW',
      MIGRATE_MINDMAP_VIEW: 'MIGRATE_MINDMAP_VIEW',
      UPDATE_LIST_VIEW: 'UPDATE_LIST_VIEW',
      REORDER_LIST_VIEW: 'REORDER_LIST_VIEW',
      DEPRECATE_LIST_VIEW: 'DEPRECATE_LIST_VIEW',
      CREATE_USER_VIEW: 'CREATE_USER_VIEW',
      UPDATE_USER_VIEW: 'UPDATE_USER_VIEW',
      REORDER_USER_VIEW: 'REORDER_USER_VIEW',
      DEPRECATE_USER_VIEW: 'DEPRECATE_USER_VIEW',
      CREATE_LIST_FILTER: 'CREATE_LIST_FILTER',
      UPDATE_LIST_FILTER: 'UPDATE_LIST_FILTER',
      DEPRECATE_LIST_FILTER: 'DEPRECATE_LIST_FILTER',
      CREATE_LIST_ELEMENT: 'CREATE_LIST_ELEMENT',
      COPY_LIST_ELEMENT: 'COPY_LIST_ELEMENT',
      UPDATE_LIST_ELEMENT: 'UPDATE_LIST_ELEMENT',
      UPDATE_MINDMAP: 'UPDATE_MINDMAP',
      SET_LIST_ELEMENT_AS_PRIMARY: 'SET_LIST_ELEMENT_AS_PRIMARY',
      SORT_LIST_ELEMENT: 'SORT_LIST_ELEMENT',
      MIGRATE_LIST_ELEMENT: 'MIGRATE_LIST_ELEMENT',
      DEPRECATE_LIST_ELEMENT: 'DEPRECATE_LIST_ELEMENT',
      RESTORE_LIST_ELEMENT: 'RESTORE_LIST_ELEMENT',
      DELETE_LIST_ELEMENT: 'DELETE_LIST_ELEMENT',
      UPDATE_LIST: 'UPDATE_LIST',
      UPDATE_LIST_VISIBILITY: 'UPDATE_LIST_VISIBILITY',
      UPDATE_LIST_BACKGROUND: 'UPDATE_LIST_BACKGROUND',
      PUBLISH_LIST: 'PUBLISH_LIST',
      UNPUBLISH_LIST: 'UNPUBLISH_LIST',
      REORDER_LISTS_OF_WORKSPACE: 'REORDER_LISTS_OF_WORKSPACE',
      MOVE_LIST_TO_WORKSPACE: 'MOVE_LIST_TO_WORKSPACE',
      DEPRECATE_LIST: 'DEPRECATE_LIST',
      RESTORE_LIST: 'RESTORE_LIST',
      DELETE_LIST: 'DELETE_LIST',
      CLONE_LIST: 'CLONE_LIST',
      TRANSFER_LIST_RESOURCE_TAGS_OWNERSHIP: 'TRANSFER_LIST_RESOURCE_TAGS_OWNERSHIP',
      CREATE_LIST_ACCESS: 'CREATE_LIST_ACCESS',
      UPDATE_LIST_ACCESS: 'UPDATE_LIST_ACCESS',
      DELETE_LIST_ACCESS: 'DELETE_LIST_ACCESS',
      REPLACE_LIST_USER: 'REPLACE_LIST_USER',
      CREATE_WORKSPACE_ACCESS: 'CREATE_WORKSPACE_ACCESS',
      UPDATE_WORKSPACE_ACCESS: 'UPDATE_WORKSPACE_ACCESS',
      DELETE_WORKSPACE_ACCESS: 'DELETE_WORKSPACE_ACCESS',
      INVITE_UNREGISTERED_USER: 'INVITE_UNREGISTERED_USER',
      TRANSFER_LIST_OWNERSHIP: 'TRANSFER_LIST_OWNERSHIP',
      TRANSFER_WORKSPACE_OWNERSHIP: 'TRANSFER_WORKSPACE_OWNERSHIP',
      CREATE_WORKSPACE: 'CREATE_WORKSPACE',
      UPDATE_WORKSPACE: 'UPDATE_WORKSPACE',
      DEPRECATE_WORKSPACE: 'DEPRECATE_WORKSPACE',
      CLONE_WORKSPACE: 'CLONE_WORKSPACE',
      CREATE_LIST: 'CREATE_LIST',
      SORT_CATEGORIES: 'SORT_CATEGORIES',
      CREATE_REMINDER: 'CREATE_REMINDER',
      UPDATE_REMINDER: 'UPDATE_REMINDER',
      DEPRECATE_REMINDER: 'DEPRECATE_REMINDER',
      CREATE_RECURRENCE_RULE: 'CREATE_RECURRENCE_RULE',
      DEPRECATE_RECURRENCE_RULE: 'DEPRECATE_RECURRENCE_RULE',
      ADD_GROUP_USER: 'ADD_GROUP_USER',
      REMOVE_GROUP_USER: 'REMOVE_GROUP_USER',
      ADD_GROUP_SUBGROUP: 'ADD_GROUP_SUBGROUP',
      REMOVE_GROUP_SUBGROUP: 'REMOVE_GROUP_SUBGROUP',
      CREATE_GROUP: 'CREATE_GROUP',
      UPDATE_GROUP: 'UPDATE_GROUP',
      DELETE_GROUP: 'DELETE_GROUP',
      CREATE_ORGANIZATION_ACCESS: 'CREATE_ORGANIZATION_ACCESS',
      UPDATE_ORGANIZATION_ACCESS: 'UPDATE_ORGANIZATION_ACCESS',
      DELETE_ORGANIZATION_ACCESS: 'DELETE_ORGANIZATION_ACCESS',
      CREATE_USER_TAG: 'CREATE_USER_TAG',
      UPDATE_USER_TAGS: 'UPDATE_USER_TAGS',
      ASSIGN_USER_TAG: 'ASSIGN_USER_TAG',
      REMOVE_USER_TAG: 'REMOVE_USER_TAG',
      REMOVE_ALL_USER_TAGS_FROM_LIST: 'REMOVE_ALL_USER_TAGS_FROM_LIST',
      MARK_NOTIFICATIONS_AS_READ: 'MARK_NOTIFICATIONS_AS_READ',
      MARK_NOTIFICATIONS_AS_NEW: 'MARK_NOTIFICATIONS_AS_NEW',
      CONVERT_COMMENT_TO_ENTRY: 'CONVERT_COMMENT_TO_ENTRY',
      UPLOAD_ORGANIZATION_IMAGE: 'UPLOAD_ORGANIZATION_IMAGE',
      UPLOAD_WORKSPACE_IMAGE: 'UPLOAD_WORKSPACE_IMAGE',
      UPLOAD_LIST_IMAGE: 'UPLOAD_LIST_IMAGE',
      DELETE_ORGANIZATION_IMAGE: 'DELETE_ORGANIZATION_IMAGE',
      DELETE_WORKSPACE_IMAGE: 'DELETE_WORKSPACE_IMAGE',
      DELETE_LIST_IMAGE: 'DELETE_LIST_IMAGE',
      UPLOAD_CURRENT_USER_COVER_IMAGE: 'UPLOAD_CURRENT_USER_COVER_IMAGE',
      UPLOAD_ORGANIZATION_COVER_IMAGE: 'UPLOAD_ORGANIZATION_COVER_IMAGE',
      UPLOAD_WORKSPACE_COVER_IMAGE: 'UPLOAD_WORKSPACE_COVER_IMAGE',
      UPLOAD_LIST_COVER_IMAGE: 'UPLOAD_LIST_COVER_IMAGE',
      DELETE_CURRENT_USER_COVER_IMAGE: 'DELETE_CURRENT_USER_COVER_IMAGE',
      DELETE_ORGANIZATION_COVER_IMAGE: 'DELETE_ORGANIZATION_COVER_IMAGE',
      DELETE_WORKSPACE_COVER_IMAGE: 'DELETE_WORKSPACE_COVER_IMAGE',
      DELETE_LIST_COVER_IMAGE: 'DELETE_LIST_COVER_IMAGE',
      UPDATE_ORGANIZATION: 'UPDATE_ORGANIZATION',
    },
    actionPayloadMayContainFiles: {
      UPLOAD_USER_FILE: !0,
      UPLOAD_PROFILE_IMAGE: !0,
      UPLOAD_CURRENT_USER_COVER_IMAGE: !0,
      UPLOAD_ORGANIZATION_IMAGE: !0,
      UPLOAD_ORGANIZATION_COVER_IMAGE: !0,
      UPLOAD_FILE_FOR_LIST_ENTRY: !0,
      UPLOAD_LIST_IMAGE: !0,
      UPLOAD_LIST_COVER_IMAGE: !0,
      UPLOAD_WORKSPACE_IMAGE: !0,
      UPLOAD_WORKSPACE_COVER_IMAGE: !0,
      CREATE_LIST_ENTRY_COMMENT: !0,
      CREATE_LIST_COMMENT: !0,
      CREATE_WORKSPACE_COMMENT: !0,
    },
    commands: [
      'login',
      'loginViaToken',
      'register',
      'internalLogout',
      'logout',
      'logoutOtherDevices',
      'changeTimezone',
      'verifyEmail',
      'setEmailToPrimary',
      'completePasswordReset',
      'confirmOrganizationInvite',
      'getOrganizationAcquisition',
      'confirmOrganizationAcquisition',
      'getOAuthAuthorizationRequestData',
      'authorizeOAuthRequest',
      'getOAuthClientsWithAccessToSelf',
      'disconnectOAuthClientAccess',
      'getOAuthClientsForSelf',
      'deleteOAuthClient',
      'registerOAuthClient',
      'updateOAuthClient',
      'resetOAuthClientSecret',
      'handlePushNotificationData',
      'getLinkMetadata',
      'getNotifications',
      'getExternalOembedSnippet',
      'createThirdPartyWebhook',
      'deleteThirdPartyWebhook',
      'getThirdPartyWebhook',
      'getWebhooksForList',
      'syncCurrentUser',
      'syncAllUserResources',
      'syncAccesses',
      'syncWorkspacesWithLists',
      'clearOfflineStorage',
      'clearAccessToken',
      'requestSocketRoom',
      'releaseSocketRoom',
      'isSocketRoomActive',
      'reconnect',
      'disconnect',
      'checkConnection',
      'setLanguage',
      'retryAction',
      'dropAction',
      'getUndoAction',
      'getActionErrorDetails',
      'ensureSynchronizations',
      'createListSynchronization',
      'deleteListSynchronization',
      'triggerListSynchronization',
      'createWorkspaceSynchronization',
      'deleteWorkspaceSynchronization',
      'triggerWorkspaceSynchronization',
      'getListSynchronization',
      'isListAvailableOffline',
      'getWorkspaceSynchronization',
      'isWorkspaceAvailableOffline',
      'getAllListSynchronizations',
      'getAllWorkspaceSynchronizations',
      'startBackgroundSynchronization',
      'triggerBackgroundSynchronization',
      'updateRecentlyChangedResourcesOfList',
      'getSyncStatus',
      'getOrganizations',
      'getOrganizationUsers',
      'createOrganizationUser',
      'deleteOrganizationUser',
      'getDefaultBackground',
      'getBackground',
      'getWorkspacesWithListsForMe',
      'getSizeOfStorageInBytes',
      'isIndexedDBSupported',
      'addResourceTags',
      'removeResourceTags',
      'registerDevice',
      'closeIndexedDB',
    ],
  }),
  (function (t) {
    if ('object' == typeof exports && 'undefined' != typeof module) module.exports = t()
    else if ('function' == typeof define && define.amd) define([], t)
    else {
      var e
      'undefined' != typeof window
        ? (e = window)
        : 'undefined' != typeof global
        ? (e = global)
        : 'undefined' != typeof self && (e = self),
        (e.Promise = t())
    }
  })(function () {
    return (function r(t, e, n) {
      function i(s, a) {
        if (!e[s]) {
          if (!t[s]) {
            var c = 'function' == typeof _dereq_ && _dereq_
            if (!a && c) return c(s, !0)
            if (o) return o(s, !0)
            var l = new Error("Cannot find module '" + s + "'")
            throw ((l.code = 'MODULE_NOT_FOUND'), l)
          }
          var u = (e[s] = { exports: {} })
          t[s][0].call(
            u.exports,
            function (e) {
              var n = t[s][1][e]
              return i(n || e)
            },
            u,
            u.exports,
            r,
            t,
            e,
            n,
          )
        }
        return e[s].exports
      }
      for (var o = 'function' == typeof _dereq_ && _dereq_, s = 0; s < n.length; s++) i(n[s])
      return i
    })(
      {
        1: [
          function (t, e, n) {
            'use strict'
            e.exports = function (t) {
              function e(t) {
                var e = new n(t),
                  r = e.promise()
                return e.setHowMany(1), e.setUnwrap(), e.init(), r
              }
              var n = t._SomePromiseArray
              ;(t.any = function (t) {
                return e(t)
              }),
                (t.prototype.any = function () {
                  return e(this)
                })
            }
          },
          {},
        ],
        2: [
          function (t, e, n) {
            'use strict'
            function r() {
              ;(this._customScheduler = !1),
                (this._isTickUsed = !1),
                (this._lateQueue = new u(16)),
                (this._normalQueue = new u(16)),
                (this._haveDrainedQueues = !1),
                (this._trampolineEnabled = !0)
              var t = this
              ;(this.drainQueues = function () {
                t._drainQueues()
              }),
                (this._schedule = l)
            }
            function i(t, e, n) {
              this._lateQueue.push(t, e, n), this._queueTick()
            }
            function o(t, e, n) {
              this._normalQueue.push(t, e, n), this._queueTick()
            }
            function s(t) {
              this._normalQueue._pushOne(t), this._queueTick()
            }
            var a
            try {
              throw new Error()
            } catch (c) {
              a = c
            }
            var l = t('./schedule'),
              u = t('./queue'),
              p = t('./util')
            ;(r.prototype.setScheduler = function (t) {
              var e = this._schedule
              return (this._schedule = t), (this._customScheduler = !0), e
            }),
              (r.prototype.hasCustomScheduler = function () {
                return this._customScheduler
              }),
              (r.prototype.enableTrampoline = function () {
                this._trampolineEnabled = !0
              }),
              (r.prototype.disableTrampolineIfNecessary = function () {
                p.hasDevTools && (this._trampolineEnabled = !1)
              }),
              (r.prototype.haveItemsQueued = function () {
                return this._isTickUsed || this._haveDrainedQueues
              }),
              (r.prototype.fatalError = function (t, e) {
                e
                  ? (process.stderr.write('Fatal ' + (t instanceof Error ? t.stack : t) + '\n'), process.exit(2))
                  : this.throwLater(t)
              }),
              (r.prototype.throwLater = function (t, e) {
                if (
                  (1 === arguments.length &&
                    ((e = t),
                    (t = function () {
                      throw e
                    })),
                  'undefined' != typeof setTimeout)
                )
                  setTimeout(function () {
                    t(e)
                  }, 0)
                else
                  try {
                    this._schedule(function () {
                      t(e)
                    })
                  } catch (n) {
                    throw new Error('No async scheduler available\n\n    See http://goo.gl/MqrFmX\n')
                  }
              }),
              p.hasDevTools
                ? ((r.prototype.invokeLater = function (t, e, n) {
                    this._trampolineEnabled
                      ? i.call(this, t, e, n)
                      : this._schedule(function () {
                          setTimeout(function () {
                            t.call(e, n)
                          }, 100)
                        })
                  }),
                  (r.prototype.invoke = function (t, e, n) {
                    this._trampolineEnabled
                      ? o.call(this, t, e, n)
                      : this._schedule(function () {
                          t.call(e, n)
                        })
                  }),
                  (r.prototype.settlePromises = function (t) {
                    this._trampolineEnabled
                      ? s.call(this, t)
                      : this._schedule(function () {
                          t._settlePromises()
                        })
                  }))
                : ((r.prototype.invokeLater = i), (r.prototype.invoke = o), (r.prototype.settlePromises = s)),
              (r.prototype._drainQueue = function (t) {
                for (; t.length() > 0; ) {
                  var e = t.shift()
                  if ('function' == typeof e) {
                    var n = t.shift(),
                      r = t.shift()
                    e.call(n, r)
                  } else e._settlePromises()
                }
              }),
              (r.prototype._drainQueues = function () {
                this._drainQueue(this._normalQueue),
                  this._reset(),
                  (this._haveDrainedQueues = !0),
                  this._drainQueue(this._lateQueue)
              }),
              (r.prototype._queueTick = function () {
                this._isTickUsed || ((this._isTickUsed = !0), this._schedule(this.drainQueues))
              }),
              (r.prototype._reset = function () {
                this._isTickUsed = !1
              }),
              (e.exports = r),
              (e.exports.firstLineError = a)
          },
          { './queue': 26, './schedule': 29, './util': 36 },
        ],
        3: [
          function (t, e, n) {
            'use strict'
            e.exports = function (t, e, n, r) {
              var i = !1,
                o = function (t, e) {
                  this._reject(e)
                },
                s = function (t, e) {
                  ;(e.promiseRejectionQueued = !0), e.bindingPromise._then(o, o, null, this, t)
                },
                a = function (t, e) {
                  0 == (50397184 & this._bitField) && this._resolveCallback(e.target)
                },
                c = function (t, e) {
                  e.promiseRejectionQueued || this._reject(t)
                }
              ;(t.prototype.bind = function (o) {
                i ||
                  ((i = !0),
                  (t.prototype._propagateFrom = r.propagateFromFunction()),
                  (t.prototype._boundValue = r.boundValueFunction()))
                var l = n(o),
                  u = new t(e)
                u._propagateFrom(this, 1)
                var p = this._target()
                if ((u._setBoundTo(l), l instanceof t)) {
                  var h = { promiseRejectionQueued: !1, promise: u, target: p, bindingPromise: l }
                  p._then(e, s, void 0, u, h), l._then(a, c, void 0, u, h), u._setOnCancel(l)
                } else u._resolveCallback(p)
                return u
              }),
                (t.prototype._setBoundTo = function (t) {
                  void 0 !== t
                    ? ((this._bitField = 2097152 | this._bitField), (this._boundTo = t))
                    : (this._bitField = -2097153 & this._bitField)
                }),
                (t.prototype._isBound = function () {
                  return 2097152 == (2097152 & this._bitField)
                }),
                (t.bind = function (e, n) {
                  return t.resolve(n).bind(e)
                })
            }
          },
          {},
        ],
        4: [
          function (t, e, n) {
            'use strict'
            var i
            'undefined' != typeof Promise && (i = Promise)
            var o = t('./promise')()
            ;(o.noConflict = function () {
              try {
                Promise === o && (Promise = i)
              } catch (t) {}
              return o
            }),
              (e.exports = o)
          },
          { './promise': 22 },
        ],
        5: [
          function (t, e, n) {
            'use strict'
            var r = Object.create
            if (r) {
              var i = r(null),
                o = r(null)
              i[' size'] = o[' size'] = 0
            }
            e.exports = function (e) {
              function n(t, n) {
                var r
                if ((null != t && (r = t[n]), 'function' != typeof r)) {
                  var i = 'Object ' + a.classString(t) + " has no method '" + a.toString(n) + "'"
                  throw new e.TypeError(i)
                }
                return r
              }
              function r(t) {
                return n(t, this.pop()).apply(t, this)
              }
              function i(t) {
                return t[this]
              }
              function o(t) {
                var e = +this
                return 0 > e && (e = Math.max(0, e + t.length)), t[e]
              }
              var a = t('./util'),
                c = a.canEvaluate
              a.isIdentifier,
                (e.prototype.call = function (t) {
                  var e = [].slice.call(arguments, 1)
                  return e.push(t), this._then(r, void 0, void 0, e, void 0)
                }),
                (e.prototype.get = function (t) {
                  var e
                  if ('number' == typeof t) e = o
                  else if (c) {
                    var r = undefined(t)
                    e = null !== r ? r : i
                  } else e = i
                  return this._then(e, void 0, void 0, t, void 0)
                })
            }
          },
          { './util': 36 },
        ],
        6: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i) {
              var o = t('./util'),
                s = o.tryCatch,
                a = o.errorObj,
                c = e._async
              ;(e.prototype.break = e.prototype.cancel =
                function () {
                  if (!i.cancellation()) return this._warn('cancellation is disabled')
                  for (var t = this, e = t; t._isCancellable(); ) {
                    if (!t._cancelBy(e)) {
                      e._isFollowing() ? e._followee().cancel() : e._cancelBranched()
                      break
                    }
                    var n = t._cancellationParent
                    if (null == n || !n._isCancellable()) {
                      t._isFollowing() ? t._followee().cancel() : t._cancelBranched()
                      break
                    }
                    t._isFollowing() && t._followee().cancel(), t._setWillBeCancelled(), (e = t), (t = n)
                  }
                }),
                (e.prototype._branchHasCancelled = function () {
                  this._branchesRemainingToCancel--
                }),
                (e.prototype._enoughBranchesHaveCancelled = function () {
                  return void 0 === this._branchesRemainingToCancel || this._branchesRemainingToCancel <= 0
                }),
                (e.prototype._cancelBy = function (t) {
                  return t === this
                    ? ((this._branchesRemainingToCancel = 0), this._invokeOnCancel(), !0)
                    : (this._branchHasCancelled(),
                      !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), !0))
                }),
                (e.prototype._cancelBranched = function () {
                  this._enoughBranchesHaveCancelled() && this._cancel()
                }),
                (e.prototype._cancel = function () {
                  this._isCancellable() && (this._setCancelled(), c.invoke(this._cancelPromises, this, void 0))
                }),
                (e.prototype._cancelPromises = function () {
                  this._length() > 0 && this._settlePromises()
                }),
                (e.prototype._unsetOnCancel = function () {
                  this._onCancelField = void 0
                }),
                (e.prototype._isCancellable = function () {
                  return this.isPending() && !this._isCancelled()
                }),
                (e.prototype.isCancellable = function () {
                  return this.isPending() && !this.isCancelled()
                }),
                (e.prototype._doInvokeOnCancel = function (t, e) {
                  if (o.isArray(t)) for (var n = 0; n < t.length; ++n) this._doInvokeOnCancel(t[n], e)
                  else if (void 0 !== t)
                    if ('function' == typeof t) {
                      if (!e) {
                        var r = s(t).call(this._boundValue())
                        r === a && (this._attachExtraTrace(r.e), c.throwLater(r.e))
                      }
                    } else t._resultCancelled(this)
                }),
                (e.prototype._invokeOnCancel = function () {
                  var t = this._onCancel()
                  this._unsetOnCancel(), c.invoke(this._doInvokeOnCancel, this, t)
                }),
                (e.prototype._invokeInternalOnCancel = function () {
                  this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel())
                }),
                (e.prototype._resultCancelled = function () {
                  this.cancel()
                })
            }
          },
          { './util': 36 },
        ],
        7: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e) {
              var r = t('./util'),
                i = t('./es5').keys,
                o = r.tryCatch,
                s = r.errorObj
              return function (t, n, a) {
                return function (c) {
                  var l = a._boundValue()
                  t: for (var u = 0; u < t.length; ++u) {
                    var p = t[u]
                    if (p === Error || (null != p && p.prototype instanceof Error)) {
                      if (c instanceof p) return o(n).call(l, c)
                    } else if ('function' == typeof p) {
                      var h = o(p).call(l, c)
                      if (h === s) return h
                      if (h) return o(n).call(l, c)
                    } else if (r.isObject(c)) {
                      for (var f = i(p), _ = 0; _ < f.length; ++_) {
                        var d = f[_]
                        if (p[d] != c[d]) continue t
                      }
                      return o(n).call(l, c)
                    }
                  }
                  return e
                }
              }
            }
          },
          { './es5': 13, './util': 36 },
        ],
        8: [
          function (t, e, n) {
            'use strict'
            e.exports = function (t) {
              function e() {
                this._trace = new e.CapturedTrace(r())
              }
              function r() {
                var t = o.length - 1
                return t >= 0 ? o[t] : void 0
              }
              var i = !1,
                o = []
              return (
                (t.prototype._promiseCreated = function () {}),
                (t.prototype._pushContext = function () {}),
                (t.prototype._popContext = function () {
                  return null
                }),
                (t._peekContext = t.prototype._peekContext = function () {}),
                (e.prototype._pushContext = function () {
                  void 0 !== this._trace && ((this._trace._promiseCreated = null), o.push(this._trace))
                }),
                (e.prototype._popContext = function () {
                  if (void 0 !== this._trace) {
                    var t = o.pop(),
                      e = t._promiseCreated
                    return (t._promiseCreated = null), e
                  }
                  return null
                }),
                (e.CapturedTrace = null),
                (e.create = function () {
                  return i ? new e() : void 0
                }),
                (e.deactivateLongStackTraces = function () {}),
                (e.activateLongStackTraces = function () {
                  var n = t.prototype._pushContext,
                    o = t.prototype._popContext,
                    s = t._peekContext,
                    a = t.prototype._peekContext,
                    c = t.prototype._promiseCreated
                  ;(e.deactivateLongStackTraces = function () {
                    ;(t.prototype._pushContext = n),
                      (t.prototype._popContext = o),
                      (t._peekContext = s),
                      (t.prototype._peekContext = a),
                      (t.prototype._promiseCreated = c),
                      (i = !1)
                  }),
                    (i = !0),
                    (t.prototype._pushContext = e.prototype._pushContext),
                    (t.prototype._popContext = e.prototype._popContext),
                    (t._peekContext = t.prototype._peekContext = r),
                    (t.prototype._promiseCreated = function () {
                      var t = this._peekContext()
                      t && null == t._promiseCreated && (t._promiseCreated = this)
                    })
                }),
                e
              )
            }
          },
          {},
        ],
        9: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n) {
              function r(t, e) {
                return { promise: e }
              }
              function i() {
                return !1
              }
              function o(t, e, n) {
                var r = this
                try {
                  t(e, n, function (t) {
                    if ('function' != typeof t)
                      throw new TypeError('onCancel must be a function, got: ' + H.toString(t))
                    r._attachCancellationCallback(t)
                  })
                } catch (i) {
                  return i
                }
              }
              function s(t) {
                if (!this._isCancellable()) return this
                var e = this._onCancel()
                void 0 !== e ? (H.isArray(e) ? e.push(t) : this._setOnCancel([e, t])) : this._setOnCancel(t)
              }
              function a() {
                return this._onCancelField
              }
              function c(t) {
                this._onCancelField = t
              }
              function l() {
                ;(this._cancellationParent = void 0), (this._onCancelField = void 0)
              }
              function u(t, e) {
                if (0 != (1 & e)) {
                  this._cancellationParent = t
                  var n = t._branchesRemainingToCancel
                  void 0 === n && (n = 0), (t._branchesRemainingToCancel = n + 1)
                }
                0 != (2 & e) && t._isBound() && this._setBoundTo(t._boundTo)
              }
              function h() {
                var t = this._boundTo
                return void 0 !== t && t instanceof e ? (t.isFulfilled() ? t.value() : void 0) : t
              }
              function f() {
                this._trace = new S(this._peekContext())
              }
              function _(t, e) {
                if (N(t)) {
                  var n = this._trace
                  if ((void 0 !== n && e && (n = n._parent), void 0 !== n)) n.attachExtraTrace(t)
                  else if (!t.__stackCleaned__) {
                    var r = j(t)
                    H.notEnumerableProp(t, 'stack', r.message + '\n' + r.stack.join('\n')),
                      H.notEnumerableProp(t, '__stackCleaned__', !0)
                  }
                }
              }
              function y(t, n, r) {
                if (ot.warnings) {
                  var i,
                    o = new L(t)
                  if (n) r._attachExtraTrace(o)
                  else if (ot.longStackTraces && (i = e._peekContext())) i.attachExtraTrace(o)
                  else {
                    var s = j(o)
                    o.stack = s.message + '\n' + s.stack.join('\n')
                  }
                  tt('warning', o) || E(o, '', !0)
                }
              }
              function w(t) {
                for (var e = [], n = 0; n < t.length; ++n) {
                  var r = t[n],
                    i = '    (No stack trace)' === r || q.test(r),
                    o = i && nt(r)
                  i && !o && ($ && ' ' !== r.charAt(0) && (r = '    ' + r), e.push(r))
                }
                return e
              }
              function j(t) {
                var e = t.stack,
                  n = t.toString()
                return (
                  (e =
                    'string' == typeof e && e.length > 0
                      ? (function (t) {
                          for (var e = t.stack.replace(/\s+$/g, '').split('\n'), n = 0; n < e.length; ++n) {
                            var r = e[n]
                            if ('    (No stack trace)' === r || q.test(r)) break
                          }
                          return n > 0 && 'SyntaxError' != t.name && (e = e.slice(n)), e
                        })(t)
                      : ['    (No stack trace)']),
                  { message: n, stack: 'SyntaxError' == t.name ? e : w(e) }
                )
              }
              function E(t, e, n) {
                if ('undefined' != typeof console) {
                  var r
                  if (H.isObject(t)) {
                    var i = t.stack
                    r = e + Q(i, t)
                  } else r = e + String(t)
                  'function' == typeof D
                    ? D(r, n)
                    : ('function' == typeof console.log || 'object' == typeof console.log) && console.log(r)
                }
              }
              function k(t, e, n, r) {
                var i = !1
                try {
                  'function' == typeof e && ((i = !0), 'rejectionHandled' === t ? e(r) : e(n, r))
                } catch (o) {
                  I.throwLater(o)
                }
                'unhandledRejection' === t ? tt(t, n, r) || i || E(n, 'Unhandled rejection ') : tt(t, r)
              }
              function F(t) {
                var e
                if ('function' == typeof t) e = '[function ' + (t.name || 'anonymous') + ']'
                else {
                  e = t && 'function' == typeof t.toString ? t.toString() : H.toString(t)
                  if (/\[object [a-zA-Z0-9$_]+\]/.test(e))
                    try {
                      e = JSON.stringify(t)
                    } catch (i) {}
                  0 === e.length && (e = '(empty array)')
                }
                return (
                  '(<' +
                  (function (t) {
                    var e = 41
                    return t.length < e ? t : t.substr(0, e - 3) + '...'
                  })(e) +
                  '>, no stack trace)'
                )
              }
              function T() {
                return 'function' == typeof it
              }
              function P(t) {
                var e = t.match(rt)
                return e ? { fileName: e[1], line: parseInt(e[2], 10) } : void 0
              }
              function S(t) {
                ;(this._parent = t), (this._promisesCreated = 0)
                var e = (this._length = 1 + (void 0 === t ? 0 : t._length))
                it(this, S), e > 32 && this.uncycle()
              }
              var O,
                A,
                D,
                V = e._getDomain,
                I = e._async,
                L = t('./errors').Warning,
                H = t('./util'),
                N = H.canAttachTrace,
                B = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/,
                U = /\((?:timers\.js):\d+:\d+\)/,
                M = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/,
                q = null,
                Q = null,
                $ = !1,
                G = !(
                  0 == H.env('BLUEBIRD_DEBUG') ||
                  (!H.env('BLUEBIRD_DEBUG') && 'development' !== H.env('NODE_ENV'))
                ),
                z = !(0 == H.env('BLUEBIRD_WARNINGS') || (!G && !H.env('BLUEBIRD_WARNINGS'))),
                X = !(0 == H.env('BLUEBIRD_LONG_STACK_TRACES') || (!G && !H.env('BLUEBIRD_LONG_STACK_TRACES'))),
                W = 0 != H.env('BLUEBIRD_W_FORGOTTEN_RETURN') && (z || !!H.env('BLUEBIRD_W_FORGOTTEN_RETURN'))
              ;(e.prototype.suppressUnhandledRejections = function () {
                var t = this._target()
                t._bitField = (-1048577 & t._bitField) | 524288
              }),
                (e.prototype._ensurePossibleRejectionHandled = function () {
                  if (0 == (524288 & this._bitField)) {
                    this._setRejectionIsUnhandled()
                    var t = this
                    setTimeout(function () {
                      t._notifyUnhandledRejection()
                    }, 1)
                  }
                }),
                (e.prototype._notifyUnhandledRejectionIsHandled = function () {
                  k('rejectionHandled', O, void 0, this)
                }),
                (e.prototype._setReturnedNonUndefined = function () {
                  this._bitField = 268435456 | this._bitField
                }),
                (e.prototype._returnedNonUndefined = function () {
                  return 0 != (268435456 & this._bitField)
                }),
                (e.prototype._notifyUnhandledRejection = function () {
                  if (this._isRejectionUnhandled()) {
                    var t = this._settledValue()
                    this._setUnhandledRejectionIsNotified(), k('unhandledRejection', A, t, this)
                  }
                }),
                (e.prototype._setUnhandledRejectionIsNotified = function () {
                  this._bitField = 262144 | this._bitField
                }),
                (e.prototype._unsetUnhandledRejectionIsNotified = function () {
                  this._bitField = -262145 & this._bitField
                }),
                (e.prototype._isUnhandledRejectionNotified = function () {
                  return (262144 & this._bitField) > 0
                }),
                (e.prototype._setRejectionIsUnhandled = function () {
                  this._bitField = 1048576 | this._bitField
                }),
                (e.prototype._unsetRejectionIsUnhandled = function () {
                  ;(this._bitField = -1048577 & this._bitField),
                    this._isUnhandledRejectionNotified() &&
                      (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled())
                }),
                (e.prototype._isRejectionUnhandled = function () {
                  return (1048576 & this._bitField) > 0
                }),
                (e.prototype._warn = function (t, e, n) {
                  return y(t, e, n || this)
                }),
                (e.onPossiblyUnhandledRejection = function (t) {
                  var e = V()
                  A = 'function' == typeof t ? (null === e ? t : H.domainBind(e, t)) : void 0
                }),
                (e.onUnhandledRejectionHandled = function (t) {
                  var e = V()
                  O = 'function' == typeof t ? (null === e ? t : H.domainBind(e, t)) : void 0
                })
              var K = function () {}
              ;(e.longStackTraces = function () {
                if (I.haveItemsQueued() && !ot.longStackTraces)
                  throw new Error(
                    'cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n',
                  )
                if (!ot.longStackTraces && T()) {
                  var t = e.prototype._captureStackTrace,
                    r = e.prototype._attachExtraTrace
                  ;(ot.longStackTraces = !0),
                    (K = function () {
                      if (I.haveItemsQueued() && !ot.longStackTraces)
                        throw new Error(
                          'cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n',
                        )
                      ;(e.prototype._captureStackTrace = t),
                        (e.prototype._attachExtraTrace = r),
                        n.deactivateLongStackTraces(),
                        I.enableTrampoline(),
                        (ot.longStackTraces = !1)
                    }),
                    (e.prototype._captureStackTrace = f),
                    (e.prototype._attachExtraTrace = _),
                    n.activateLongStackTraces(),
                    I.disableTrampolineIfNecessary()
                }
              }),
                (e.hasLongStackTraces = function () {
                  return ot.longStackTraces && T()
                })
              var J = (function () {
                  try {
                    if ('function' == typeof CustomEvent) {
                      var t = new CustomEvent('CustomEvent')
                      return (
                        H.global.dispatchEvent(t),
                        function (t, e) {
                          var n = new CustomEvent(t.toLowerCase(), { detail: e, cancelable: !0 })
                          return !H.global.dispatchEvent(n)
                        }
                      )
                    }
                    if ('function' == typeof Event) {
                      t = new Event('CustomEvent')
                      return (
                        H.global.dispatchEvent(t),
                        function (t, e) {
                          var n = new Event(t.toLowerCase(), { cancelable: !0 })
                          return (n.detail = e), !H.global.dispatchEvent(n)
                        }
                      )
                    }
                    return (
                      (t = document.createEvent('CustomEvent')).initCustomEvent('testingtheevent', !1, !0, {}),
                      H.global.dispatchEvent(t),
                      function (t, e) {
                        var n = document.createEvent('CustomEvent')
                        return n.initCustomEvent(t.toLowerCase(), !1, !0, e), !H.global.dispatchEvent(n)
                      }
                    )
                  } catch (e) {}
                  return function () {
                    return !1
                  }
                })(),
                Y = H.isNode
                  ? function () {
                      return process.emit.apply(process, arguments)
                    }
                  : H.global
                  ? function (t) {
                      var e = 'on' + t.toLowerCase(),
                        n = H.global[e]
                      return !!n && (n.apply(H.global, [].slice.call(arguments, 1)), !0)
                    }
                  : function () {
                      return !1
                    },
                Z = {
                  promiseCreated: r,
                  promiseFulfilled: r,
                  promiseRejected: r,
                  promiseResolved: r,
                  promiseCancelled: r,
                  promiseChained: function (t, e, n) {
                    return { promise: e, child: n }
                  },
                  warning: function (t, e) {
                    return { warning: e }
                  },
                  unhandledRejection: function (t, e, n) {
                    return { reason: e, promise: n }
                  },
                  rejectionHandled: r,
                },
                tt = function (t) {
                  var e = !1
                  try {
                    e = Y.apply(null, arguments)
                  } catch (n) {
                    I.throwLater(n), (e = !0)
                  }
                  var r = !1
                  try {
                    r = J(t, Z[t].apply(null, arguments))
                  } catch (n) {
                    I.throwLater(n), (r = !0)
                  }
                  return r || e
                }
              ;(e.config = function (t) {
                if (
                  ('longStackTraces' in (t = Object(t)) &&
                    (t.longStackTraces ? e.longStackTraces() : !t.longStackTraces && e.hasLongStackTraces() && K()),
                  'warnings' in t)
                ) {
                  var n = t.warnings
                  ;(ot.warnings = !!n),
                    (W = ot.warnings),
                    H.isObject(n) && 'wForgottenReturn' in n && (W = !!n.wForgottenReturn)
                }
                if ('cancellation' in t && t.cancellation && !ot.cancellation) {
                  if (I.haveItemsQueued()) throw new Error('cannot enable cancellation after promises are in use')
                  ;(e.prototype._clearCancellationData = l),
                    (e.prototype._propagateFrom = u),
                    (e.prototype._onCancel = a),
                    (e.prototype._setOnCancel = c),
                    (e.prototype._attachCancellationCallback = s),
                    (e.prototype._execute = o),
                    (et = u),
                    (ot.cancellation = !0)
                }
                return (
                  'monitoring' in t &&
                    (t.monitoring && !ot.monitoring
                      ? ((ot.monitoring = !0), (e.prototype._fireEvent = tt))
                      : !t.monitoring && ot.monitoring && ((ot.monitoring = !1), (e.prototype._fireEvent = i))),
                  e
                )
              }),
                (e.prototype._fireEvent = i),
                (e.prototype._execute = function (t, e, n) {
                  try {
                    t(e, n)
                  } catch (r) {
                    return r
                  }
                }),
                (e.prototype._onCancel = function () {}),
                (e.prototype._setOnCancel = function (t) {}),
                (e.prototype._attachCancellationCallback = function (t) {}),
                (e.prototype._captureStackTrace = function () {}),
                (e.prototype._attachExtraTrace = function () {}),
                (e.prototype._clearCancellationData = function () {}),
                (e.prototype._propagateFrom = function (t, e) {})
              var et = function (t, e) {
                  0 != (2 & e) && t._isBound() && this._setBoundTo(t._boundTo)
                },
                nt = function () {
                  return !1
                },
                rt = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/
              H.inherits(S, Error),
                (n.CapturedTrace = S),
                (S.prototype.uncycle = function () {
                  var t = this._length
                  if (!(2 > t)) {
                    for (var e = [], n = {}, r = 0, i = this; void 0 !== i; ++r) e.push(i), (i = i._parent)
                    for (r = (t = this._length = r) - 1; r >= 0; --r) {
                      var o = e[r].stack
                      void 0 === n[o] && (n[o] = r)
                    }
                    for (r = 0; t > r; ++r) {
                      var a = n[e[r].stack]
                      if (void 0 !== a && a !== r) {
                        a > 0 && ((e[a - 1]._parent = void 0), (e[a - 1]._length = 1)),
                          (e[r]._parent = void 0),
                          (e[r]._length = 1)
                        var c = r > 0 ? e[r - 1] : this
                        t - 1 > a
                          ? ((c._parent = e[a + 1]), c._parent.uncycle(), (c._length = c._parent._length + 1))
                          : ((c._parent = void 0), (c._length = 1))
                        for (var l = c._length + 1, u = r - 2; u >= 0; --u) (e[u]._length = l), l++
                        return
                      }
                    }
                  }
                }),
                (S.prototype.attachExtraTrace = function (t) {
                  if (!t.__stackCleaned__) {
                    this.uncycle()
                    for (var e = j(t), n = e.message, r = [e.stack], i = this; void 0 !== i; )
                      r.push(w(i.stack.split('\n'))), (i = i._parent)
                    ;(function (t) {
                      for (var e = t[0], n = 1; n < t.length; ++n) {
                        for (var r = t[n], i = e.length - 1, o = e[i], s = -1, a = r.length - 1; a >= 0; --a)
                          if (r[a] === o) {
                            s = a
                            break
                          }
                        for (a = s; a >= 0; --a) {
                          var c = r[a]
                          if (e[i] !== c) break
                          e.pop(), i--
                        }
                        e = r
                      }
                    })(r),
                      (function (t) {
                        for (var e = 0; e < t.length; ++e)
                          (0 === t[e].length || (e + 1 < t.length && t[e][0] === t[e + 1][0])) && (t.splice(e, 1), e--)
                      })(r),
                      H.notEnumerableProp(
                        t,
                        'stack',
                        (function (t, e) {
                          for (var n = 0; n < e.length - 1; ++n)
                            e[n].push('From previous event:'), (e[n] = e[n].join('\n'))
                          return n < e.length && (e[n] = e[n].join('\n')), t + '\n' + e.join('\n')
                        })(n, r),
                      ),
                      H.notEnumerableProp(t, '__stackCleaned__', !0)
                  }
                })
              var it = (function () {
                var t = /^\s*at\s*/,
                  e = function (t, _e) {
                    return 'string' == typeof t
                      ? t
                      : void 0 !== _e.name && void 0 !== _e.message
                      ? _e.toString()
                      : F(_e)
                  }
                if ('number' == typeof Error.stackTraceLimit && 'function' == typeof Error.captureStackTrace) {
                  ;(Error.stackTraceLimit += 6), (q = t), (Q = e)
                  var n = Error.captureStackTrace
                  return (
                    (nt = function (t) {
                      return B.test(t)
                    }),
                    function (t, e) {
                      ;(Error.stackTraceLimit += 6), n(t, e), (Error.stackTraceLimit -= 6)
                    }
                  )
                }
                var i,
                  r = new Error()
                if ('string' == typeof r.stack && r.stack.split('\n')[0].indexOf('stackDetection@') >= 0)
                  return (
                    (q = /@/),
                    (Q = e),
                    ($ = !0),
                    function (t) {
                      t.stack = new Error().stack
                    }
                  )
                try {
                  throw new Error()
                } catch (o) {
                  i = 'stack' in o
                }
                return 'stack' in r || !i || 'number' != typeof Error.stackTraceLimit
                  ? ((Q = function (t, e) {
                      return 'string' == typeof t
                        ? t
                        : ('object' != typeof e && 'function' != typeof e) || void 0 === e.name || void 0 === e.message
                        ? F(e)
                        : e.toString()
                    }),
                    null)
                  : ((q = t),
                    (Q = e),
                    function (t) {
                      Error.stackTraceLimit += 6
                      try {
                        throw new Error()
                      } catch (e) {
                        t.stack = e.stack
                      }
                      Error.stackTraceLimit -= 6
                    })
              })()
              'undefined' != typeof console &&
                void 0 !== console.warn &&
                ((D = function (t) {
                  console.warn(t)
                }),
                H.isNode && process.stderr.isTTY
                  ? (D = function (t, e) {
                      var n = e ? '[33m' : '[31m'
                      console.warn(n + t + '[0m\n')
                    })
                  : H.isNode ||
                    'string' != typeof new Error().stack ||
                    (D = function (t, e) {
                      console.warn('%c' + t, e ? 'color: darkorange' : 'color: red')
                    }))
              var ot = { warnings: z, longStackTraces: !1, cancellation: !1, monitoring: !1 }
              return (
                X && e.longStackTraces(),
                {
                  longStackTraces: function () {
                    return ot.longStackTraces
                  },
                  warnings: function () {
                    return ot.warnings
                  },
                  cancellation: function () {
                    return ot.cancellation
                  },
                  monitoring: function () {
                    return ot.monitoring
                  },
                  propagateFromFunction: function () {
                    return et
                  },
                  boundValueFunction: function () {
                    return h
                  },
                  checkForgottenReturns: function (t, e, n, r, i) {
                    if (void 0 === t && null !== e && W) {
                      if (void 0 !== i && i._returnedNonUndefined()) return
                      if (0 == (65535 & r._bitField)) return
                      n && (n += ' ')
                      var o = '',
                        s = ''
                      if (e._trace) {
                        for (var a = e._trace.stack.split('\n'), c = w(a), l = c.length - 1; l >= 0; --l) {
                          var u = c[l]
                          if (!U.test(u)) {
                            var p = u.match(M)
                            p && (o = 'at ' + p[1] + ':' + p[2] + ':' + p[3] + ' ')
                            break
                          }
                        }
                        if (c.length > 0) {
                          var h = c[0]
                          for (l = 0; l < a.length; ++l)
                            if (a[l] === h) {
                              l > 0 && (s = '\n' + a[l - 1])
                              break
                            }
                        }
                      }
                      var f =
                        'a promise was created in a ' +
                        n +
                        'handler ' +
                        o +
                        'but was not returned from it, see http://goo.gl/rRqMUw' +
                        s
                      r._warn(f, !0, e)
                    }
                  },
                  setBounds: function (t, e) {
                    if (T()) {
                      for (
                        var n, r, i = t.stack.split('\n'), o = e.stack.split('\n'), s = -1, a = -1, c = 0;
                        c < i.length;
                        ++c
                      ) {
                        if ((l = P(i[c]))) {
                          ;(n = l.fileName), (s = l.line)
                          break
                        }
                      }
                      for (c = 0; c < o.length; ++c) {
                        var l
                        if ((l = P(o[c]))) {
                          ;(r = l.fileName), (a = l.line)
                          break
                        }
                      }
                      0 > s ||
                        0 > a ||
                        !n ||
                        !r ||
                        n !== r ||
                        s >= a ||
                        (nt = function (t) {
                          if (B.test(t)) return !0
                          var e = P(t)
                          return !!(e && e.fileName === n && s <= e.line && e.line <= a)
                        })
                    }
                  },
                  warn: y,
                  deprecated: function (t, e) {
                    var n = t + ' is deprecated and will be removed in a future version.'
                    return e && (n += ' Use ' + e + ' instead.'), y(n)
                  },
                  CapturedTrace: S,
                  fireDomEvent: J,
                  fireGlobalEvent: Y,
                }
              )
            }
          },
          { './errors': 12, './util': 36 },
        ],
        10: [
          function (t, e, n) {
            'use strict'
            e.exports = function (t) {
              function e() {
                return this.value
              }
              function n() {
                throw this.reason
              }
              ;(t.prototype.return = t.prototype.thenReturn =
                function (n) {
                  return (
                    n instanceof t && n.suppressUnhandledRejections(),
                    this._then(e, void 0, void 0, { value: n }, void 0)
                  )
                }),
                (t.prototype.throw = t.prototype.thenThrow =
                  function (t) {
                    return this._then(n, void 0, void 0, { reason: t }, void 0)
                  }),
                (t.prototype.catchThrow = function (t) {
                  if (arguments.length <= 1) return this._then(void 0, n, void 0, { reason: t }, void 0)
                  var e = arguments[1],
                    r = function () {
                      throw e
                    }
                  return this.caught(t, r)
                }),
                (t.prototype.catchReturn = function (n) {
                  if (arguments.length <= 1)
                    return (
                      n instanceof t && n.suppressUnhandledRejections(),
                      this._then(void 0, e, void 0, { value: n }, void 0)
                    )
                  var r = arguments[1]
                  r instanceof t && r.suppressUnhandledRejections()
                  var i = function () {
                    return r
                  }
                  return this.caught(n, i)
                })
            }
          },
          {},
        ],
        11: [
          function (t, e, n) {
            'use strict'
            e.exports = function (t, e) {
              function n() {
                return o(this)
              }
              var i = t.reduce,
                o = t.all
              ;(t.prototype.each = function (t) {
                return i(this, t, e, 0)._then(n, void 0, void 0, this, void 0)
              }),
                (t.prototype.mapSeries = function (t) {
                  return i(this, t, e, e)
                }),
                (t.each = function (t, r) {
                  return i(t, r, e, 0)._then(n, void 0, void 0, t, void 0)
                }),
                (t.mapSeries = function (t, n) {
                  return i(t, n, e, e)
                })
            }
          },
          {},
        ],
        12: [
          function (t, e, n) {
            'use strict'
            function r(t, e) {
              function n(r) {
                return this instanceof n
                  ? (p(this, 'message', 'string' == typeof r ? r : e),
                    p(this, 'name', t),
                    void (Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this)))
                  : new n(r)
              }
              return u(n, Error), n
            }
            function i(t) {
              return this instanceof i
                ? (p(this, 'name', 'OperationalError'),
                  p(this, 'message', t),
                  (this.cause = t),
                  (this.isOperational = !0),
                  void (t instanceof Error
                    ? (p(this, 'message', t.message), p(this, 'stack', t.stack))
                    : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor)))
                : new i(t)
            }
            var o,
              s,
              a = t('./es5'),
              c = a.freeze,
              l = t('./util'),
              u = l.inherits,
              p = l.notEnumerableProp,
              h = r('Warning', 'warning'),
              f = r('CancellationError', 'cancellation error'),
              _ = r('TimeoutError', 'timeout error'),
              d = r('AggregateError', 'aggregate error')
            try {
              ;(o = TypeError), (s = RangeError)
            } catch (v) {
              ;(o = r('TypeError', 'type error')), (s = r('RangeError', 'range error'))
            }
            for (
              var y =
                  'join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse'.split(
                    ' ',
                  ),
                m = 0;
              m < y.length;
              ++m
            )
              'function' == typeof Array.prototype[y[m]] && (d.prototype[y[m]] = Array.prototype[y[m]])
            a.defineProperty(d.prototype, 'length', { value: 0, configurable: !1, writable: !0, enumerable: !0 }),
              (d.prototype.isOperational = !0)
            var g = 0
            ;(d.prototype.toString = function () {
              var t = Array(4 * g + 1).join(' '),
                e = '\n' + t + 'AggregateError of:\n'
              g++, (t = Array(4 * g + 1).join(' '))
              for (var n = 0; n < this.length; ++n) {
                for (
                  var r = this[n] === this ? '[Circular AggregateError]' : this[n] + '', i = r.split('\n'), o = 0;
                  o < i.length;
                  ++o
                )
                  i[o] = t + i[o]
                e += (r = i.join('\n')) + '\n'
              }
              return g--, e
            }),
              u(i, Error)
            var b = Error.__BluebirdErrorTypes__
            b ||
              ((b = c({
                CancellationError: f,
                TimeoutError: _,
                OperationalError: i,
                RejectionError: i,
                AggregateError: d,
              })),
              a.defineProperty(Error, '__BluebirdErrorTypes__', {
                value: b,
                writable: !1,
                enumerable: !1,
                configurable: !1,
              })),
              (e.exports = {
                Error,
                TypeError: o,
                RangeError: s,
                CancellationError: b.CancellationError,
                OperationalError: b.OperationalError,
                TimeoutError: b.TimeoutError,
                AggregateError: b.AggregateError,
                Warning: h,
              })
          },
          { './es5': 13, './util': 36 },
        ],
        13: [
          function (t, e, n) {
            var r = (function () {
              'use strict'
              return void 0 === this
            })()
            if (r)
              e.exports = {
                freeze: Object.freeze,
                defineProperty: Object.defineProperty,
                getDescriptor: Object.getOwnPropertyDescriptor,
                keys: Object.keys,
                names: Object.getOwnPropertyNames,
                getPrototypeOf: Object.getPrototypeOf,
                isArray: Array.isArray,
                isES5: r,
                propertyIsWritable: function (t, e) {
                  var n = Object.getOwnPropertyDescriptor(t, e)
                  return !(n && !n.writable && !n.set)
                },
              }
            else {
              var i = {}.hasOwnProperty,
                o = {}.toString,
                s = {}.constructor.prototype,
                a = function (t) {
                  var e = []
                  for (var n in t) i.call(t, n) && e.push(n)
                  return e
                }
              e.exports = {
                isArray: function (t) {
                  try {
                    return '[object Array]' === o.call(t)
                  } catch (e) {
                    return !1
                  }
                },
                keys: a,
                names: a,
                defineProperty: function (t, e, n) {
                  return (t[e] = n.value), t
                },
                getDescriptor: function (t, e) {
                  return { value: t[e] }
                },
                freeze: function (t) {
                  return t
                },
                getPrototypeOf: function (t) {
                  try {
                    return Object(t).constructor.prototype
                  } catch (e) {
                    return s
                  }
                },
                isES5: r,
                propertyIsWritable: function () {
                  return !0
                },
              }
            }
          },
          {},
        ],
        14: [
          function (t, e, n) {
            'use strict'
            e.exports = function (t, e) {
              var n = t.map
              ;(t.prototype.filter = function (t, r) {
                return n(this, t, r, e)
              }),
                (t.filter = function (t, r, i) {
                  return n(t, r, i, e)
                })
            }
          },
          {},
        ],
        15: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r) {
              function i(t, e, n) {
                ;(this.promise = t),
                  (this.type = e),
                  (this.handler = n),
                  (this.called = !1),
                  (this.cancelPromise = null)
              }
              function o(t) {
                this.finallyHandler = t
              }
              function s(t, e) {
                return (
                  null != t.cancelPromise &&
                  (arguments.length > 1 ? t.cancelPromise._reject(e) : t.cancelPromise._cancel(),
                  (t.cancelPromise = null),
                  !0)
                )
              }
              function a() {
                return l.call(this, this.promise._target()._settledValue())
              }
              function c(t) {
                return s(this, t) ? void 0 : ((h.e = t), h)
              }
              function l(t) {
                var i = this.promise,
                  l = this.handler
                if (!this.called) {
                  this.called = !0
                  var u = this.isFinallyHandler() ? l.call(i._boundValue()) : l.call(i._boundValue(), t)
                  if (u === r) return u
                  if (void 0 !== u) {
                    i._setReturnedNonUndefined()
                    var f = n(u, i)
                    if (f instanceof e) {
                      if (null != this.cancelPromise) {
                        if (f._isCancelled()) {
                          var _ = new p('late cancellation observer')
                          return i._attachExtraTrace(_), (h.e = _), h
                        }
                        f.isPending() && f._attachCancellationCallback(new o(this))
                      }
                      return f._then(a, c, void 0, this, void 0)
                    }
                  }
                }
                return i.isRejected() ? (s(this), (h.e = t), h) : (s(this), t)
              }
              var u = t('./util'),
                p = e.CancellationError,
                h = u.errorObj,
                f = t('./catch_filter')(r)
              return (
                (i.prototype.isFinallyHandler = function () {
                  return 0 === this.type
                }),
                (o.prototype._resultCancelled = function () {
                  s(this.finallyHandler)
                }),
                (e.prototype._passThrough = function (t, e, n, r) {
                  return 'function' != typeof t ? this.then() : this._then(n, r, void 0, new i(this, e, t), void 0)
                }),
                (e.prototype.lastly = e.prototype.finally =
                  function (t) {
                    return this._passThrough(t, 0, l, l)
                  }),
                (e.prototype.tap = function (t) {
                  return this._passThrough(t, 1, l)
                }),
                (e.prototype.tapCatch = function (t) {
                  var n = arguments.length
                  if (1 === n) return this._passThrough(t, 1, void 0, l)
                  var r,
                    i = new Array(n - 1),
                    o = 0
                  for (r = 0; n - 1 > r; ++r) {
                    var s = arguments[r]
                    if (!u.isObject(s))
                      return e.reject(
                        new TypeError('tapCatch statement predicate: expecting an object but got ' + u.classString(s)),
                      )
                    i[o++] = s
                  }
                  i.length = o
                  var a = arguments[r]
                  return this._passThrough(f(i, a, this), 1, void 0, l)
                }),
                i
              )
            }
          },
          { './catch_filter': 7, './util': 36 },
        ],
        16: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i, o, s) {
              function c(t, n, i, o) {
                if (s.cancellation()) {
                  var a = new e(r),
                    c = (this._finallyPromise = new e(r))
                  ;(this._promise = a.lastly(function () {
                    return c
                  })),
                    a._captureStackTrace(),
                    a._setOnCancel(this)
                } else {
                  ;(this._promise = new e(r))._captureStackTrace()
                }
                ;(this._stack = o),
                  (this._generatorFunction = t),
                  (this._receiver = n),
                  (this._generator = void 0),
                  (this._yieldHandlers = 'function' == typeof i ? [i].concat(_) : _),
                  (this._yieldedPromise = null),
                  (this._cancellationPhase = !1)
              }
              var u = t('./errors').TypeError,
                p = t('./util'),
                h = p.errorObj,
                f = p.tryCatch,
                _ = []
              p.inherits(c, o),
                (c.prototype._isResolved = function () {
                  return null === this._promise
                }),
                (c.prototype._cleanup = function () {
                  ;(this._promise = this._generator = null),
                    s.cancellation() &&
                      null !== this._finallyPromise &&
                      (this._finallyPromise._fulfill(), (this._finallyPromise = null))
                }),
                (c.prototype._promiseCancelled = function () {
                  if (!this._isResolved()) {
                    var t
                    if (void 0 !== this._generator.return)
                      this._promise._pushContext(),
                        (t = f(this._generator.return).call(this._generator, void 0)),
                        this._promise._popContext()
                    else {
                      var r = new e.CancellationError('generator .return() sentinel')
                      ;(e.coroutine.returnSentinel = r),
                        this._promise._attachExtraTrace(r),
                        this._promise._pushContext(),
                        (t = f(this._generator.throw).call(this._generator, r)),
                        this._promise._popContext()
                    }
                    ;(this._cancellationPhase = !0), (this._yieldedPromise = null), this._continue(t)
                  }
                }),
                (c.prototype._promiseFulfilled = function (t) {
                  ;(this._yieldedPromise = null), this._promise._pushContext()
                  var e = f(this._generator.next).call(this._generator, t)
                  this._promise._popContext(), this._continue(e)
                }),
                (c.prototype._promiseRejected = function (t) {
                  ;(this._yieldedPromise = null), this._promise._attachExtraTrace(t), this._promise._pushContext()
                  var e = f(this._generator.throw).call(this._generator, t)
                  this._promise._popContext(), this._continue(e)
                }),
                (c.prototype._resultCancelled = function () {
                  if (this._yieldedPromise instanceof e) {
                    var t = this._yieldedPromise
                    ;(this._yieldedPromise = null), t.cancel()
                  }
                }),
                (c.prototype.promise = function () {
                  return this._promise
                }),
                (c.prototype._run = function () {
                  ;(this._generator = this._generatorFunction.call(this._receiver)),
                    (this._receiver = this._generatorFunction = void 0),
                    this._promiseFulfilled(void 0)
                }),
                (c.prototype._continue = function (t) {
                  var n = this._promise
                  if (t === h) return this._cleanup(), this._cancellationPhase ? n.cancel() : n._rejectCallback(t.e, !1)
                  var r = t.value
                  if (!0 === t.done)
                    return this._cleanup(), this._cancellationPhase ? n.cancel() : n._resolveCallback(r)
                  var o = i(r, this._promise)
                  if (
                    o instanceof e ||
                    null !==
                      (o = (function (t, n, r) {
                        for (var o = 0; o < n.length; ++o) {
                          r._pushContext()
                          var s = f(n[o])(t)
                          if ((r._popContext(), s === h)) {
                            r._pushContext()
                            var a = e.reject(h.e)
                            return r._popContext(), a
                          }
                          var c = i(s, r)
                          if (c instanceof e) return c
                        }
                        return null
                      })(o, this._yieldHandlers, this._promise))
                  ) {
                    var s = (o = o._target())._bitField
                    0 == (50397184 & s)
                      ? ((this._yieldedPromise = o), o._proxy(this, null))
                      : 0 != (33554432 & s)
                      ? e._async.invoke(this._promiseFulfilled, this, o._value())
                      : 0 != (16777216 & s)
                      ? e._async.invoke(this._promiseRejected, this, o._reason())
                      : this._promiseCancelled()
                  } else
                    this._promiseRejected(
                      new u(
                        'A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n'.replace(
                          '%s',
                          String(r),
                        ) +
                          'From coroutine:\n' +
                          this._stack.split('\n').slice(1, -7).join('\n'),
                      ),
                    )
                }),
                (e.coroutine = function (t, e) {
                  if ('function' != typeof t)
                    throw new u('generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n')
                  var n = Object(e).yieldHandler,
                    r = c,
                    i = new Error().stack
                  return function () {
                    var e = t.apply(this, arguments),
                      o = new r(void 0, void 0, n, i),
                      s = o.promise()
                    return (o._generator = e), o._promiseFulfilled(void 0), s
                  }
                }),
                (e.coroutine.addYieldHandler = function (t) {
                  if ('function' != typeof t) throw new u('expecting a function but got ' + p.classString(t))
                  _.push(t)
                }),
                (e.spawn = function (t) {
                  if ((s.deprecated('Promise.spawn()', 'Promise.coroutine()'), 'function' != typeof t))
                    return n('generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n')
                  var r = new c(t, this),
                    i = r.promise()
                  return r._run(e.spawn), i
                })
            }
          },
          { './errors': 12, './util': 36 },
        ],
        17: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i, o, s) {
              var a = t('./util')
              a.canEvaluate,
                a.tryCatch,
                a.errorObj,
                (e.join = function () {
                  var t,
                    e = arguments.length - 1
                  e > 0 && 'function' == typeof arguments[e] && (t = arguments[e])
                  var i = [].slice.call(arguments)
                  t && i.pop()
                  var r = new n(i).promise()
                  return void 0 !== t ? r.spread(t) : r
                })
            }
          },
          { './util': 36 },
        ],
        18: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i, o, s) {
              function a(t, e, n, r) {
                this.constructor$(t), this._promise._captureStackTrace()
                var i = l()
                ;(this._callback = null === i ? e : u.domainBind(i, e)),
                  (this._preservedValues = r === o ? new Array(this.length()) : null),
                  (this._limit = n),
                  (this._inFlight = 0),
                  (this._queue = []),
                  f.invoke(this._asyncInit, this, void 0)
              }
              function c(t, n, i, o) {
                if ('function' != typeof n) return r('expecting a function but got ' + u.classString(n))
                var s = 0
                if (void 0 !== i) {
                  if ('object' != typeof i || null === i)
                    return e.reject(new TypeError('options argument must be an object but it is ' + u.classString(i)))
                  if ('number' != typeof i.concurrency)
                    return e.reject(
                      new TypeError("'concurrency' must be a number but it is " + u.classString(i.concurrency)),
                    )
                  s = i.concurrency
                }
                return new a(t, n, (s = 'number' == typeof s && isFinite(s) && s >= 1 ? s : 0), o).promise()
              }
              var l = e._getDomain,
                u = t('./util'),
                p = u.tryCatch,
                h = u.errorObj,
                f = e._async
              u.inherits(a, n),
                (a.prototype._asyncInit = function () {
                  this._init$(void 0, -2)
                }),
                (a.prototype._init = function () {}),
                (a.prototype._promiseFulfilled = function (t, n) {
                  var r = this._values,
                    o = this.length(),
                    a = this._preservedValues,
                    c = this._limit
                  if (0 > n) {
                    if (
                      ((r[(n = -1 * n - 1)] = t), c >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
                    )
                      return !0
                  } else {
                    if (c >= 1 && this._inFlight >= c) return (r[n] = t), this._queue.push(n), !1
                    null !== a && (a[n] = t)
                    var l = this._promise,
                      u = this._callback,
                      f = l._boundValue()
                    l._pushContext()
                    var _ = p(u).call(f, t, n, o),
                      d = l._popContext()
                    if ((s.checkForgottenReturns(_, d, null !== a ? 'Promise.filter' : 'Promise.map', l), _ === h))
                      return this._reject(_.e), !0
                    var v = i(_, this._promise)
                    if (v instanceof e) {
                      var y = (v = v._target())._bitField
                      if (0 == (50397184 & y))
                        return c >= 1 && this._inFlight++, (r[n] = v), v._proxy(this, -1 * (n + 1)), !1
                      if (0 == (33554432 & y))
                        return 0 != (16777216 & y) ? (this._reject(v._reason()), !0) : (this._cancel(), !0)
                      _ = v._value()
                    }
                    r[n] = _
                  }
                  return ++this._totalResolved >= o && (null !== a ? this._filter(r, a) : this._resolve(r), !0)
                }),
                (a.prototype._drainQueue = function () {
                  for (var t = this._queue, e = this._limit, n = this._values; t.length > 0 && this._inFlight < e; ) {
                    if (this._isResolved()) return
                    var r = t.pop()
                    this._promiseFulfilled(n[r], r)
                  }
                }),
                (a.prototype._filter = function (t, e) {
                  for (var n = e.length, r = new Array(n), i = 0, o = 0; n > o; ++o) t[o] && (r[i++] = e[o])
                  ;(r.length = i), this._resolve(r)
                }),
                (a.prototype.preservedValues = function () {
                  return this._preservedValues
                }),
                (e.prototype.map = function (t, e) {
                  return c(this, t, e, null)
                }),
                (e.map = function (t, e, n, r) {
                  return c(t, e, n, r)
                })
            }
          },
          { './util': 36 },
        ],
        19: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i, o) {
              var s = t('./util'),
                a = s.tryCatch
              ;(e.method = function (t) {
                if ('function' != typeof t) throw new e.TypeError('expecting a function but got ' + s.classString(t))
                return function () {
                  var r = new e(n)
                  r._captureStackTrace(), r._pushContext()
                  var i = a(t).apply(this, arguments),
                    s = r._popContext()
                  return o.checkForgottenReturns(i, s, 'Promise.method', r), r._resolveFromSyncValue(i), r
                }
              }),
                (e.attempt = e.try =
                  function (t) {
                    if ('function' != typeof t) return i('expecting a function but got ' + s.classString(t))
                    var c,
                      r = new e(n)
                    if ((r._captureStackTrace(), r._pushContext(), arguments.length > 1)) {
                      o.deprecated('calling Promise.try with more than 1 argument')
                      var l = arguments[1],
                        u = arguments[2]
                      c = s.isArray(l) ? a(t).apply(u, l) : a(t).call(u, l)
                    } else c = a(t)()
                    var p = r._popContext()
                    return o.checkForgottenReturns(c, p, 'Promise.try', r), r._resolveFromSyncValue(c), r
                  }),
                (e.prototype._resolveFromSyncValue = function (t) {
                  t === s.errorObj ? this._rejectCallback(t.e, !1) : this._resolveCallback(t, !0)
                })
            }
          },
          { './util': 36 },
        ],
        20: [
          function (t, e, n) {
            'use strict'
            function i(t) {
              var e
              if (
                (function (t) {
                  return t instanceof Error && u.getPrototypeOf(t) === Error.prototype
                })(t)
              ) {
                ;((e = new l(t)).name = t.name), (e.message = t.message), (e.stack = t.stack)
                for (var n = u.keys(t), i = 0; i < n.length; ++i) {
                  var o = n[i]
                  p.test(o) || (e[o] = t[o])
                }
                return e
              }
              return s.markAsOriginatingFromRejection(t), t
            }
            var s = t('./util'),
              a = s.maybeWrapAsError,
              l = t('./errors').OperationalError,
              u = t('./es5'),
              p = /^(?:name|message|stack|cause)$/
            e.exports = function (t, e) {
              return function (n, r) {
                if (null !== t) {
                  if (n) {
                    var o = i(a(n))
                    t._attachExtraTrace(o), t._reject(o)
                  } else if (e) {
                    var s = [].slice.call(arguments, 1)
                    t._fulfill(s)
                  } else t._fulfill(r)
                  t = null
                }
              }
            }
          },
          { './errors': 12, './es5': 13, './util': 36 },
        ],
        21: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e) {
              function n(t, e) {
                if (!o.isArray(t)) return r.call(this, t, e)
                var i = a(e).apply(this._boundValue(), [null].concat(t))
                i === c && s.throwLater(i.e)
              }
              function r(t, e) {
                var r = this._boundValue(),
                  i = void 0 === t ? a(e).call(r, null) : a(e).call(r, null, t)
                i === c && s.throwLater(i.e)
              }
              function i(t, e) {
                if (!t) {
                  var r = new Error(t + '')
                  ;(r.cause = t), (t = r)
                }
                var i = a(e).call(this._boundValue(), t)
                i === c && s.throwLater(i.e)
              }
              var o = t('./util'),
                s = e._async,
                a = o.tryCatch,
                c = o.errorObj
              e.prototype.asCallback = e.prototype.nodeify = function (t, e) {
                if ('function' == typeof t) {
                  var o = r
                  void 0 !== e && Object(e).spread && (o = n), this._then(o, i, void 0, this, t)
                }
                return this
              }
            }
          },
          { './util': 36 },
        ],
        22: [
          function (t, e, n) {
            'use strict'
            e.exports = function () {
              function n() {}
              function i(t) {
                t !== b &&
                  (function (t, e) {
                    if (null == t || t.constructor !== i)
                      throw new m(
                        'the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n',
                      )
                    if ('function' != typeof e) throw new m('expecting a function but got ' + f.classString(e))
                  })(this, t),
                  (this._bitField = 0),
                  (this._fulfillmentHandler0 = void 0),
                  (this._rejectionHandler0 = void 0),
                  (this._promise0 = void 0),
                  (this._receiver0 = void 0),
                  this._resolveFromExecutor(t),
                  this._promiseCreated(),
                  this._fireEvent('promiseCreated', this)
              }
              function o(t) {
                this.promise._resolveCallback(t)
              }
              function s(t) {
                this.promise._rejectCallback(t, !1)
              }
              function a(t) {
                var e = new i(b)
                ;(e._fulfillmentHandler0 = t), (e._rejectionHandler0 = t), (e._promise0 = t), (e._receiver0 = t)
              }
              var c,
                l = function () {
                  return new m('circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n')
                },
                u = function () {
                  return new i.PromiseInspection(this._target())
                },
                p = function (t) {
                  return i.reject(new m(t))
                },
                h = {},
                f = t('./util')
              ;(c = f.isNode
                ? function () {
                    var t = process.domain
                    return void 0 === t && (t = null), t
                  }
                : function () {
                    return null
                  }),
                f.notEnumerableProp(i, '_getDomain', c)
              var _ = t('./es5'),
                d = t('./async'),
                v = new d()
              _.defineProperty(i, '_async', { value: v })
              var y = t('./errors'),
                m = (i.TypeError = y.TypeError)
              i.RangeError = y.RangeError
              var g = (i.CancellationError = y.CancellationError)
              ;(i.TimeoutError = y.TimeoutError),
                (i.OperationalError = y.OperationalError),
                (i.RejectionError = y.OperationalError),
                (i.AggregateError = y.AggregateError)
              var b = function () {},
                w = {},
                C = {},
                j = t('./thenables')(i, b),
                E = t('./promise_array')(i, b, j, p, n),
                k = t('./context')(i),
                F = k.create,
                x = t('./debuggability')(i, k),
                T = (x.CapturedTrace, t('./finally')(i, j, C)),
                P = t('./catch_filter')(C),
                R = t('./nodeback'),
                S = f.errorObj,
                O = f.tryCatch
              return (
                (i.prototype.toString = function () {
                  return '[object Promise]'
                }),
                (i.prototype.caught = i.prototype.catch =
                  function (t) {
                    var e = arguments.length
                    if (e > 1) {
                      var n,
                        r = new Array(e - 1),
                        i = 0
                      for (n = 0; e - 1 > n; ++n) {
                        var o = arguments[n]
                        if (!f.isObject(o))
                          return p('Catch statement predicate: expecting an object but got ' + f.classString(o))
                        r[i++] = o
                      }
                      return (r.length = i), (t = arguments[n]), this.then(void 0, P(r, t, this))
                    }
                    return this.then(void 0, t)
                  }),
                (i.prototype.reflect = function () {
                  return this._then(u, u, void 0, this, void 0)
                }),
                (i.prototype.then = function (t, e) {
                  if (x.warnings() && arguments.length > 0 && 'function' != typeof t && 'function' != typeof e) {
                    var n = '.then() only accepts functions but was passed: ' + f.classString(t)
                    arguments.length > 1 && (n += ', ' + f.classString(e)), this._warn(n)
                  }
                  return this._then(t, e, void 0, void 0, void 0)
                }),
                (i.prototype.done = function (t, e) {
                  this._then(t, e, void 0, void 0, void 0)._setIsFinal()
                }),
                (i.prototype.spread = function (t) {
                  return 'function' != typeof t
                    ? p('expecting a function but got ' + f.classString(t))
                    : this.all()._then(t, void 0, void 0, w, void 0)
                }),
                (i.prototype.toJSON = function () {
                  var t = { isFulfilled: !1, isRejected: !1, fulfillmentValue: void 0, rejectionReason: void 0 }
                  return (
                    this.isFulfilled()
                      ? ((t.fulfillmentValue = this.value()), (t.isFulfilled = !0))
                      : this.isRejected() && ((t.rejectionReason = this.reason()), (t.isRejected = !0)),
                    t
                  )
                }),
                (i.prototype.all = function () {
                  return (
                    arguments.length > 0 && this._warn('.all() was passed arguments but it does not take any'),
                    new E(this).promise()
                  )
                }),
                (i.prototype.error = function (t) {
                  return this.caught(f.originatesFromRejection, t)
                }),
                (i.getNewLibraryCopy = e.exports),
                (i.is = function (t) {
                  return t instanceof i
                }),
                (i.fromNode = i.fromCallback =
                  function (t) {
                    var e = new i(b)
                    e._captureStackTrace()
                    var n = arguments.length > 1 && !!Object(arguments[1]).multiArgs,
                      r = O(t)(R(e, n))
                    return r === S && e._rejectCallback(r.e, !0), e._isFateSealed() || e._setAsyncGuaranteed(), e
                  }),
                (i.all = function (t) {
                  return new E(t).promise()
                }),
                (i.cast = function (t) {
                  var e = j(t)
                  return (
                    e instanceof i ||
                      ((e = new i(b))._captureStackTrace(), e._setFulfilled(), (e._rejectionHandler0 = t)),
                    e
                  )
                }),
                (i.resolve = i.fulfilled = i.cast),
                (i.reject = i.rejected =
                  function (t) {
                    var e = new i(b)
                    return e._captureStackTrace(), e._rejectCallback(t, !0), e
                  }),
                (i.setScheduler = function (t) {
                  if ('function' != typeof t) throw new m('expecting a function but got ' + f.classString(t))
                  return v.setScheduler(t)
                }),
                (i.prototype._then = function (t, e, n, r, o) {
                  var s = void 0 !== o,
                    a = s ? o : new i(b),
                    l = this._target(),
                    u = l._bitField
                  s ||
                    (a._propagateFrom(this, 3),
                    a._captureStackTrace(),
                    void 0 === r &&
                      0 != (2097152 & this._bitField) &&
                      (r = 0 != (50397184 & u) ? this._boundValue() : l === this ? void 0 : this._boundTo),
                    this._fireEvent('promiseChained', this, a))
                  var p = c()
                  if (0 != (50397184 & u)) {
                    var h,
                      _,
                      d = l._settlePromiseCtx
                    0 != (33554432 & u)
                      ? ((_ = l._rejectionHandler0), (h = t))
                      : 0 != (16777216 & u)
                      ? ((_ = l._fulfillmentHandler0), (h = e), l._unsetRejectionIsUnhandled())
                      : ((d = l._settlePromiseLateCancellationObserver),
                        (_ = new g('late cancellation observer')),
                        l._attachExtraTrace(_),
                        (h = e)),
                      v.invoke(d, l, {
                        handler: null === p ? h : 'function' == typeof h && f.domainBind(p, h),
                        promise: a,
                        receiver: r,
                        value: _,
                      })
                  } else l._addCallbacks(t, e, a, r, p)
                  return a
                }),
                (i.prototype._length = function () {
                  return 65535 & this._bitField
                }),
                (i.prototype._isFateSealed = function () {
                  return 0 != (117506048 & this._bitField)
                }),
                (i.prototype._isFollowing = function () {
                  return 67108864 == (67108864 & this._bitField)
                }),
                (i.prototype._setLength = function (t) {
                  this._bitField = (-65536 & this._bitField) | (65535 & t)
                }),
                (i.prototype._setFulfilled = function () {
                  ;(this._bitField = 33554432 | this._bitField), this._fireEvent('promiseFulfilled', this)
                }),
                (i.prototype._setRejected = function () {
                  ;(this._bitField = 16777216 | this._bitField), this._fireEvent('promiseRejected', this)
                }),
                (i.prototype._setFollowing = function () {
                  ;(this._bitField = 67108864 | this._bitField), this._fireEvent('promiseResolved', this)
                }),
                (i.prototype._setIsFinal = function () {
                  this._bitField = 4194304 | this._bitField
                }),
                (i.prototype._isFinal = function () {
                  return (4194304 & this._bitField) > 0
                }),
                (i.prototype._unsetCancelled = function () {
                  this._bitField = -65537 & this._bitField
                }),
                (i.prototype._setCancelled = function () {
                  ;(this._bitField = 65536 | this._bitField), this._fireEvent('promiseCancelled', this)
                }),
                (i.prototype._setWillBeCancelled = function () {
                  this._bitField = 8388608 | this._bitField
                }),
                (i.prototype._setAsyncGuaranteed = function () {
                  v.hasCustomScheduler() || (this._bitField = 134217728 | this._bitField)
                }),
                (i.prototype._receiverAt = function (t) {
                  var e = 0 === t ? this._receiver0 : this[4 * t - 4 + 3]
                  return e === h ? void 0 : void 0 === e && this._isBound() ? this._boundValue() : e
                }),
                (i.prototype._promiseAt = function (t) {
                  return this[4 * t - 4 + 2]
                }),
                (i.prototype._fulfillmentHandlerAt = function (t) {
                  return this[4 * t - 4 + 0]
                }),
                (i.prototype._rejectionHandlerAt = function (t) {
                  return this[4 * t - 4 + 1]
                }),
                (i.prototype._boundValue = function () {}),
                (i.prototype._migrateCallback0 = function (t) {
                  var e = (t._bitField, t._fulfillmentHandler0),
                    n = t._rejectionHandler0,
                    r = t._promise0,
                    i = t._receiverAt(0)
                  void 0 === i && (i = h), this._addCallbacks(e, n, r, i, null)
                }),
                (i.prototype._migrateCallbackAt = function (t, e) {
                  var n = t._fulfillmentHandlerAt(e),
                    r = t._rejectionHandlerAt(e),
                    i = t._promiseAt(e),
                    o = t._receiverAt(e)
                  void 0 === o && (o = h), this._addCallbacks(n, r, i, o, null)
                }),
                (i.prototype._addCallbacks = function (t, e, n, r, i) {
                  var o = this._length()
                  if ((o >= 65531 && ((o = 0), this._setLength(0)), 0 === o))
                    (this._promise0 = n),
                      (this._receiver0 = r),
                      'function' == typeof t && (this._fulfillmentHandler0 = null === i ? t : f.domainBind(i, t)),
                      'function' == typeof e && (this._rejectionHandler0 = null === i ? e : f.domainBind(i, e))
                  else {
                    var s = 4 * o - 4
                    ;(this[s + 2] = n),
                      (this[s + 3] = r),
                      'function' == typeof t && (this[s + 0] = null === i ? t : f.domainBind(i, t)),
                      'function' == typeof e && (this[s + 1] = null === i ? e : f.domainBind(i, e))
                  }
                  return this._setLength(o + 1), o
                }),
                (i.prototype._proxy = function (t, e) {
                  this._addCallbacks(void 0, void 0, e, t, null)
                }),
                (i.prototype._resolveCallback = function (t, e) {
                  if (0 == (117506048 & this._bitField)) {
                    if (t === this) return this._rejectCallback(l(), !1)
                    var n = j(t, this)
                    if (!(n instanceof i)) return this._fulfill(t)
                    e && this._propagateFrom(n, 2)
                    var r = n._target()
                    if (r === this) return void this._reject(l())
                    var o = r._bitField
                    if (0 == (50397184 & o)) {
                      var s = this._length()
                      s > 0 && r._migrateCallback0(this)
                      for (var a = 1; s > a; ++a) r._migrateCallbackAt(this, a)
                      this._setFollowing(), this._setLength(0), this._setFollowee(r)
                    } else if (0 != (33554432 & o)) this._fulfill(r._value())
                    else if (0 != (16777216 & o)) this._reject(r._reason())
                    else {
                      var c = new g('late cancellation observer')
                      r._attachExtraTrace(c), this._reject(c)
                    }
                  }
                }),
                (i.prototype._rejectCallback = function (t, e, n) {
                  var r = f.ensureErrorObject(t),
                    i = r === t
                  if (!i && !n && x.warnings()) {
                    var o = 'a promise was rejected with a non-error: ' + f.classString(t)
                    this._warn(o, !0)
                  }
                  this._attachExtraTrace(r, !!e && i), this._reject(t)
                }),
                (i.prototype._resolveFromExecutor = function (t) {
                  if (t !== b) {
                    var e = this
                    this._captureStackTrace(), this._pushContext()
                    var n = !0,
                      r = this._execute(
                        t,
                        function (t) {
                          e._resolveCallback(t)
                        },
                        function (t) {
                          e._rejectCallback(t, n)
                        },
                      )
                    ;(n = !1), this._popContext(), void 0 !== r && e._rejectCallback(r, !0)
                  }
                }),
                (i.prototype._settlePromiseFromHandler = function (t, e, n, r) {
                  var i = r._bitField
                  if (0 == (65536 & i)) {
                    var o
                    r._pushContext(),
                      e === w
                        ? n && 'number' == typeof n.length
                          ? (o = O(t).apply(this._boundValue(), n))
                          : ((o = S).e = new m('cannot .spread() a non-array: ' + f.classString(n)))
                        : (o = O(t).call(e, n))
                    var s = r._popContext()
                    0 == (65536 & (i = r._bitField)) &&
                      (o === C
                        ? r._reject(n)
                        : o === S
                        ? r._rejectCallback(o.e, !1)
                        : (x.checkForgottenReturns(o, s, '', r, this), r._resolveCallback(o)))
                  }
                }),
                (i.prototype._target = function () {
                  for (var t = this; t._isFollowing(); ) t = t._followee()
                  return t
                }),
                (i.prototype._followee = function () {
                  return this._rejectionHandler0
                }),
                (i.prototype._setFollowee = function (t) {
                  this._rejectionHandler0 = t
                }),
                (i.prototype._settlePromise = function (t, e, r, o) {
                  var s = t instanceof i,
                    a = this._bitField,
                    c = 0 != (134217728 & a)
                  0 != (65536 & a)
                    ? (s && t._invokeInternalOnCancel(),
                      r instanceof T && r.isFinallyHandler()
                        ? ((r.cancelPromise = t), O(e).call(r, o) === S && t._reject(S.e))
                        : e === u
                        ? t._fulfill(u.call(r))
                        : r instanceof n
                        ? r._promiseCancelled(t)
                        : s || t instanceof E
                        ? t._cancel()
                        : r.cancel())
                    : 'function' == typeof e
                    ? s
                      ? (c && t._setAsyncGuaranteed(), this._settlePromiseFromHandler(e, r, o, t))
                      : e.call(r, o, t)
                    : r instanceof n
                    ? r._isResolved() || (0 != (33554432 & a) ? r._promiseFulfilled(o, t) : r._promiseRejected(o, t))
                    : s && (c && t._setAsyncGuaranteed(), 0 != (33554432 & a) ? t._fulfill(o) : t._reject(o))
                }),
                (i.prototype._settlePromiseLateCancellationObserver = function (t) {
                  var e = t.handler,
                    n = t.promise,
                    r = t.receiver,
                    o = t.value
                  'function' == typeof e
                    ? n instanceof i
                      ? this._settlePromiseFromHandler(e, r, o, n)
                      : e.call(r, o, n)
                    : n instanceof i && n._reject(o)
                }),
                (i.prototype._settlePromiseCtx = function (t) {
                  this._settlePromise(t.promise, t.handler, t.receiver, t.value)
                }),
                (i.prototype._settlePromise0 = function (t, e, n) {
                  var r = this._promise0,
                    i = this._receiverAt(0)
                  ;(this._promise0 = void 0), (this._receiver0 = void 0), this._settlePromise(r, t, i, e)
                }),
                (i.prototype._clearCallbackDataAtIndex = function (t) {
                  var e = 4 * t - 4
                  this[e + 2] = this[e + 3] = this[e + 0] = this[e + 1] = void 0
                }),
                (i.prototype._fulfill = function (t) {
                  var e = this._bitField
                  if (!((117506048 & e) >>> 16)) {
                    if (t === this) {
                      var n = l()
                      return this._attachExtraTrace(n), this._reject(n)
                    }
                    this._setFulfilled(),
                      (this._rejectionHandler0 = t),
                      (65535 & e) > 0 && (0 != (134217728 & e) ? this._settlePromises() : v.settlePromises(this))
                  }
                }),
                (i.prototype._reject = function (t) {
                  var e = this._bitField
                  if (!((117506048 & e) >>> 16))
                    return (
                      this._setRejected(),
                      (this._fulfillmentHandler0 = t),
                      this._isFinal()
                        ? v.fatalError(t, f.isNode)
                        : void ((65535 & e) > 0 ? v.settlePromises(this) : this._ensurePossibleRejectionHandled())
                    )
                }),
                (i.prototype._fulfillPromises = function (t, e) {
                  for (var n = 1; t > n; n++) {
                    var r = this._fulfillmentHandlerAt(n),
                      i = this._promiseAt(n),
                      o = this._receiverAt(n)
                    this._clearCallbackDataAtIndex(n), this._settlePromise(i, r, o, e)
                  }
                }),
                (i.prototype._rejectPromises = function (t, e) {
                  for (var n = 1; t > n; n++) {
                    var r = this._rejectionHandlerAt(n),
                      i = this._promiseAt(n),
                      o = this._receiverAt(n)
                    this._clearCallbackDataAtIndex(n), this._settlePromise(i, r, o, e)
                  }
                }),
                (i.prototype._settlePromises = function () {
                  var t = this._bitField,
                    e = 65535 & t
                  if (e > 0) {
                    if (0 != (16842752 & t)) {
                      var n = this._fulfillmentHandler0
                      this._settlePromise0(this._rejectionHandler0, n, t), this._rejectPromises(e, n)
                    } else {
                      var r = this._rejectionHandler0
                      this._settlePromise0(this._fulfillmentHandler0, r, t), this._fulfillPromises(e, r)
                    }
                    this._setLength(0)
                  }
                  this._clearCancellationData()
                }),
                (i.prototype._settledValue = function () {
                  var t = this._bitField
                  return 0 != (33554432 & t)
                    ? this._rejectionHandler0
                    : 0 != (16777216 & t)
                    ? this._fulfillmentHandler0
                    : void 0
                }),
                (i.defer = i.pending =
                  function () {
                    return x.deprecated('Promise.defer', 'new Promise'), { promise: new i(b), resolve: o, reject: s }
                  }),
                f.notEnumerableProp(i, '_makeSelfResolutionError', l),
                t('./method')(i, b, j, p, x),
                t('./bind')(i, b, j, x),
                t('./cancel')(i, E, p, x),
                t('./direct_resolve')(i),
                t('./synchronous_inspection')(i),
                t('./join')(i, E, j, b, v, c),
                (i.Promise = i),
                (i.version = '3.5.1'),
                t('./map.js')(i, E, p, j, b, x),
                t('./call_get.js')(i),
                t('./using.js')(i, p, j, F, b, x),
                t('./timers.js')(i, b, x),
                t('./generators.js')(i, p, b, j, n, x),
                t('./nodeify.js')(i),
                t('./promisify.js')(i, b),
                t('./props.js')(i, E, j, p),
                t('./race.js')(i, b, j, p),
                t('./reduce.js')(i, E, p, j, b, x),
                t('./settle.js')(i, E, x),
                t('./some.js')(i, E, p),
                t('./filter.js')(i, b),
                t('./each.js')(i, b),
                t('./any.js')(i),
                f.toFastProperties(i),
                f.toFastProperties(i.prototype),
                a({ a: 1 }),
                a({ b: 2 }),
                a({ c: 3 }),
                a(1),
                a(function () {}),
                a(void 0),
                a(!1),
                a(new i(b)),
                x.setBounds(d.firstLineError, f.lastLineError),
                i
              )
            }
          },
          {
            './any.js': 1,
            './async': 2,
            './bind': 3,
            './call_get.js': 5,
            './cancel': 6,
            './catch_filter': 7,
            './context': 8,
            './debuggability': 9,
            './direct_resolve': 10,
            './each.js': 11,
            './errors': 12,
            './es5': 13,
            './filter.js': 14,
            './finally': 15,
            './generators.js': 16,
            './join': 17,
            './map.js': 18,
            './method': 19,
            './nodeback': 20,
            './nodeify.js': 21,
            './promise_array': 23,
            './promisify.js': 24,
            './props.js': 25,
            './race.js': 27,
            './reduce.js': 28,
            './settle.js': 30,
            './some.js': 31,
            './synchronous_inspection': 32,
            './thenables': 33,
            './timers.js': 34,
            './using.js': 35,
            './util': 36,
          },
        ],
        23: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i, o) {
              function a(t) {
                var r = (this._promise = new e(n))
                t instanceof e && r._propagateFrom(t, 3),
                  r._setOnCancel(this),
                  (this._values = t),
                  (this._length = 0),
                  (this._totalResolved = 0),
                  this._init(void 0, -2)
              }
              var c = t('./util')
              return (
                c.isArray,
                c.inherits(a, o),
                (a.prototype.length = function () {
                  return this._length
                }),
                (a.prototype.promise = function () {
                  return this._promise
                }),
                (a.prototype._init = function l(t, n) {
                  var o = r(this._values, this._promise)
                  if (o instanceof e) {
                    var a = (o = o._target())._bitField
                    if (((this._values = o), 0 == (50397184 & a)))
                      return this._promise._setAsyncGuaranteed(), o._then(l, this._reject, void 0, this, n)
                    if (0 == (33554432 & a)) return 0 != (16777216 & a) ? this._reject(o._reason()) : this._cancel()
                    o = o._value()
                  }
                  if (null !== (o = c.asArray(o)))
                    return 0 === o.length
                      ? void (-5 === n
                          ? this._resolveEmptyArray()
                          : this._resolve(
                              (function (t) {
                                switch (t) {
                                  case -2:
                                    return []
                                  case -3:
                                    return {}
                                  case -6:
                                    return new Map()
                                }
                              })(n),
                            ))
                      : void this._iterate(o)
                  var u = i('expecting an array or an iterable object but got ' + c.classString(o)).reason()
                  this._promise._rejectCallback(u, !1)
                }),
                (a.prototype._iterate = function (t) {
                  var n = this.getActualLength(t.length)
                  ;(this._length = n), (this._values = this.shouldCopyValues() ? new Array(n) : this._values)
                  for (var i = this._promise, o = !1, s = null, a = 0; n > a; ++a) {
                    var c = r(t[a], i)
                    c instanceof e ? (s = (c = c._target())._bitField) : (s = null),
                      o
                        ? null !== s && c.suppressUnhandledRejections()
                        : null !== s
                        ? 0 == (50397184 & s)
                          ? (c._proxy(this, a), (this._values[a] = c))
                          : (o =
                              0 != (33554432 & s)
                                ? this._promiseFulfilled(c._value(), a)
                                : 0 != (16777216 & s)
                                ? this._promiseRejected(c._reason(), a)
                                : this._promiseCancelled(a))
                        : (o = this._promiseFulfilled(c, a))
                  }
                  o || i._setAsyncGuaranteed()
                }),
                (a.prototype._isResolved = function () {
                  return null === this._values
                }),
                (a.prototype._resolve = function (t) {
                  ;(this._values = null), this._promise._fulfill(t)
                }),
                (a.prototype._cancel = function () {
                  !this._isResolved() &&
                    this._promise._isCancellable() &&
                    ((this._values = null), this._promise._cancel())
                }),
                (a.prototype._reject = function (t) {
                  ;(this._values = null), this._promise._rejectCallback(t, !1)
                }),
                (a.prototype._promiseFulfilled = function (t, e) {
                  return (
                    (this._values[e] = t), ++this._totalResolved >= this._length && (this._resolve(this._values), !0)
                  )
                }),
                (a.prototype._promiseCancelled = function () {
                  return this._cancel(), !0
                }),
                (a.prototype._promiseRejected = function (t) {
                  return this._totalResolved++, this._reject(t), !0
                }),
                (a.prototype._resultCancelled = function () {
                  if (!this._isResolved()) {
                    var t = this._values
                    if ((this._cancel(), t instanceof e)) t.cancel()
                    else for (var n = 0; n < t.length; ++n) t[n] instanceof e && t[n].cancel()
                  }
                }),
                (a.prototype.shouldCopyValues = function () {
                  return !0
                }),
                (a.prototype.getActualLength = function (t) {
                  return t
                }),
                a
              )
            }
          },
          { './util': 36 },
        ],
        24: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n) {
              function r(t) {
                return !C.test(t)
              }
              function i(t) {
                try {
                  return !0 === t.__isPromisified__
                } catch (e) {
                  return !1
                }
              }
              function o(t, e, n) {
                var r = f.getDataPropertyOrDefault(t, e + n, b)
                return !!r && i(r)
              }
              function a(t, e, n, r) {
                for (var a = f.inheritedDataKeys(t), c = [], l = 0; l < a.length; ++l) {
                  var u = a[l],
                    p = t[u],
                    h = r === j || j(u, p, t)
                  'function' != typeof p || i(p) || o(t, u, e) || !r(u, p, t, h) || c.push(u, p)
                }
                return (
                  (function (t, e, n) {
                    for (var r = 0; r < t.length; r += 2) {
                      var i = t[r]
                      if (n.test(i))
                        for (var o = i.replace(n, ''), s = 0; s < t.length; s += 2)
                          if (t[s] === o)
                            throw new m(
                              "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace(
                                '%s',
                                e,
                              ),
                            )
                    }
                  })(c, e, n),
                  c
                )
              }
              function l(t, e, n, r, i) {
                for (var o = new RegExp(E(e) + '$'), s = a(t, e, o, n), c = 0, l = s.length; l > c; c += 2) {
                  var u = s[c],
                    p = s[c + 1],
                    _ = u + e
                  if (r === k) t[_] = k(u, h, u, p, e, i)
                  else {
                    var d = r(p, function () {
                      return k(u, h, u, p, e, i)
                    })
                    f.notEnumerableProp(d, '__isPromisified__', !0), (t[_] = d)
                  }
                }
                return f.toFastProperties(t), t
              }
              var h = {},
                f = t('./util'),
                _ = t('./nodeback'),
                d = f.withAppended,
                v = f.maybeWrapAsError,
                y = f.canEvaluate,
                m = t('./errors').TypeError,
                b = { __isPromisified__: !0 },
                C = new RegExp(
                  '^(?:' +
                    ['arity', 'length', 'name', 'arguments', 'caller', 'callee', 'prototype', '__isPromisified__'].join(
                      '|',
                    ) +
                    ')$',
                ),
                j = function (t) {
                  return f.isIdentifier(t) && '_' !== t.charAt(0) && 'constructor' !== t
                },
                E = function (t) {
                  return t.replace(/([$])/, '\\$')
                },
                k = y
                  ? undefined
                  : function (t, r, i, o, s, a) {
                      function c() {
                        var i = r
                        r === h && (i = this)
                        var o = new e(n)
                        o._captureStackTrace()
                        var s = 'string' == typeof u && this !== l ? this[u] : t,
                          c = _(o, a)
                        try {
                          s.apply(i, d(arguments, c))
                        } catch (p) {
                          o._rejectCallback(v(p), !0, !0)
                        }
                        return o._isFateSealed() || o._setAsyncGuaranteed(), o
                      }
                      var l = (function () {
                          return this
                        })(),
                        u = t
                      return 'string' == typeof u && (t = o), f.notEnumerableProp(c, '__isPromisified__', !0), c
                    }
              ;(e.promisify = function (t, e) {
                if ('function' != typeof t) throw new m('expecting a function but got ' + f.classString(t))
                if (i(t)) return t
                var s = (function (t, e, n) {
                  return k(t, e, void 0, t, null, n)
                })(t, void 0 === (e = Object(e)).context ? h : e.context, !!e.multiArgs)
                return f.copyDescriptors(t, s, r), s
              }),
                (e.promisifyAll = function (t, e) {
                  if ('function' != typeof t && 'object' != typeof t)
                    throw new m(
                      'the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n',
                    )
                  var n = !!(e = Object(e)).multiArgs,
                    r = e.suffix
                  'string' != typeof r && (r = 'Async')
                  var i = e.filter
                  'function' != typeof i && (i = j)
                  var o = e.promisifier
                  if (('function' != typeof o && (o = k), !f.isIdentifier(r)))
                    throw new RangeError('suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n')
                  for (var s = f.inheritedDataKeys(t), a = 0; a < s.length; ++a) {
                    var c = t[s[a]]
                    'constructor' !== s[a] && f.isClass(c) && (l(c.prototype, r, i, o, n), l(c, r, i, o, n))
                  }
                  return l(t, r, i, o, n)
                })
            }
          },
          { './errors': 12, './nodeback': 20, './util': 36 },
        ],
        25: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i) {
              function o(t) {
                var e,
                  n = !1
                if (void 0 !== a && t instanceof a) (e = p(t)), (n = !0)
                else {
                  var r = u.keys(t),
                    i = r.length
                  e = new Array(2 * i)
                  for (var o = 0; i > o; ++o) {
                    var s = r[o]
                    ;(e[o] = t[s]), (e[o + i] = s)
                  }
                }
                this.constructor$(e), (this._isMap = n), this._init$(void 0, n ? -6 : -3)
              }
              function s(t) {
                var n,
                  s = r(t)
                return l(s)
                  ? ((n = s instanceof e ? s._then(e.props, void 0, void 0, void 0, void 0) : new o(s).promise()),
                    s instanceof e && n._propagateFrom(s, 2),
                    n)
                  : i('cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n')
              }
              var a,
                c = t('./util'),
                l = c.isObject,
                u = t('./es5')
              'function' == typeof Map && (a = Map)
              var p = (function () {
                function t(t, r) {
                  ;(this[e] = t), (this[e + n] = r), e++
                }
                var e = 0,
                  n = 0
                return function (r) {
                  ;(n = r.size), (e = 0)
                  var i = new Array(2 * r.size)
                  return r.forEach(t, i), i
                }
              })()
              c.inherits(o, n),
                (o.prototype._init = function () {}),
                (o.prototype._promiseFulfilled = function (t, e) {
                  if (((this._values[e] = t), ++this._totalResolved >= this._length)) {
                    var r
                    if (this._isMap)
                      r = (function (t) {
                        for (var e = new a(), n = (t.length / 2) | 0, r = 0; n > r; ++r) {
                          var i = t[n + r],
                            o = t[r]
                          e.set(i, o)
                        }
                        return e
                      })(this._values)
                    else {
                      r = {}
                      for (var i = this.length(), o = 0, s = this.length(); s > o; ++o)
                        r[this._values[o + i]] = this._values[o]
                    }
                    return this._resolve(r), !0
                  }
                  return !1
                }),
                (o.prototype.shouldCopyValues = function () {
                  return !1
                }),
                (o.prototype.getActualLength = function (t) {
                  return t >> 1
                }),
                (e.prototype.props = function () {
                  return s(this)
                }),
                (e.props = function (t) {
                  return s(t)
                })
            }
          },
          { './es5': 13, './util': 36 },
        ],
        26: [
          function (t, e, n) {
            'use strict'
            function i(t) {
              ;(this._capacity = t), (this._length = 0), (this._front = 0)
            }
            ;(i.prototype._willBeOverCapacity = function (t) {
              return this._capacity < t
            }),
              (i.prototype._pushOne = function (t) {
                var e = this.length()
                this._checkCapacity(e + 1), (this[(this._front + e) & (this._capacity - 1)] = t), (this._length = e + 1)
              }),
              (i.prototype.push = function (t, e, n) {
                var r = this.length() + 3
                if (this._willBeOverCapacity(r)) return this._pushOne(t), this._pushOne(e), void this._pushOne(n)
                var i = this._front + r - 3
                this._checkCapacity(r)
                var o = this._capacity - 1
                ;(this[(i + 0) & o] = t), (this[(i + 1) & o] = e), (this[(i + 2) & o] = n), (this._length = r)
              }),
              (i.prototype.shift = function () {
                var t = this._front,
                  e = this[t]
                return (this[t] = void 0), (this._front = (t + 1) & (this._capacity - 1)), this._length--, e
              }),
              (i.prototype.length = function () {
                return this._length
              }),
              (i.prototype._checkCapacity = function (t) {
                this._capacity < t && this._resizeTo(this._capacity << 1)
              }),
              (i.prototype._resizeTo = function (t) {
                var e = this._capacity
                ;(this._capacity = t),
                  (function (t, e, n, r, i) {
                    for (var o = 0; i > o; ++o) (n[o + r] = t[o + e]), (t[o + e] = void 0)
                  })(this, 0, this, e, (this._front + this._length) & (e - 1))
              }),
              (e.exports = i)
          },
          {},
        ],
        27: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i) {
              function o(t, o) {
                var c = r(t)
                if (c instanceof e) return a(c)
                if (null === (t = s.asArray(t)))
                  return i('expecting an array or an iterable object but got ' + s.classString(t))
                var l = new e(n)
                void 0 !== o && l._propagateFrom(o, 3)
                for (var u = l._fulfill, p = l._reject, h = 0, f = t.length; f > h; ++h) {
                  var _ = t[h]
                  ;(void 0 !== _ || h in t) && e.cast(_)._then(u, p, void 0, l, null)
                }
                return l
              }
              var s = t('./util'),
                a = function (t) {
                  return t.then(function (e) {
                    return o(e, t)
                  })
                }
              ;(e.race = function (t) {
                return o(t, void 0)
              }),
                (e.prototype.race = function () {
                  return o(this, void 0)
                })
            }
          },
          { './util': 36 },
        ],
        28: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i, o, s) {
              function a(t, n, r, i) {
                this.constructor$(t)
                var s = h()
                ;(this._fn = null === s ? n : f.domainBind(s, n)),
                  void 0 !== r && (r = e.resolve(r))._attachCancellationCallback(this),
                  (this._initialValue = r),
                  (this._currentCancellable = null),
                  (this._eachValues = i === o ? Array(this._length) : 0 === i ? null : void 0),
                  this._promise._captureStackTrace(),
                  this._init$(void 0, -5)
              }
              function c(t, e) {
                this.isFulfilled() ? e._resolve(t) : e._reject(t)
              }
              function l(t, e, n, i) {
                return 'function' != typeof e
                  ? r('expecting a function but got ' + f.classString(e))
                  : new a(t, e, n, i).promise()
              }
              function u(t) {
                ;(this.accum = t), this.array._gotAccum(t)
                var n = i(this.value, this.array._promise)
                return n instanceof e
                  ? ((this.array._currentCancellable = n), n._then(p, void 0, void 0, this, void 0))
                  : p.call(this, n)
              }
              function p(t) {
                var o,
                  n = this.array,
                  r = n._promise,
                  i = _(n._fn)
                r._pushContext(),
                  (o =
                    void 0 !== n._eachValues
                      ? i.call(r._boundValue(), t, this.index, this.length)
                      : i.call(r._boundValue(), this.accum, t, this.index, this.length)) instanceof e &&
                    (n._currentCancellable = o)
                var a = r._popContext()
                return s.checkForgottenReturns(o, a, void 0 !== n._eachValues ? 'Promise.each' : 'Promise.reduce', r), o
              }
              var h = e._getDomain,
                f = t('./util'),
                _ = f.tryCatch
              f.inherits(a, n),
                (a.prototype._gotAccum = function (t) {
                  void 0 !== this._eachValues && null !== this._eachValues && t !== o && this._eachValues.push(t)
                }),
                (a.prototype._eachComplete = function (t) {
                  return null !== this._eachValues && this._eachValues.push(t), this._eachValues
                }),
                (a.prototype._init = function () {}),
                (a.prototype._resolveEmptyArray = function () {
                  this._resolve(void 0 !== this._eachValues ? this._eachValues : this._initialValue)
                }),
                (a.prototype.shouldCopyValues = function () {
                  return !1
                }),
                (a.prototype._resolve = function (t) {
                  this._promise._resolveCallback(t), (this._values = null)
                }),
                (a.prototype._resultCancelled = function (t) {
                  return t === this._initialValue
                    ? this._cancel()
                    : void (
                        this._isResolved() ||
                        (this._resultCancelled$(),
                        this._currentCancellable instanceof e && this._currentCancellable.cancel(),
                        this._initialValue instanceof e && this._initialValue.cancel())
                      )
                }),
                (a.prototype._iterate = function (t) {
                  this._values = t
                  var n,
                    r,
                    i = t.length
                  if (
                    (void 0 !== this._initialValue
                      ? ((n = this._initialValue), (r = 0))
                      : ((n = e.resolve(t[0])), (r = 1)),
                    (this._currentCancellable = n),
                    !n.isRejected())
                  )
                    for (; i > r; ++r) {
                      var o = { accum: null, value: t[r], index: r, length: i, array: this }
                      n = n._then(u, void 0, void 0, o, void 0)
                    }
                  void 0 !== this._eachValues && (n = n._then(this._eachComplete, void 0, void 0, this, void 0)),
                    n._then(c, c, void 0, n, this)
                }),
                (e.prototype.reduce = function (t, e) {
                  return l(this, t, e, null)
                }),
                (e.reduce = function (t, e, n, r) {
                  return l(t, e, n, r)
                })
            }
          },
          { './util': 36 },
        ],
        29: [
          function (t, e, n) {
            'use strict'
            var r,
              i = t('./util'),
              s = i.getNativePromise()
            if (i.isNode && 'undefined' == typeof MutationObserver) {
              var a = global.setImmediate,
                c = process.nextTick
              r = i.isRecentNode
                ? function (t) {
                    a.call(global, t)
                  }
                : function (t) {
                    c.call(process, t)
                  }
            } else if ('function' == typeof s && 'function' == typeof s.resolve) {
              var l = s.resolve()
              r = function (t) {
                l.then(t)
              }
            } else
              r =
                'undefined' == typeof MutationObserver ||
                ('undefined' != typeof window && window.navigator && (window.navigator.standalone || window.cordova))
                  ? 'undefined' != typeof setImmediate
                    ? function (t) {
                        setImmediate(t)
                      }
                    : 'undefined' != typeof setTimeout
                    ? function (t) {
                        setTimeout(t, 0)
                      }
                    : function () {
                        throw new Error('No async scheduler available\n\n    See http://goo.gl/MqrFmX\n')
                      }
                  : (function () {
                      var t = document.createElement('div'),
                        e = { attributes: !0 },
                        n = !1,
                        r = document.createElement('div')
                      new MutationObserver(function () {
                        t.classList.toggle('foo'), (n = !1)
                      }).observe(r, e)
                      var o = function () {
                        n || ((n = !0), r.classList.toggle('foo'))
                      }
                      return function (n) {
                        var r = new MutationObserver(function () {
                          r.disconnect(), n()
                        })
                        r.observe(t, e), o()
                      }
                    })()
            e.exports = r
          },
          { './util': 36 },
        ],
        30: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r) {
              function i(t) {
                this.constructor$(t)
              }
              var o = e.PromiseInspection
              t('./util').inherits(i, n),
                (i.prototype._promiseResolved = function (t, e) {
                  return (
                    (this._values[t] = e), ++this._totalResolved >= this._length && (this._resolve(this._values), !0)
                  )
                }),
                (i.prototype._promiseFulfilled = function (t, e) {
                  var n = new o()
                  return (n._bitField = 33554432), (n._settledValueField = t), this._promiseResolved(e, n)
                }),
                (i.prototype._promiseRejected = function (t, e) {
                  var n = new o()
                  return (n._bitField = 16777216), (n._settledValueField = t), this._promiseResolved(e, n)
                }),
                (e.settle = function (t) {
                  return r.deprecated('.settle()', '.reflect()'), new i(t).promise()
                }),
                (e.prototype.settle = function () {
                  return e.settle(this)
                })
            }
          },
          { './util': 36 },
        ],
        31: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r) {
              function i(t) {
                this.constructor$(t), (this._howMany = 0), (this._unwrap = !1), (this._initialized = !1)
              }
              function o(t, e) {
                if ((0 | e) !== e || 0 > e) return r('expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n')
                var n = new i(t),
                  o = n.promise()
                return n.setHowMany(e), n.init(), o
              }
              var s = t('./util'),
                a = t('./errors').RangeError,
                c = t('./errors').AggregateError,
                l = s.isArray,
                u = {}
              s.inherits(i, n),
                (i.prototype._init = function () {
                  if (this._initialized) {
                    if (0 === this._howMany) return void this._resolve([])
                    this._init$(void 0, -5)
                    var t = l(this._values)
                    !this._isResolved() &&
                      t &&
                      this._howMany > this._canPossiblyFulfill() &&
                      this._reject(this._getRangeError(this.length()))
                  }
                }),
                (i.prototype.init = function () {
                  ;(this._initialized = !0), this._init()
                }),
                (i.prototype.setUnwrap = function () {
                  this._unwrap = !0
                }),
                (i.prototype.howMany = function () {
                  return this._howMany
                }),
                (i.prototype.setHowMany = function (t) {
                  this._howMany = t
                }),
                (i.prototype._promiseFulfilled = function (t) {
                  return (
                    this._addFulfilled(t),
                    this._fulfilled() === this.howMany() &&
                      ((this._values.length = this.howMany()),
                      1 === this.howMany() && this._unwrap
                        ? this._resolve(this._values[0])
                        : this._resolve(this._values),
                      !0)
                  )
                }),
                (i.prototype._promiseRejected = function (t) {
                  return this._addRejected(t), this._checkOutcome()
                }),
                (i.prototype._promiseCancelled = function () {
                  return this._values instanceof e || null == this._values
                    ? this._cancel()
                    : (this._addRejected(u), this._checkOutcome())
                }),
                (i.prototype._checkOutcome = function () {
                  if (this.howMany() > this._canPossiblyFulfill()) {
                    for (var t = new c(), e = this.length(); e < this._values.length; ++e)
                      this._values[e] !== u && t.push(this._values[e])
                    return t.length > 0 ? this._reject(t) : this._cancel(), !0
                  }
                  return !1
                }),
                (i.prototype._fulfilled = function () {
                  return this._totalResolved
                }),
                (i.prototype._rejected = function () {
                  return this._values.length - this.length()
                }),
                (i.prototype._addRejected = function (t) {
                  this._values.push(t)
                }),
                (i.prototype._addFulfilled = function (t) {
                  this._values[this._totalResolved++] = t
                }),
                (i.prototype._canPossiblyFulfill = function () {
                  return this.length() - this._rejected()
                }),
                (i.prototype._getRangeError = function (t) {
                  var e =
                    'Input array must contain at least ' + this._howMany + ' items but contains only ' + t + ' items'
                  return new a(e)
                }),
                (i.prototype._resolveEmptyArray = function () {
                  this._reject(this._getRangeError(0))
                }),
                (e.some = function (t, e) {
                  return o(t, e)
                }),
                (e.prototype.some = function (t) {
                  return o(this, t)
                }),
                (e._SomePromiseArray = i)
            }
          },
          { './errors': 12, './util': 36 },
        ],
        32: [
          function (t, e, n) {
            'use strict'
            e.exports = function (t) {
              function e(t) {
                void 0 !== t
                  ? ((t = t._target()),
                    (this._bitField = t._bitField),
                    (this._settledValueField = t._isFateSealed() ? t._settledValue() : void 0))
                  : ((this._bitField = 0), (this._settledValueField = void 0))
              }
              e.prototype._settledValue = function () {
                return this._settledValueField
              }
              var n = (e.prototype.value = function () {
                  if (!this.isFulfilled())
                    throw new TypeError(
                      'cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n',
                    )
                  return this._settledValue()
                }),
                r =
                  (e.prototype.error =
                  e.prototype.reason =
                    function () {
                      if (!this.isRejected())
                        throw new TypeError(
                          'cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n',
                        )
                      return this._settledValue()
                    }),
                i = (e.prototype.isFulfilled = function () {
                  return 0 != (33554432 & this._bitField)
                }),
                o = (e.prototype.isRejected = function () {
                  return 0 != (16777216 & this._bitField)
                }),
                s = (e.prototype.isPending = function () {
                  return 0 == (50397184 & this._bitField)
                }),
                a = (e.prototype.isResolved = function () {
                  return 0 != (50331648 & this._bitField)
                })
              ;(e.prototype.isCancelled = function () {
                return 0 != (8454144 & this._bitField)
              }),
                (t.prototype.__isCancelled = function () {
                  return 65536 == (65536 & this._bitField)
                }),
                (t.prototype._isCancelled = function () {
                  return this._target().__isCancelled()
                }),
                (t.prototype.isCancelled = function () {
                  return 0 != (8454144 & this._target()._bitField)
                }),
                (t.prototype.isPending = function () {
                  return s.call(this._target())
                }),
                (t.prototype.isRejected = function () {
                  return o.call(this._target())
                }),
                (t.prototype.isFulfilled = function () {
                  return i.call(this._target())
                }),
                (t.prototype.isResolved = function () {
                  return a.call(this._target())
                }),
                (t.prototype.value = function () {
                  return n.call(this._target())
                }),
                (t.prototype.reason = function () {
                  var t = this._target()
                  return t._unsetRejectionIsUnhandled(), r.call(t)
                }),
                (t.prototype._value = function () {
                  return this._settledValue()
                }),
                (t.prototype._reason = function () {
                  return this._unsetRejectionIsUnhandled(), this._settledValue()
                }),
                (t.PromiseInspection = e)
            }
          },
          {},
        ],
        33: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n) {
              function o(t) {
                try {
                  return (function (t) {
                    return t.then
                  })(t)
                } catch (e) {
                  return (l.e = e), l
                }
              }
              function a(t, r, i) {
                var a = new e(n),
                  u = a
                i && i._pushContext(), a._captureStackTrace(), i && i._popContext()
                var p = !0,
                  h = c.tryCatch(r).call(
                    t,
                    function (t) {
                      a && (a._resolveCallback(t), (a = null))
                    },
                    function (t) {
                      a && (a._rejectCallback(t, p, !0), (a = null))
                    },
                  )
                return (p = !1), a && h === l && (a._rejectCallback(h.e, !0, !0), (a = null)), u
              }
              var c = t('./util'),
                l = c.errorObj,
                u = c.isObject,
                p = {}.hasOwnProperty
              return function (t, r) {
                if (u(t)) {
                  if (t instanceof e) return t
                  var i = o(t)
                  if (i === l) {
                    r && r._pushContext()
                    var c = e.reject(i.e)
                    return r && r._popContext(), c
                  }
                  if ('function' == typeof i) {
                    if (
                      (function (t) {
                        try {
                          return p.call(t, '_promise0')
                        } catch (e) {
                          return !1
                        }
                      })(t)
                    ) {
                      c = new e(n)
                      return t._then(c._fulfill, c._reject, void 0, c, null), c
                    }
                    return a(t, i, r)
                  }
                }
                return t
              }
            }
          },
          { './util': 36 },
        ],
        34: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r) {
              function i(t) {
                this.handle = t
              }
              function o(t) {
                return clearTimeout(this.handle), t
              }
              function s(t) {
                throw (clearTimeout(this.handle), t)
              }
              var a = t('./util'),
                c = e.TimeoutError
              i.prototype._resultCancelled = function () {
                clearTimeout(this.handle)
              }
              var l = function (t) {
                  return u(+this).thenReturn(t)
                },
                u = (e.delay = function (t, o) {
                  var s, a
                  return (
                    void 0 !== o
                      ? ((s = e.resolve(o)._then(l, null, null, t, void 0)),
                        r.cancellation() && o instanceof e && s._setOnCancel(o))
                      : ((s = new e(n)),
                        (a = setTimeout(function () {
                          s._fulfill()
                        }, +t)),
                        r.cancellation() && s._setOnCancel(new i(a)),
                        s._captureStackTrace()),
                    s._setAsyncGuaranteed(),
                    s
                  )
                })
              e.prototype.delay = function (t) {
                return u(t, this)
              }
              var p = function (t, e, n) {
                var r
                ;(r = 'string' != typeof e ? (e instanceof Error ? e : new c('operation timed out')) : new c(e)),
                  a.markAsOriginatingFromRejection(r),
                  t._attachExtraTrace(r),
                  t._reject(r),
                  null != n && n.cancel()
              }
              e.prototype.timeout = function (t, e) {
                t = +t
                var n,
                  a,
                  c = new i(
                    setTimeout(function () {
                      n.isPending() && p(n, e, a)
                    }, t),
                  )
                return (
                  r.cancellation()
                    ? ((a = this.then()), (n = a._then(o, s, void 0, c, void 0))._setOnCancel(c))
                    : (n = this._then(o, s, void 0, c, void 0)),
                  n
                )
              }
            }
          },
          { './util': 36 },
        ],
        35: [
          function (t, e, n) {
            'use strict'
            e.exports = function (e, n, r, i, o, s) {
              function a(t) {
                setTimeout(function () {
                  throw t
                }, 0)
              }
              function l(t, n) {
                var s = 0,
                  l = t.length,
                  u = new e(o)
                return (
                  (function i() {
                    if (s >= l) return u._fulfill()
                    var o = (function (t) {
                      var e = r(t)
                      return (
                        e !== t &&
                          'function' == typeof t._isDisposable &&
                          'function' == typeof t._getDisposer &&
                          t._isDisposable() &&
                          e._setDisposable(t._getDisposer()),
                        e
                      )
                    })(t[s++])
                    if (o instanceof e && o._isDisposable()) {
                      try {
                        o = r(o._getDisposer().tryDispose(n), t.promise)
                      } catch (p) {
                        return a(p)
                      }
                      if (o instanceof e) return o._then(i, a, null, null, null)
                    }
                    i()
                  })(),
                  u
                )
              }
              function u(t, e, n) {
                ;(this._data = t), (this._promise = e), (this._context = n)
              }
              function p(t, e, n) {
                this.constructor$(t, e, n)
              }
              function h(t) {
                return u.isDisposer(t) ? (this.resources[this.index]._setDisposable(t), t.promise()) : t
              }
              function f(t) {
                ;(this.length = t), (this.promise = null), (this[t - 1] = null)
              }
              var _ = t('./util'),
                d = t('./errors').TypeError,
                v = t('./util').inherits,
                y = _.errorObj,
                m = _.tryCatch,
                g = {}
              ;(u.prototype.data = function () {
                return this._data
              }),
                (u.prototype.promise = function () {
                  return this._promise
                }),
                (u.prototype.resource = function () {
                  return this.promise().isFulfilled() ? this.promise().value() : g
                }),
                (u.prototype.tryDispose = function (t) {
                  var e = this.resource(),
                    n = this._context
                  void 0 !== n && n._pushContext()
                  var r = e !== g ? this.doDispose(e, t) : null
                  return void 0 !== n && n._popContext(), this._promise._unsetDisposable(), (this._data = null), r
                }),
                (u.isDisposer = function (t) {
                  return null != t && 'function' == typeof t.resource && 'function' == typeof t.tryDispose
                }),
                v(p, u),
                (p.prototype.doDispose = function (t, e) {
                  return this.data().call(t, t, e)
                }),
                (f.prototype._resultCancelled = function () {
                  for (var t = this.length, n = 0; t > n; ++n) {
                    var r = this[n]
                    r instanceof e && r.cancel()
                  }
                }),
                (e.using = function () {
                  var t = arguments.length
                  if (2 > t) return n('you must pass at least 2 arguments to Promise.using')
                  var i = arguments[t - 1]
                  if ('function' != typeof i) return n('expecting a function but got ' + _.classString(i))
                  var o,
                    a = !0
                  2 === t && Array.isArray(arguments[0])
                    ? ((t = (o = arguments[0]).length), (a = !1))
                    : ((o = arguments), t--)
                  for (var c = new f(t), p = 0; t > p; ++p) {
                    var d = o[p]
                    if (u.isDisposer(d)) {
                      var v = d
                      ;(d = d.promise())._setDisposable(v)
                    } else {
                      var g = r(d)
                      g instanceof e && (d = g._then(h, null, null, { resources: c, index: p }, void 0))
                    }
                    c[p] = d
                  }
                  var b = new Array(c.length)
                  for (p = 0; p < b.length; ++p) b[p] = e.resolve(c[p]).reflect()
                  var w = e.all(b).then(function (t) {
                      for (var e = 0; e < t.length; ++e) {
                        var n = t[e]
                        if (n.isRejected()) return (y.e = n.error()), y
                        if (!n.isFulfilled()) return void w.cancel()
                        t[e] = n.value()
                      }
                      C._pushContext(), (i = m(i))
                      var r = a ? i.apply(void 0, t) : i(t),
                        o = C._popContext()
                      return s.checkForgottenReturns(r, o, 'Promise.using', C), r
                    }),
                    C = w.lastly(function () {
                      var t = new e.PromiseInspection(w)
                      return l(c, t)
                    })
                  return (c.promise = C), C._setOnCancel(c), C
                }),
                (e.prototype._setDisposable = function (t) {
                  ;(this._bitField = 131072 | this._bitField), (this._disposer = t)
                }),
                (e.prototype._isDisposable = function () {
                  return (131072 & this._bitField) > 0
                }),
                (e.prototype._getDisposer = function () {
                  return this._disposer
                }),
                (e.prototype._unsetDisposable = function () {
                  ;(this._bitField = -131073 & this._bitField), (this._disposer = void 0)
                }),
                (e.prototype.disposer = function (t) {
                  if ('function' == typeof t) return new p(t, this, i())
                  throw new d()
                })
            }
          },
          { './errors': 12, './util': 36 },
        ],
        36: [
          function (t, e, n) {
            'use strict'
            function r() {
              try {
                var t = P
                return (P = null), t.apply(this, arguments)
              } catch (e) {
                return (T.e = e), T
              }
            }
            function o(t) {
              return null == t || !0 === t || !1 === t || 'string' == typeof t || 'number' == typeof t
            }
            function u(t, e, n) {
              if (o(t)) return t
              var r = { value: n, configurable: !0, enumerable: !1, writable: !0 }
              return F.defineProperty(t, e, r), t
            }
            function v(t) {
              try {
                return t + ''
              } catch (e) {
                return '[no string representation]'
              }
            }
            function y(t) {
              return (
                t instanceof Error ||
                (null !== t && 'object' == typeof t && 'string' == typeof t.message && 'string' == typeof t.name)
              )
            }
            function b(t) {
              return y(t) && F.propertyIsWritable(t, 'stack')
            }
            function w(t) {
              return {}.toString.call(t)
            }
            var P,
              F = t('./es5'),
              x = 'undefined' == typeof navigator,
              T = { e: {} },
              R =
                'undefined' != typeof self
                  ? self
                  : 'undefined' != typeof window
                  ? window
                  : 'undefined' != typeof global
                  ? global
                  : void 0 !== this
                  ? this
                  : null,
              O = (function () {
                var t = [Array.prototype, Object.prototype, Function.prototype],
                  e = function (_e2) {
                    for (var n = 0; n < t.length; ++n) if (t[n] === _e2) return !0
                    return !1
                  }
                if (F.isES5) {
                  var n = Object.getOwnPropertyNames
                  return function (t) {
                    for (var r = [], i = Object.create(null); null != t && !e(t); ) {
                      var o
                      try {
                        o = n(t)
                      } catch (s) {
                        return r
                      }
                      for (var a = 0; a < o.length; ++a) {
                        var c = o[a]
                        if (!i[c]) {
                          i[c] = !0
                          var l = Object.getOwnPropertyDescriptor(t, c)
                          null != l && null == l.get && null == l.set && r.push(c)
                        }
                      }
                      t = F.getPrototypeOf(t)
                    }
                    return r
                  }
                }
                var r = {}.hasOwnProperty
                return function (n) {
                  if (e(n)) return []
                  var i = []
                  t: for (var o in n)
                    if (r.call(n, o)) i.push(o)
                    else {
                      for (var s = 0; s < t.length; ++s) if (r.call(t[s], o)) continue t
                      i.push(o)
                    }
                  return i
                }
              })(),
              A = /this\s*\.\s*\S+\s*=/,
              D = /^[a-z$_][a-z$_0-9]*$/i,
              V =
                'stack' in new Error()
                  ? function (t) {
                      return b(t) ? t : new Error(v(t))
                    }
                  : function (t) {
                      if (b(t)) return t
                      try {
                        throw new Error(v(t))
                      } catch (e) {
                        return e
                      }
                    },
              I = function (t) {
                return F.isArray(t) ? t : null
              }
            if ('undefined' != typeof Symbol && Symbol.iterator) {
              var L =
                'function' == typeof Array.from
                  ? function (t) {
                      return Array.from(t)
                    }
                  : function (t) {
                      for (var e, n = [], r = t[Symbol.iterator](); !(e = r.next()).done; ) n.push(e.value)
                      return n
                    }
              I = function (t) {
                return F.isArray(t) ? t : null != t && 'function' == typeof t[Symbol.iterator] ? L(t) : null
              }
            }
            var H = 'undefined' != typeof process && '[object process]' === w(process).toLowerCase(),
              N = 'undefined' != typeof process && void 0 !== process.env,
              B = {
                isClass: function (t) {
                  try {
                    if ('function' == typeof t) {
                      var e = F.names(t.prototype),
                        n = F.isES5 && e.length > 1,
                        r = e.length > 0 && !(1 === e.length && 'constructor' === e[0]),
                        i = A.test(t + '') && F.names(t).length > 0
                      if (n || r || i) return !0
                    }
                    return !1
                  } catch (o) {
                    return !1
                  }
                },
                isIdentifier: function (t) {
                  return D.test(t)
                },
                inheritedDataKeys: O,
                getDataPropertyOrDefault: function (t, e, n) {
                  if (!F.isES5) return {}.hasOwnProperty.call(t, e) ? t[e] : void 0
                  var r = Object.getOwnPropertyDescriptor(t, e)
                  return null != r ? (null == r.get && null == r.set ? r.value : n) : void 0
                },
                thrower: function (t) {
                  throw t
                },
                isArray: F.isArray,
                asArray: I,
                notEnumerableProp: u,
                isPrimitive: o,
                isObject: function (t) {
                  return 'function' == typeof t || ('object' == typeof t && null !== t)
                },
                isError: y,
                canEvaluate: x,
                errorObj: T,
                tryCatch: function (t) {
                  return (P = t), r
                },
                inherits: function (t, e) {
                  function n() {
                    for (var n in ((this.constructor = t), (this.constructor$ = e), e.prototype))
                      r.call(e.prototype, n) && '$' !== n.charAt(n.length - 1) && (this[n + '$'] = e.prototype[n])
                  }
                  var r = {}.hasOwnProperty
                  return (n.prototype = e.prototype), (t.prototype = new n()), t.prototype
                },
                withAppended: function (t, e) {
                  var n,
                    r = t.length,
                    i = new Array(r + 1)
                  for (n = 0; r > n; ++n) i[n] = t[n]
                  return (i[n] = e), i
                },
                maybeWrapAsError: function (t) {
                  return o(t) ? new Error(v(t)) : t
                },
                toFastProperties: function (t) {
                  function e() {}
                  e.prototype = t
                  for (var n = 8; n--; ) new e()
                  return t
                },
                filledRange: function (t, e, n) {
                  for (var r = new Array(t), i = 0; t > i; ++i) r[i] = e + i + n
                  return r
                },
                toString: v,
                canAttachTrace: b,
                ensureErrorObject: V,
                originatesFromRejection: function (t) {
                  return (
                    null != t && (t instanceof Error.__BluebirdErrorTypes__.OperationalError || !0 === t.isOperational)
                  )
                },
                markAsOriginatingFromRejection: function (t) {
                  try {
                    u(t, 'isOperational', !0)
                  } catch (e) {}
                },
                classString: w,
                copyDescriptors: function (t, e, n) {
                  for (var r = F.names(t), i = 0; i < r.length; ++i) {
                    var o = r[i]
                    if (n(o))
                      try {
                        F.defineProperty(e, o, F.getDescriptor(t, o))
                      } catch (s) {}
                  }
                },
                hasDevTools: 'undefined' != typeof chrome && chrome && 'function' == typeof chrome.loadTimes,
                isNode: H,
                hasEnvVariables: N,
                env: function (t) {
                  return N ? process.env[t] : void 0
                },
                global: R,
                getNativePromise: function () {
                  if ('function' == typeof Promise)
                    try {
                      var t = new Promise(function () {})
                      if ('[object Promise]' === {}.toString.call(t)) return Promise
                    } catch (e) {}
                },
                domainBind: function (t, e) {
                  return t.bind(e)
                },
              }
            ;(B.isRecentNode =
              B.isNode &&
              (function () {
                var t = process.versions.node.split('.').map(Number)
                return (0 === t[0] && t[1] > 10) || t[0] > 0
              })()),
              B.isNode && B.toFastProperties(process)
            try {
              throw new Error()
            } catch (U) {
              B.lastLineError = U
            }
            e.exports = B
          },
          { './es5': 13 },
        ],
      },
      {},
      [4],
    )(4)
  }),
  'undefined' != typeof window && null !== window
    ? (window.P = window.Promise)
    : 'undefined' != typeof self && null !== self && (self.P = self.Promise),
  (function (self) {
    'use strict'
    if (!self.fetch) {
      var support_searchParams = 'URLSearchParams' in self,
        support_iterable = 'Symbol' in self && 'iterator' in Symbol,
        support_blob =
          'FileReader' in self &&
          'Blob' in self &&
          (function () {
            try {
              return new Blob(), !0
            } catch (e) {
              return !1
            }
          })(),
        support_formData = 'FormData' in self,
        support_arrayBuffer = 'ArrayBuffer' in self
      if (support_arrayBuffer)
        var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]',
          ],
          isDataView = function (obj) {
            return obj && DataView.prototype.isPrototypeOf(obj)
          },
          isArrayBufferView =
            ArrayBuffer.isView ||
            function (obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
            }
      ;(Headers.prototype.append = function (name, value) {
        ;(name = normalizeName(name)), (value = normalizeValue(value))
        var oldValue = this.map[name]
        this.map[name] = oldValue ? oldValue + ',' + value : value
      }),
        (Headers.prototype.delete = function (name) {
          delete this.map[normalizeName(name)]
        }),
        (Headers.prototype.get = function (name) {
          return (name = normalizeName(name)), this.has(name) ? this.map[name] : null
        }),
        (Headers.prototype.has = function (name) {
          return this.map.hasOwnProperty(normalizeName(name))
        }),
        (Headers.prototype.set = function (name, value) {
          this.map[normalizeName(name)] = normalizeValue(value)
        }),
        (Headers.prototype.forEach = function (callback, thisArg) {
          for (var name in this.map) this.map.hasOwnProperty(name) && callback.call(thisArg, this.map[name], name, this)
        }),
        (Headers.prototype.keys = function () {
          var items = []
          return (
            this.forEach(function (value, name) {
              items.push(name)
            }),
            iteratorFor(items)
          )
        }),
        (Headers.prototype.values = function () {
          var items = []
          return (
            this.forEach(function (value) {
              items.push(value)
            }),
            iteratorFor(items)
          )
        }),
        (Headers.prototype.entries = function () {
          var items = []
          return (
            this.forEach(function (value, name) {
              items.push([name, value])
            }),
            iteratorFor(items)
          )
        }),
        support_iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries)
      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
      ;(Request.prototype.clone = function () {
        return new Request(this, { body: this._bodyInit })
      }),
        Body.call(Request.prototype),
        Body.call(Response.prototype),
        (Response.prototype.clone = function () {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url,
          })
        }),
        (Response.error = function () {
          var response = new Response(null, { status: 0, statusText: '' })
          return (response.type = 'error'), response
        })
      var redirectStatuses = [301, 302, 303, 307, 308]
      ;(Response.redirect = function (url, status) {
        if (-1 === redirectStatuses.indexOf(status)) throw new RangeError('Invalid status code')
        return new Response(null, { status, headers: { location: url } })
      }),
        (self.Headers = Headers),
        (self.Request = Request),
        (self.Response = Response),
        (self.fetch = function (input, init) {
          return new Promise(function (resolve, reject) {
            var request = new Request(input, init),
              xhr = new XMLHttpRequest()
            ;(xhr.onload = function () {
              var rawHeaders,
                headers,
                options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers:
                    ((rawHeaders = xhr.getAllResponseHeaders() || ''),
                    (headers = new Headers()),
                    rawHeaders
                      .replace(/\r?\n[\t ]+/g, ' ')
                      .split(/\r?\n/)
                      .forEach(function (line) {
                        var parts = line.split(':'),
                          key = parts.shift().trim()
                        if (key) {
                          var value = parts.join(':').trim()
                          headers.append(key, value)
                        }
                      }),
                    headers),
                }
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
              var body = 'response' in xhr ? xhr.response : xhr.responseText
              resolve(new Response(body, options))
            }),
              (xhr.onerror = function () {
                reject(new TypeError('Network request failed'))
              }),
              (xhr.ontimeout = function () {
                reject(new TypeError('Network request failed'))
              }),
              xhr.open(request.method, request.url, !0),
              'include' === request.credentials
                ? (xhr.withCredentials = !0)
                : 'omit' === request.credentials && (xhr.withCredentials = !1),
              'responseType' in xhr && support_blob && (xhr.responseType = 'blob'),
              request.headers.forEach(function (value, name) {
                xhr.setRequestHeader(name, value)
              }),
              xhr.send(void 0 === request._bodyInit ? null : request._bodyInit)
          })
        }),
        (self.fetch.polyfill = !0)
    }
    function normalizeName(name) {
      if (('string' != typeof name && (name = String(name)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)))
        throw new TypeError('Invalid character in header field name')
      return name.toLowerCase()
    }
    function normalizeValue(value) {
      return 'string' != typeof value && (value = String(value)), value
    }
    function iteratorFor(items) {
      var iterator = {
        next: function () {
          var value = items.shift()
          return { done: void 0 === value, value }
        },
      }
      return (
        support_iterable &&
          (iterator[Symbol.iterator] = function () {
            return iterator
          }),
        iterator
      )
    }
    function Headers(headers) {
      ;(this.map = {}),
        headers instanceof Headers
          ? headers.forEach(function (value, name) {
              this.append(name, value)
            }, this)
          : Array.isArray(headers)
          ? headers.forEach(function (header) {
              this.append(header[0], header[1])
            }, this)
          : headers &&
            Object.getOwnPropertyNames(headers).forEach(function (name) {
              this.append(name, headers[name])
            }, this)
    }
    function consumed(body) {
      if (body.bodyUsed) return Promise.reject(new TypeError('Already read'))
      body.bodyUsed = !0
    }
    function fileReaderReady(reader) {
      return new Promise(function (resolve, reject) {
        ;(reader.onload = function () {
          resolve(reader.result)
        }),
          (reader.onerror = function () {
            reject(reader.error)
          })
      })
    }
    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader(),
        promise = fileReaderReady(reader)
      return reader.readAsArrayBuffer(blob), promise
    }
    function bufferClone(buf) {
      if (buf.slice) return buf.slice(0)
      var view = new Uint8Array(buf.byteLength)
      return view.set(new Uint8Array(buf)), view.buffer
    }
    function Body() {
      return (
        (this.bodyUsed = !1),
        (this._initBody = function (body) {
          if (((this._bodyInit = body), body))
            if ('string' == typeof body) this._bodyText = body
            else if (support_blob && Blob.prototype.isPrototypeOf(body)) this._bodyBlob = body
            else if (support_formData && FormData.prototype.isPrototypeOf(body)) this._bodyFormData = body
            else if (support_searchParams && URLSearchParams.prototype.isPrototypeOf(body))
              this._bodyText = body.toString()
            else if (support_arrayBuffer && support_blob && isDataView(body))
              (this._bodyArrayBuffer = bufferClone(body.buffer)), (this._bodyInit = new Blob([this._bodyArrayBuffer]))
            else {
              if (!support_arrayBuffer || (!ArrayBuffer.prototype.isPrototypeOf(body) && !isArrayBufferView(body)))
                throw new Error('unsupported BodyInit type')
              this._bodyArrayBuffer = bufferClone(body)
            }
          else this._bodyText = ''
          this.headers.get('content-type') ||
            ('string' == typeof body
              ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
              : this._bodyBlob && this._bodyBlob.type
              ? this.headers.set('content-type', this._bodyBlob.type)
              : support_searchParams &&
                URLSearchParams.prototype.isPrototypeOf(body) &&
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8'))
        }),
        support_blob &&
          ((this.blob = function () {
            var rejected = consumed(this)
            if (rejected) return rejected
            if (this._bodyBlob) return Promise.resolve(this._bodyBlob)
            if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]))
            if (this._bodyFormData) throw new Error('could not read FormData body as blob')
            return Promise.resolve(new Blob([this._bodyText]))
          }),
          (this.arrayBuffer = function () {
            return this._bodyArrayBuffer
              ? consumed(this) || Promise.resolve(this._bodyArrayBuffer)
              : this.blob().then(readBlobAsArrayBuffer)
          })),
        (this.text = function () {
          var blob,
            reader,
            promise,
            rejected = consumed(this)
          if (rejected) return rejected
          if (this._bodyBlob)
            return (
              (blob = this._bodyBlob),
              (reader = new FileReader()),
              (promise = fileReaderReady(reader)),
              reader.readAsText(blob),
              promise
            )
          if (this._bodyArrayBuffer)
            return Promise.resolve(
              (function (buf) {
                for (var view = new Uint8Array(buf), chars = new Array(view.length), i = 0; i < view.length; i++)
                  chars[i] = String.fromCharCode(view[i])
                return chars.join('')
              })(this._bodyArrayBuffer),
            )
          if (this._bodyFormData) throw new Error('could not read FormData body as text')
          return Promise.resolve(this._bodyText)
        }),
        support_formData &&
          (this.formData = function () {
            return this.text().then(decode)
          }),
        (this.json = function () {
          return this.text().then(JSON.parse)
        }),
        this
      )
    }
    function Request(input, options) {
      var method,
        upcased,
        body = (options = options || {}).body
      if (input instanceof Request) {
        if (input.bodyUsed) throw new TypeError('Already read')
        ;(this.url = input.url),
          (this.credentials = input.credentials),
          options.headers || (this.headers = new Headers(input.headers)),
          (this.method = input.method),
          (this.mode = input.mode),
          body || null == input._bodyInit || ((body = input._bodyInit), (input.bodyUsed = !0))
      } else this.url = String(input)
      if (
        ((this.credentials = options.credentials || this.credentials || 'omit'),
        (!options.headers && this.headers) || (this.headers = new Headers(options.headers)),
        (this.method =
          ((method = options.method || this.method || 'GET'),
          (upcased = method.toUpperCase()),
          methods.indexOf(upcased) > -1 ? upcased : method)),
        (this.mode = options.mode || this.mode || null),
        (this.referrer = null),
        ('GET' === this.method || 'HEAD' === this.method) && body)
      )
        throw new TypeError('Body not allowed for GET or HEAD requests')
      this._initBody(body)
    }
    function decode(body) {
      var form = new FormData()
      return (
        body
          .trim()
          .split('&')
          .forEach(function (bytes) {
            if (bytes) {
              var split = bytes.split('='),
                name = split.shift().replace(/\+/g, ' '),
                value = split.join('=').replace(/\+/g, ' ')
              form.append(decodeURIComponent(name), decodeURIComponent(value))
            }
          }),
        form
      )
    }
    function Response(bodyInit, options) {
      options || (options = {}),
        (this.type = 'default'),
        (this.status = void 0 === options.status ? 200 : options.status),
        (this.ok = this.status >= 200 && this.status < 300),
        (this.statusText = 'statusText' in options ? options.statusText : 'OK'),
        (this.headers = new Headers(options.headers)),
        (this.url = options.url || ''),
        this._initBody(bodyInit)
    }
  })('undefined' != typeof self ? self : this),
  (function () {
    var h
    function l(a) {
      var c = 0
      return function () {
        return c < a.length ? { done: !1, value: a[c++] } : { done: !0 }
      }
    }
    var m =
      'function' == typeof Object.defineProperties
        ? Object.defineProperty
        : function (a, c, b) {
            return a == Array.prototype || a == Object.prototype || (a[c] = b.value), a
          }
    var w,
      p = (function (a) {
        a = [
          'object' == typeof globalThis && globalThis,
          a,
          'object' == typeof window && window,
          'object' == typeof self && self,
          'object' == typeof global && global,
        ]
        for (var c = 0; c < a.length; ++c) {
          var b = a[c]
          if (b && b.Math == Math) return b
        }
        throw Error('Cannot find global object')
      })(this)
    function r(a, c) {
      if (c) {
        for (var b = p, d = a.split('.'), e = 0; e < d.length - 1; e++) {
          var f = d[e]
          f in b || (b[f] = {}), (b = b[f])
        }
        ;(f = c((e = b[(d = d[d.length - 1])]))) != e &&
          null != f &&
          m(b, d, { configurable: !0, writable: !0, value: f })
      }
    }
    function u(a) {
      return (
        ((a = { next: a })[Symbol.iterator] = function () {
          return this
        }),
        a
      )
    }
    function v(a) {
      var c = 'undefined' != typeof Symbol && Symbol.iterator && a[Symbol.iterator]
      return c ? c.call(a) : { next: l(a) }
    }
    if (
      (r('Symbol', function (a) {
        function b(e, f) {
          ;(this.o = e), m(this, 'description', { configurable: !0, writable: !0, value: f })
        }
        if (a) return a
        b.prototype.toString = function () {
          return this.o
        }
        var d = 0
        return function c(e) {
          if (this instanceof c) throw new TypeError('Symbol is not a constructor')
          return new b('jscomp_symbol_' + (e || '') + '_' + d++, e)
        }
      }),
      r('Symbol.iterator', function (a) {
        if (a) return a
        a = Symbol('Symbol.iterator')
        for (
          var c =
              'Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array'.split(
                ' ',
              ),
            b = 0;
          b < c.length;
          b++
        ) {
          var d = p[c[b]]
          'function' == typeof d &&
            'function' != typeof d.prototype[a] &&
            m(d.prototype, a, {
              configurable: !0,
              writable: !0,
              value: function () {
                return u(l(this))
              },
            })
        }
        return a
      }),
      'function' == typeof Object.setPrototypeOf)
    )
      w = Object.setPrototypeOf
    else {
      var y
      a: {
        var A = {}
        try {
          ;(A.__proto__ = { u: !0 }), (y = A.u)
          break a
        } catch (a) {}
        y = !1
      }
      w = y
        ? function (a, c) {
            if (((a.__proto__ = c), a.__proto__ !== c)) throw new TypeError(a + ' is not extensible')
            return a
          }
        : null
    }
    var B = w
    function C() {
      ;(this.h = !1), (this.f = null), (this.m = void 0), (this.b = 1), (this.l = this.v = 0), (this.g = null)
    }
    function D(a) {
      if (a.h) throw new TypeError('Generator is already running')
      a.h = !0
    }
    function E(a, c) {
      return (a.b = 3), { value: c }
    }
    function F(a) {
      ;(this.a = new C()), (this.B = a)
    }
    function G(a, c, b, d) {
      try {
        var e = c.call(a.a.f, b)
        if (!(e instanceof Object)) throw new TypeError('Iterator result ' + e + ' is not an object')
        if (!e.done) return (a.a.h = !1), e
        var f = e.value
      } catch (g) {
        return (a.a.f = null), a.a.j(g), H(a)
      }
      return (a.a.f = null), d.call(a.a, f), H(a)
    }
    function H(a) {
      for (; a.a.b; )
        try {
          var c = a.B(a.a)
          if (c) return (a.a.h = !1), { value: c.value, done: !1 }
        } catch (b) {
          ;(a.a.m = void 0), a.a.j(b)
        }
      if (((a.a.h = !1), a.a.g)) {
        if (((c = a.a.g), (a.a.g = null), c.A)) throw c.w
        return { value: c.return, done: !0 }
      }
      return { value: void 0, done: !0 }
    }
    function J(a) {
      ;(this.next = function (c) {
        return a.i(c)
      }),
        (this.throw = function (c) {
          return a.j(c)
        }),
        (this.return = function (c) {
          return (function (a, c) {
            D(a.a)
            var b = a.a.f
            return b
              ? G(
                  a,
                  'return' in b
                    ? b.return
                    : function (d) {
                        return { value: d, done: !0 }
                      },
                  c,
                  a.a.return,
                )
              : (a.a.return(c), H(a))
          })(a, c)
        }),
        (this[Symbol.iterator] = function () {
          return this
        })
    }
    function K(a, c) {
      var b = new J(new F(c))
      return B && B(b, a.prototype), b
    }
    if (
      ((C.prototype.i = function (a) {
        this.m = a
      }),
      (C.prototype.j = function (a) {
        ;(this.g = { w: a, A: !0 }), (this.b = this.v || this.l)
      }),
      (C.prototype.return = function (a) {
        ;(this.g = { return: a }), (this.b = this.l)
      }),
      (F.prototype.i = function (a) {
        return D(this.a), this.a.f ? G(this, this.a.f.next, a, this.a.i) : (this.a.i(a), H(this))
      }),
      (F.prototype.j = function (a) {
        return D(this.a), this.a.f ? G(this, this.a.f.throw, a, this.a.i) : (this.a.j(a), H(this))
      }),
      'undefined' != typeof Blob && ('undefined' == typeof FormData || !FormData.prototype.keys))
    ) {
      var L = function (a, c) {
          for (var b = 0; b < a.length; b++) c(a[b])
        },
        M = function (a, c, b) {
          return c instanceof Blob
            ? [String(a), c, void 0 !== b ? b + '' : 'string' == typeof c.name ? c.name : 'blob']
            : [String(a), String(c)]
        },
        N = function (a, c) {
          if (a.length < c) throw new TypeError(c + ' argument required, but only ' + a.length + ' present.')
        },
        O = function (a) {
          var c = v(a)
          a = c.next().value
          var b = c.next().value
          return (
            (c = c.next().value),
            b instanceof Blob && (b = new File([b], c, { type: b.type, lastModified: b.lastModified })),
            [a, b]
          )
        },
        P =
          'object' == typeof globalThis
            ? globalThis
            : 'object' == typeof window
            ? window
            : 'object' == typeof self
            ? self
            : this,
        Q = P.FormData,
        R = P.XMLHttpRequest && P.XMLHttpRequest.prototype.send,
        S = P.Request && P.fetch,
        T = P.navigator && P.navigator.sendBeacon,
        U = P.Element && P.Element.prototype,
        V = P.Symbol && Symbol.toStringTag
      V &&
        (Blob.prototype[V] || (Blob.prototype[V] = 'Blob'),
        'File' in P && !File.prototype[V] && (File.prototype[V] = 'File'))
      try {
        new File([], '')
      } catch (a) {
        P.File = function (c, b, d) {
          return (
            (c = new Blob(c, d)),
            (d = d && void 0 !== d.lastModified ? new Date(d.lastModified) : new Date()),
            Object.defineProperties(c, {
              name: { value: b },
              lastModifiedDate: { value: d },
              lastModified: { value: +d },
              toString: {
                value: function () {
                  return '[object File]'
                },
              },
            }),
            V && Object.defineProperty(c, V, { value: 'File' }),
            c
          )
        }
      }
      var W = function (a) {
        this.c = []
        var c = this
        a &&
          L(a.elements, function (b) {
            if (
              b.name &&
              !b.disabled &&
              'submit' !== b.type &&
              'button' !== b.type &&
              !b.matches('form fieldset[disabled] *')
            )
              if ('file' === b.type) {
                var d = b.files && b.files.length ? b.files : [new File([], '', { type: 'application/octet-stream' })]
                L(d, function (e) {
                  c.append(b.name, e)
                })
              } else
                'select-multiple' === b.type || 'select-one' === b.type
                  ? L(b.options, function (e) {
                      !e.disabled && e.selected && c.append(b.name, e.value)
                    })
                  : 'checkbox' === b.type || 'radio' === b.type
                  ? b.checked && c.append(b.name, b.value)
                  : ((d = 'textarea' === b.type ? b.value.replace(/\r\n/g, '\n').replace(/\n/g, '\r\n') : b.value),
                    c.append(b.name, d))
          })
      }
      if (
        (((h = W.prototype).append = function (a, c, b) {
          N(arguments, 2), this.c.push(M(a, c, b))
        }),
        (h.delete = function (a) {
          N(arguments, 1)
          var c = []
          ;(a = String(a)),
            L(this.c, function (b) {
              b[0] !== a && c.push(b)
            }),
            (this.c = c)
        }),
        (h.entries = function c() {
          var b,
            d = this
          return K(c, function (e) {
            if ((1 == e.b && (b = 0), 3 != e.b))
              return b < d.c.length ? (e = E(e, O(d.c[b]))) : ((e.b = 0), (e = void 0)), e
            b++, (e.b = 2)
          })
        }),
        (h.forEach = function (c, b) {
          N(arguments, 1)
          for (var d = v(this), e = d.next(); !e.done; e = d.next()) {
            var f = v(e.value)
            ;(e = f.next().value), (f = f.next().value), c.call(b, f, e, this)
          }
        }),
        (h.get = function (c) {
          N(arguments, 1)
          var b = this.c
          c = String(c)
          for (var d = 0; d < b.length; d++) if (b[d][0] === c) return O(b[d])[1]
          return null
        }),
        (h.getAll = function (c) {
          N(arguments, 1)
          var b = []
          return (
            (c = String(c)),
            L(this.c, function (d) {
              d[0] === c && b.push(O(d)[1])
            }),
            b
          )
        }),
        (h.has = function (c) {
          N(arguments, 1), (c = String(c))
          for (var b = 0; b < this.c.length; b++) if (this.c[b][0] === c) return !0
          return !1
        }),
        (h.keys = function b() {
          var e,
            f,
            g,
            k,
            d = this
          return K(b, function (t) {
            if ((1 == t.b && ((e = v(d)), (f = e.next())), 3 != t.b))
              return f.done ? void (t.b = 0) : ((g = f.value), (k = v(g)), E(t, k.next().value))
            ;(f = e.next()), (t.b = 2)
          })
        }),
        (h.set = function (b, d, e) {
          N(arguments, 2), (b = String(b))
          var f = [],
            g = M(b, d, e),
            k = !0
          L(this.c, function (q) {
            q[0] === b ? k && (k = !f.push(g)) : f.push(q)
          }),
            k && f.push(g),
            (this.c = f)
        }),
        (h.values = function d() {
          var f,
            g,
            k,
            q,
            e = this
          return K(d, function (x) {
            if ((1 == x.b && ((f = v(e)), (g = f.next())), 3 != x.b))
              return g.done ? void (x.b = 0) : ((k = g.value), (q = v(k)).next(), E(x, q.next().value))
            ;(g = f.next()), (x.b = 2)
          })
        }),
        (W.prototype._asNative = function () {
          for (var d = new Q(), e = v(this), f = e.next(); !f.done; f = e.next()) {
            var g = v(f.value)
            ;(f = g.next().value), (g = g.next().value), d.append(f, g)
          }
          return d
        }),
        (W.prototype._blob = function () {
          for (
            var d = '----formdata-polyfill-' + Math.random(), e = [], f = v(this), g = f.next();
            !g.done;
            g = f.next()
          ) {
            var k = v(g.value)
            ;(g = k.next().value),
              (k = k.next().value),
              e.push('--' + d + '\r\n'),
              k instanceof Blob
                ? e.push(
                    'Content-Disposition: form-data; name="' +
                      g +
                      '"; filename="' +
                      k.name +
                      '"\r\nContent-Type: ' +
                      (k.type || 'application/octet-stream') +
                      '\r\n\r\n',
                    k,
                    '\r\n',
                  )
                : e.push('Content-Disposition: form-data; name="' + g + '"\r\n\r\n' + k + '\r\n')
          }
          return e.push('--' + d + '--'), new Blob(e, { type: 'multipart/form-data; boundary=' + d })
        }),
        (W.prototype[Symbol.iterator] = function () {
          return this.entries()
        }),
        (W.prototype.toString = function () {
          return '[object FormData]'
        }),
        U &&
          !U.matches &&
          (U.matches =
            U.matchesSelector ||
            U.mozMatchesSelector ||
            U.msMatchesSelector ||
            U.oMatchesSelector ||
            U.webkitMatchesSelector ||
            function (d) {
              for (
                var e = (d = (this.document || this.ownerDocument).querySelectorAll(d)).length;
                0 <= --e && d.item(e) !== this;

              );
              return -1 < e
            }),
        V && (W.prototype[V] = 'FormData'),
        R)
      ) {
        var X = P.XMLHttpRequest.prototype.setRequestHeader
        ;(P.XMLHttpRequest.prototype.setRequestHeader = function (d, e) {
          X.call(this, d, e), 'content-type' === d.toLowerCase() && (this.s = !0)
        }),
          (P.XMLHttpRequest.prototype.send = function (d) {
            d instanceof W
              ? ((d = d._blob()), this.s || this.setRequestHeader('Content-Type', d.type), R.call(this, d))
              : R.call(this, d)
          })
      }
      S &&
        (P.fetch = function (d, e) {
          return e && e.body && e.body instanceof W && (e.body = e.body._blob()), S.call(this, d, e)
        }),
        T &&
          (P.navigator.sendBeacon = function (d, e) {
            return e instanceof W && (e = e._asNative()), T.call(this, d, e)
          }),
        (P.FormData = W)
    }
  })(),
  (function (window) {
    var Node = function (parent, key) {
      ;(this.parent = parent), (this.key = key), (this.children = []), (this.templateIndex = null), (this.links = [])
    }
    Node.prototype.follow = function (key) {
      return key in this.children || (this.children[key] = new Node(this, key)), this.children[key]
    }
    var process = function process(root, value) {
        var result, i, key, node
        if ('object' == typeof value) {
          var type = Object.prototype.toString.apply(value)
          if ('[object Array]' === type)
            for (result = [], i = 0; i < value.length; i++) result.push(process(root, value[i]))
          else if ('[object Date]' === type) result = value.toJSON()
          else if ('[object Null]' === type) result = null
          else {
            for (key in ((node = root), (result = { '': [] }), value))
              Object.hasOwnProperty.call(value, key) &&
                ((node = node.follow(key)), result[''].push(process(root, value[key])))
            node.links.push(result)
          }
        } else result = value
        return result
      },
      expand = function expand(templates, value) {
        var result, i, keys
        if ('object' == typeof value) {
          var type = Object.prototype.toString.apply(value)
          if ('[object Array]' === type)
            for (result = [], i = 0; i < value.length; i++) result.push(expand(templates, value[i]))
          else if ('[object Null]' === type) result = null
          else
            for (
              result = {},
                keys = (function (templates, index) {
                  for (var keys = []; index > 0; )
                    (keys = templates[index - 1].slice(1).concat(keys)), (index = templates[index - 1][0])
                  return keys
                })(templates, value[''][0]),
                i = 0;
              i < keys.length;
              i++
            )
              result[keys[i]] = expand(templates, value[''][i + 1])
        } else result = value
        return result
      },
      CompactJSON = {}
    ;(CompactJSON.stringify = function (value) {
      var root, templates, values
      return (
        (root = new Node(null, '')),
        (values = process(root, value)),
        (templates = (function (root) {
          var node,
            template,
            cur,
            i,
            key,
            numChildren,
            templates = [],
            queue = []
          for (key in ((root.templateIndex = 0), root.children))
            Object.hasOwnProperty.call(root.children, key) && queue.push(root.children[key])
          for (; queue.length > 0; ) {
            for (key in ((numChildren = 0), (node = queue.shift()).children))
              Object.hasOwnProperty.call(node.children, key) && (queue.push(node.children[key]), (numChildren += 1))
            if (numChildren > 1 || node.links.length > 0) {
              for (template = [], cur = node; null === cur.templateIndex; )
                template.unshift(cur.key), (cur = cur.parent)
              for (
                template.unshift(cur.templateIndex),
                  templates.push(template),
                  node.templateIndex = templates.length,
                  i = 0;
                i < node.links.length;
                i++
              )
                node.links[i][''].unshift(node.templateIndex)
            }
          }
          return templates
        })(root)).length > 0
          ? JSON.stringify({ t: templates, v: values }, null, null)
          : JSON.stringify(value)
      )
    }),
      (CompactJSON.parse = function (str) {
        var value = JSON.parse(str)
        return 'object' == typeof value && 't' in value && 'v' in value ? expand(value.t, value.v) : value
      }),
      'undefined' == typeof module ? (window.CompactJSON = CompactJSON) : (module.exports = CompactJSON)
  })(this),
  (function (name, context, definition, plugins) {
    context[name] = definition.call(context)
    for (var i = 0; i < plugins.length; i++) plugins[i](context[name])
    'undefined' != typeof module && module.exports
      ? (module.exports = context[name])
      : 'function' == typeof define &&
        define.amd &&
        define(function () {
          return context[name]
        })
  })(
    'Primus',
    this || {},
    function () {
      return (function r(e, n, t) {
        function o(i, f) {
          if (!n[i]) {
            if (!e[i]) {
              var c = 'function' == typeof require && require
              if (!f && c) return c(i, !0)
              if (u) return u(i, !0)
              var a = new Error("Cannot find module '" + i + "'")
              throw ((a.code = 'MODULE_NOT_FOUND'), a)
            }
            var p = (n[i] = { exports: {} })
            e[i][0].call(
              p.exports,
              function (r) {
                return o(e[i][1][r] || r)
              },
              p,
              p.exports,
              r,
              e,
              n,
              t,
            )
          }
          return n[i].exports
        }
        for (var u = 'function' == typeof require && require, i = 0; i < t.length; i++) o(t[i])
        return o
      })(
        {
          1: [
            function (_dereq_, module, exports) {
              'use strict'
              module.exports = function (keys, options) {
                var split = /[, ]+/
                function run(key, selfie) {
                  if (options[key]) {
                    if (
                      ('string' == typeof options[key] && (options[key] = options[key].split(split)),
                      'function' == typeof options[key])
                    )
                      return options[key].call(selfie)
                    for (var type, what, i = 0; i < options[key].length; i++)
                      'function' === (type = typeof (what = options[key][i]))
                        ? what.call(selfie)
                        : 'string' === type && 'function' == typeof selfie[what] && selfie[what]()
                  }
                }
                return (
                  (options = options || {}),
                  'string' == typeof (keys = keys || []) && (keys = keys.split(split)),
                  function () {
                    var prop,
                      i = 0
                    if (null === this[keys[0]]) return !1
                    for (run('before', this); i < keys.length; i++)
                      this[(prop = keys[i])] &&
                        ('function' == typeof this[prop].destroy && this[prop].destroy(), (this[prop] = null))
                    return this.emit && this.emit('destroy'), run('after', this), !0
                  }
                )
              }
            },
            {},
          ],
          2: [
            function (_dereq_, module, exports) {
              'use strict'
              module.exports = function () {
                for (var parser, self = this, i = 0, l = arguments.length, args = new Array(l); i < l; i++)
                  args[i] = arguments[i]
                return 'function' != typeof args[args.length - 1]
                  ? function () {
                      for (var i = 0, l = arguments.length, arg = new Array(l); i < l; i++) arg[i] = arguments[i]
                      return self.emit.apply(self, args.concat(arg))
                    }
                  : ((parser = args.pop()),
                    function () {
                      for (var i = 0, l = arguments.length, arg = new Array(l + 1); i < l; i++)
                        arg[i + 1] = arguments[i]
                      return (
                        (arg[0] = function (err, returned) {
                          if (err) return self.emit('error', err)
                          ;(arg = void 0 === returned ? arg.slice(1) : null === returned ? [] : returned),
                            self.emit.apply(self, args.concat(arg))
                        }),
                        parser.apply(self, arg),
                        !0
                      )
                    })
              }
            },
            {},
          ],
          3: [
            function (_dereq_, module, exports) {
              'use strict'
              var has = Object.prototype.hasOwnProperty,
                prefix = '~'
              function Events() {}
              function EE(fn, context, once) {
                ;(this.fn = fn), (this.context = context), (this.once = once || !1)
              }
              function addListener(emitter, event, fn, context, once) {
                if ('function' != typeof fn) throw new TypeError('The listener must be a function')
                var listener = new EE(fn, context || emitter, once),
                  evt = prefix ? prefix + event : event
                return (
                  emitter._events[evt]
                    ? emitter._events[evt].fn
                      ? (emitter._events[evt] = [emitter._events[evt], listener])
                      : emitter._events[evt].push(listener)
                    : ((emitter._events[evt] = listener), emitter._eventsCount++),
                  emitter
                )
              }
              function clearEvent(emitter, evt) {
                0 == --emitter._eventsCount ? (emitter._events = new Events()) : delete emitter._events[evt]
              }
              function EventEmitter() {
                ;(this._events = new Events()), (this._eventsCount = 0)
              }
              Object.create && ((Events.prototype = Object.create(null)), new Events().__proto__ || (prefix = !1)),
                (EventEmitter.prototype.eventNames = function () {
                  var events,
                    name,
                    names = []
                  if (0 === this._eventsCount) return names
                  for (name in (events = this._events))
                    has.call(events, name) && names.push(prefix ? name.slice(1) : name)
                  return Object.getOwnPropertySymbols ? names.concat(Object.getOwnPropertySymbols(events)) : names
                }),
                (EventEmitter.prototype.listeners = function (event) {
                  var evt = prefix ? prefix + event : event,
                    handlers = this._events[evt]
                  if (!handlers) return []
                  if (handlers.fn) return [handlers.fn]
                  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) ee[i] = handlers[i].fn
                  return ee
                }),
                (EventEmitter.prototype.listenerCount = function (event) {
                  var evt = prefix ? prefix + event : event,
                    listeners = this._events[evt]
                  return listeners ? (listeners.fn ? 1 : listeners.length) : 0
                }),
                (EventEmitter.prototype.emit = function (event, a1, a2, a3, a4, a5) {
                  var evt = prefix ? prefix + event : event
                  if (!this._events[evt]) return !1
                  var args,
                    i,
                    listeners = this._events[evt],
                    len = arguments.length
                  if (listeners.fn) {
                    switch ((listeners.once && this.removeListener(event, listeners.fn, void 0, !0), len)) {
                      case 1:
                        return listeners.fn.call(listeners.context), !0
                      case 2:
                        return listeners.fn.call(listeners.context, a1), !0
                      case 3:
                        return listeners.fn.call(listeners.context, a1, a2), !0
                      case 4:
                        return listeners.fn.call(listeners.context, a1, a2, a3), !0
                      case 5:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4), !0
                      case 6:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), !0
                    }
                    for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i]
                    listeners.fn.apply(listeners.context, args)
                  } else {
                    var j,
                      length = listeners.length
                    for (i = 0; i < length; i++)
                      switch ((listeners[i].once && this.removeListener(event, listeners[i].fn, void 0, !0), len)) {
                        case 1:
                          listeners[i].fn.call(listeners[i].context)
                          break
                        case 2:
                          listeners[i].fn.call(listeners[i].context, a1)
                          break
                        case 3:
                          listeners[i].fn.call(listeners[i].context, a1, a2)
                          break
                        case 4:
                          listeners[i].fn.call(listeners[i].context, a1, a2, a3)
                          break
                        default:
                          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j]
                          listeners[i].fn.apply(listeners[i].context, args)
                      }
                  }
                  return !0
                }),
                (EventEmitter.prototype.on = function (event, fn, context) {
                  return addListener(this, event, fn, context, !1)
                }),
                (EventEmitter.prototype.once = function (event, fn, context) {
                  return addListener(this, event, fn, context, !0)
                }),
                (EventEmitter.prototype.removeListener = function (event, fn, context, once) {
                  var evt = prefix ? prefix + event : event
                  if (!this._events[evt]) return this
                  if (!fn) return clearEvent(this, evt), this
                  var listeners = this._events[evt]
                  if (listeners.fn)
                    listeners.fn !== fn ||
                      (once && !listeners.once) ||
                      (context && listeners.context !== context) ||
                      clearEvent(this, evt)
                  else {
                    for (var i = 0, events = [], length = listeners.length; i < length; i++)
                      (listeners[i].fn !== fn ||
                        (once && !listeners[i].once) ||
                        (context && listeners[i].context !== context)) &&
                        events.push(listeners[i])
                    events.length
                      ? (this._events[evt] = 1 === events.length ? events[0] : events)
                      : clearEvent(this, evt)
                  }
                  return this
                }),
                (EventEmitter.prototype.removeAllListeners = function (event) {
                  var evt
                  return (
                    event
                      ? ((evt = prefix ? prefix + event : event), this._events[evt] && clearEvent(this, evt))
                      : ((this._events = new Events()), (this._eventsCount = 0)),
                    this
                  )
                }),
                (EventEmitter.prototype.off = EventEmitter.prototype.removeListener),
                (EventEmitter.prototype.addListener = EventEmitter.prototype.on),
                (EventEmitter.prefixed = prefix),
                (EventEmitter.EventEmitter = EventEmitter),
                void 0 !== module && (module.exports = EventEmitter)
            },
            {},
          ],
          4: [
            function (_dereq_, module, exports) {
              'function' == typeof Object.create
                ? (module.exports = function (ctor, superCtor) {
                    ;(ctor.super_ = superCtor),
                      (ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: { value: ctor, enumerable: !1, writable: !0, configurable: !0 },
                      }))
                  })
                : (module.exports = function (ctor, superCtor) {
                    ctor.super_ = superCtor
                    var TempCtor = function () {}
                    ;(TempCtor.prototype = superCtor.prototype),
                      (ctor.prototype = new TempCtor()),
                      (ctor.prototype.constructor = ctor)
                  })
            },
            {},
          ],
          5: [
            function (_dereq_, module, exports) {
              'use strict'
              var regex = new RegExp(
                  '^((?:\\d+)?\\.?\\d+) *(' +
                    [
                      'milliseconds?',
                      'msecs?',
                      'ms',
                      'seconds?',
                      'secs?',
                      's',
                      'minutes?',
                      'mins?',
                      'm',
                      'hours?',
                      'hrs?',
                      'h',
                      'days?',
                      'd',
                      'weeks?',
                      'wks?',
                      'w',
                      'years?',
                      'yrs?',
                      'y',
                    ].join('|') +
                    ')?$',
                  'i',
                ),
                day = 864e5
              module.exports = function (ms) {
                var amount,
                  match,
                  type = typeof ms
                if ('number' === type) return ms
                if ('string' !== type || '0' === ms || !ms) return 0
                if (+ms) return +ms
                if (ms.length > 1e4 || !(match = regex.exec(ms))) return 0
                switch (((amount = parseFloat(match[1])), match[2].toLowerCase())) {
                  case 'years':
                  case 'year':
                  case 'yrs':
                  case 'yr':
                  case 'y':
                    return 31536e6 * amount
                  case 'weeks':
                  case 'week':
                  case 'wks':
                  case 'wk':
                  case 'w':
                    return 6048e5 * amount
                  case 'days':
                  case 'day':
                  case 'd':
                    return amount * day
                  case 'hours':
                  case 'hour':
                  case 'hrs':
                  case 'hr':
                  case 'h':
                    return 36e5 * amount
                  case 'minutes':
                  case 'minute':
                  case 'mins':
                  case 'min':
                  case 'm':
                    return 6e4 * amount
                  case 'seconds':
                  case 'second':
                  case 'secs':
                  case 'sec':
                  case 's':
                    return 1e3 * amount
                  default:
                    return amount
                }
              }
            },
            {},
          ],
          6: [
            function (_dereq_, module, exports) {
              'use strict'
              module.exports = function (fn) {
                var value,
                  called = 0
                function onetime() {
                  return called || ((called = 1), (value = fn.apply(this, arguments)), (fn = null)), value
                }
                return (onetime.displayName = fn.displayName || fn.name || onetime.displayName || onetime.name), onetime
              }
            },
            {},
          ],
          7: [
            function (_dereq_, module, exports) {
              'use strict'
              var has = Object.prototype.hasOwnProperty
              function decode(input) {
                return decodeURIComponent(input.replace(/\+/g, ' '))
              }
              ;(exports.stringify = function (obj, prefix) {
                prefix = prefix || ''
                var pairs = []
                for (var key in ('string' != typeof prefix && (prefix = '?'), obj))
                  has.call(obj, key) && pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]))
                return pairs.length ? prefix + pairs.join('&') : ''
              }),
                (exports.parse = function (query) {
                  for (var part, parser = /([^=?&]+)=?([^&]*)/g, result = {}; (part = parser.exec(query)); ) {
                    var key = decode(part[1]),
                      value = decode(part[2])
                    key in result || (result[key] = value)
                  }
                  return result
                })
            },
            {},
          ],
          8: [
            function (_dereq_, module, exports) {
              'use strict'
              var EventEmitter = _dereq_('eventemitter3'),
                millisecond = _dereq_('millisecond'),
                destroy = _dereq_('demolish'),
                Tick = _dereq_('tick-tock'),
                one = _dereq_('one-time')
              function defaults(name, selfie, opts) {
                return millisecond(name in opts ? opts[name] : name in selfie ? selfie[name] : Recovery[name])
              }
              function Recovery(options) {
                if (!(this instanceof Recovery)) return new Recovery(options)
                ;(options = options || {}),
                  (this.attempt = null),
                  (this._fn = null),
                  (this['reconnect timeout'] = defaults('reconnect timeout', this, options)),
                  (this.retries = defaults('retries', this, options)),
                  (this.factor = defaults('factor', this, options)),
                  (this.max = defaults('max', this, options)),
                  (this.min = defaults('min', this, options)),
                  (this.timers = new Tick(this))
              }
              ;(Recovery.prototype = new EventEmitter()),
                (Recovery.prototype.constructor = Recovery),
                (Recovery['reconnect timeout'] = '30 seconds'),
                (Recovery.max = 1 / 0),
                (Recovery.min = '500 ms'),
                (Recovery.retries = 10),
                (Recovery.factor = 2),
                (Recovery.prototype.reconnect = function () {
                  var recovery = this
                  return recovery.backoff(function (err, opts) {
                    if (((opts.duration = +new Date() - opts.start), err))
                      return recovery.emit('reconnect failed', err, opts)
                    recovery.emit('reconnected', opts)
                  }, recovery.attempt)
                }),
                (Recovery.prototype.backoff = function (fn, opts) {
                  var recovery = this
                  return (opts = opts || recovery.attempt || {}).backoff
                    ? recovery
                    : ((opts['reconnect timeout'] = defaults('reconnect timeout', recovery, opts)),
                      (opts.retries = defaults('retries', recovery, opts)),
                      (opts.factor = defaults('factor', recovery, opts)),
                      (opts.max = defaults('max', recovery, opts)),
                      (opts.min = defaults('min', recovery, opts)),
                      (opts.start = +opts.start || +new Date()),
                      (opts.duration = +opts.duration || 0),
                      (opts.attempt = +opts.attempt || 0),
                      opts.attempt === opts.retries
                        ? (fn.call(recovery, new Error('Unable to recover'), opts), recovery)
                        : ((opts.backoff = !0),
                          opts.attempt++,
                          (recovery.attempt = opts),
                          (opts.scheduled =
                            1 !== opts.attempt
                              ? Math.min(
                                  Math.round((Math.random() + 1) * opts.min * Math.pow(opts.factor, opts.attempt - 1)),
                                  opts.max,
                                )
                              : opts.min),
                          recovery.timers.setTimeout(
                            'reconnect',
                            function () {
                              ;(opts.duration = +new Date() - opts.start),
                                (opts.backoff = !1),
                                recovery.timers.clear('reconnect, timeout')
                              var connect = (recovery._fn = one(function (err) {
                                if ((recovery.reset(), err)) return recovery.backoff(fn, opts)
                                fn.call(recovery, void 0, opts)
                              }))
                              recovery.emit('reconnect', opts, connect),
                                recovery.timers.setTimeout(
                                  'timeout',
                                  function () {
                                    var err = new Error('Failed to reconnect in a timely manner')
                                    ;(opts.duration = +new Date() - opts.start),
                                      recovery.emit('reconnect timeout', err, opts),
                                      connect(err)
                                  },
                                  opts['reconnect timeout'],
                                )
                            },
                            opts.scheduled,
                          ),
                          recovery.emit('reconnect scheduled', opts),
                          recovery))
                }),
                (Recovery.prototype.reconnecting = function () {
                  return !!this.attempt
                }),
                (Recovery.prototype.reconnected = function (err) {
                  return this._fn && this._fn(err), this
                }),
                (Recovery.prototype.reset = function () {
                  return (this._fn = this.attempt = null), this.timers.clear('reconnect, timeout'), this
                }),
                (Recovery.prototype.destroy = destroy('timers attempt _fn')),
                (module.exports = Recovery)
            },
            { demolish: 1, eventemitter3: 9, millisecond: 5, 'one-time': 6, 'tick-tock': 11 },
          ],
          9: [
            function (_dereq_, module, exports) {
              'use strict'
              var prefix = 'function' != typeof Object.create && '~'
              function EE(fn, context, once) {
                ;(this.fn = fn), (this.context = context), (this.once = once || !1)
              }
              function EventEmitter() {}
              ;(EventEmitter.prototype._events = void 0),
                (EventEmitter.prototype.listeners = function (event, exists) {
                  var evt = prefix ? prefix + event : event,
                    available = this._events && this._events[evt]
                  if (exists) return !!available
                  if (!available) return []
                  if (available.fn) return [available.fn]
                  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) ee[i] = available[i].fn
                  return ee
                }),
                (EventEmitter.prototype.emit = function (event, a1, a2, a3, a4, a5) {
                  var evt = prefix ? prefix + event : event
                  if (!this._events || !this._events[evt]) return !1
                  var args,
                    i,
                    listeners = this._events[evt],
                    len = arguments.length
                  if ('function' == typeof listeners.fn) {
                    switch ((listeners.once && this.removeListener(event, listeners.fn, void 0, !0), len)) {
                      case 1:
                        return listeners.fn.call(listeners.context), !0
                      case 2:
                        return listeners.fn.call(listeners.context, a1), !0
                      case 3:
                        return listeners.fn.call(listeners.context, a1, a2), !0
                      case 4:
                        return listeners.fn.call(listeners.context, a1, a2, a3), !0
                      case 5:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4), !0
                      case 6:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), !0
                    }
                    for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i]
                    listeners.fn.apply(listeners.context, args)
                  } else {
                    var j,
                      length = listeners.length
                    for (i = 0; i < length; i++)
                      switch ((listeners[i].once && this.removeListener(event, listeners[i].fn, void 0, !0), len)) {
                        case 1:
                          listeners[i].fn.call(listeners[i].context)
                          break
                        case 2:
                          listeners[i].fn.call(listeners[i].context, a1)
                          break
                        case 3:
                          listeners[i].fn.call(listeners[i].context, a1, a2)
                          break
                        default:
                          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j]
                          listeners[i].fn.apply(listeners[i].context, args)
                      }
                  }
                  return !0
                }),
                (EventEmitter.prototype.on = function (event, fn, context) {
                  var listener = new EE(fn, context || this),
                    evt = prefix ? prefix + event : event
                  return (
                    this._events || (this._events = prefix ? {} : Object.create(null)),
                    this._events[evt]
                      ? this._events[evt].fn
                        ? (this._events[evt] = [this._events[evt], listener])
                        : this._events[evt].push(listener)
                      : (this._events[evt] = listener),
                    this
                  )
                }),
                (EventEmitter.prototype.once = function (event, fn, context) {
                  var listener = new EE(fn, context || this, !0),
                    evt = prefix ? prefix + event : event
                  return (
                    this._events || (this._events = prefix ? {} : Object.create(null)),
                    this._events[evt]
                      ? this._events[evt].fn
                        ? (this._events[evt] = [this._events[evt], listener])
                        : this._events[evt].push(listener)
                      : (this._events[evt] = listener),
                    this
                  )
                }),
                (EventEmitter.prototype.removeListener = function (event, fn, context, once) {
                  var evt = prefix ? prefix + event : event
                  if (!this._events || !this._events[evt]) return this
                  var listeners = this._events[evt],
                    events = []
                  if (fn)
                    if (listeners.fn)
                      (listeners.fn !== fn ||
                        (once && !listeners.once) ||
                        (context && listeners.context !== context)) &&
                        events.push(listeners)
                    else
                      for (var i = 0, length = listeners.length; i < length; i++)
                        (listeners[i].fn !== fn ||
                          (once && !listeners[i].once) ||
                          (context && listeners[i].context !== context)) &&
                          events.push(listeners[i])
                  return (
                    events.length
                      ? (this._events[evt] = 1 === events.length ? events[0] : events)
                      : delete this._events[evt],
                    this
                  )
                }),
                (EventEmitter.prototype.removeAllListeners = function (event) {
                  return this._events
                    ? (event
                        ? delete this._events[prefix ? prefix + event : event]
                        : (this._events = prefix ? {} : Object.create(null)),
                      this)
                    : this
                }),
                (EventEmitter.prototype.off = EventEmitter.prototype.removeListener),
                (EventEmitter.prototype.addListener = EventEmitter.prototype.on),
                (EventEmitter.prototype.setMaxListeners = function () {
                  return this
                }),
                (EventEmitter.prefixed = prefix),
                void 0 !== module && (module.exports = EventEmitter)
            },
            {},
          ],
          10: [
            function (_dereq_, module, exports) {
              'use strict'
              module.exports = function (port, protocol) {
                if (((protocol = protocol.split(':')[0]), !(port = +port))) return !1
                switch (protocol) {
                  case 'http':
                  case 'ws':
                    return 80 !== port
                  case 'https':
                  case 'wss':
                    return 443 !== port
                  case 'ftp':
                    return 21 !== port
                  case 'gopher':
                    return 70 !== port
                  case 'file':
                    return !1
                }
                return 0 !== port
              }
            },
            {},
          ],
          11: [
            function (_dereq_, module, exports) {
              'use strict'
              var has = Object.prototype.hasOwnProperty,
                ms = _dereq_('millisecond')
              function Timer(timer, clear, duration, fn) {
                ;(this.start = +new Date()),
                  (this.duration = duration),
                  (this.clear = clear),
                  (this.timer = timer),
                  (this.fns = [fn])
              }
              function unsetTimeout(id) {
                clearTimeout(id)
              }
              function unsetInterval(id) {
                clearInterval(id)
              }
              function unsetImmediate(id) {
                clearImmediate(id)
              }
              function Tick(context) {
                if (!(this instanceof Tick)) return new Tick(context)
                ;(this.timers = {}), (this.context = context || this)
              }
              ;(Timer.prototype.remaining = function () {
                return this.duration - this.taken()
              }),
                (Timer.prototype.taken = function () {
                  return +new Date() - this.start
                }),
                (Tick.prototype.tock = function (name, clear) {
                  var tock = this
                  return function () {
                    if (name in tock.timers) {
                      var fns = tock.timers[name].fns.slice(),
                        l = fns.length,
                        i = 0
                      for (clear ? tock.clear(name) : (tock.start = +new Date()); i < l; i++) fns[i].call(tock.context)
                    }
                  }
                }),
                (Tick.prototype.setTimeout = function (name, fn, time) {
                  var tock
                  return this.timers[name]
                    ? (this.timers[name].fns.push(fn), this)
                    : ((tock = ms(time)),
                      (this.timers[name] = new Timer(
                        setTimeout(this.tock(name, !0), ms(time)),
                        unsetTimeout,
                        tock,
                        fn,
                      )),
                      this)
                }),
                (Tick.prototype.setInterval = function (name, fn, time) {
                  var tock
                  return this.timers[name]
                    ? (this.timers[name].fns.push(fn), this)
                    : ((tock = ms(time)),
                      (this.timers[name] = new Timer(setInterval(this.tock(name), ms(time)), unsetInterval, tock, fn)),
                      this)
                }),
                (Tick.prototype.setImmediate = function (name, fn) {
                  return 'function' != typeof setImmediate
                    ? this.setTimeout(name, fn, 0)
                    : this.timers[name]
                    ? (this.timers[name].fns.push(fn), this)
                    : ((this.timers[name] = new Timer(setImmediate(this.tock(name, !0)), unsetImmediate, 0, fn)), this)
                }),
                (Tick.prototype.active = function (name) {
                  return name in this.timers
                }),
                (Tick.prototype.clear = function () {
                  var timer,
                    i,
                    l,
                    args = arguments.length ? arguments : [],
                    tick = this
                  if (
                    (1 === args.length && 'string' == typeof args[0] && (args = args[0].split(/[, ]+/)), !args.length)
                  )
                    for (timer in tick.timers) has.call(tick.timers, timer) && args.push(timer)
                  for (i = 0, l = args.length; i < l; i++)
                    (timer = tick.timers[args[i]]) &&
                      (timer.clear(timer.timer),
                      (timer.fns = timer.timer = timer.clear = null),
                      delete tick.timers[args[i]])
                  return tick
                }),
                (Tick.prototype.adjust = function (name, time) {
                  var interval,
                    tock = ms(time),
                    timer = this.timers[name]
                  return timer
                    ? ((interval = timer.clear === unsetInterval),
                      timer.clear(timer.timer),
                      (timer.start = +new Date()),
                      (timer.duration = tock),
                      (timer.timer = (interval ? setInterval : setTimeout)(this.tock(name, !interval), tock)),
                      this)
                    : this
                }),
                (Tick.prototype.end = Tick.prototype.destroy =
                  function () {
                    return !!this.context && (this.clear(), (this.context = this.timers = null), !0)
                  }),
                (Tick.Timer = Timer),
                (module.exports = Tick)
            },
            { millisecond: 5 },
          ],
          12: [
            function (_dereq_, module, exports) {
              ;(function (global) {
                'use strict'
                var required = _dereq_('requires-port'),
                  qs = _dereq_('querystringify'),
                  protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i,
                  slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
                  rules = [
                    ['#', 'hash'],
                    ['?', 'query'],
                    ['/', 'pathname'],
                    ['@', 'auth', 1],
                    [NaN, 'host', void 0, 1, 1],
                    [/:(\d+)$/, 'port', void 0, 1],
                    [NaN, 'hostname', void 0, 1, 1],
                  ],
                  ignore = { hash: 1, query: 1 }
                function lolcation(loc) {
                  var key,
                    finaldestination = {},
                    type = typeof (loc = loc || global.location || {})
                  if ('blob:' === loc.protocol) finaldestination = new URL(unescape(loc.pathname), {})
                  else if ('string' === type)
                    for (key in ((finaldestination = new URL(loc, {})), ignore)) delete finaldestination[key]
                  else if ('object' === type) {
                    for (key in loc) key in ignore || (finaldestination[key] = loc[key])
                    void 0 === finaldestination.slashes && (finaldestination.slashes = slashes.test(loc.href))
                  }
                  return finaldestination
                }
                function extractProtocol(address) {
                  var match = protocolre.exec(address)
                  return { protocol: match[1] ? match[1].toLowerCase() : '', slashes: !!match[2], rest: match[3] }
                }
                function URL(address, location, parser) {
                  if (!(this instanceof URL)) return new URL(address, location, parser)
                  var relative,
                    extracted,
                    parse,
                    instruction,
                    index,
                    key,
                    instructions = rules.slice(),
                    type = typeof location,
                    url = this,
                    i = 0
                  for (
                    'object' !== type && 'string' !== type && ((parser = location), (location = null)),
                      parser && 'function' != typeof parser && (parser = qs.parse),
                      location = lolcation(location),
                      relative = !(extracted = extractProtocol(address || '')).protocol && !extracted.slashes,
                      url.slashes = extracted.slashes || (relative && location.slashes),
                      url.protocol = extracted.protocol || location.protocol || '',
                      address = extracted.rest,
                      extracted.slashes || (instructions[2] = [/(.*)/, 'pathname']);
                    i < instructions.length;
                    i++
                  )
                    (parse = (instruction = instructions[i])[0]),
                      (key = instruction[1]),
                      parse != parse
                        ? (url[key] = address)
                        : 'string' == typeof parse
                        ? ~(index = address.indexOf(parse)) &&
                          ('number' == typeof instruction[2]
                            ? ((url[key] = address.slice(0, index)), (address = address.slice(index + instruction[2])))
                            : ((url[key] = address.slice(index)), (address = address.slice(0, index))))
                        : (index = parse.exec(address)) &&
                          ((url[key] = index[1]), (address = address.slice(0, index.index))),
                      (url[key] = url[key] || (relative && instruction[3] && location[key]) || ''),
                      instruction[4] && (url[key] = url[key].toLowerCase())
                  parser && (url.query = parser(url.query)),
                    relative &&
                      location.slashes &&
                      '/' !== url.pathname.charAt(0) &&
                      ('' !== url.pathname || '' !== location.pathname) &&
                      (url.pathname = (function (relative, base) {
                        for (
                          var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),
                            i = path.length,
                            last = path[i - 1],
                            unshift = !1,
                            up = 0;
                          i--;

                        )
                          '.' === path[i]
                            ? path.splice(i, 1)
                            : '..' === path[i]
                            ? (path.splice(i, 1), up++)
                            : up && (0 === i && (unshift = !0), path.splice(i, 1), up--)
                        return (
                          unshift && path.unshift(''), ('.' !== last && '..' !== last) || path.push(''), path.join('/')
                        )
                      })(url.pathname, location.pathname)),
                    required(url.port, url.protocol) || ((url.host = url.hostname), (url.port = '')),
                    (url.username = url.password = ''),
                    url.auth &&
                      ((instruction = url.auth.split(':')),
                      (url.username = instruction[0] || ''),
                      (url.password = instruction[1] || '')),
                    (url.origin =
                      url.protocol && url.host && 'file:' !== url.protocol ? url.protocol + '//' + url.host : 'null'),
                    (url.href = url.toString())
                }
                ;(URL.prototype = {
                  set: function (part, value, fn) {
                    var url = this
                    switch (part) {
                      case 'query':
                        'string' == typeof value && value.length && (value = (fn || qs.parse)(value)),
                          (url[part] = value)
                        break
                      case 'port':
                        ;(url[part] = value),
                          required(value, url.protocol)
                            ? value && (url.host = url.hostname + ':' + value)
                            : ((url.host = url.hostname), (url[part] = ''))
                        break
                      case 'hostname':
                        ;(url[part] = value), url.port && (value += ':' + url.port), (url.host = value)
                        break
                      case 'host':
                        ;(url[part] = value),
                          /:\d+$/.test(value)
                            ? ((value = value.split(':')), (url.port = value.pop()), (url.hostname = value.join(':')))
                            : ((url.hostname = value), (url.port = ''))
                        break
                      case 'protocol':
                        ;(url.protocol = value.toLowerCase()), (url.slashes = !fn)
                        break
                      case 'pathname':
                      case 'hash':
                        if (value) {
                          var char = 'pathname' === part ? '/' : '#'
                          url[part] = value.charAt(0) !== char ? char + value : value
                        } else url[part] = value
                        break
                      default:
                        url[part] = value
                    }
                    for (var i = 0; i < rules.length; i++) {
                      var ins = rules[i]
                      ins[4] && (url[ins[1]] = url[ins[1]].toLowerCase())
                    }
                    return (
                      (url.origin =
                        url.protocol && url.host && 'file:' !== url.protocol ? url.protocol + '//' + url.host : 'null'),
                      (url.href = url.toString()),
                      url
                    )
                  },
                  toString: function (stringify) {
                    ;(stringify && 'function' == typeof stringify) || (stringify = qs.stringify)
                    var query,
                      url = this,
                      protocol = url.protocol
                    protocol && ':' !== protocol.charAt(protocol.length - 1) && (protocol += ':')
                    var result = protocol + (url.slashes ? '//' : '')
                    return (
                      url.username &&
                        ((result += url.username), url.password && (result += ':' + url.password), (result += '@')),
                      (result += url.host + url.pathname),
                      (query = 'object' == typeof url.query ? stringify(url.query) : url.query) &&
                        (result += '?' !== query.charAt(0) ? '?' + query : query),
                      url.hash && (result += url.hash),
                      result
                    )
                  },
                }),
                  (URL.extractProtocol = extractProtocol),
                  (URL.location = lolcation),
                  (URL.qs = qs),
                  (module.exports = URL)
              }.call(
                this,
                'undefined' != typeof global
                  ? global
                  : 'undefined' != typeof self
                  ? self
                  : 'undefined' != typeof window
                  ? window
                  : {},
              ))
            },
            { querystringify: 7, 'requires-port': 10 },
          ],
          13: [
            function (_dereq_, module, exports) {
              'use strict'
              var prev,
                alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
                map = {},
                seed = 0,
                i = 0
              function encode(num) {
                var encoded = ''
                do {
                  ;(encoded = alphabet[num % 64] + encoded), (num = Math.floor(num / 64))
                } while (num > 0)
                return encoded
              }
              function yeast() {
                var now = encode(+new Date())
                return now !== prev ? ((seed = 0), (prev = now)) : now + '.' + encode(seed++)
              }
              for (; i < 64; i++) map[alphabet[i]] = i
              ;(yeast.encode = encode),
                (yeast.decode = function (str) {
                  var decoded = 0
                  for (i = 0; i < str.length; i++) decoded = 64 * decoded + map[str.charAt(i)]
                  return decoded
                }),
                (module.exports = yeast)
            },
            {},
          ],
          14: [
            function (_dereq_, module, exports) {
              'use strict'
              var defaultUrl,
                EventEmitter = _dereq_('eventemitter3'),
                TickTock = _dereq_('tick-tock'),
                Recovery = _dereq_('recovery'),
                qs = _dereq_('querystringify'),
                inherits = _dereq_('inherits'),
                destroy = _dereq_('demolish'),
                yeast = _dereq_('yeast'),
                u2028 = /\u2028/g,
                u2029 = /\u2029/g
              function context(self, method) {
                if (!(self instanceof Primus)) {
                  var failure = new Error('Primus#' + method + "'s context should called with a Primus instance")
                  if ('function' != typeof self.listeners || !self.listeners('error').length) throw failure
                  self.emit('error', failure)
                }
              }
              try {
                defaultUrl = location.origin ? location.origin : location.protocol + '//' + location.host
              } catch (e) {
                defaultUrl = 'http://127.0.0.1'
              }
              function Primus(url, options) {
                if (!(this instanceof Primus)) return new Primus(url, options)
                if ((Primus.Stream.call(this), 'function' != typeof this.client))
                  return this.critical(
                    new Error(
                      'The client library has not been compiled correctly, see https://github.com/primus/primus#client-library for more details',
                    ),
                  )
                if (
                  ('object' == typeof url
                    ? (url = (options = url).url || options.uri || defaultUrl)
                    : (options = options || {}),
                  'ping' in options || 'pong' in options)
                )
                  return this.critical(new Error('The `ping` and `pong` options have been removed'))
                var primus = this
                ;(options.queueSize = 'queueSize' in options ? options.queueSize : 1 / 0),
                  (options.timeout = 'timeout' in options ? options.timeout : 1e4),
                  (options.reconnect = 'reconnect' in options ? options.reconnect : {}),
                  (options.pingTimeout = 'pingTimeout' in options ? options.pingTimeout : 45e3),
                  (options.strategy = 'strategy' in options ? options.strategy : []),
                  (options.transport = 'transport' in options ? options.transport : {}),
                  (primus.buffer = []),
                  (primus.writable = !0),
                  (primus.readable = !0),
                  (primus.url = primus.parse(url || defaultUrl)),
                  (primus.readyState = Primus.CLOSED),
                  (primus.options = options),
                  (primus.timers = new TickTock(this)),
                  (primus.socket = null),
                  (primus.disconnect = !1),
                  (primus.transport = options.transport),
                  (primus.transformers = { outgoing: [], incoming: [] }),
                  (primus.recovery = new Recovery(options.reconnect)),
                  'string' == typeof options.strategy && (options.strategy = options.strategy.split(/\s?,\s?/g)),
                  !1 === options.strategy
                    ? (options.strategy = [])
                    : options.strategy.length ||
                      (options.strategy.push('disconnect', 'online'),
                      this.authorization || options.strategy.push('timeout')),
                  (options.strategy = options.strategy.join(',').toLowerCase()),
                  'websockets' in options && (primus.AVOID_WEBSOCKETS = !options.websockets),
                  'network' in options && (primus.NETWORK_EVENTS = options.network),
                  options.manual ||
                    primus.timers.setTimeout(
                      'open',
                      function () {
                        primus.timers.clear('open'), primus.open()
                      },
                      0,
                    ),
                  primus.initialise(options)
              }
              Primus.requires = Primus.require = function (name) {
                if ('function' == typeof _dereq_) return _dereq_(name)
              }
              try {
                Primus.Stream = Primus.requires('stream')
              } catch (e) {}
              Primus.Stream || (Primus.Stream = EventEmitter),
                inherits(Primus, Primus.Stream),
                (Primus.OPENING = 1),
                (Primus.CLOSED = 2),
                (Primus.OPEN = 3),
                (Primus.prototype.AVOID_WEBSOCKETS = !1),
                (Primus.prototype.NETWORK_EVENTS = !1),
                (Primus.prototype.online = !0)
              try {
                ;(Primus.prototype.NETWORK_EVENTS =
                  'onLine' in navigator && (window.addEventListener || document.body.attachEvent)) &&
                  (navigator.onLine || (Primus.prototype.online = !1))
              } catch (e) {}
              if (
                ((Primus.prototype.ark = {}),
                (Primus.prototype.emits = _dereq_('emits')),
                (Primus.prototype.plugin = function (name) {
                  if ((context(this, 'plugin'), name)) return this.ark[name]
                  var plugins = {}
                  for (name in this.ark) plugins[name] = this.ark[name]
                  return plugins
                }),
                (Primus.prototype.reserved = function (evt) {
                  return /^(incoming|outgoing)::/.test(evt) || evt in this.reserved.events
                }),
                (Primus.prototype.reserved.events = {
                  'reconnect scheduled': 1,
                  'reconnect timeout': 1,
                  readyStateChange: 1,
                  'reconnect failed': 1,
                  reconnected: 1,
                  reconnect: 1,
                  offline: 1,
                  timeout: 1,
                  destroy: 1,
                  online: 1,
                  error: 1,
                  close: 1,
                  open: 1,
                  data: 1,
                  end: 1,
                }),
                (Primus.prototype.initialise = function (options) {
                  var primus = this
                  for (var plugin in (primus.recovery
                    .on('reconnected', primus.emits('reconnected'))
                    .on(
                      'reconnect failed',
                      primus.emits('reconnect failed', function (next) {
                        primus.emit('end'), next()
                      }),
                    )
                    .on('reconnect timeout', primus.emits('reconnect timeout'))
                    .on('reconnect scheduled', primus.emits('reconnect scheduled'))
                    .on(
                      'reconnect',
                      primus.emits('reconnect', function (next) {
                        primus.emit('outgoing::reconnect'), next()
                      }),
                    ),
                  primus.on('outgoing::open', function () {
                    var readyState = primus.readyState
                    ;(primus.readyState = Primus.OPENING),
                      readyState !== primus.readyState && primus.emit('readyStateChange', 'opening')
                  }),
                  primus.on('incoming::open', function () {
                    var readyState = primus.readyState
                    if (
                      (primus.recovery.reconnecting() && primus.recovery.reconnected(),
                      (primus.writable = !0),
                      (primus.readable = !0),
                      primus.online || ((primus.online = !0), primus.emit('online')),
                      (primus.readyState = Primus.OPEN),
                      readyState !== primus.readyState && primus.emit('readyStateChange', 'open'),
                      primus.heartbeat(),
                      primus.buffer.length)
                    ) {
                      var data = primus.buffer.slice(),
                        length = data.length,
                        i = 0
                      for (primus.buffer.length = 0; i < length; i++) primus._write(data[i])
                    }
                    primus.emit('open')
                  }),
                  primus.on('incoming::ping', function (time) {
                    ;(primus.online = !0),
                      primus.heartbeat(),
                      primus.emit('outgoing::pong', time),
                      primus._write('primus::pong::' + time)
                  }),
                  primus.on('incoming::error', function (e) {
                    var connect = primus.timers.active('connect'),
                      err = e
                    if ('string' == typeof e) err = new Error(e)
                    else if (!(e instanceof Error) && 'object' == typeof e)
                      for (var key in ((err = new Error(e.message || e.reason)), e))
                        Object.prototype.hasOwnProperty.call(e, key) && (err[key] = e[key])
                    if (primus.recovery.reconnecting()) return primus.recovery.reconnected(err)
                    primus.listeners('error').length && primus.emit('error', err),
                      connect &&
                        (~primus.options.strategy.indexOf('timeout') ? primus.recovery.reconnect() : primus.end())
                  }),
                  primus.on('incoming::data', function (raw) {
                    primus.decoder(raw, function (err, data) {
                      if (err) return primus.listeners('error').length && primus.emit('error', err)
                      primus.protocol(data) || primus.transforms(primus, primus, 'incoming', data, raw)
                    })
                  }),
                  primus.on('incoming::end', function () {
                    var readyState = primus.readyState
                    return primus.disconnect
                      ? ((primus.disconnect = !1), primus.end())
                      : ((primus.readyState = Primus.CLOSED),
                        readyState !== primus.readyState && primus.emit('readyStateChange', 'end'),
                        primus.timers.active('connect') && primus.end(),
                        readyState !== Primus.OPEN
                          ? !!primus.recovery.reconnecting() && primus.recovery.reconnect()
                          : ((this.writable = !1),
                            (this.readable = !1),
                            this.timers.clear(),
                            primus.emit('close'),
                            ~primus.options.strategy.indexOf('disconnect')
                              ? primus.recovery.reconnect()
                              : (primus.emit('outgoing::end'), void primus.emit('end'))))
                  }),
                  primus.client(),
                  primus.ark))
                    primus.ark[plugin].call(primus, primus, options)
                  return primus.NETWORK_EVENTS
                    ? ((primus.offlineHandler = function () {
                        primus.online &&
                          ((primus.online = !1), primus.emit('offline'), primus.end(), primus.recovery.reset())
                      }),
                      (primus.onlineHandler = function () {
                        primus.online ||
                          ((primus.online = !0),
                          primus.emit('online'),
                          ~primus.options.strategy.indexOf('online') && primus.recovery.reconnect())
                      }),
                      window.addEventListener
                        ? (window.addEventListener('offline', primus.offlineHandler, !1),
                          window.addEventListener('online', primus.onlineHandler, !1))
                        : document.body.attachEvent &&
                          (document.body.attachEvent('onoffline', primus.offlineHandler),
                          document.body.attachEvent('ononline', primus.onlineHandler)),
                      primus)
                    : primus
                }),
                (Primus.prototype.protocol = function (msg) {
                  if ('string' != typeof msg || 0 !== msg.indexOf('primus::')) return !1
                  var last = msg.indexOf(':', 8),
                    value = msg.slice(last + 2)
                  switch (msg.slice(8, last)) {
                    case 'ping':
                      this.emit('incoming::ping', +value)
                      break
                    case 'server':
                      'close' === value && (this.disconnect = !0)
                      break
                    case 'id':
                      this.emit('incoming::id', value)
                      break
                    default:
                      return !1
                  }
                  return !0
                }),
                (Primus.prototype.transforms = function (primus, connection, type, data, raw) {
                  var packet = { data },
                    fns = primus.transformers[type]
                  return (
                    (function transform(index, done) {
                      var transformer = fns[index++]
                      if (!transformer) return done()
                      if (1 === transformer.length) {
                        if (!1 === transformer.call(connection, packet)) return
                        return transform(index, done)
                      }
                      transformer.call(connection, packet, function (err, arg) {
                        if (err) return connection.emit('error', err)
                        !1 !== arg && transform(index, done)
                      })
                    })(0, function () {
                      if ('incoming' === type) return connection.emit('data', packet.data, raw)
                      connection._write(packet.data)
                    }),
                    this
                  )
                }),
                (Primus.prototype.id = function (fn) {
                  return this.socket && this.socket.id
                    ? fn(this.socket.id)
                    : (this._write('primus::id::'), this.once('incoming::id', fn))
                }),
                (Primus.prototype.open = function () {
                  return (
                    context(this, 'open'),
                    !this.recovery.reconnecting() && this.options.timeout && this.timeout(),
                    this.emit('outgoing::open'),
                    this
                  )
                }),
                (Primus.prototype.write = function (data) {
                  return context(this, 'write'), this.transforms(this, this, 'outgoing', data), !0
                }),
                (Primus.prototype._write = function (data) {
                  var primus = this
                  return Primus.OPEN !== primus.readyState
                    ? (this.buffer.length === this.options.queueSize && this.buffer.splice(0, 1),
                      this.buffer.push(data),
                      !1)
                    : (primus.encoder(data, function (err, packet) {
                        if (err) return primus.listeners('error').length && primus.emit('error', err)
                        'string' == typeof packet &&
                          (~packet.indexOf('\u2028') && (packet = packet.replace(u2028, '\\u2028')),
                          ~packet.indexOf('\u2029') && (packet = packet.replace(u2029, '\\u2029'))),
                          primus.emit('outgoing::data', packet)
                      }),
                      !0)
                }),
                (Primus.prototype.heartbeat = function () {
                  return this.options.pingTimeout
                    ? (this.timers.clear('heartbeat'),
                      this.timers.setTimeout(
                        'heartbeat',
                        function () {
                          this.online && ((this.online = !1), this.emit('offline'), this.emit('incoming::end'))
                        },
                        this.options.pingTimeout,
                      ),
                      this)
                    : this
                }),
                (Primus.prototype.timeout = function () {
                  var primus = this
                  function remove() {
                    primus
                      .removeListener('error', remove)
                      .removeListener('open', remove)
                      .removeListener('end', remove)
                      .timers.clear('connect')
                  }
                  return (
                    primus.timers.setTimeout(
                      'connect',
                      function () {
                        remove(),
                          primus.readyState === Primus.OPEN ||
                            primus.recovery.reconnecting() ||
                            (primus.emit('timeout'),
                            ~primus.options.strategy.indexOf('timeout') ? primus.recovery.reconnect() : primus.end())
                      },
                      primus.options.timeout,
                    ),
                    primus.on('error', remove).on('open', remove).on('end', remove)
                  )
                }),
                (Primus.prototype.end = function (data) {
                  if (
                    (context(this, 'end'),
                    this.readyState === Primus.CLOSED && !this.timers.active('connect') && !this.timers.active('open'))
                  )
                    return this.recovery.reconnecting() && (this.recovery.reset(), this.emit('end')), this
                  void 0 !== data && this.write(data), (this.writable = !1), (this.readable = !1)
                  var readyState = this.readyState
                  return (
                    (this.readyState = Primus.CLOSED),
                    readyState !== this.readyState && this.emit('readyStateChange', 'end'),
                    this.timers.clear(),
                    this.emit('outgoing::end'),
                    this.emit('close'),
                    this.emit('end'),
                    this
                  )
                }),
                (Primus.prototype.destroy = destroy('url timers options recovery socket transport transformers', {
                  before: 'end',
                  after: [
                    'removeAllListeners',
                    function () {
                      this.NETWORK_EVENTS &&
                        (window.addEventListener
                          ? (window.removeEventListener('offline', this.offlineHandler),
                            window.removeEventListener('online', this.onlineHandler))
                          : document.body.attachEvent &&
                            (document.body.detachEvent('onoffline', this.offlineHandler),
                            document.body.detachEvent('ononline', this.onlineHandler)))
                    },
                  ],
                })),
                (Primus.prototype.clone = function (obj) {
                  return this.merge({}, obj)
                }),
                (Primus.prototype.merge = function (target) {
                  for (var key, obj, i = 1; i < arguments.length; i++)
                    for (key in (obj = arguments[i]))
                      Object.prototype.hasOwnProperty.call(obj, key) && (target[key] = obj[key])
                  return target
                }),
                (Primus.prototype.parse = _dereq_('url-parse')),
                (Primus.prototype.querystring = qs.parse),
                (Primus.prototype.querystringify = qs.stringify),
                (Primus.prototype.uri = function (options) {
                  var url = this.url,
                    server = [],
                    qsa = !1
                  options.query && (qsa = !0),
                    ((options = options || {}).protocol = 'protocol' in options ? options.protocol : 'http:'),
                    (options.query = !(!url.query || !qsa) && url.query.slice(1)),
                    (options.secure =
                      'secure' in options ? options.secure : 'https:' === url.protocol || 'wss:' === url.protocol),
                    (options.auth = 'auth' in options ? options.auth : url.auth),
                    (options.pathname = 'pathname' in options ? options.pathname : this.pathname),
                    (options.port = 'port' in options ? +options.port : +url.port || (options.secure ? 443 : 80))
                  var querystring = this.querystring(options.query || '')
                  return (
                    (querystring._primuscb = yeast()),
                    (options.query = this.querystringify(querystring)),
                    this.emit('outgoing::url', options),
                    server.push(options.secure ? options.protocol.replace(':', 's:') : options.protocol, ''),
                    server.push(options.auth ? options.auth + '@' + url.host : url.host),
                    options.pathname && server.push(options.pathname.slice(1)),
                    qsa ? (server[server.length - 1] += '?' + options.query) : delete options.query,
                    options.object ? options : server.join('/')
                  )
                }),
                (Primus.prototype.transform = function (type, fn) {
                  return (
                    context(this, 'transform'),
                    type in this.transformers
                      ? (this.transformers[type].push(fn), this)
                      : this.critical(new Error('Invalid transformer type'))
                  )
                }),
                (Primus.prototype.critical = function (err) {
                  if (this.emit('error', err)) return this
                  throw err
                }),
                (Primus.connect = function (url, options) {
                  return new Primus(url, options)
                }),
                (Primus.EventEmitter = EventEmitter),
                (Primus.prototype.client = function () {
                  var socket,
                    primus = this,
                    Factory = (function () {
                      if ('undefined' != typeof WebSocket) return WebSocket
                      if ('undefined' != typeof MozWebSocket) return MozWebSocket
                      try {
                        return Primus.requires('ws')
                      } catch (e) {}
                    })()
                  if (!Factory)
                    return primus.critical(
                      new Error('Missing required `ws` module. Please run `npm install --save ws`'),
                    )
                  primus.on('outgoing::open', function () {
                    primus.emit('outgoing::end')
                    try {
                      var options = { protocol: 'ws+unix:' === primus.url.protocol ? 'ws+unix:' : 'ws:', query: !0 }
                      3 === Factory.length
                        ? ('ws+unix:' === options.protocol &&
                            (options.pathname = primus.url.pathname + ':' + primus.pathname),
                          (primus.socket = socket = new Factory(primus.uri(options), [], primus.transport)))
                        : ((primus.socket = socket = new Factory(primus.uri(options))),
                          (socket.binaryType = 'arraybuffer'))
                    } catch (e) {
                      return primus.emit('error', e)
                    }
                    ;(socket.onopen = primus.emits('incoming::open')),
                      (socket.onerror = primus.emits('incoming::error')),
                      (socket.onclose = primus.emits('incoming::end')),
                      (socket.onmessage = primus.emits('incoming::data', function (next, evt) {
                        next(void 0, evt.data)
                      }))
                  }),
                    primus.on('outgoing::data', function (message) {
                      if (socket && socket.readyState === Factory.OPEN)
                        try {
                          socket.send(message)
                        } catch (e) {
                          primus.emit('incoming::error', e)
                        }
                    }),
                    primus.on('outgoing::reconnect', function () {
                      primus.emit('outgoing::open')
                    }),
                    primus.on('outgoing::end', function () {
                      socket &&
                        ((socket.onerror = socket.onopen = socket.onclose = socket.onmessage = function () {}),
                        socket.close(),
                        (socket = null))
                    })
                }),
                (Primus.prototype.authorization = !1),
                (Primus.prototype.pathname = '/primus'),
                (Primus.prototype.encoder = function (data, fn) {
                  var err
                  try {
                    data = JSON.stringify(data)
                  } catch (e) {
                    err = e
                  }
                  fn(err, data)
                }),
                (Primus.prototype.decoder = function (data, fn) {
                  var err
                  if ('string' != typeof data) return fn(err, data)
                  try {
                    data = JSON.parse(data)
                  } catch (e) {
                    err = e
                  }
                  fn(err, data)
                }),
                (Primus.prototype.version = '7.2.2'),
                'undefined' != typeof document && 'undefined' != typeof navigator)
              ) {
                document.addEventListener &&
                  document.addEventListener(
                    'keydown',
                    function (e) {
                      27 === e.keyCode && e.preventDefault && e.preventDefault()
                    },
                    !1,
                  )
                var ua = (navigator.userAgent || '').toLowerCase(),
                  parsed = ua.match(/.+(?:rv|it|ra|ie)[/: ](\d+)\.(\d+)(?:\.(\d+))?/) || [],
                  version = +[parsed[1], parsed[2]].join('.')
                !~ua.indexOf('chrome') &&
                  ~ua.indexOf('safari') &&
                  version < 534.54 &&
                  (Primus.prototype.AVOID_WEBSOCKETS = !0)
              }
              module.exports = Primus
            },
            {
              demolish: 1,
              emits: 2,
              eventemitter3: 3,
              inherits: 4,
              querystringify: 7,
              recovery: 8,
              'tick-tock': 11,
              'url-parse': 12,
              yeast: 13,
            },
          ],
        },
        {},
        [14],
      )(14)
    },
    [],
  ),
  (self.makeIndexedDB = function (dependencies) {
    var dbPromise,
      _ = dependencies.lodash,
      bowser = dependencies.bowser,
      Promise = dependencies.Promise,
      utils = dependencies.utils,
      indexedDB = self.indexedDB || self.mozIndexedDB || self.webkitIndexedDB || self.msIndexedDB,
      DB_NAME = 'zenkit-offline-storage',
      _isSupported = void 0,
      rejectWithIndexedDBNotSupportedError = function () {
        return Promise.reject(new Error('IndexedDB is not supported'))
      },
      whenSupportChecked = new Promise(function (resolve, reject) {
        if (bowser.msedge || bowser.msie) return resolve(!1)
        var testReq = indexedDB.deleteDatabase('Zenkit Offline Storage')
        ;(testReq.onsuccess = function () {
          resolve(!0)
        }),
          (testReq.onblocked = function () {
            resolve(!1)
          }),
          (testReq.onerror = function () {
            resolve(!1)
          })
      }).catch(_.constant(!1)),
      TRX_MODI_READ_ONLY = 'readonly',
      TRX_MODI_READ_WRITE = 'readwrite',
      OBJECT_STORES = {
        ACCESSES: { name: 'accesses', primaryKey: ['resourceType', 'resourceId'] },
        LIST_ENTRIES: { name: 'listEntries', primaryKey: ['listId', 'uuid'] },
        LIST_ELEMENTS: { name: 'listElements', primaryKey: ['listId', 'uuid'] },
        ACTIVITIES: {
          name: 'listActivities',
          primaryKey: ['listId', 'uuid'],
          indices: { created_at: ['listId', 'created_at'] },
        },
        ACTIVITIES_PER_WORKSPACE: {
          name: 'workspaceActivities',
          primaryKey: ['workspaceId', 'uuid'],
          indices: { created_at: ['workspaceId', 'created_at'] },
        },
        VIEWS: { name: 'listViews', primaryKey: ['listId', 'uuid'] },
        USER_VIEWS: { name: 'userViews', primaryKey: ['uuid'] },
        LIST_FILTERS: { name: 'listFilters', primaryKey: ['listId', 'uuid'] },
        RECURRENCE_RULES: { name: 'recurrenceRules', primaryKey: ['listId', 'id'] },
        LIST_SYNCHRONIZATIONS: { name: 'listSynchronizations', primaryKey: ['listId'] },
        WORKSPACE_SYNCHRONIZATIONS: { name: 'workspaceSynchronizations', primaryKey: ['workspaceId'] },
        BACKGROUNDS: { name: 'backgrounds', primaryKey: ['id'] },
        ELEMENTCATEGORIES: { name: 'elementcategories', primaryKey: ['id'] },
        USERS: { name: 'users', primaryKey: ['id'] },
        GROUPS: { name: 'groups', primaryKey: ['id'] },
        USER_TAGS: { name: 'userTags', primaryKey: ['id'] },
        USER_TAG_ASSIGNMENTS: { name: 'userTagAssignments', primaryKey: ['id'] },
        MINIMAL_NEW_NOTIFICATIONS: { name: 'minimalNewNotifications', primaryKey: ['id'] },
        ACTIONS: { name: 'actions', primaryKey: ['uuid'] },
      },
      KEY_VALUE_STORE = { name: 'keyValue' },
      getIndexName = function (indexConfig) {
        if (_.isString(indexConfig)) return indexConfig
        if (_.isArray(indexConfig)) return _.join(indexConfig, '-')
        throw new Error('getIndexName: Invalid key path')
      },
      makeDefaultEventResolver = function (resolve) {
        return function (event) {
          return resolve(event.target.result)
        }
      },
      makeDefaultEventRejector = function (reject, request) {
        return function () {
          return reject(_.get(request, ['error']) || new Error('makeDefaultEventRejector: Unknown Error'))
        }
      },
      getDatabase = function () {
        return (
          _.isNil(dbPromise) &&
            (dbPromise = new Promise(function (resolve, reject) {
              if (_.isNil(indexedDB)) return reject(new Error('indexedDB not supported'))
              var request = indexedDB.open(DB_NAME, 1)
              ;(request.onerror = makeDefaultEventRejector(reject, request)),
                (request.onsuccess = makeDefaultEventResolver(resolve)),
                (request.onupgradeneeded = function (event) {
                  var db = event.target.result
                  _.forEach(OBJECT_STORES, function (storeConfig) {
                    var primaryKey = storeConfig.primaryKey
                    if (_.isNil(primaryKey))
                      throw new Error(
                        'Every object store config needs to specify a primaryKey. Failed to create object store for ' +
                          storeConfig.name +
                          '.',
                      )
                    var store = db.createObjectStore(storeConfig.name)
                    store.createIndex(getIndexName(primaryKey), primaryKey, { unique: !0 }),
                      storeConfig.indices &&
                        _.forEach(storeConfig.indices, function (keyPath) {
                          store.createIndex(getIndexName(keyPath), keyPath, { unique: !1 })
                        })
                  }),
                    db.createObjectStore(KEY_VALUE_STORE.name)
                })
            }).then(function (db) {
              return (
                (db.onversionchange = function () {
                  db.close(), (dbPromise = null)
                }),
                db
              )
            })),
          dbPromise
        )
      },
      getObjectStore = function (storeConfig, mode) {
        return (
          (mode = mode || TRX_MODI_READ_ONLY),
          getDatabase().then(function (database) {
            return database.transaction(storeConfig.name, mode).objectStore(storeConfig.name)
          })
        )
      },
      getObjectStoreIndex = function (storeConfig, mode) {
        return getObjectStore(storeConfig, mode).then(function (store) {
          return store.index(getIndexName(storeConfig.primaryKey))
        })
      },
      getKeyPath = function (storeConfig, identifiers) {
        return _.map(storeConfig.primaryKey, function (key) {
          var identifier = identifiers[key]
          return (
            _.isNil(identifier) && console.error('Invalid identifier for key path', { storeConfig, identifiers }),
            identifier
          )
        })
      },
      isSafari = bowser.safari || !1,
      setItem = function (storeConfig, identifiers, value) {
        if (!1 === _isSupported) return rejectWithIndexedDBNotSupportedError()
        if (void 0 === value)
          return Promise.reject(
            new Error('setItem does not support storing undefined. Please pass null if you want to delete a key.'),
          )
        var keyPath = getKeyPath(storeConfig, identifiers)
        return getObjectStore(storeConfig, TRX_MODI_READ_WRITE).then(function (store) {
          return new Promise(function (resolve, reject) {
            var request
            ;((request = null === value ? store.delete(keyPath) : store.put(value, keyPath)).onerror =
              makeDefaultEventRejector(reject, request)),
              (request.onsuccess = makeDefaultEventResolver(resolve))
          })
        })
      },
      keyValueStore = {
        getItem: function (key) {
          return !1 === _isSupported
            ? Promise.resolve(null)
            : getObjectStore(KEY_VALUE_STORE).then(function (store) {
                return new Promise(function (resolve, reject) {
                  var request = store.openCursor(key)
                  ;(request.onsuccess = function (event) {
                    var cursor = event.target.result
                    return cursor && cursor.value ? resolve(cursor.value) : resolve(null)
                  }),
                    (request.onerror = makeDefaultEventRejector(reject, request))
                })
              })
        },
        setItem: function (key, value) {
          return !1 === _isSupported
            ? rejectWithIndexedDBNotSupportedError()
            : void 0 === value
            ? Promise.reject(
                new Error(
                  'keyValueStore.setItem does not support storing undefined. Please pass null if you want to delete a key.',
                ),
              )
            : getObjectStore(KEY_VALUE_STORE, TRX_MODI_READ_WRITE).then(function (store) {
                return new Promise(function (resolve, reject) {
                  var request
                  ;((request = null === value ? store.delete(key) : store.put(value, key)).onerror =
                    makeDefaultEventRejector(reject, request)),
                    (request.onsuccess = makeDefaultEventResolver(resolve))
                })
              })
        },
      }
    return {
      initialLoad: whenSupportChecked.then(function (result) {
        return (
          !1 === (_isSupported = result) &&
            console.info(
              "IndexedDB is not supported by your browser. Therefore you won't be able to use Zenkit offline",
            ),
          _isSupported
        )
      }),
      isSupported: function () {
        return _isSupported
      },
      rejectWithIndexedDBNotSupportedError,
      OBJECT_STORES,
      keyValueStore,
      getItem: function (storeConfig, identifiers) {
        return !1 === _isSupported
          ? Promise.resolve(null)
          : getObjectStoreIndex(storeConfig, TRX_MODI_READ_ONLY).then(function (index) {
              var keyPath = getKeyPath(storeConfig, identifiers)
              return (
                isSafari && (keyPath = 1 === _.size(keyPath) ? _.head(keyPath) : keyPath),
                new Promise(function (resolve, reject) {
                  var request = index.openCursor(IDBKeyRange.lowerBound(keyPath))
                  ;(request.onsuccess = function (event) {
                    var cursor = event.target.result
                    return cursor && cursor.value ? resolve(cursor.value) : resolve(null)
                  }),
                    (request.onerror = makeDefaultEventRejector(reject, request))
                })
              )
            })
      },
      setItem,
      getFirstItemFromIndex: function (params) {
        if (!1 === _isSupported) return Promise.resolve(null)
        var identifierKey = (params = utils.validateParameters(params, {
          storeConfig: { type: 'object' },
          index: { type: 'array' },
          identifier: { type: 'number' },
          direction: { type: 'string', default: 'asc' },
          accepts: { type: 'function', default: _.constant(!0) },
        })).index[0]
        return getObjectStore(params.storeConfig)
          .then(function (store) {
            return store.index(getIndexName(params.index))
          })
          .then(function (index) {
            return new Promise(function (resolve, reject) {
              var keyRange, request
              'desc' === params.direction
                ? ((keyRange = IDBKeyRange.upperBound([params.identifier + 1])),
                  (request = index.openCursor(keyRange, 'prev')))
                : ((keyRange = IDBKeyRange.lowerBound([params.identifier])),
                  (request = index.openCursor(keyRange, 'next'))),
                (request.onsuccess = function (event) {
                  var cursor = event.target.result,
                    value = cursor && cursor.value
                  value && value[identifierKey] === params.identifier
                    ? !1 === params.accepts(value)
                      ? cursor.continue()
                      : resolve(value)
                    : resolve(null)
                }),
                (request.onerror = makeDefaultEventRejector(reject, request))
            })
          })
      },
      getAll: function (storeConfig) {
        if (!1 === _isSupported) return Promise.resolve([])
        return getObjectStoreIndex(storeConfig, TRX_MODI_READ_ONLY).then(function (index) {
          return index.getAll
            ? (function (index) {
                return new Promise(function (resolve, reject) {
                  var request = index.getAll()
                  ;(request.onsuccess = function (event) {
                    resolve(event.target.result)
                  }),
                    (request.onerror = makeDefaultEventRejector(reject, request))
                })
              })(index)
            : (function (index) {
                return new Promise(function (resolve, reject) {
                  var request = index.openCursor(),
                    results = []
                  ;(request.onsuccess = function (event) {
                    var cursor = event.target.result
                    cursor ? (results.push(cursor.value), cursor.continue()) : resolve(results)
                  }),
                    (request.onerror = makeDefaultEventRejector(reject, request))
                })
              })(index)
        })
      },
      setAll: function (storeConfig, values) {
        return !1 === _isSupported
          ? rejectWithIndexedDBNotSupportedError()
          : getDatabase().then(function (database) {
              return new Promise(function (resolve, reject) {
                var trx = database.transaction(storeConfig.name, TRX_MODI_READ_WRITE),
                  store = trx.objectStore(storeConfig.name)
                store.clear(),
                  _.forEach(values, function (value) {
                    if (null !== value) {
                      var keyPath = getKeyPath(storeConfig, value)
                      store.put(value, keyPath)
                    }
                  }),
                  (trx.oncomplete = makeDefaultEventResolver(resolve)),
                  (trx.onerror = makeDefaultEventRejector(reject))
              })
            })
      },
      getAllFor: function (storeConfig, identifier) {
        if (!1 === _isSupported) return Promise.resolve([])
        return getObjectStoreIndex(storeConfig, TRX_MODI_READ_ONLY).then(function (index) {
          return index.getAll && _.isNumber(identifier)
            ? (function (index) {
                return new Promise(function (resolve, reject) {
                  var request = index.getAll(IDBKeyRange.bound([identifier], [identifier + 1]))
                  ;(request.onsuccess = function (event) {
                    resolve(event.target.result)
                  }),
                    (request.onerror = makeDefaultEventRejector(reject, request))
                })
              })(index)
            : (function (index) {
                return new Promise(function (resolve, reject) {
                  var keyRange = IDBKeyRange.lowerBound([identifier]),
                    request = index.openCursor(keyRange),
                    results = []
                  ;(request.onsuccess = function (event) {
                    var cursor = event.target.result
                    cursor && cursor.key[0] === identifier
                      ? (results.push(cursor.value), cursor.continue())
                      : resolve(results)
                  }),
                    (request.onerror = makeDefaultEventRejector(reject, request))
                })
              })(index)
        })
      },
      setAllFor: function (storeConfig, identifier, values) {
        return !1 === _isSupported
          ? rejectWithIndexedDBNotSupportedError()
          : getObjectStoreIndex(storeConfig, TRX_MODI_READ_WRITE).then(function (index) {
              return new Promise(function (resolve, reject) {
                var request = index.openCursor(IDBKeyRange.lowerBound([identifier]))
                ;(request.onsuccess = function (event) {
                  var cursor = event.target.result
                  cursor && cursor.key[0] === identifier ? (cursor.delete(), cursor.continue()) : resolve()
                }),
                  (request.onerror = makeDefaultEventRejector(reject, request))
              }).then(function () {
                if (!_.isNil(values))
                  return Promise.map(values, function (value) {
                    var path = _.toPath(index.keyPath),
                      identifiers = _.reduce(
                        path,
                        function (identifiers, partialKey) {
                          return (identifiers[partialKey] = value[partialKey]), identifiers
                        },
                        [],
                      )
                    return setItem(storeConfig, identifiers, value)
                  })
              })
            })
      },
      clear: function () {
        return !1 === _isSupported
          ? Promise.resolve()
          : getDatabase()
              .then(function () {
                return new Promise(function (resolve, reject) {
                  var request = indexedDB.deleteDatabase(DB_NAME)
                  ;(request.onsuccess = makeDefaultEventResolver(resolve)),
                    (request.onblocked = (function (reject, request) {
                      return function () {
                        return reject(new Error('Request is blocked'))
                      }
                    })(reject)),
                    (request.onerror = makeDefaultEventRejector(reject, request))
                })
              })
              .then(function () {
                return (dbPromise = null), getDatabase()
              })
      },
      close: function () {
        return getDatabase().then(function (db) {
          db.close()
        })
      },
    }
  }),
  (self.makeStorageHandlers = function (dependencies) {
    var storageHandlers,
      objectStore,
      _ = dependencies.lodash,
      zenkitIndexedDB = dependencies.zenkitIndexedDB,
      makeKeyValueStorageHandler =
        (dependencies.Promise,
        function (keyOrFn) {
          var keyFn = _.isFunction(keyOrFn) ? keyOrFn : _.constant(keyOrFn)
          return {
            load: function (identifiers) {
              var key = keyFn(identifiers)
              return zenkitIndexedDB.keyValueStore.getItem(key).then(function (resource) {
                return resource
              })
            },
            save: function (identifiers, resource) {
              var key = keyFn(identifiers)
              return zenkitIndexedDB.keyValueStore.setItem(key, resource)
            },
          }
        }),
      makeSingleResourceStorageHandler = function (objectStore) {
        return {
          load: function (identifiers) {
            return zenkitIndexedDB.getItem(objectStore, identifiers)
          },
          save: function (identifiers, resource) {
            return zenkitIndexedDB.setItem(objectStore, identifiers, resource)
          },
        }
      },
      makeAllResourcesStorageHandler = function (objectStore) {
        return {
          load: function () {
            return zenkitIndexedDB.getAll(objectStore)
          },
          save: function (identifiers, resource) {
            return zenkitIndexedDB.setAll(objectStore, resource)
          },
        }
      },
      makeMultiListResourceStorageHandler = function (objectStore) {
        return {
          load: function (identifiers) {
            return zenkitIndexedDB.getAllFor(objectStore, identifiers.listId)
          },
          save: function (identifiers, resource) {
            return zenkitIndexedDB.setAllFor(objectStore, identifiers.listId, resource)
          },
        }
      },
      makeKeyFunction = function (prefix, identifier, postfix) {
        return function (identifiers) {
          return prefix + ':' + identifiers[identifier] + ':' + postfix
        }
      }
    return (storageHandlers = {
      LIST_ENTRY: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.LIST_ENTRIES),
      LIST_ENTRIES: makeMultiListResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.LIST_ENTRIES),
      LIST_ELEMENT: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.LIST_ELEMENTS),
      LIST_ELEMENTS: makeMultiListResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.LIST_ELEMENTS),
      LIST_ACTIVITY: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.ACTIVITIES),
      LIST_ENTRY_ACTIVITY: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.ACTIVITIES),
      ACTIVITIES: makeMultiListResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.ACTIVITIES),
      ACTIVITIES_PER_WORKSPACE:
        ((objectStore = zenkitIndexedDB.OBJECT_STORES.ACTIVITIES_PER_WORKSPACE),
        {
          load: function (identifiers) {
            return zenkitIndexedDB.getAllFor(objectStore, identifiers.workspaceId)
          },
          save: function (identifiers, resource) {
            return zenkitIndexedDB.setAllFor(objectStore, identifiers.workspaceId, resource)
          },
        }),
      WORKSPACE_ACTIVITY: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.ACTIVITIES_PER_WORKSPACE),
      VIEW: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.VIEWS),
      VIEWS: makeMultiListResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.VIEWS),
      USER_VIEW: {
        load: function (identifiers) {
          return zenkitIndexedDB.getItem(zenkitIndexedDB.OBJECT_STORES.USER_VIEWS, identifiers)
        },
        save: function (identifiers, resource) {
          return zenkitIndexedDB.setItem(zenkitIndexedDB.OBJECT_STORES.USER_VIEWS, identifiers, resource)
        },
      },
      USER_VIEWS: {
        load: function () {
          return zenkitIndexedDB.getAll(zenkitIndexedDB.OBJECT_STORES.USER_VIEWS)
        },
        save: function (identifiers, resource) {
          return zenkitIndexedDB.setAll(zenkitIndexedDB.OBJECT_STORES.USER_VIEWS, resource)
        },
      },
      LIST_FILTER: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.LIST_FILTERS),
      LIST_FILTERS: makeMultiListResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.LIST_FILTERS),
      LIST_SYNCHRONIZATION: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.LIST_SYNCHRONIZATIONS),
      LIST_SYNCHRONIZATIONS: {
        load: function () {
          return zenkitIndexedDB
            .getAll(zenkitIndexedDB.OBJECT_STORES.LIST_SYNCHRONIZATIONS)
            .then(function (listSynchronizations) {
              return _.keyBy(listSynchronizations, 'listId')
            })
        },
        save: function (identifiers, resource) {
          throw new Error('Not implemented.')
        },
      },
      WORKSPACE_SYNCHRONIZATION: makeSingleResourceStorageHandler(
        zenkitIndexedDB.OBJECT_STORES.WORKSPACE_SYNCHRONIZATIONS,
      ),
      WORKSPACE_SYNCHRONIZATIONS: {
        load: function () {
          return zenkitIndexedDB
            .getAll(zenkitIndexedDB.OBJECT_STORES.WORKSPACE_SYNCHRONIZATIONS)
            .then(function (workspaceSynchronizations) {
              return _.keyBy(workspaceSynchronizations, 'workspaceId')
            })
        },
        save: function (identifiers, resource) {
          throw new Error('Not implemented.')
        },
      },
      RECURRENCE_RULE: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.RECURRENCE_RULES),
      RECURRENCE_RULES: makeMultiListResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.RECURRENCE_RULES),
      ACCESSES: makeAllResourcesStorageHandler(zenkitIndexedDB.OBJECT_STORES.ACCESSES),
      ACCESS: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.ACCESSES),
      BACKGROUND: makeSingleResourceStorageHandler(zenkitIndexedDB.OBJECT_STORES.BACKGROUNDS),
      BACKGROUNDS: makeAllResourcesStorageHandler(zenkitIndexedDB.OBJECT_STORES.BACKGROUNDS),
      CURRENT_USER: makeKeyValueStorageHandler('current-user'),
      USERS: makeAllResourcesStorageHandler(zenkitIndexedDB.OBJECT_STORES.USERS),
      GROUPS: makeAllResourcesStorageHandler(zenkitIndexedDB.OBJECT_STORES.GROUPS),
      ACCESSES_PER_LIST: makeKeyValueStorageHandler(makeKeyFunction('list', 'listId', 'accesses')),
      ACCESSES_PER_WORKSPACE: makeKeyValueStorageHandler(makeKeyFunction('workspace', 'workspaceId', 'accesses')),
      ACCESSES_PER_ORGANIZATION: makeKeyValueStorageHandler(
        makeKeyFunction('organization', 'organizationId', 'accesses'),
      ),
      CATEGORY_SORT_ORDERS_PER_LIST: makeKeyValueStorageHandler(function (identifiers) {
        return 'list:' + identifiers.listId + ':category-sort-orders'
      }),
      CATEGORY_SORT_ORDER: {
        load: function (identifiers) {
          return storageHandlers.CATEGORY_SORT_ORDERS_PER_LIST.load({ listId: identifiers.listId }).then(function (
            sortOrders,
          ) {
            return _.find(sortOrders, { elementId: identifiers.elementId })
          })
        },
        save: function (identifiers, sortOrder) {
          return storageHandlers.CATEGORY_SORT_ORDERS_PER_LIST.load({ listId: identifiers.listId })
            .then(function (sortOrders) {
              return _.unionBy([sortOrder], sortOrders, 'elementId')
            })
            .then(function (updatedSortOrders) {
              return storageHandlers.CATEGORY_SORT_ORDERS_PER_LIST.save(
                { listId: identifiers.listId },
                updatedSortOrders,
              )
            })
        },
      },
      LAST_USED_VIEW_UUID_PER_LIST: makeKeyValueStorageHandler(function (identifiers) {
        return 'list:' + identifiers.listId + ':last-used-view-uuid'
      }),
      WORKSPACES_WITH_LISTS: makeKeyValueStorageHandler('workspaces-with-lists'),
      LISTS_OF_WORKSPACE: {
        load: function (identifiers) {
          return storageHandlers.WORKSPACES_WITH_LISTS.load().then(function (workspacesWithLists) {
            var workspace = _.find(workspacesWithLists, { id: identifiers.id })
            if (_.isNil(workspace))
              throw new Error('LISTS_OF_WORKSPACE storageHandler: Workspace not found: ' + identifiers.id)
            return workspace.lists
          })
        },
        save: function (identifiers, lists) {
          return storageHandlers.WORKSPACES_WITH_LISTS.load().then(function (workspacesWithLists) {
            var workspace = _.find(workspacesWithLists, { id: identifiers.id })
            if (_.isNil(workspace))
              throw new Error('LISTS_OF_WORKSPACE storageHandler: Workspace not found: ' + identifiers.id)
            return (workspace.lists = lists), storageHandlers.WORKSPACES_WITH_LISTS.save({}, workspacesWithLists)
          })
        },
      },
      WORKSPACE: {
        load: function (identifiers) {
          return storageHandlers.WORKSPACES_WITH_LISTS.load().then(function (workspacesWithLists) {
            var workspace = _.find(workspacesWithLists, { id: identifiers.id })
            if (_.isNil(workspace)) throw new Error('WORKSPACE storageHandler: Workspace not found: ' + identifiers.id)
            return workspace
          })
        },
        save: function (identifiers, workspace) {
          return storageHandlers.WORKSPACES_WITH_LISTS.load().then(function (workspacesWithLists) {
            var workspaceIndex = _.findIndex(workspacesWithLists, { id: identifiers.id })
            return (
              _.isNil(workspace) || !1 === _.isNil(workspace.deprecated_at)
                ? -1 !== workspaceIndex && workspacesWithLists.splice(workspaceIndex, 1)
                : -1 === workspaceIndex
                ? (_.isNil(workspace.lists) && (workspace = _.defaults({}, workspace, { lists: [] })),
                  workspacesWithLists.push(workspace))
                : (workspacesWithLists[workspaceIndex] = _.defaults({}, workspace, {
                    lists: workspacesWithLists[workspaceIndex].lists,
                  })),
              storageHandlers.WORKSPACES_WITH_LISTS.save({}, workspacesWithLists)
            )
          })
        },
      },
      LIST: {
        load: function (identifiers) {
          return storageHandlers.WORKSPACES_WITH_LISTS.load().then(function (workspacesWithLists) {
            var lists = _.flatMap(workspacesWithLists, 'lists'),
              list = _.find(lists, { id: identifiers.id })
            if (_.isNil(list)) throw new Error('LIST storageHandler: List not found: ' + identifiers.id)
            return list
          })
        },
        save: function (identifiers, list) {
          return storageHandlers.WORKSPACES_WITH_LISTS.load().then(function (workspacesWithLists) {
            var newWorkspacesWithLists = _.map(workspacesWithLists, function (workspace) {
              var listIndex = _.findIndex(workspace.lists, { id: identifiers.id })
              return _.isNil(list) || workspace.id !== list.workspaceId
                ? (-1 !== listIndex && workspace.lists.splice(listIndex, 1), workspace)
                : -1 === listIndex
                ? (workspace.lists.push(list), workspace)
                : ((workspace.lists[listIndex] = list), workspace)
            })
            return storageHandlers.WORKSPACES_WITH_LISTS.save({}, newWorkspacesWithLists)
          })
        },
      },
      ELEMENTCATEGORIES: makeAllResourcesStorageHandler(zenkitIndexedDB.OBJECT_STORES.ELEMENTCATEGORIES),
      ORGANIZATION: {
        load: function (identifiers) {
          return storageHandlers.ORGANIZATIONS.load().then(function (data) {
            var organizations = data && data.organizations,
              organization = _.find(organizations, ['id', identifiers.id])
            if (_.isNil(organization))
              throw new Error('ORGANIZATION storageHandler: Organization not found: '.concat(identifiers.id))
            return organization
          })
        },
        save: function (identifiers, organization) {
          return storageHandlers.ORGANIZATIONS.load()
            .then(function (organizationsContainer) {
              var organizations = (organizationsContainer && organizationsContainer.organizations) || [],
                index = _.findIndex(organizations, ['id', identifiers.id])
              return _.isNil(organization)
                ? -1 === index
                  ? organizationsContainer
                  : (organizations.splice(index, 1), _.defaults({ organizations }, organizationsContainer))
                : -1 === index
                ? (organizations.push(organization), _.defaults({ organizations }, organizationsContainer))
                : (_.assign(organizations[index], organization), _.defaults({ organizations }, organizationsContainer))
            })
            .then(organizationsContainer => storageHandlers.ORGANIZATIONS.save({}, organizationsContainer))
        },
      },
      ORGANIZATIONS: makeKeyValueStorageHandler('organizations-container'),
      DB_VERSION: makeKeyValueStorageHandler('db-version'),
      ACCESS_TOKEN: makeKeyValueStorageHandler('access-token'),
      USER_RESOURCES_SYNC_TIMESTAMPS: makeKeyValueStorageHandler('user-resources-sync-timestamps'),
      USER_TAGS: {
        load: function () {
          return zenkitIndexedDB.getAll(zenkitIndexedDB.OBJECT_STORES.USER_TAGS)
        },
        save: function (identifiers, resource) {
          return zenkitIndexedDB.setAll(zenkitIndexedDB.OBJECT_STORES.USER_TAGS, resource)
        },
      },
      USER_TAG_ASSIGNMENTS: {
        load: function () {
          return zenkitIndexedDB.getAll(zenkitIndexedDB.OBJECT_STORES.USER_TAG_ASSIGNMENTS)
        },
        save: function (identifiers, resource) {
          return zenkitIndexedDB.setAll(zenkitIndexedDB.OBJECT_STORES.USER_TAG_ASSIGNMENTS, resource)
        },
      },
      MINIMAL_NEW_NOTIFICATIONS: {
        load: function () {
          return zenkitIndexedDB.getAll(zenkitIndexedDB.OBJECT_STORES.MINIMAL_NEW_NOTIFICATIONS)
        },
        save: function (identifiers, resource) {
          return zenkitIndexedDB.setAll(zenkitIndexedDB.OBJECT_STORES.MINIMAL_NEW_NOTIFICATIONS, resource)
        },
      },
    })
  }),
  (self.makeResources = function (dependencies) {
    var resourceHandlers,
      mainKey,
      keyBy,
      defaults,
      _ = dependencies.lodash,
      utils = dependencies.utils,
      emitResourceChanged = dependencies.emitResourceChanged,
      resources = dependencies.resources,
      publishTypes = dependencies.publishTypes,
      getListResourcePath = function (mainKey, identifierKey, identifiers) {
        return [mainKey, identifiers.listId, identifiers[identifierKey]]
      },
      makeSingleListResourceHandler = function (mainKey, identifierKey, defaults) {
        return _.defaults(
          {
            get: function (data, identifiers) {
              var path = getListResourcePath(mainKey, identifierKey, identifiers)
              return _.get(data, path)
            },
            set: function (data, identifiers, updatedResource) {
              var path = getListResourcePath(mainKey, identifierKey, identifiers)
              return _.isNil(updatedResource) ? _.unset(data, path) : _.set(data, path, updatedResource), data
            },
          },
          defaults,
        )
      },
      makeMultiListResourceHandler = function (mainKey, keyBy, defaults) {
        return _.defaults(
          {
            get: function (data, identifiers) {
              var path = [mainKey, identifiers.listId]
              return _.get(data, path)
            },
            set: function (data, identifiers, updatedResource) {
              var path = [mainKey, identifiers.listId]
              return (
                _.isNil(updatedResource) ? _.unset(data, path) : _.set(data, path, _.keyBy(updatedResource, keyBy)),
                data
              )
            },
          },
          defaults,
        )
      },
      makePublishSingleListResourceToMulti = function (publishFn) {
        return function (params) {
          return (
            (params = utils.validateParameters(params, {
              identifiers: { type: 'object' },
              publishType: { type: 'string' },
              resource: { type: 'object' },
            })),
            publishFn({
              identifiers: { listId: params.identifiers.listId },
              publishType: params.publishType,
              resource: [params.resource],
            })
          )
        }
      },
      publishActivities = function (params) {
        var activities =
            null ===
            (params = utils.validateParameters(params, {
              identifiers: { type: 'object' },
              publishType: { type: 'string' },
              resource: { type: ['array', 'object', 'null'] },
            })).resource
              ? null
              : _.values(params.resource),
          changes = { user: params.user }
        if (null === activities) changes.reloadNeeded = !0
        else if (params.publishType === publishTypes.ADDED) changes.added = activities
        else if (params.publishType === publishTypes.CHANGED) changes.changed = activities
        else {
          if (params.publishType !== publishTypes.REMOVED)
            return void console.warn('unsupported publish type:', params.publishType)
          changes.removed = activities
        }
        var resourceName = params.identifiers.listId ? resources.ACTIVITIES : resources.ACTIVITIES_PER_WORKSPACE
        return emitResourceChanged({ resource: resourceName, identifiers: params.identifiers, changes })
      },
      publishListEntries = function (params) {
        var listEntries =
            null ===
            (params = utils.validateParameters(params, {
              identifiers: { type: 'object' },
              publishType: { type: 'string' },
              resource: { type: ['array', 'object', 'null'] },
              user: { type: ['object', 'undefined'] },
            })).resource
              ? null
              : _.values(params.resource),
          changes = { user: params.user }
        if (null === listEntries) changes.reloadNeeded = !0
        else if (params.publishType === publishTypes.ADDED) changes.added = listEntries
        else if (params.publishType === publishTypes.CHANGED) changes.changed = listEntries
        else {
          if (params.publishType !== publishTypes.REMOVED)
            return void console.warn('unsupported publish type:', params.publishType)
          changes.removed = listEntries
        }
        return emitResourceChanged({ resource: resources.LIST_ENTRIES, identifiers: params.identifiers, changes })
      },
      publishListElements = function (params) {
        var listElements =
            null ===
            (params = utils.validateParameters(params, {
              identifiers: { type: 'object' },
              publishType: { type: 'string' },
              resource: { type: ['array', 'object', 'null'] },
              user: { type: ['object', 'undefined'] },
            })).resource
              ? null
              : _.values(params.resource),
          changes = { user: params.user }
        if (null === listElements) changes.reloadNeeded = !0
        else if (params.publishType === publishTypes.ADDED) changes.added = listElements
        else if (params.publishType === publishTypes.CHANGED) changes.changed = listElements
        else {
          if (params.publishType !== publishTypes.REMOVED)
            return void console.warn('unsupported publish type:', params.publishType)
          changes.removed = listElements
        }
        return emitResourceChanged({ resource: resources.LIST_ELEMENTS, identifiers: params.identifiers, changes })
      },
      publishViews = function (params) {
        params = utils.validateParameters(params, {
          identifiers: { type: 'object' },
          publishType: { type: 'string' },
          resource: { type: ['array', 'object'] },
          user: { type: ['object', 'undefined'] },
        })
        var changes = {},
          views = _.values(params.resource)
        if (params.publishType === publishTypes.ADDED) changes.added = views
        else if (params.publishType === publishTypes.CHANGED) changes.changed = views
        else {
          if (params.publishType !== publishTypes.REMOVED)
            return void console.warn('unsupported publish type:', params.publishType)
          changes.removed = views
        }
        return emitResourceChanged({ resource: resources.VIEWS, identifiers: params.identifiers, changes })
      },
      publishUserViews = function (params) {
        params = utils.validateParameters(params, {
          identifiers: { type: 'object' },
          publishType: { type: 'string' },
          resource: { type: ['array', 'object'] },
          user: { type: ['object', 'undefined'] },
        })
        var changes = {},
          views = _.values(params.resource)
        if (params.publishType === publishTypes.ADDED) changes.added = views
        else if (params.publishType === publishTypes.CHANGED) changes.changed = views
        else {
          if (params.publishType !== publishTypes.REMOVED)
            return void console.warn('unsupported publish type:', params.publishType)
          changes.removed = views
        }
        return emitResourceChanged({ resource: resources.USER_VIEWS, identifiers: params.identifiers, changes })
      },
      publishFilters = function (params) {
        params = utils.validateParameters(params, {
          identifiers: { type: 'object' },
          publishType: { type: 'string' },
          resource: { type: ['array', 'object'] },
        })
        var changes = {},
          filters = _.values(params.resource)
        if (params.publishType === publishTypes.ADDED) changes.added = filters
        else if (params.publishType === publishTypes.CHANGED) changes.changed = filters
        else {
          if (params.publishType !== publishTypes.REMOVED)
            return void console.warn('unsupported publish type:', params.publishType)
          changes.removed = filters
        }
        return emitResourceChanged({ resource: resources.LIST_FILTERS, identifiers: params.identifiers, changes })
      },
      publishRecurrenceRules = function (params) {
        params = utils.validateParameters(params, {
          identifiers: { type: 'object' },
          publishType: { type: 'string' },
          resource: { type: ['array', 'object'] },
        })
        var changes = {},
          rules = _.values(params.resource)
        if (params.publishType === publishTypes.ADDED) changes.added = rules
        else if (params.publishType === publishTypes.CHANGED) changes.changed = rules
        else {
          if (params.publishType !== publishTypes.REMOVED)
            return void console.warn('unsupported publish type:', params.publishType)
          changes.removed = rules
        }
        return emitResourceChanged({ resource: resources.RECURRENCE_RULES, identifiers: params.identifiers, changes })
      }
    return (
      (resourceHandlers = {
        NO_RESOURCE: { identifierValidation: {}, get: _.constant(null), set: _.noop, publish: _.noop },
        ACCESSES: {
          identifierValidation: {},
          get: function (data) {
            return data.accesses
          },
          set: function (data, identifiers, updatedResource) {
            return (data.accesses = updatedResource), data
          },
          publish: function (params) {
            return emitResourceChanged({ resource: resources.ACCESSES, identifiers: params.identifiers })
          },
        },
        ACCESS: {
          identifierValidation: { resourceType: { type: 'string' }, resourceId: { type: 'number' } },
          get: function (data, identifiers) {
            return _.find(data.accesses, identifiers)
          },
          set: function (data, identifiers, updatedResource) {
            var accesses = _.reject(data.accesses, identifiers)
            return (
              !1 === _.isNil(updatedResource) && accesses.push(updatedResource),
              (data.accesses = _.orderBy(accesses, ['updated_at'])),
              data
            )
          },
          publish: function (params) {
            return resourceHandlers.ACCESSES.publish({ identifiers: {} })
          },
        },
        LIST_ENTRY: makeSingleListResourceHandler('entriesPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' }, uuid: { type: 'string' } },
          getSocketRoom: function (data, identifiers) {
            return 'zenkit_room_list_' + identifiers.listId + '_listentries'
          },
          publish: makePublishSingleListResourceToMulti(publishListEntries),
        }),
        LIST_ENTRIES: makeMultiListResourceHandler('entriesPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' } },
          getSocketRoom: function (data, identifiers) {
            return 'zenkit_room_list_' + identifiers.listId + '_listentries'
          },
          publish: publishListEntries,
        }),
        LIST_ELEMENT: makeSingleListResourceHandler('elementsPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' }, uuid: { type: 'string' } },
          getSocketRoom: function (data, identifiers) {
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return _.isNil(list) ? null : 'zenkit_room_listUUID_' + list.uuid + '_listelements'
          },
          publish: makePublishSingleListResourceToMulti(publishListElements),
        }),
        LIST_ELEMENTS: makeMultiListResourceHandler('elementsPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' } },
          getSocketRoom: function (data, identifiers) {
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return _.isNil(list) ? null : 'zenkit_room_listUUID_' + list.uuid + '_listelements'
          },
          publish: publishListElements,
        }),
        USER: {
          identifierValidation: { id: { type: 'number' } },
          get: function (data, identifiers) {
            return _.find(data.users, ['id', identifiers.id])
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource)
              ? ((data.users = _.reject(data.users, ['id', identifiers.id])), data)
              : ((data.users = _.unionBy([updatedResource], data.users, 'id')), data)
          },
          publish: function (params) {
            return emitResourceChanged({
              resource: resources.USER,
              identifiers: params.identifiers,
              changes: { changed: params.resource },
            })
          },
        },
        USERS: {
          identifierValidation: {},
          get: function (data) {
            return data.users
          },
          set: function (data, identifiers, updatedResource) {
            return (data.users = updatedResource), data
          },
          publish: function (params) {
            return emitResourceChanged({
              resource: resources.USERS,
              identifiers: params.identifiers,
              users: params.resource,
            })
          },
        },
        GROUPS: {
          identifierValidation: {},
          get: function (data) {
            return data.groups
          },
          set: function (data, identifiers, updatedResource) {
            return (data.groups = updatedResource), data
          },
          publish: function (params) {
            var changes = {}
            if (params.publishType === publishTypes.ADDED) changes.added = params.resource
            else if (params.publishType === publishTypes.CHANGED) changes.changed = params.resource
            else {
              if (params.publishType !== publishTypes.REMOVED)
                return void console.warn('unsupported publish type:', params.publishType)
              changes.removed = params.resource
            }
            return emitResourceChanged({ resource: resources.GROUPS, identifiers: params.identifiers, changes })
          },
        },
        GROUP: {
          identifierValidation: { id: { type: 'number' }, organizationId: { type: ['number', 'undefined'] } },
          get: function (data, identifiers) {
            return _.find(data.groups, ['id', identifiers.id])
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource)
              ? ((data.groups = _.reject(data.groups, ['id', identifiers.id])), data)
              : ((data.groups = _.unionBy([updatedResource], data.groups, 'id')), data)
          },
          publish: function (params) {
            return resourceHandlers.GROUPS.publish({
              identifiers: {},
              publishType: params.publishType,
              resource: [params.resource],
            })
          },
        },
        CURRENT_USER: {
          identifierValidation: {},
          get: function (data) {
            return data.currentUser || null
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource) ? delete data.currentUser : (data.currentUser = updatedResource), data
          },
          publish: function (params) {
            return (
              (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: ['object', 'null'] },
              })),
              emitResourceChanged({ resource: resources.CURRENT_USER, identifiers: {}, user: params.resource })
            )
          },
        },
        ACCESSES_PER_ORGANIZATION: {
          identifierValidation: { organizationId: { type: 'number' } },
          get: function (data, identifiers) {
            return data.accessesPerOrganization[identifiers.organizationId]
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource)
              ? (delete data.accessesPerOrganization[identifiers.organizationId], data)
              : ((data.accessesPerOrganization[identifiers.organizationId] = updatedResource), data)
          },
          publish: function (params) {
            return (
              (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: ['object', 'null'] },
              })),
              emitResourceChanged({
                resource: resources.ACCESSES_PER_ORGANIZATION,
                identifiers: params.identifiers,
                accesses: params.resource,
              })
            )
          },
        },
        ACCESSES_PER_LIST: {
          identifierValidation: { listId: { type: 'number' } },
          get: function (data, identifiers) {
            return data.accessesPerList[identifiers.listId]
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource)
              ? (delete data.accessesPerList[identifiers.listId], data)
              : ((data.accessesPerList[identifiers.listId] = updatedResource), data)
          },
          publish: function (params) {
            return (
              (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: 'array' },
              })),
              emitResourceChanged({
                resource: resources.ACCESSES_PER_LIST,
                identifiers: params.identifiers,
                accesses: params.resource,
              })
            )
          },
        },
        ACCESSES_PER_WORKSPACE: {
          identifierValidation: { workspaceId: { type: 'number' } },
          get: function (data, identifiers) {
            return data.accessesPerWorkspace[identifiers.workspaceId]
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource)
              ? (delete data.accessesPerWorkspace[identifiers.workspaceId], data)
              : ((data.accessesPerWorkspace[identifiers.workspaceId] = updatedResource), data)
          },
          publish: function (params) {
            return (
              (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: ['object', 'null'] },
              })),
              emitResourceChanged({
                resource: resources.ACCESSES_PER_WORKSPACE,
                identifiers: params.identifiers,
                accesses: params.resource,
              })
            )
          },
        },
        WORKSPACES_WITH_LISTS: {
          identifierValidation: {},
          get: function (data) {
            return data.workspacesWithLists
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(updatedResource) ? delete data.workspacesWithLists : (data.workspacesWithLists = updatedResource),
              data
            )
          },
          publish: function (params) {
            _.forEach(params.resource, function (workspace) {
              return emitResourceChanged({
                resource: resources.WORKSPACE,
                identifiers: { id: params.resource.id },
                changes: { changed: workspace },
              })
            })
          },
        },
        LIST: {
          identifierValidation: { id: { type: 'number' } },
          get: function (data, identifiers) {
            return _.chain(data.workspacesWithLists).flatMap('lists').find({ id: identifiers.id }).value()
          },
          set: function (data, identifiers, updatedResource) {
            if (
              ((data.workspacesWithLists = _.map(data.workspacesWithLists, function (workspace) {
                return (workspace.lists = _.reject(workspace.lists, { id: identifiers.id })), workspace
              })),
              !1 === _.isNil(updatedResource))
            ) {
              var workspace = _.find(data.workspacesWithLists, { id: updatedResource.workspaceId })
              !1 === _.isNil(workspace) &&
                (workspace.lists = _.sortBy(_.unionBy([updatedResource], workspace.lists, 'id'), 'sortOrder'))
            }
            return data
          },
          publish: function (params) {
            var changes = {
              user: (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: 'object' },
                beforeAnchorId: { type: ['number', 'null', 'undefined'] },
                sortData: {
                  type: ['object', 'undefined'],
                  customCheck: function (sortData) {
                    return params.publishType !== publishTypes.REORDERED || !_.isNil(sortData)
                  },
                },
                user: { type: ['object', 'undefined'] },
              })).user,
            }
            if (params.publishType === publishTypes.ADDED) changes.added = params.resource
            else if (params.publishType === publishTypes.CHANGED) changes.changed = params.resource
            else if (params.publishType === publishTypes.REMOVED) changes.removed = params.resource
            else {
              if (params.publishType !== publishTypes.REORDERED)
                return void console.warn('unsupported publish type:', params.publishType)
              ;(changes.reordered = params.resource),
                (changes.beforeAnchorId = params.beforeAnchorId),
                (changes.sortData = params.sortData)
            }
            return emitResourceChanged({ resource: resources.LIST, identifiers: { id: params.resource.id }, changes })
          },
        },
        WORKSPACE: {
          identifierValidation: { id: { type: 'number' } },
          get: function (data, identifiers) {
            return _.find(data.workspacesWithLists, { id: identifiers.id })
          },
          set: function (data, identifiers, updatedResource) {
            var workspaces = data.workspacesWithLists || []
            return (
              updatedResource &&
                _.isNil(updatedResource.lists) &&
                (updatedResource = _.assign({}, updatedResource, {
                  lists: _.get(_.find(workspaces, { id: identifiers.id }), ['lists']) || [],
                })),
              (data.workspacesWithLists =
                _.isNil(updatedResource) || !1 === _.isNil(updatedResource.deprecated_at)
                  ? _.reject(workspaces, { id: identifiers.id })
                  : _.unionBy([updatedResource], workspaces, 'id')),
              data
            )
          },
          publish: function (params) {
            var changes = {
              user: (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: 'object' },
                user: { type: ['object', 'undefined'] },
              })).user,
            }
            if (params.publishType === publishTypes.ADDED) changes.added = params.resource
            else if (params.publishType === publishTypes.CHANGED) changes.changed = params.resource
            else {
              if (params.publishType !== publishTypes.REMOVED)
                return void console.warn('unsupported publish type:', params.publishType)
              changes.removed = params.resource
            }
            return emitResourceChanged({
              resource: resources.WORKSPACE,
              identifiers: { id: params.resource.id },
              changes,
            })
          },
        },
        LIST_ENTRY_ACTIVITY: makeSingleListResourceHandler('activitiesPerList', 'uuid', {
          identifierValidation: {
            listId: { type: 'number' },
            listEntryUuid: { type: 'string' },
            uuid: { type: 'string' },
          },
          publish: makePublishSingleListResourceToMulti(publishActivities),
        }),
        LIST_ACTIVITY: makeSingleListResourceHandler('activitiesPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' }, uuid: { type: 'string' } },
          publish: makePublishSingleListResourceToMulti(publishActivities),
        }),
        WORKSPACE_ACTIVITY: {
          identifierValidation: { uuid: { type: 'string' }, workspaceId: { type: 'number' } },
          get: function (data, identifiers) {
            return _.get(data, ['activitiesPerWorkspace', identifiers.workspaceId, identifiers.uuid])
          },
          set: function (data, identifiers, updatedResource) {
            var path = ['activitiesPerWorkspace', identifiers.workspaceId, identifiers.uuid]
            return _.isNil(updatedResource) ? _.unset(data, path) : _.set(data, path, updatedResource), data
          },
          publish: function (params) {
            return (
              (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: 'object' },
              })),
              publishActivities({
                identifiers: { workspaceId: params.identifiers.workspaceId },
                publishType: params.publishType,
                resource: [params.resource],
              })
            )
          },
        },
        ACTIVITIES: makeMultiListResourceHandler('activitiesPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' } },
          publish: publishActivities,
        }),
        ACTIVITIES_PER_WORKSPACE:
          ((mainKey = 'activitiesPerWorkspace'),
          (keyBy = 'uuid'),
          (defaults = { identifierValidation: { workspaceId: { type: 'number' } }, publish: publishActivities }),
          _.defaults(
            {
              get: function (data, identifiers) {
                var path = [mainKey, identifiers.workspaceId]
                return _.get(data, path)
              },
              set: function (data, identifiers, updatedResource) {
                var path = [mainKey, identifiers.workspaceId]
                return (
                  _.isNil(updatedResource) ? _.unset(data, path) : _.set(data, path, _.keyBy(updatedResource, keyBy)),
                  data
                )
              },
            },
            defaults,
          )),
        ELEMENTCATEGORIES: {
          identifierValidation: {},
          get: function (data) {
            return data.elementcategories
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(updatedResource) ? delete data.elementcategories : (data.elementcategories = updatedResource),
              data
            )
          },
          publish: _.noop,
        },
        BACKGROUNDS: {
          identifierValidation: {},
          get: function (data) {
            return data.backgrounds
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource) ? delete data.backgrounds : (data.backgrounds = updatedResource), data
          },
          publish: _.noop,
        },
        BACKGROUND: {
          identifierValidation: { id: { type: 'number' } },
          get: function (data, identifiers) {
            return _.find(data.backgrounds, { id: identifiers.id })
          },
          set: function (data, identifiers, updatedResource) {
            var backgrounds = data.backgrounds || []
            return (
              (data.backgrounds = _.isNil(updatedResource)
                ? _.reject(backgrounds, ['id', identifiers.id])
                : _.unionBy([updatedResource], backgrounds, 'id')),
              data
            )
          },
          publish: _.noop,
        },
        VIEW: makeSingleListResourceHandler('viewsPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' }, uuid: { type: 'string' } },
          publish: makePublishSingleListResourceToMulti(publishViews),
        }),
        VIEWS: makeMultiListResourceHandler('viewsPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' } },
          publish: publishViews,
        }),
        USER_VIEW: {
          identifierValidation: { uuid: { type: 'string' } },
          get: function (data, identifiers) {
            return data.userViews[identifiers.uuid]
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(updatedResource)
                ? delete data.userViews[identifiers.uuid]
                : (data.userViews[identifiers.uuid] = updatedResource),
              data
            )
          },
          publish: function (params) {
            return (
              (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: 'object' },
              })),
              publishUserViews({ identifiers: {}, publishType: params.publishType, resource: [params.resource] })
            )
          },
        },
        USER_VIEWS: {
          identifierValidation: {},
          get: function (data) {
            return data.userViews
          },
          set: function (data, identifiers, updatedResource) {
            return (data.userViews = _.keyBy(updatedResource, 'uuid')), data
          },
          publish: publishUserViews,
        },
        LIST_FILTER: makeSingleListResourceHandler('filtersPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' }, uuid: { type: 'string' } },
          publish: makePublishSingleListResourceToMulti(publishFilters),
        }),
        LIST_FILTERS: makeMultiListResourceHandler('filtersPerList', 'uuid', {
          identifierValidation: { listId: { type: 'number' } },
          publish: publishFilters,
        }),
        LIST_FILE: {
          identifierValidation: { listId: { type: 'number' }, id: { type: 'number' } },
          get: _.constant(null),
          set: function (data) {
            return data
          },
        },
        LAST_USED_VIEW_UUID_PER_LIST: {
          identifierValidation: { listId: { type: 'number' } },
          get: function (data, identifiers) {
            return data.lastUsedViewIdPerList[identifiers.listId]
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(updatedResource)
                ? delete data.lastUsedViewIdPerList[identifiers.listId]
                : (data.lastUsedViewIdPerList[identifiers.listId] = updatedResource),
              data
            )
          },
          publish: _.noop,
        },
        CATEGORY_SORT_ORDERS_PER_LIST: {
          identifierValidation: { listId: { type: 'number' } },
          get: function (data, identifiers) {
            return data.categorySortOrdersPerList[identifiers.listId]
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(updatedResource)
                ? delete data.categorySortOrdersPerList[identifiers.listId]
                : (data.categorySortOrdersPerList[identifiers.listId] = updatedResource),
              data
            )
          },
          publish: _.noop,
        },
        CATEGORY_SORT_ORDER: {
          identifierValidation: { listId: { type: 'number' }, elementId: { type: 'number' } },
          get: function (data, identifiers) {
            return _.find(data.categorySortOrdersPerList[identifiers.listId], { elementId: identifiers.elementId })
          },
          set: function (data, identifiers, updatedResource) {
            var currentSortOrders = data.categorySortOrdersPerList[identifiers.listId]
            _.isNil(currentSortOrders) &&
              ((currentSortOrders = []), (data.categorySortOrdersPerList[identifiers.listId] = currentSortOrders))
            var currentSortOrder = _.find(data.categorySortOrdersPerList[identifiers.listId], {
              elementId: identifiers.elementId,
            })
            return (
              currentSortOrder ? _.assign(currentSortOrder, updatedResource) : currentSortOrders.push(updatedResource),
              data
            )
          },
          publish: function (params) {
            var changes = {
              user: (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: ['object'] },
                user: { type: ['object', 'undefined'] },
              })).user,
            }
            if (params.publishType === publishTypes.ADDED) changes.added = params.resource
            else if (params.publishType === publishTypes.CHANGED) changes.changed = params.resource
            else {
              if (params.publishType !== publishTypes.REMOVED)
                return void console.warn('unsupported publish type:', params.publishType)
              changes.removed = params.resource
            }
            return emitResourceChanged({
              resource: resources.CATEGORY_SORT_ORDER,
              identifiers: params.identifiers,
              changes,
            })
          },
        },
        LIST_SYNCHRONIZATIONS: {
          identifierValidation: {},
          get: function (data) {
            return data.listSynchronizations
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(updatedResource)
                ? delete data.listSynchronizations
                : (data.listSynchronizations = updatedResource),
              data
            )
          },
          publish: _.noop,
        },
        LIST_SYNCHRONIZATION: {
          identifierValidation: { listId: { type: 'number' } },
          get: function (data, identifiers) {
            return data.listSynchronizations[identifiers.listId]
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(data.listSynchronizations) && (data.listSynchronizations = {}),
              _.isNil(updatedResource)
                ? delete data.listSynchronizations[identifiers.listId]
                : (data.listSynchronizations[identifiers.listId] = updatedResource),
              data
            )
          },
          publish: _.noop,
        },
        WORKSPACE_SYNCHRONIZATIONS: {
          identifierValidation: {},
          get: function (data) {
            return data.workspaceSynchronizations
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(updatedResource)
                ? delete data.workspaceSynchronizations
                : (data.workspaceSynchronizations = updatedResource),
              data
            )
          },
          publish: _.noop,
        },
        WORKSPACE_SYNCHRONIZATION: {
          identifierValidation: { workspaceId: { type: 'number' } },
          get: function (data, identifiers) {
            return data.workspaceSynchronizations[identifiers.workspaceId]
          },
          set: function (data, identifiers, updatedResource) {
            return (
              _.isNil(data.workspaceSynchronizations) && (data.workspaceSynchronizations = {}),
              _.isNil(updatedResource)
                ? delete data.workspaceSynchronizations[identifiers.workspaceId]
                : (data.workspaceSynchronizations[identifiers.workspaceId] = updatedResource),
              data
            )
          },
          publish: _.noop,
        },
        ORGANIZATION: {
          identifierValidation: { id: { type: 'number' } },
          get: function (data, identifiers) {
            return _.find(data.organizations, { id: identifiers.id })
          },
          set: function (data, identifiers, updatedResource) {
            var organizations = data.organizations || []
            return (
              (data.organizations = _.isNil(updatedResource)
                ? _.reject(organizations, { id: identifiers.id })
                : _.unionBy([updatedResource], organizations, 'id')),
              data
            )
          },
          publish: function (params) {
            return (
              (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: 'object' },
              })).publishType !== publishTypes.CHANGED && console.warn('Unsupported publish type for organizations'),
              emitResourceChanged({
                resource: resources.ORGANIZATION,
                identifiers: { id: params.resource.id },
                changes: { changed: params.resource, user: params.user },
              })
            )
          },
        },
        ORGANIZATIONS: {
          identifierValidation: {},
          get: function (data) {
            return data.organizations
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource) ? delete data.organizations : (data.organizations = updatedResource), data
          },
          publish: function (params) {
            ;(params = utils.validateParameters(params, {
              identifiers: { type: 'object' },
              publishType: { type: 'string' },
              resource: { type: 'array' },
            })),
              _.forEach(params.resource, function (organization) {
                resourceHandlers.ORGANIZATION.publish({
                  identifiers: { id: organization.id },
                  publishType: params.publishType,
                  resource: organization,
                })
              })
          },
        },
        DB_VERSION: {
          identifierValidation: {},
          get: function (data) {
            return data.dbVersion
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource) ? delete data.dbVersion : (data.dbVersion = updatedResource), data
          },
          publish: _.noop,
        },
        ACCESS_TOKEN: {
          identifierValidation: {},
          get: function (data) {
            return data.accessToken
          },
          set: function (data, identifiers, updatedResource) {
            return _.isNil(updatedResource) ? delete data.accessToken : (data.accessToken = updatedResource), data
          },
          publish: function (params) {
            return (
              (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: ['string', 'null'] },
              })),
              emitResourceChanged({ resource: resources.ACCESS_TOKEN, identifiers: {}, token: params.resource })
            )
          },
        },
        REMINDER: {
          identifierValidation: { uuid: { type: 'string' } },
          get: function (data, identifiers) {
            return _.find(data.reminders, { uuid: identifiers.uuid })
          },
          set: function (data, identifiers, resource) {
            return (
              _.isNil(resource)
                ? _.unset(data.reminders, [identifiers.uuid])
                : _.set(data.reminders, [identifiers.uuid], resource),
              data
            )
          },
          publish: function (params) {
            resourceHandlers.REMINDERS.publish({
              identifiers: {},
              publishType: params.publishType,
              resource: [params.resource],
            })
          },
        },
        REMINDERS: {
          identifierValidation: {},
          get: function (data, identifiers) {
            return data.reminders
          },
          set: function (data, identifiers, resource) {
            return (data.reminders = resource), data
          },
          publish: function (params) {
            var changes = {},
              reminders = (params = utils.validateParameters(params, {
                identifiers: { type: 'object' },
                publishType: { type: 'string' },
                resource: { type: ['array', 'null'] },
              })).resource
            if (null === reminders) changes.reloadNeeded = !0
            else if (params.publishType === publishTypes.ADDED) changes.added = reminders
            else if (params.publishType === publishTypes.CHANGED) changes.changed = reminders
            else if (params.publishType === publishTypes.REMOVED) changes.removed = reminders
            else {
              if (params.publishType !== publishTypes.ACTIVATED)
                return void console.warn('unsupported publish type:', params.publishType)
              changes.activated = reminders
            }
            return emitResourceChanged({ resource: resources.REMINDERS, identifiers: params.identifiers, changes })
          },
        },
        RECURRENCE_RULE: makeSingleListResourceHandler('recurrenceRulesPerList', 'id', {
          identifierValidation: { id: { type: 'number' }, listId: { type: 'number' } },
          publish: makePublishSingleListResourceToMulti(publishRecurrenceRules),
        }),
        RECURRENCE_RULES: makeMultiListResourceHandler('recurrenceRulesPerList', 'id', {
          identifierValidation: { listId: { type: 'number' } },
          publish: publishRecurrenceRules,
        }),
        USER_TAGS: {
          identifierValidation: {},
          get: function (data, identifiers) {
            return data.userTags
          },
          set: function (data, identifiers, resource) {
            return (data.userTags = resource), data
          },
          publish: function (params) {
            return emitResourceChanged({
              resource: resources.USER_TAGS,
              identifiers: params.identifiers,
              userTags: params.resource,
            })
          },
        },
        USER_TAG_ASSIGNMENTS: {
          identifierValidation: {},
          get: function (data, identifiers) {
            return data.userTagAssignments
          },
          set: function (data, identifiers, resource) {
            return (data.userTagAssignments = resource), data
          },
          publish: function (params) {
            return emitResourceChanged({
              resource: resources.USER_TAG_ASSIGNMENTS,
              identifiers: params.identifiers,
              userTagAssignments: params.resource,
            })
          },
        },
        MINIMAL_NEW_NOTIFICATIONS: {
          identifierValidation: {},
          get: function (data, identifiers) {
            return data.minimalNewNotifications
          },
          set: function (data, identifiers, resource) {
            return (data.minimalNewNotifications = resource), data
          },
          publish: function (params) {
            return emitResourceChanged({
              resource: resources.MINIMAL_NEW_NOTIFICATIONS,
              identifiers: params.identifiers,
              minimalNewNotifications: params.resource,
            })
          },
        },
        USER_RESOURCES_SYNC_TIMESTAMPS: {
          identifierValidation: {},
          get: function (data, identifiers) {
            return data.userResourcesSyncTimestamps || {}
          },
          set: function (data, identifiers, resource) {
            return (data.userResourcesSyncTimestamps = resource), data
          },
          publish: _.noop,
        },
      }),
      _.forEach(resourceHandlers, function (handler, resource) {
        if (_.isNil(handler.identifierValidation))
          console.warn('Resource handler without identifier validation found.', handler)
        else if (_.isNil(resources[resource]))
          console.warn('Resource handler for non existent resource found', handler, resource)
        else {
          var originalGet = handler.get,
            originalSet = handler.set,
            orgiginalPublish = handler.publish
          ;(handler.get = function (data, identifiers) {
            return (
              (identifiers = utils.validateParameters(identifiers, handler.identifierValidation)),
              originalGet(data, identifiers)
            )
          }),
            (handler.set = function (data, identifiers, updatedResource) {
              return (
                (identifiers = utils.validateParameters(identifiers, handler.identifierValidation)),
                originalSet(data, identifiers, updatedResource)
              )
            }),
            (handler.publish = function (params) {
              if (_.get(params, ['publishType']) !== publishTypes.NONE) return orgiginalPublish(params)
            })
        }
      }),
      resourceHandlers
    )
  }),
  (self.makeActionHandlers = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      globals = dependencies.globals,
      utils = dependencies.utils,
      RESOURCES = dependencies.resources,
      publishTypes = dependencies.publishTypes,
      resourceHandlers = dependencies.resourceHandlers,
      moment = dependencies.moment,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      zenkitFetch = dependencies.zenkitFetch,
      zenkitFetchPreventSockets = dependencies.zenkitFetchPreventSockets,
      actions = dependencies.actions,
      uploadFile = function (url, options) {
        var body = new FormData()
        options.uuid && body.append('uuid', options.uuid)
        var file = options.file,
          filename = file.name
        return (
          body.append('file', file, filename),
          zenkitFetch(url, { method: 'post', body }).catch(err => {
            if (_.get(err, ['code']) === ZenkitErrorCodes.RESOURCE_ALREADY_EXISTS.code) {
              var getterUrl = zenkitFetch.buildUrl('/files/:fileAllId/model', { fileAllId: options.uuid })
              return zenkitFetch.get(getterUrl)
            }
            return Promise.reject(err)
          })
        )
      },
      reduceListEntryCreateOptionsToDatabaseRelevantData = function (params) {
        return (
          (params = utils.validateParameters(params, {
            listEntryPrototype: { type: 'object' },
            listElements: { type: 'array' },
            elementcategories: { type: 'array' },
          })),
          _.pickBy(params.listEntryPrototype, function (value, key) {
            if ('id' === key && void 0 !== value)
              return (
                console.warn(
                  'Ids should always be generated by the server. Please use uuid instead.',
                  params.listEntryPrototype,
                ),
                !1
              )
            if (_.includes(['listId', 'displayString'], key) && void 0 !== value) return !1
            if ('created_at' === key) return !0
            if (_.includes(['updated_at', 'deprecated_at'], key)) return !1
            var keyPartials = key.split('_')
            if (2 !== keyPartials.length) return !0
            var elementcategory,
              elementUUID = keyPartials[0],
              businessDataName = keyPartials[1],
              listElement = _.find(params.listElements, { uuid: elementUUID }),
              hasDatabaseColumn = !1
            return (
              void 0 !== listElement &&
                void 0 !== (elementcategory = _.find(params.elementcategories, { id: listElement.elementcategory })) &&
                (hasDatabaseColumn =
                  elementcategory.businessDataDefinition[businessDataName] &&
                  !!elementcategory.businessDataDefinition[businessDataName].createColumnInDatabase),
              hasDatabaseColumn
            )
          })
        )
      },
      getMinimalEntryForReferencesSort = function (entry) {
        return _.pick(entry, ['id', 'uuid', 'shortId', 'listId', 'displayString', 'deprecated_at'])
      },
      computeListEntryPropertiesForOptimisticUpdate = function (data, identifiers, payload) {
        return _.reduce(
          payload,
          function (computed, value, key) {
            if (
              ((computed[key] = value),
              _.includes(
                ['sortOrder', 'created_at', 'updated_at', 'deprecated_at', 'created_by', 'updated_by', 'deprecated_by'],
                key,
              ))
            )
              return computed
            var partials = _.split(key, '_')
            if (2 !== _.size(partials)) return computed
            var elementUuid = partials[0],
              suffix = partials[1],
              element = resourceHandlers.LIST_ELEMENT.get(data, { listId: identifiers.listId, uuid: elementUuid })
            if (_.isNil(element)) return computed
            var ecName = _.keyBy(resourceHandlers.ELEMENTCATEGORIES.get(data), 'id')[element.elementcategory].name
            if ('Textfield' === ecName)
              (computed[elementUuid + '_searchText'] = value),
                element.isPrimary && 'text' === suffix && (computed.displayString = value)
            else if ('Persons' === ecName)
              computed[key + '_sort'] = _.map(value, function (userId) {
                return (
                  resourceHandlers.USER.get(data, { id: userId }) || {
                    id: userId,
                    displayname: 'User not cached',
                    initials: '',
                  }
                )
              })
            else if ('References' === ecName && 'references' === suffix) {
              var childListId = element.elementData.childList.id
              computed[key + '_sort'] = _.map(value, function (uuid) {
                var listEntry = resourceHandlers.LIST_ENTRY.get(data, { listId: childListId, uuid })
                return _.isNil(listEntry)
                  ? { listId: childListId, uuid, ACCESS_DENIED: !0 }
                  : getMinimalEntryForReferencesSort(listEntry)
              })
            } else if (('Subentries' !== ecName && 'Dependencies' !== ecName) || 'references' !== suffix) {
              if ('Categories' === ecName) {
                var categories = element.elementData.predefinedCategories
                computed[key + '_sort'] = _.map(value, function (id) {
                  return _.find(categories, { id })
                })
              } else if ('Files' === ecName && _.isArray(value) && !1 === _.isEmpty(value)) {
                var currentListEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers),
                  filesById = _.keyBy(_.get(currentListEntry, [elementUuid + '_filesData']), 'id')
                computed[elementUuid + '_filesData'] = _.map(value, function (id) {
                  return filesById[id]
                })
              }
            } else
              (computed[key + '_sort'] = _.map(value, function (uuid) {
                var listEntry = resourceHandlers.LIST_ENTRY.get(data, { listId: identifiers.listId, uuid })
                return _.isNil(listEntry)
                  ? { listId: childListId, uuid, ACCESS_DENIED: !0 }
                  : getMinimalEntryForReferencesSort(listEntry)
              })),
                'Dependencies' === ecName &&
                  (computed[elementUuid + '_tags'] = _.pick(
                    computed[elementUuid + '_tags'] ||
                      _.get(resourceHandlers.LIST_ENTRY.get(data, identifiers), [elementUuid + '_tags']),
                    value,
                  ))
            return computed
          },
          {},
        )
      },
      isCurrentUserCached = function (data) {
        var user = resourceHandlers.CURRENT_USER.get(data, {})
        return !1 === _.isNil(user)
      },
      areListElementsCached = function (data, identifiers) {
        var elementsMap = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId })
        return !1 === _.isEmpty(elementsMap)
      },
      isListElementCached = function (data, identifiers) {
        var listElement = resourceHandlers.LIST_ELEMENT.get(data, identifiers)
        return !1 === _.isNil(listElement)
      },
      isListEntryCached = function (data, identifiers) {
        var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers)
        return !1 === _.isNil(listEntry)
      },
      isListCached = function (data, identifiers) {
        var list = resourceHandlers.LIST.get(data, identifiers)
        return !1 === _.isNil(list)
      },
      isListAvailableOffline = function (data, identifiers) {
        return _.get(data, ['listSynchronizations', identifiers.id, 'wasSynchronizedAtLeastOnce'], !1)
      },
      isListCommentCached = function (data, identifiers) {
        var comment = resourceHandlers.LIST_ACTIVITY.get(data, identifiers)
        return !1 === _.isNil(comment)
      },
      isWorkspaceCached = function (data, identifiers) {
        var workspace = resourceHandlers.WORKSPACE.get(data, identifiers)
        return !1 === _.isNil(workspace)
      },
      isWorkspaceCommentCached = function (data, identifiers) {
        var comment = resourceHandlers.WORKSPACE_ACTIVITY.get(data, identifiers)
        return !1 === _.isNil(comment)
      },
      isCommentCached = function (data, identifiers) {
        return identifiers.listId
          ? isListCommentCached(data, identifiers)
          : !!identifiers.workspaceId && isWorkspaceCommentCached(data, identifiers)
      },
      isUserViewCached = function (data, identifiers) {
        var view = resourceHandlers.USER_VIEW.get(data, identifiers)
        return !1 === _.isNil(view)
      },
      updateEveryEntrySeperately = function (_ref7) {
        var { listEntries, inMemoryDb } = _ref7
        if (_.isNil(listEntries)) return Promise.resolve()
        var updates = _.map(listEntries, function (listEntry) {
          return {
            resource: RESOURCES.LIST_ENTRY,
            identifiers: _.pick(listEntry, ['listId', 'uuid']),
            value: listEntry,
          }
        })
        return inMemoryDb.updateMultiple(updates)
      },
      _markListEntryAsUpdated = function (data, listEntry, publishType, markResourceAsUpdated) {
        listEntry.updated_at = new Date()
        var identifiers = _.pick(listEntry, ['listId', 'uuid'])
        return (
          markResourceAsUpdated({
            resource: RESOURCES.LIST_ENTRY,
            publishType: publishType || publishTypes.CHANGED,
            identifiers,
          }),
          resourceHandlers.LIST_ENTRY.set(data, identifiers, listEntry)
        )
      },
      evaluateSubentryPathsForElement = function (params) {
        var data = params.data,
          listElement = params.listElement
        return (
          utils.evaluateSubentryPathsForElement({
            listEntriesByUuid: resourceHandlers.LIST_ENTRIES.get(data, { listId: listElement.listId }),
            listElement,
            topLevelOrderWasAffected: params.topLevelOrderWasAffected,
            markListEntryAsUpdated: function (listEntry, publishType) {
              data = _markListEntryAsUpdated(data, listEntry, publishType, params.markResourceAsUpdated)
            },
          }),
          data
        )
      },
      evaluateSubentryPathsForList = function (params) {
        var data = params.data,
          elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
          listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: params.listId }),
          subentriesElementcategory = _.find(elementcategories, { name: 'Subentries' }),
          subentriesElements = _.filter(listElementsByUuid, { elementcategory: subentriesElementcategory.id })
        return _.reduce(
          subentriesElements,
          function (data, subentriesElement) {
            return evaluateSubentryPathsForElement({
              data,
              listElement: subentriesElement,
              markResourceAsUpdated: params.markResourceAsUpdated,
              topLevelOrderWasAffected: params.topLevelOrderWasAffected,
            })
          },
          data,
        )
      },
      updateInMemoryDbSubentryPathsForList = function (params) {
        var listId = params.listId,
          inMemoryDb = params.inMemoryDb,
          topLevelOrderWasAffected = params.topLevelOrderWasAffected,
          data = inMemoryDb.getData()
        return !1 === isListAvailableOffline(data, { id: listId })
          ? Promise.resolve()
          : Promise.try(function () {
              var updatedEntryIdentifiers = []
              data = evaluateSubentryPathsForList({
                data,
                listId,
                markResourceAsUpdated: function (params) {
                  params.resource === RESOURCES.LIST_ENTRY
                    ? updatedEntryIdentifiers.push(params.identifiers)
                    : console.warn('Unexpected changed resource', params)
                },
                topLevelOrderWasAffected,
              })
              var updates = _.map(updatedEntryIdentifiers, function (identifiers) {
                return {
                  resource: RESOURCES.LIST_ENTRY,
                  identifiers,
                  value: resourceHandlers.LIST_ENTRY.get(data, identifiers),
                }
              })
              return inMemoryDb.updateMultiple(updates)
            }).catch(function (err) {
              console.warn('updateInMemoryDbSubentryPathsForList failed.', params.listId, err)
            })
      },
      getAllChildrenOfListEntry = function getAllChildrenOfListEntry(_ref9) {
        var { parentEntry, subentriesElement, listEntriesByUuid } = _ref9,
          referencesKey = subentriesElement.uuid + '_references',
          directChildren = _.compact(_.map(parentEntry[referencesKey], uuid => listEntriesByUuid[uuid])),
          childrenOfChildren = _.flatMap(directChildren, child =>
            getAllChildrenOfListEntry({ parentEntry: child, subentriesElement, listEntriesByUuid }),
          )
        return _.concat(directChildren, childrenOfChildren)
      },
      handleSubtasksAfterCategoryValueChanged = function (params) {
        var data = params.data,
          taskData = params.taskData,
          oldListEntry = params.oldListEntry,
          updatedListEntry = params.updatedListEntry,
          subentriesElement = params.subentriesElement,
          markResourceAsUpdated = params.markResourceAsUpdated,
          referencesKey = subentriesElement.uuid + '_references',
          parentsKey = (subentriesElement.uuid, subentriesElement.uuid + '_parents'),
          categoriesBefore = oldListEntry[taskData.listElementKey],
          categoriesAfter = updatedListEntry[taskData.listElementKey],
          wasDoneBefore = _.isEqual(categoriesBefore, [taskData.done.id]),
          isDoneAfter = _.isEqual(categoriesAfter, [taskData.done.id])
        if (wasDoneBefore === isDoneAfter) return data
        var listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: updatedListEntry.listId })
        if (isDoneAfter) {
          if (_.isEmpty(updatedListEntry[referencesKey])) return
          var children = getAllChildrenOfListEntry({
            parentEntry: updatedListEntry,
            listEntriesByUuid,
            subentriesElement,
          })
          _.forEach(children, function (child) {
            _.isEqual(child[taskData.listElementKey], [taskData.done.id]) ||
              ((child[taskData.listElementKey] = [taskData.done.id]),
              (data = _markListEntryAsUpdated(data, child, publishTypes.CHANGED, markResourceAsUpdated)))
          })
        } else {
          var parents = _.map(updatedListEntry[parentsKey], function (parentUuid) {
            return listEntriesByUuid[parentUuid]
          })
          _.forEach(parents, function (parent) {
            !1 !== _.isEqual(parent[taskData.listElementKey], [taskData.done.id]) &&
              ((parent[taskData.listElementKey] = [taskData.todo.id]),
              (data = _markListEntryAsUpdated(data, parent, publishTypes.CHANGED, markResourceAsUpdated)))
          })
        }
        return data
      },
      removeEntryFromMirrorReferences = function (params) {
        var data = params.data,
          listEntryUuid = params.listEntryUuid,
          referenceElement = params.referenceElement,
          removedReferences = params.removedReferences,
          markResourceAsUpdated = params.markResourceAsUpdated
        if (_.isEmpty(removedReferences)) return data
        var childListId = _.get(referenceElement, ['elementData', 'childList', 'id']),
          mirrorElementUUID = _.get(referenceElement, ['elementData', 'mirrorElementUUID'])
        if (_.isNil(childListId) || _.isNil(mirrorElementUUID)) return data
        var mirrorElementKey = mirrorElementUUID + '_references',
          mirrorElementKeySort = mirrorElementUUID + '_references_sort'
        return (
          _.forEach(removedReferences, function (removedReferenceUUID) {
            var mirrorListEntry = resourceHandlers.LIST_ENTRY.get(data, {
              listId: childListId,
              uuid: removedReferenceUUID,
            })
            mirrorListEntry &&
              ((mirrorListEntry[mirrorElementKey] = _.without(mirrorListEntry[mirrorElementKey], listEntryUuid)),
              (mirrorListEntry[mirrorElementKeySort] = _.reject(mirrorListEntry[mirrorElementKeySort], [
                'uuid',
                listEntryUuid,
              ])),
              (data = _markListEntryAsUpdated(data, mirrorListEntry, publishTypes.CHANGED, markResourceAsUpdated)))
          }),
          data
        )
      },
      updateMirrorReferencesForEntry = function (params) {
        var data = params.data,
          listElements = params.listElements,
          oldListEntry = params.oldListEntry || {},
          updatedListEntry = params.updatedListEntry,
          markResourceAsUpdated = params.markResourceAsUpdated,
          elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
          referencesEc = _.find(elementcategories, ['name', 'References'])
        return (
          _.forEach(listElements, function (element) {
            if (element.elementcategory === referencesEc.id) {
              var childListId = _.get(element, ['elementData', 'childList', 'id']),
                mirrorElementUUID = _.get(element, ['elementData', 'mirrorElementUUID'])
              if (!_.isNil(childListId) && !_.isNil(mirrorElementUUID)) {
                var referencesKey = element.uuid + '_references',
                  oldReferences = oldListEntry[referencesKey],
                  updatedReferences = updatedListEntry[referencesKey]
                if (!_.isEmpty(oldReferences) || !_.isEmpty(updatedReferences)) {
                  var mirrorElementKey = mirrorElementUUID + '_references',
                    mirrorElementKeySort = mirrorElementUUID + '_references_sort',
                    minimalUpdatedEntry = getMinimalEntryForReferencesSort(updatedListEntry)
                  _.forEach(updatedReferences, function (referenceUUID) {
                    var mirrorListEntry = resourceHandlers.LIST_ENTRY.get(data, {
                      listId: childListId,
                      uuid: referenceUUID,
                    })
                    if (mirrorListEntry) {
                      var updatedMirrorReferences = _.union(mirrorListEntry[mirrorElementKey] || [], [
                        minimalUpdatedEntry.uuid,
                      ])
                      ;(mirrorListEntry[mirrorElementKey] = updatedMirrorReferences),
                        (mirrorListEntry[mirrorElementKeySort] = _.chain([minimalUpdatedEntry])
                          .unionBy(mirrorListEntry[mirrorElementKeySort] || [], 'uuid')
                          .orderBy(function (entry) {
                            return _.indexOf(updatedMirrorReferences, entry.uuid)
                          })
                          .value()),
                        (data = _markListEntryAsUpdated(
                          data,
                          mirrorListEntry,
                          publishTypes.CHANGED,
                          markResourceAsUpdated,
                        ))
                    }
                  })
                  var removedReferences = _.difference(oldReferences, updatedReferences)
                  !1 === _.isEmpty(removedReferences) &&
                    (data = removeEntryFromMirrorReferences({
                      data,
                      referenceElement: element,
                      listEntryUuid: updatedListEntry.uuid,
                      removedReferences,
                      markResourceAsUpdated,
                    }))
                }
              }
            }
          }),
          data
        )
      },
      optimisticallyDeprecateListEntry = function (params) {
        var data = params.data,
          listId = params.listId,
          listEntryUuid = params.listEntryUuid,
          deprecatedAt = params.deprecatedAt || new Date(),
          markResourceAsUpdated = params.markResourceAsUpdated,
          shouldRemoveEntriesFromReferences = params.removeEntriesFromReferences,
          oldListEntry = resourceHandlers.LIST_ENTRY.get(data, { listId, uuid: listEntryUuid })
        if (_.isNil(oldListEntry)) return data
        var updatedListEntry = _.assign({}, oldListEntry, { updated_at: deprecatedAt, deprecated_at: deprecatedAt }),
          elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
          listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId }),
          listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId })
        data = shouldRemoveEntriesFromReferences
          ? (function (params) {
              var data = params.data,
                listEntry = params.listEntry,
                listElements = params.listElements,
                markResourceAsUpdated = params.markResourceAsUpdated,
                elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
                referencesEc = _.find(elementcategories, ['name', 'References'])
              return (
                _.forEach(listElements, function (element) {
                  if (element.elementcategory === referencesEc.id) {
                    var referencesKey = element.uuid + '_references',
                      removedReferences = listEntry[referencesKey]
                    _.isEmpty(removedReferences) ||
                      ((listEntry[referencesKey] = []),
                      (listEntry[referencesKey + '_sort'] = []),
                      (data = _markListEntryAsUpdated(data, listEntry, publishTypes.CHANGED, markResourceAsUpdated)),
                      (data = removeEntryFromMirrorReferences({
                        data,
                        referenceElement: element,
                        listEntryUuid: listEntry.uuid,
                        removedReferences,
                        markResourceAsUpdated,
                      })))
                  }
                }),
                data
              )
            })({ data, listEntry: updatedListEntry, listElements: _.values(listElementsByUuid), markResourceAsUpdated })
          : updateMirrorReferencesForEntry({
              data,
              updatedListEntry,
              listElements: _.values(listElementsByUuid),
              markResourceAsUpdated,
            })
        var subentriesElementcategory = _.find(elementcategories, ['name', 'Subentries']),
          subentriesElements = _.filter(listElementsByUuid, ['elementcategory', subentriesElementcategory.id])
        return (
          _.forEach(subentriesElements, function (subentriesElement) {
            var referencesKey = subentriesElement.uuid + '_references',
              referencesSortKey = subentriesElement.uuid + '_references_sort',
              parentsKey = subentriesElement.uuid + '_parents',
              parentUuid = _.last(updatedListEntry[parentsKey])
            if (parentUuid) {
              var parent = resourceHandlers.LIST_ENTRY.get(data, { listId, uuid: parentUuid })
              ;(parent[referencesKey] = _.without(parent[referencesKey], updatedListEntry.uuid)),
                (parent[referencesSortKey] = _.reject(parent[referencesSortKey], { uuid: updatedListEntry.uuid })),
                (data = _markListEntryAsUpdated(data, parent, publishTypes.CHANGED, markResourceAsUpdated))
            }
            var children = getAllChildrenOfListEntry({
              parentEntry: updatedListEntry,
              subentriesElement,
              listEntriesByUuid,
            })
            _.forEach(children, child => {
              _.assign(child, { updated_at: deprecatedAt, deprecated_at: deprecatedAt }),
                (data = _markListEntryAsUpdated(data, child, publishTypes.CHANGED, markResourceAsUpdated))
            }),
              (data = evaluateSubentryPathsForElement({
                data,
                listElement: subentriesElement,
                markResourceAsUpdated,
                topLevelOrderWasAffected: _.isEmpty(updatedListEntry[parentsKey]),
              }))
          }),
          _markListEntryAsUpdated(data, updatedListEntry, publishTypes.REMOVED, markResourceAsUpdated)
        )
      },
      optimisticallyRestoreListEntry = function (params) {
        var data = params.data,
          listId = params.listId,
          listEntryUuid = params.listEntryUuid,
          updatedAt = params.updatedAt || new Date(),
          markResourceAsUpdated = params.markResourceAsUpdated,
          listEntry = resourceHandlers.LIST_ENTRY.get(data, { listId, uuid: listEntryUuid })
        if (_.isNil(listEntry) || _.isNil(listEntry.deprecated_at)) return data
        var restoredListEntry = _.defaults({ deprecated_at: null, updated_at: updatedAt }, listEntry)
        data = _markListEntryAsUpdated(data, restoredListEntry, publishTypes.ADDED, markResourceAsUpdated)
        var elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
          listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId }),
          listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId })
        data = updateMirrorReferencesForEntry({
          data,
          updatedListEntry: restoredListEntry,
          listElements: _.values(listElementsByUuid),
          markResourceAsUpdated,
        })
        var subentriesElementcategory = _.find(elementcategories, { name: 'Subentries' }),
          subentriesElements = _.filter(listElementsByUuid, { elementcategory: subentriesElementcategory.id })
        return (
          _.forEach(subentriesElements, function (subentriesElement) {
            var referencesKey = subentriesElement.uuid + '_references',
              referencesSortKey = subentriesElement.uuid + '_references_sort',
              parentsKey = subentriesElement.uuid + '_parents',
              parentUuid = _.last(restoredListEntry[parentsKey])
            if (parentUuid) {
              var parent = resourceHandlers.LIST_ENTRY.get(data, { listId, uuid: parentUuid })
              ;(parent[referencesKey] = _.without(parent[referencesKey], listEntryUuid)),
                (parent[referencesSortKey] = _.reject(parent[referencesSortKey], { uuid: listEntryUuid })),
                (data = _markListEntryAsUpdated(data, parent, publishTypes.CHANGED, markResourceAsUpdated))
            }
            var children = getAllChildrenOfListEntry({
              parentEntry: restoredListEntry,
              subentriesElement,
              listEntriesByUuid,
            })
            _.forEach(children, child => {
              _.assign(child, { updated_at: updatedAt, deprecated_at: null }),
                (data = _markListEntryAsUpdated(data, child, publishTypes.CHANGED, markResourceAsUpdated))
            }),
              (data = evaluateSubentryPathsForElement({
                data,
                listElement: subentriesElement,
                markResourceAsUpdated,
                topLevelOrderWasAffected: _.isEmpty(restoredListEntry[parentsKey]),
              }))
          }),
          data
        )
      },
      areAffectedListEntriesCached = function (params) {
        var data = params.data,
          listId = params.listId,
          filter = params.filter,
          invert = !0 === params.invert,
          listEntryUuids = params.listEntryUuids
        return !1 === invert && utils.isFilterEmpty(filter)
          ? _.some(listEntryUuids, function (uuid) {
              return isListEntryCached(data, { listId, uuid })
            })
          : isListAvailableOffline(data, { id: listId })
      },
      getAffectedListEntryUuids = function (params) {
        var data = params.data,
          listId = params.listId,
          filter = params.filter,
          invert = !0 === params.invert,
          listEntryUuids = params.listEntryUuids,
          preFilterListEntries = params.preFilterListEntries || _.identity,
          filterIsEmpty = utils.isFilterEmpty(filter)
        if (!1 === invert && filterIsEmpty) return listEntryUuids
        if (!1 === isListAvailableOffline(data, { id: listId })) return null
        var filteredListEntries = preFilterListEntries(resourceHandlers.LIST_ENTRIES.get(data, { listId }))
        if (!1 === _.isEmpty(filteredListEntries) && !1 === filterIsEmpty) {
          var listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId }),
            elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
            currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
            userTagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(data, {})
          filteredListEntries = utils.filterListEntries({
            listEntries: filteredListEntries,
            filter,
            listElementsByUuid,
            elementcategories,
            currentUser,
            userTagAssignments,
          })
        }
        var filteredListEntryUuids = _.map(filteredListEntries, 'uuid')
        return invert
          ? _.difference(filteredListEntryUuids, listEntryUuids)
          : _.intersection(filteredListEntryUuids, listEntryUuids)
      },
      publishEveryEntryInResponseAndReturnMainEntry = function (params) {
        var mainEntry = params.serverResponse.entry,
          otherEntries = params.serverResponse.entries,
          identifiers = { listId: params.identifiers.listId }
        if (null === otherEntries)
          return (
            resourceHandlers.LIST_ENTRIES.publish({ identifiers, resource: null, publishType: publishTypes.CHANGED }),
            mainEntry
          )
        var entriesByPublishType = _.reduce(
          otherEntries,
          (entriesByPublishType, entry) => {
            var publishType = entry.deprecated_at ? publishTypes.REMOVED : publishTypes.CHANGED
            return (
              _.isNil(entriesByPublishType[publishType]) && (entriesByPublishType[publishType] = []),
              entriesByPublishType[publishType].push(entry),
              entriesByPublishType
            )
          },
          { [params.publishType]: [mainEntry] },
        )
        return (
          _.forEach(entriesByPublishType, (resource, publishType) => {
            resourceHandlers.LIST_ENTRIES.publish({ identifiers, resource, publishType })
          }),
          mainEntry
        )
      },
      makeCreateCommentAction = function (resource) {
        return {
          resource,
          publishType: publishTypes.ADDED,
          payloadValidation: {
            message: { type: 'string' },
            created_at: { type: 'object' },
            parentUUID: { type: ['string', 'null', 'undefined'] },
            enrichments: { type: ['array', 'undefined'] },
          },
          isOptimisticUpdatePossible: function (data, identifiers) {
            return (
              !1 !== isCurrentUserCached(data) &&
              (resource === RESOURCES.LIST_ACTIVITY || resource === RESOURCES.LIST_ENTRY_ACTIVITY
                ? isListCached(data, { id: identifiers.listId })
                : isWorkspaceCached(data, { id: identifiers.workspaceId }))
            )
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              comment = _.assign({ created_at: new Date(), updated_at: new Date() }, payload, {
                uuid: identifiers.uuid,
                type: ZenkitControlsShared.activityTypes.TYPE.COMMENT,
                isBulk: !1,
                userId: currentUser.id,
                userInitials: currentUser.initials,
                userUsername: currentUser.username,
                userFullname: currentUser.fullname,
                userDisplayname: currentUser.displayname,
                userImagelink: currentUser.imageLink,
                userIsImagePreferred: currentUser.isImagePreferred,
              })
            if (resource === RESOURCES.WORKSPACE_ACTIVITY) {
              var workspace = resourceHandlers.WORKSPACE.get(data, { id: identifiers.workspaceId })
              _.assign(comment, {
                workspaceId: identifiers.workspaceId,
                workspaceShortId: workspace.shortId,
                workspaceName: workspace.name,
                created_in: ZenkitControlsShared.activityTypes.CREATED_IN.WORKSPACE,
              })
            } else {
              var list = resourceHandlers.LIST.get(data, { id: identifiers.listId }),
                created_in =
                  resource === RESOURCES.LIST_ENTRY_ACTIVITY
                    ? ZenkitControlsShared.activityTypes.CREATED_IN.LIST_ENTRY
                    : ZenkitControlsShared.activityTypes.CREATED_IN.LIST
              _.assign(comment, {
                listId: identifiers.listId,
                workspaceId: list.workspaceId,
                listShortId: list.shortId,
                listName: list.name,
                listEntryUUID: identifiers.listEntryUuid,
                created_in,
              })
            }
            if (resource === RESOURCES.LIST_ENTRY_ACTIVITY) {
              var listEntry = resourceHandlers.LIST_ENTRY.get(data, {
                listId: identifiers.listId,
                uuid: identifiers.listEntryUuid,
              })
              listEntry &&
                ((listEntry.comment_count += 1),
                (data = _markListEntryAsUpdated(data, listEntry, publishTypes.CHANGED, markResourceAsUpdated)))
            }
            return resourceHandlers[resource].set(data, identifiers, comment)
          },
          save: function (data, identifiers, payload, updatePayload) {
            var enrichments = payload.enrichments || []
            return Promise.reduce(
              enrichments,
              function (payload, enrichment, index) {
                if (enrichment.type !== ZenkitControlsShared.enrichmentTypes.FILE) return payload
                if (!1 === _.isNil(enrichment.fileId)) return payload
                if (_.isNil(enrichment.fileBlob))
                  throw new Error('Invalid file enrichment, either a fileId or fileBlob must be passed.')
                var url =
                  resource === RESOURCES.WORKSPACE_ACTIVITY
                    ? zenkitFetch.buildUrl('workspaces/:workspaceAllId/files', {
                        workspaceAllId: identifiers.workspaceId,
                      })
                    : zenkitFetch.buildUrl('lists/:listAllId/files', { listAllId: identifiers.listId })
                return uploadFile(url, { uuid: enrichment.fileUUID, file: enrichment.fileBlob })
                  .then(function (file) {
                    var fileEnrichment = _.defaults(
                        { fileId: file.id, file },
                        _.pick(enrichment, ['uuid', 'type', 'created_at']),
                      ),
                      enrichments = _.map(payload.enrichments, function (enrichment, i) {
                        return index === i ? fileEnrichment : enrichment
                      })
                    return _.defaults({ enrichments }, payload)
                  })
                  .tap(updatePayload)
              },
              payload,
            ).then(function (payload) {
              var serverPayload = _.defaults(
                  {
                    uuid: identifiers.uuid,
                    enrichments: _.map(payload.enrichments, function (enrichment) {
                      if (enrichment.type === ZenkitControlsShared.enrichmentTypes.FILE)
                        return _.omit(enrichment, ['file'])
                      if (enrichment.type === ZenkitControlsShared.enrichmentTypes.LINK) {
                        var _data = _.pick(enrichment.data, ['url'])
                        return _.defaults({ data: _data }, enrichment)
                      }
                      return enrichment
                    }),
                  },
                  payload,
                ),
                url =
                  resource === RESOURCES.LIST_ENTRY_ACTIVITY
                    ? zenkitFetch.buildUrl('users/me/lists/:listAllId/entries/:entryAllId/activities', {
                        listAllId: identifiers.listId,
                        entryAllId: identifiers.listEntryUuid,
                      })
                    : resource === RESOURCES.LIST_ACTIVITY
                    ? zenkitFetch.buildUrl('users/me/lists/:listAllId/activities', { listAllId: identifiers.listId })
                    : zenkitFetch.buildUrl('/users/me/workspaces/:workspaceAllId/activities', {
                        workspaceAllId: identifiers.workspaceId,
                      })
              return zenkitFetch.post(url, serverPayload)
            })
          },
          getErrorMessage: function (data, identifiers, payload) {
            return {
              translateId: 'STORE.ERROR_MESSAGES.CREATE_LIST_COMMENT_FAILED',
              translateValues: { message: payload.message },
            }
          },
        }
      },
      actionHandlers = {
        INSTALL_APP: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: { appType: { type: 'string' } },
          save: function (data, identifiers, payload) {
            return zenkitFetch.post('users/me/app-instances', payload)
          },
        },
        UNINSTALL_APP: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: { password: { type: 'string' }, appType: { type: 'string' } },
          save: function (data, identifiers, payload) {
            return zenkitFetch.delete('users/me/app-instances', payload)
          },
        },
        UPDATE_CURRENT_USER: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isCurrentUserCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.CURRENT_USER,
              user = resourceHandler.get(data, identifiers),
              updatedUser = _.assign({}, user, payload)
            return resourceHandler.set(data, identifiers, updatedUser)
          },
          save: function (data, identifiers, payload) {
            var validPayload = _.pick(payload, [
              'fullname',
              'username',
              'initials',
              'description',
              'imageLink',
              'trello_token',
              'timezone',
              'isImagePreferred',
            ])
            return zenkitFetchPreventSockets.put('users/me/changeProfile', validPayload).then(function (result) {
              return _.get(result, ['user'])
            })
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.USER_UPDATE_FAILED' }),
        },
        UPLOAD_PROFILE_IMAGE: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload, updatePayload) {
            return (
              payload.fileShortId
                ? Promise.resolve(payload.fileShortId)
                : uploadFile('files', { file: payload.file })
                    .then(_.head)
                    .get('shortId')
                    .tap(function (fileShortId) {
                      return updatePayload({ fileShortId })
                    })
            )
              .then(function (fileShortId) {
                return zenkitFetchPreventSockets.put('users/me/changeProfile', {
                  imageLink: fileShortId,
                  isImagePreferred: !0,
                })
              })
              .get('user')
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.USER_UPDATE_FAILED' }),
        },
        UPLOAD_USER_FILE: {
          resource: RESOURCES.NO_RESOURCE,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            return uploadFile('files', payload).then(_.head)
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.USER_UPDATE_FAILED' }),
        },
        UPDATE_CURRENT_USER_BACKGROUND: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isCurrentUserCached,
          payloadValidation: {
            deviceType: { type: 'string', default: 'desktop' },
            backgroundId: { type: ['number', 'null'] },
            dark: { type: ['boolean', 'undefined'] },
            transparent: { type: ['boolean', 'undefined'] },
          },
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.CURRENT_USER,
              user = resourceHandler.get(data, identifiers),
              settingsKey = payload.deviceType + 'Background',
              current = _.get(user, ['settings', settingsKey]),
              settings = _.defaults(_.omit(payload, ['deviceType']), current)
            return _.set(user, ['settings', settingsKey], settings), resourceHandler.set(data, identifiers, user)
          },
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.put('users/me/background', payload)
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.USER_UPDATE_FAILED' }),
        },
        DELETE_CURRENT_USER: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: { password: { type: 'string' }, reason: { type: ['string', 'null', 'undefined'] } },
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.delete('users/me', payload).then(_.constant(null))
          },
          getErrorMessage: _.constant({ translateId: 'PROFILE.SETTINGS.LEAVE.ERROR' }),
        },
        RESET_ONBOARDING: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isCurrentUserCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.CURRENT_USER,
              user = resourceHandler.get(data, identifiers)
            return (
              (user.settings = _.assign({}, user.settings, {
                textfieldInfoDismissed: !1,
                listElementSettingsInfoDismissed: !1,
                workspaceOnboardingVideoDismissed: !1,
                themeOnboardingDismissed: !1,
                addElementExampleInDetailsViewDismissed: !1,
                taskAddonInfoDismissed: !1,
                userAssignmentsInfoDismissed: !1,
                userTagsInfoDismissed: !1,
              })),
              resourceHandler.set(data, identifiers, user)
            )
          },
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.put('/users/me/reset-onboarding')
          },
          getErrorMessage: _.constant({ translateId: 'PROFILE.SETTINGS.ONBOARDING.ERROR' }),
        },
        UPDATE_USER_SETTINGS: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isCurrentUserCached,
          getUndoAction: function (data, identifiers, payload) {
            var currentUser = resourceHandlers.CURRENT_USER.get(data, identifiers)
            return {
              action: 'UPDATE_USER_SETTINGS',
              identifiers,
              payload: _.pick(currentUser.settings, _.keys(payload)),
            }
          },
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.CURRENT_USER,
              user = resourceHandler.get(data, identifiers)
            return _.assign(user.settings, payload), resourceHandler.set(data, identifiers, user)
          },
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.put('users/me/settings', payload)
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.USER_UPDATE_FAILED' }),
        },
        ACCEPT_TERMS: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isCurrentUserCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.CURRENT_USER,
              currentUser = resourceHandler.get(data, identifiers),
              updatedUser = _.assign(currentUser, { terms_accepted_at: payload })
            return resourceHandler.set(data, identifiers, updatedUser)
          },
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.put('users/me/accept-terms', { terms_accepted_at: payload })
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.ACCEPT_TERMS_FAILED' }),
        },
        ACCEPT_PRIVACY_POLICY: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          payloadValidation: { privacy_policy_accepted_at: { customCheck: _.isDate } },
          isOptimisticUpdatePossible: isCurrentUserCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.CURRENT_USER,
              currentUser = resourceHandler.get(data, identifiers),
              updatedUser = _.assign(currentUser, payload)
            return resourceHandler.set(data, identifiers, updatedUser)
          },
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.put('users/me/accept-privacy-policy', payload)
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.ACCEPT_PRIVACY_POLICY_FAILED' }),
        },
        CREATE_EMAIL: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isCurrentUserCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.CURRENT_USER,
              currentUser = resourceHandler.get(data, identifiers)
            return currentUser.emails.push(payload), resourceHandler.set(data, identifiers, currentUser)
          },
          save: function (data, identifiers, payload) {
            return zenkitFetch.post('users/me/emails', { email: payload.email })
          },
          getErrorMessage: function (data, identifiers, payload) {
            return {
              translateId: 'STORE.ERROR_MESSAGES.CREATE_EMAIL_FAILED',
              translateValues: { email: payload.email },
            }
          },
        },
        DEPRECATE_EMAIL: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isCurrentUserCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.CURRENT_USER,
              currentUser = resourceHandler.get(data, identifiers)
            return (
              (currentUser.emails = _.reject(currentUser.emails, { id: payload.emailId })),
              resourceHandler.set(data, identifiers, currentUser)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('emails/:emailAllId', { emailAllId: payload.emailId })
            return zenkitFetch.delete(url)
          },
          getErrorMessage: _.constant({ translateId: 'PROFILE.SETTINGS.EMAIL.DELETE_ERROR' }),
        },
        DEPRECATE_PROVIDER: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          payloadValidation: { providerUUID: { type: 'string' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('users/me/providers/:providerUUID', { providerUUID: payload.providerUUID })
            return zenkitFetch.delete(url)
          },
          getErrorMessage: _.constant({ translateId: 'PROFILE.SETTINGS.PROVIDERS.DELETE_ERROR' }),
        },
        CHANGE_API_KEY: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.put('users/me/apikey')
          },
          getErrorMessage: _.constant({ translateId: 'PROFILE.SETTINGS.API_KEY.ERROR' }),
        },
        FINISH_2FA_SETUP: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          payloadValidation: { token: { type: 'string' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.put('users/me/twofactor/setup', { token: payload.token })
          },
          getErrorMessage: _.constant({ translateId: '2FA.ERROR_INVALID_TOKEN' }),
        },
        DISABLE_2FA: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: { token: { type: 'string' } },
          save: function (data, identifiers, payload) {
            return zenkitFetchPreventSockets.delete('users/me/twofactor/setup', payload)
          },
          getErrorMessage: _.constant({ translateId: '2FA.ERROR_DISABLE' }),
        },
        CREATE_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: areListElementsCached,
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var listEntryToAdd = _.defaults(
                {},
                identifiers,
                computeListEntryPropertiesForOptimisticUpdate(data, identifiers, payload),
              ),
              listElements = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId })
            if (
              (_.forEach(listElements, function (listElement) {
                _.defaults(listEntryToAdd, utils.getEntryDefaultsForElement(listElement))
              }),
              _.isNil(listEntryToAdd.sortOrder) || _.includes(['highest', 'lowest'], listEntryToAdd.sortOrder))
            ) {
              var sortOrder,
                listEntries = resourceHandlers.LIST_ENTRIES.get(data, { listId: identifiers.listId }),
                user = resourceHandlers.CURRENT_USER.get(data, {}),
                sortOrderString =
                  listEntryToAdd.sortOrder || _.get(user, ['settings', 'defaultSortOrderForNewEntries']) || 'lowest',
                sortOrders = _.compact(
                  _.map(listEntries, function (listEntry) {
                    return parseFloat(listEntry.sortOrder)
                  }),
                ),
                listEntryReorderConfig = ZenkitControlsShared.listEntryReorderConfig
              ;(sortOrder = _.isEmpty(sortOrders)
                ? listEntryReorderConfig.defaultStart
                : 'highest' === sortOrderString
                ? _.max(sortOrders) + listEntryReorderConfig.step
                : _.min(sortOrders) - listEntryReorderConfig.step),
                (listEntryToAdd.sortOrder = sortOrder)
            }
            return (
              (data = _markListEntryAsUpdated(data, listEntryToAdd, publishTypes.ADDED, markResourceAsUpdated)),
              (data = updateMirrorReferencesForEntry({
                data,
                updatedListEntry: listEntryToAdd,
                listElements: _.values(listElements),
                markResourceAsUpdated,
              })),
              (data = evaluateSubentryPathsForList({
                data,
                listId: identifiers.listId,
                markResourceAsUpdated,
                topLevelOrderWasAffected: !0,
              }))
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            return { action: 'DEPRECATE_LIST_ENTRY', identifiers, payload: { deprecated_at: new Date() } }
          },
          save: function (data, identifiers, payload) {
            var cachedListElementsMap = data.elementsPerList[identifiers.listId],
              whenListElementsAreLoaded = Promise.resolve(_.values(cachedListElementsMap))
            if (_.isEmpty(cachedListElementsMap)) {
              var url = zenkitFetch.buildUrl('lists/:listAllId/elements', { listAllId: identifiers.listId })
              whenListElementsAreLoaded = zenkitFetch.get(url)
            }
            return whenListElementsAreLoaded.then(function (listElements) {
              payload = reduceListEntryCreateOptionsToDatabaseRelevantData({
                listEntryPrototype: _.assign({}, payload, identifiers),
                listElements,
                elementcategories: data.elementcategories,
              })
              var url = zenkitFetch.buildUrl('lists/:listAllId/entries', { listAllId: identifiers.listId })
              return zenkitFetch.post(url, payload)
            })
          },
          updateInMemoryDb: function (params) {
            return params.inMemoryDb
              .update(RESOURCES.LIST_ENTRY, params.identifiers, params.resource)
              .then(function () {
                return updateInMemoryDbSubentryPathsForList({
                  listId: params.identifiers.listId,
                  inMemoryDb: params.inMemoryDb,
                  topLevelOrderWasAffected: !0,
                })
              })
          },
          getErrorMessage: function (data, identifiers, payload, err) {
            return {
              translateId:
                'STORE.ERROR_MESSAGES.CREATE_ENTRY_' +
                (_.get(err, ['code']) === ZenkitErrorCodes.RESOURCE_ALREADY_EXISTS.code ? 'EXISTS' : 'FAILED'),
              translateValues: { displayString: payload.displayString },
            }
          },
        },
        CREATE_LIST_ENTRIES_BULK: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.ADDED,
          payloadValidation: { entries: { type: 'array' } },
          isOptimisticUpdatePossible: areListElementsCached,
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var elementsByUUID = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
              currentEntries = resourceHandlers.LIST_ENTRIES.get(data, { listId: identifiers.listId }),
              reorderConfig = ZenkitControlsShared.listEntryReorderConfig,
              lastEntry = _.maxBy(currentEntries, entry => _.toFinite(entry.sortOrder)),
              initalSortOrder = lastEntry ? _.toFinite(lastEntry.sortOrder) + 1 : reorderConfig.defaultStart,
              createdEntries = _.map(payload.entries, (entryPrototype, index) => {
                var entry = _.defaults(
                  { listId: identifiers.listId, sortOrder: initalSortOrder + index * reorderConfig.step },
                  computeListEntryPropertiesForOptimisticUpdate(data, identifiers, entryPrototype),
                )
                return (
                  _.forEach(elementsByUUID, element => {
                    _.defaults(entry, utils.getEntryDefaultsForElement(element))
                  }),
                  entry
                )
              })
            return (
              (data = (function (_ref10) {
                var { data, listElements, updatedEntries, oldEntriesByUUID = {}, markResourceAsUpdated } = _ref10
                return _.reduce(
                  updatedEntries,
                  function (data, updatedListEntry) {
                    var oldListEntry = oldEntriesByUUID[updatedListEntry.uuid] || null
                    return updateMirrorReferencesForEntry({
                      data,
                      updatedListEntry,
                      oldListEntry,
                      listElements,
                      markResourceAsUpdated,
                    })
                  },
                  data,
                )
              })({
                data: (data = (function (_ref8) {
                  var { data, entries, publishType, markResourceAsUpdated } = _ref8
                  return _.reduce(
                    entries,
                    (data, entry) => _markListEntryAsUpdated(data, entry, publishType, markResourceAsUpdated),
                    data,
                  )
                })({ data, entries: createdEntries, publishType: publishTypes.ADDED, markResourceAsUpdated })),
                updatedEntries: createdEntries,
                listElements: _.values(elementsByUUID),
                markResourceAsUpdated,
              })),
              (data = evaluateSubentryPathsForList({
                data,
                listId: identifiers.listId,
                markResourceAsUpdated,
                topLevelOrderWasAffected: !0,
              }))
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            return {
              action: 'DEPRECATE_LIST_ENTRIES',
              identifiers,
              payload: { listEntryUuids: _.map(payload.entries, 'uuid') },
            }
          },
          save: function (data, identifiers, payload) {
            var cachedListElementsMap = data.elementsPerList[identifiers.listId],
              whenListElementsAreLoaded = Promise.resolve(_.values(cachedListElementsMap))
            if (_.isEmpty(cachedListElementsMap)) {
              var url = zenkitFetch.buildUrl('lists/:listAllId/elements', { listAllId: identifiers.listId })
              whenListElementsAreLoaded = zenkitFetch.get(url)
            }
            return whenListElementsAreLoaded.then(function (listElements) {
              var entries = _.map(payload.entries, listEntryPrototype =>
                  reduceListEntryCreateOptionsToDatabaseRelevantData({
                    listEntryPrototype,
                    listElements,
                    elementcategories: data.elementcategories,
                  }),
                ),
                url = zenkitFetch.buildUrl('lists/:listAllId/entries-bulk', { listAllId: identifiers.listId })
              return zenkitFetch.post(url, entries)
            })
          },
          updateInMemoryDb: function (_ref11) {
            var { inMemoryDb, identifiers, resource } = _ref11,
              updateParams = _.map(resource, entry => ({
                resource: RESOURCES.LIST_ENTRY,
                identifiers: _.pick(entry, ['listId', 'uuid']),
                value: entry,
              }))
            return inMemoryDb
              .updateMultiple(updateParams)
              .then(() =>
                updateInMemoryDbSubentryPathsForList({
                  inMemoryDb,
                  listId: identifiers.listId,
                  topLevelOrderWasAffected: !1,
                }),
              )
          },
        },
        CREATE_SUBENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: areListElementsCached,
          payloadValidation: {
            subentry: { type: 'object' },
            listElementUuid: { type: 'string' },
            beforeAnchorUuid: { type: ['string', 'null', 'undefined'] },
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            if (_.isNil(payload.subentry.uuid))
              throw new Error('CREATE_SUBENTRY: subentry.uuid is required for the optimistic update.')
            if (_.isNil(payload.subentry.listId))
              throw new Error('CREATE_SUBENTRY: subentry.listId is required for the optimistic update.')
            var resourceHandler = resourceHandlers.LIST_ENTRY,
              listEntryToAdd = computeListEntryPropertiesForOptimisticUpdate(
                data,
                { listId: identifiers.listId, uuid: payload.subentry.uuid },
                payload.subentry,
              ),
              listElements = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId })
            _.forEach(listElements, function (listElement) {
              _.defaults(listEntryToAdd, utils.getEntryDefaultsForElement(listElement))
            }),
              (data = _markListEntryAsUpdated(data, listEntryToAdd, publishTypes.ADDED, markResourceAsUpdated)),
              (data = updateMirrorReferencesForEntry({
                data,
                updatedListEntry: listEntryToAdd,
                listElements: _.values(listElements),
                markResourceAsUpdated,
              }))
            var listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
              parentListEntry = resourceHandler.get(data, identifiers),
              subentriesElement = listElementsByUuid[payload.listElementUuid],
              referencesKey = subentriesElement.uuid + '_references',
              referencesSortKey = subentriesElement.uuid + '_references_sort',
              beforeAnchorUuid = payload.beforeAnchorUuid,
              indexToUse = _.size(parentListEntry[referencesKey])
            return (
              null === beforeAnchorUuid
                ? (indexToUse = 0)
                : beforeAnchorUuid && (indexToUse = _.indexOf(parentListEntry[referencesKey], beforeAnchorUuid) + 1),
              (parentListEntry[referencesKey] = _.union(
                parentListEntry[referencesKey].slice(0, indexToUse),
                [listEntryToAdd.uuid],
                parentListEntry[referencesKey].slice(indexToUse),
              )),
              (parentListEntry[referencesSortKey] = _.unionBy(
                parentListEntry[referencesSortKey].slice(0, indexToUse),
                [listEntryToAdd],
                parentListEntry[referencesSortKey].slice(indexToUse),
                'uuid',
              )),
              (data = _markListEntryAsUpdated(data, parentListEntry, publishTypes.CHANGED, markResourceAsUpdated)),
              (data = evaluateSubentryPathsForElement({
                data,
                listElement: subentriesElement,
                markResourceAsUpdated,
                topLevelOrderWasAffected: !1,
              }))
            )
          },
          optimisticServerResponse: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ENTRY
            return {
              parentEntry: resourceHandler.get(data, identifiers),
              subentry: resourceHandler.get(data, _.pick(payload.subentry, ['listId', 'uuid'])),
            }
          },
          getUndoAction: function (data, identifiers, payload) {
            return {
              action: 'DEPRECATE_LIST_ENTRY',
              identifiers: { listId: identifiers.listId, uuid: payload.subentry.uuid },
              payload: { deprecated_at: new Date() },
            }
          },
          save: function (data, identifiers, payload) {
            var cachedListElementsMap = data.elementsPerList[identifiers.listId],
              whenListElementsAreLoaded = Promise.resolve(_.values(cachedListElementsMap))
            if (_.isEmpty(cachedListElementsMap)) {
              var url = zenkitFetch.buildUrl('lists/:listAllId/elements', { listAllId: identifiers.listId })
              whenListElementsAreLoaded = zenkitFetch.get(url)
            }
            return whenListElementsAreLoaded.then(function (listElements) {
              var subentry = reduceListEntryCreateOptionsToDatabaseRelevantData({
                  listEntryPrototype: payload.subentry,
                  listElements,
                  elementcategories: data.elementcategories,
                }),
                url = zenkitFetch.buildUrl(
                  'lists/:listAllId/entries/:parentEntryAllId/elements/:elementAllId/subentries',
                  {
                    listAllId: identifiers.listId,
                    parentEntryAllId: identifiers.uuid,
                    elementAllId: payload.listElementUuid,
                  },
                )
              return zenkitFetch.post(url, subentry, { query: { beforeAnchorUuid: payload.beforeAnchorUuid } })
            })
          },
          updateInMemoryDb: function (params) {
            var parent = params.resource.parentEntry,
              subentry = params.resource.subentry
            return params.inMemoryDb
              .updateMultiple([
                { resource: RESOURCES.LIST_ENTRY, identifiers: _.pick(subentry, ['listId', 'uuid']), value: subentry },
                { resource: RESOURCES.LIST_ENTRY, identifiers: _.pick(parent, ['listId', 'uuid']), value: parent },
              ])
              .then(function () {
                return updateInMemoryDbSubentryPathsForList({
                  listId: params.identifiers.listId,
                  inMemoryDb: params.inMemoryDb,
                  topLevelOrderWasAffected: !1,
                })
              })
          },
          publishServerResponseAndReturnResource: function (params) {
            params = utils.validateParameters(params, {
              data: { type: 'object' },
              identifiers: { type: 'object' },
              publishType: { type: 'string' },
              serverResponse: { type: 'object' },
            })
            var resourceHandler = resourceHandlers.LIST_ENTRY
            return (
              resourceHandler.publish({
                identifiers: params.identifiers,
                publishType: params.publishType,
                resource: params.serverResponse.parentEntry,
              }),
              resourceHandler.publish({
                identifiers: _.pick(params.serverResponse.subentry, ['listId', 'uuid']),
                publishType: publishTypes.ADDED,
                resource: params.serverResponse.subentry,
              }),
              params.serverResponse
            )
          },
          getErrorMessage: function (data, identifiers, payload, err) {
            return {
              translateId:
                'STORE.ERROR_MESSAGES.CREATE_ENTRY_' +
                (_.get(err, ['code']) === ZenkitErrorCodes.RESOURCE_ALREADY_EXISTS.code ? 'EXISTS' : 'FAILED'),
              translateValues: { displayString: payload.subentry.displayString },
            }
          },
        },
        CREATE_SUBENTRIES_BULK: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: areListElementsCached,
          payloadValidation: {
            subentryWrappers: { type: 'array' },
            listElementUuid: { type: 'string' },
            beforeAnchorUuid: { type: ['string', 'null', 'undefined'] },
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var resourceHandler = resourceHandlers.LIST_ENTRY,
              parentListEntry = resourceHandler.get(data, identifiers),
              subentriesElement = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId })[
                payload.listElementUuid
              ],
              pathKey = subentriesElement.uuid + '_path',
              referencesKey = subentriesElement.uuid + '_references',
              referencesSortKey = subentriesElement.uuid + '_references_sort',
              minTargetDepth = utils.subentryPathToDepth(parentListEntry[pathKey]) + 1,
              normalizedSubentryWrappers = _.map(payload.subentryWrappers, function (wrapper, index) {
                if (
                  ((0 === index || _.isNil(wrapper.targetDepth)) && (wrapper.targetDepth = minTargetDepth),
                  (wrapper.entry.listId = identifiers.listId),
                  _.isNil(wrapper.entry.uuid))
                )
                  throw new Error('CREATE_SUBENTRIES_BULK: entry.uuid is required for the optimistic update.')
                return wrapper
              }),
              listEntriesToAdd = _.map(payload.subentryWrappers, function (wrapper) {
                return computeListEntryPropertiesForOptimisticUpdate(
                  data,
                  { listId: identifiers.listId, uuid: wrapper.entry.uuid },
                  wrapper.entry,
                )
              }),
              listElements = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId })
            _.forEach(listElements, function (listElement) {
              var defaultValues = utils.getEntryDefaultsForElement(listElement)
              _.every(defaultValues, _.isNil) ||
                (listEntriesToAdd = _.map(listEntriesToAdd, function (listEntry) {
                  return _.defaults(listEntry, defaultValues)
                }))
            }),
              _.forEach(listEntriesToAdd, function (listEntry) {
                ;(data = _markListEntryAsUpdated(data, listEntry, publishTypes.ADDED, markResourceAsUpdated)),
                  (data = updateMirrorReferencesForEntry({
                    data,
                    updatedListEntry: listEntry,
                    listElements: _.values(listElements),
                    markResourceAsUpdated,
                  }))
              })
            var beforeAnchorUuid = payload.beforeAnchorUuid,
              indexToUse = _.size(parentListEntry[referencesKey])
            null === beforeAnchorUuid
              ? (indexToUse = 0)
              : beforeAnchorUuid && (indexToUse = _.indexOf(parentListEntry[referencesKey], beforeAnchorUuid) + 1)
            var listEntriesToAddByUuid = _.keyBy(listEntriesToAdd, 'uuid'),
              uuidsForParent = _.map(
                _.filter(payload.subentryWrappers, function (wrapper) {
                  return wrapper.targetDepth <= minTargetDepth
                }),
                'entry.uuid',
              ),
              listEntriesForParentReferencesSort = _.map(uuidsForParent, function (uuid) {
                return getMinimalEntryForReferencesSort(listEntriesToAddByUuid[uuid])
              })
            ;(parentListEntry[referencesKey] = _.union(
              parentListEntry[referencesKey].slice(0, indexToUse),
              uuidsForParent,
              parentListEntry[referencesKey].slice(indexToUse),
            )),
              (parentListEntry[referencesSortKey] = _.unionBy(
                parentListEntry[referencesSortKey].slice(0, indexToUse),
                listEntriesForParentReferencesSort,
                parentListEntry[referencesSortKey].slice(indexToUse),
                'uuid',
              )),
              (data = _markListEntryAsUpdated(data, parentListEntry, publishTypes.CHANGED, markResourceAsUpdated))
            var updates = _.reduce(
              normalizedSubentryWrappers,
              function (updates, wrapper, index) {
                if (wrapper.targetDepth <= minTargetDepth) return updates
                if (0 === index) throw new Error('This target depth is not supported for the first subentry.')
                var previousWrapperWithLowerDepth = _.findLast(
                  normalizedSubentryWrappers.slice(0, index),
                  function (previousWrapper) {
                    return previousWrapper.targetDepth < wrapper.targetDepth
                  },
                )
                if (_.isNil(previousWrapperWithLowerDepth))
                  throw new Error('Previous entry with a lower depth not found')
                var parentUuid = previousWrapperWithLowerDepth.entry.uuid
                return (
                  _.isNil(updates[parentUuid]) && (updates[parentUuid] = []),
                  updates[parentUuid].push(wrapper.entry.uuid),
                  updates
                )
              },
              {},
            )
            return (
              _.forEach(updates, function (childUuids, parentUuid) {
                var parent = resourceHandler.get(data, { listId: identifiers.listId, uuid: parentUuid }),
                  childrenSort = _.map(childUuids, function (uuid) {
                    return getMinimalEntryForReferencesSort(listEntriesToAddByUuid[uuid])
                  })
                ;(parent[referencesKey] = childUuids),
                  (parent[referencesSortKey] = childrenSort),
                  (data = _markListEntryAsUpdated(data, parent, publishTypes.CHANGED, markResourceAsUpdated))
              }),
              (data = evaluateSubentryPathsForElement({
                data,
                listElement: subentriesElement,
                markResourceAsUpdated,
                topLevelOrderWasAffected: !1,
              }))
            )
          },
          optimisticServerResponse: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ENTRY
            return {
              parentEntry: resourceHandler.get(data, identifiers),
              subentries: _.map(payload.subentryWrappers, function (wrapper) {
                return resourceHandler.get(data, { listId: identifiers.listId, uuid: wrapper.entry.uuid })
              }),
            }
          },
          getUndoAction: function (data, identifiers, payload) {
            var uuids = _.map(payload.subentryWrappers, 'entry.uuid')
            return {
              action: 'DEPRECATE_LIST_ENTRIES',
              identifiers: { listId: identifiers.listId },
              payload: { listEntryUuids: uuids },
            }
          },
          save: function (data, identifiers, payload) {
            var cachedListElementsMap = data.elementsPerList[identifiers.listId],
              whenListElementsAreLoaded = Promise.resolve(_.values(cachedListElementsMap))
            if (_.isEmpty(cachedListElementsMap)) {
              var url = zenkitFetch.buildUrl('lists/:listAllId/elements', { listAllId: identifiers.listId })
              whenListElementsAreLoaded = zenkitFetch.get(url)
            }
            return whenListElementsAreLoaded.then(function (listElements) {
              var wrappers = _.map(payload.subentryWrappers, function (wrapper) {
                  return (
                    (wrapper.entry = reduceListEntryCreateOptionsToDatabaseRelevantData({
                      listEntryPrototype: wrapper.entry,
                      listElements,
                      elementcategories: data.elementcategories,
                    })),
                    wrapper
                  )
                }),
                url = zenkitFetch.buildUrl(
                  'lists/:listAllId/entries/:parentEntryAllId/elements/:elementAllId/subentries-bulk',
                  {
                    listAllId: identifiers.listId,
                    parentEntryAllId: identifiers.uuid,
                    elementAllId: payload.listElementUuid,
                  },
                )
              return zenkitFetch.post(url, wrappers, { query: { beforeAnchorUuid: payload.beforeAnchorUuid } })
            })
          },
          updateInMemoryDb: function (params) {
            var parent = params.resource.parentEntry,
              updateParams = _.map(params.resource.subentries, function (listEntry) {
                return {
                  resource: RESOURCES.LIST_ENTRY,
                  identifiers: _.pick(listEntry, ['listId', 'uuid']),
                  value: listEntry,
                }
              })
            return (
              updateParams.unshift({
                resource: RESOURCES.LIST_ENTRY,
                identifiers: _.pick(parent, ['listId', 'uuid']),
                value: parent,
              }),
              params.inMemoryDb.updateMultiple(updateParams).then(function () {
                return updateInMemoryDbSubentryPathsForList({
                  listId: params.identifiers.listId,
                  inMemoryDb: params.inMemoryDb,
                  topLevelOrderWasAffected: !1,
                })
              })
            )
          },
          publishServerResponseAndReturnResource: function (params) {
            params = utils.validateParameters(params, {
              data: { type: 'object' },
              identifiers: { type: 'object' },
              publishType: { type: 'string' },
              serverResponse: { type: 'object' },
            })
            var resourceHandler = resourceHandlers.LIST_ENTRY
            return (
              resourceHandler.publish({
                identifiers: params.identifiers,
                publishType: params.publishType,
                resource: params.serverResponse.parentEntry,
              }),
              _.forEach(params.serverResponse.subentries, function (listEntry) {
                resourceHandler.publish({
                  identifiers: _.pick(listEntry, ['listId', 'uuid']),
                  publishType: publishTypes.ADDED,
                  resource: listEntry,
                })
              }),
              params.serverResponse
            )
          },
        },
        UPDATE_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            return (
              !1 !== areListElementsCached(data, identifiers) &&
              !1 ===
                _.some(payload, function (value, key) {
                  if (!1 === _.includes(key, '_')) return !1
                  var uuid = _.head(_.split(key, '_')),
                    listElement = resourceHandlers.LIST_ELEMENT.get(data, { listId: identifiers.listId, uuid }),
                    childList = _.get(listElement, ['elementData', 'childList'])
                  return !_.isNil(childList) && !0 !== isListAvailableOffline(data, { id: childList.id })
                })
            )
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var resourceHandler = resourceHandlers.LIST_ENTRY,
              oldListEntry = resourceHandler.get(data, identifiers)
            if (_.isNil(oldListEntry)) return data
            var updatedListEntry = _.assign(
              {},
              oldListEntry,
              computeListEntryPropertiesForOptimisticUpdate(data, identifiers, payload),
            )
            data = _markListEntryAsUpdated(data, updatedListEntry, publishTypes.CHANGED, markResourceAsUpdated)
            var listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {})
            data = updateMirrorReferencesForEntry({
              data,
              oldListEntry,
              updatedListEntry,
              listElements: _.values(listElementsByUuid),
              markResourceAsUpdated,
            })
            var subentriesEc = _.find(elementcategories, { name: 'Subentries' }),
              subentriesElements = _.filter(listElementsByUuid, { elementcategory: subentriesEc.id }),
              list = resourceHandlers.LIST.get(data, { id: identifiers.listId }),
              taskData = utils.getTaskData({
                list,
                listElements: _.values(listElementsByUuid),
                elementcategories,
                appType: globals.appType,
              }),
              primaryKey = _.find(listElementsByUuid, { isPrimary: !0 }).uuid + '_text'
            return (
              _.forEach(subentriesElements, function (subentriesElement) {
                var referencesKey = subentriesElement.uuid + '_references',
                  parentsKey = subentriesElement.uuid + '_parents',
                  referencesSortKey = subentriesElement.uuid + '_references_sort',
                  connectedKey = subentriesElement.uuid + '_connected'
                if (
                  ((function () {
                    if (
                      !_.isNil(payload[primaryKey]) ||
                      (!_.isNil(taskData) && !_.isNil(payload[taskData.listElementKey]))
                    ) {
                      var directParentUuid = _.last(updatedListEntry[parentsKey])
                      if (!_.isNil(directParentUuid)) {
                        var directParent = resourceHandler.get(data, {
                          listId: identifiers.listId,
                          uuid: directParentUuid,
                        })
                        if (!_.isNil(directParent)) {
                          var columns = ['id', 'uuid', 'shortId', 'listId', 'displayString', 'deprecated_at']
                          taskData && columns.push(taskData.listElementKey),
                            (directParent[referencesSortKey] = _.map(
                              directParent[referencesSortKey],
                              function (sibling) {
                                return sibling.uuid === identifiers.uuid ? _.pick(updatedListEntry, columns) : sibling
                              },
                            )),
                            (data = _markListEntryAsUpdated(
                              data,
                              directParent,
                              publishTypes.CHANGED,
                              markResourceAsUpdated,
                            ))
                        }
                      }
                    }
                  })(),
                  taskData &&
                    (data = handleSubtasksAfterCategoryValueChanged({
                      data,
                      taskData,
                      oldListEntry,
                      updatedListEntry,
                      subentriesElement,
                      markResourceAsUpdated,
                    })),
                  !_.isNil(payload[referencesKey]))
                ) {
                  var newReferences = payload[referencesKey],
                    added = _.difference(newReferences, oldListEntry[referencesKey]),
                    removed = _.difference(oldListEntry[referencesKey], newReferences)
                  _.forEach(removed, function (removedChildUuid) {
                    var child = resourceHandlers.LIST_ENTRY.get(data, {
                      listId: identifiers.listId,
                      uuid: removedChildUuid,
                    })
                    ;(child[connectedKey] = !1),
                      (data = _markListEntryAsUpdated(data, child, publishTypes.CHANGED, markResourceAsUpdated))
                  }),
                    _.forEach(added, function (addedChildUuid) {
                      var child = resourceHandlers.LIST_ENTRY.get(data, {
                        listId: identifiers.listId,
                        uuid: addedChildUuid,
                      })
                      if (_.isNil(child)) throw new Error('Not all added children are cached. (' + addedChildUuid + ')')
                      var lastParentUuid = _.last(child[parentsKey])
                      if (lastParentUuid) {
                        var lastParent = resourceHandlers.LIST_ENTRY.get(data, {
                          listId: identifiers.listId,
                          uuid: lastParentUuid,
                        })
                        ;(lastParent[referencesKey] = _.without(lastParent[referencesKey], addedChildUuid)),
                          (lastParent[referencesSortKey] = _.reject(lastParent[referencesSortKey], {
                            uuid: addedChildUuid,
                          })),
                          (data = _markListEntryAsUpdated(
                            data,
                            lastParent,
                            publishTypes.CHANGED,
                            markResourceAsUpdated,
                          ))
                      }
                    }),
                    (data = evaluateSubentryPathsForElement({
                      data,
                      listElement: subentriesElement,
                      markResourceAsUpdated,
                      topLevelOrderWasAffected: !1 === _.isEmpty(removed),
                    }))
                }
              }),
              data
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers)
            if (_.isNil(listEntry)) return null
            var undoPayload = _.pick(listEntry, _.keys(payload))
            return delete undoPayload.updated_at, { action: 'UPDATE_LIST_ENTRY', identifiers, payload: undoPayload }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId', {
              listAllId: identifiers.listId,
              entryAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url, payload, { query: { include: 'entries' } })
          },
          publishServerResponseAndReturnResource: publishEveryEntryInResponseAndReturnMainEntry,
          updateInMemoryDb: function (params) {
            var entries = _.compact(_.concat([params.resource.entry], params.resource.entries))
            return updateEveryEntrySeperately({ listEntries: entries, inMemoryDb: params.inMemoryDb }).then(
              function () {
                if (
                  !1 !==
                  _.some(params.payload, function (value, key) {
                    if (!1 === _.includes(key, '_')) return !1
                    var uuid = _.head(_.split(key, '_')),
                      data = params.inMemoryDb.getData(),
                      elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
                      subentriesEc = _.find(elementcategories, { name: 'Subentries' }),
                      listElement = resourceHandlers.LIST_ELEMENT.get(data, { listId: params.identifiers.listId, uuid })
                    return _.get(listElement, ['elementcategory']) === subentriesEc.id
                  })
                )
                  return updateInMemoryDbSubentryPathsForList({
                    listId: params.identifiers.listId,
                    inMemoryDb: params.inMemoryDb,
                    topLevelOrderWasAffected: !0,
                  })
              },
            )
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers),
              value = _.find(payload, function (value, key) {
                var parts = _.split(key, '_')
                return 2 === _.size(parts) && value
              })
            if (_.isString(value) && moment(value).isValid()) {
              var userSettings = _.get(resourceHandlers.CURRENT_USER.get(data, {}), ['settings'])
              userSettings && (value = moment(value).format(userSettings.dateFormat + ' ' + userSettings.timeFormat))
            }
            return {
              translateId:
                'STORE.ERROR_MESSAGES.UPDATE_ENTRY_FAILED' +
                (_.isString(value) || _.isNumber(value) ? '_WITH_VALUE' : ''),
              translateValues: { displayString: utils.shorten(listEntry.displayString, 100), value },
            }
          },
        },
        UPDATE_CHECKLISTS_OF_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isListEntryCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ENTRY,
              listEntry = resourceHandler.get(data, identifiers),
              updatedListEntry = _.assign(listEntry, { checklists: payload })
            return resourceHandler.set(data, identifiers, updatedListEntry)
          },
          getUndoAction: function (data, identifiers, payload) {
            return {
              action: 'UPDATE_CHECKLISTS_OF_LIST_ENTRY',
              identifiers,
              payload: resourceHandlers.LIST_ENTRY.get(data, identifiers).checklists,
            }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId/checklists', {
              listAllId: identifiers.listId,
              entryAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url, { checklists: payload })
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_ENTRY_FAILED',
              translateValues: { displayString: utils.shorten(listEntry.displayString, 100) },
            }
          },
        },
        CONVERT_CHECKLIST_OF_LIST_ENTRY_TO_SUBENTRIES: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl(
              '/lists/:listAllId/entries/:entryAllId/checklists/:checklistUuid/convert-to-subentries/:elementAllId',
              {
                listAllId: identifiers.listId,
                entryAllId: identifiers.uuid,
                checklistUuid: payload.checklistUuid,
                elementAllId: payload.listElementUuid,
              },
            )
            return zenkitFetch.put(url).then(function (dataContainer) {
              return dataContainer.listEntry
            })
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers),
              value = _.find(payload, function (value, key) {
                var parts = _.split(key, '_')
                return 2 === _.size(parts) && value
              })
            if (_.isString(value) && moment(value).isValid()) {
              var userSettings = _.get(resourceHandlers.CURRENT_USER.get(data, {}), ['settings'])
              userSettings && (value = moment(value).format(userSettings.dateFormat + ' ' + userSettings.timeFormat))
            }
            return {
              translateId:
                'STORE.ERROR_MESSAGES.UPDATE_ENTRY_FAILED' +
                (_.isString(value) || _.isNumber(value) ? '_WITH_VALUE' : ''),
              translateValues: { displayString: utils.shorten(listEntry.displayString, 100), value },
            }
          },
        },
        DEPRECATE_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.REMOVED,
          payloadValidation: {
            deprecated_at: {
              type: 'object',
              customCheck: function (deprecated_at) {
                return moment(deprecated_at).isValid()
              },
            },
            removeEntriesFromReferences: { type: 'boolean', default: !1 },
          },
          isOptimisticUpdatePossible: isListEntryCached,
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            return optimisticallyDeprecateListEntry({
              data,
              listId: identifiers.listId,
              listEntryUuid: identifiers.uuid,
              deprecatedAt: payload.deprecated_at,
              removeEntriesFromReferences: payload.removeEntriesFromReferences,
              markResourceAsUpdated,
            })
          },
          getUndoAction: function (data, identifiers, payload) {
            return { action: 'RESTORE_LIST_ENTRY', identifiers, payload: {} }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId', {
              listAllId: identifiers.listId,
              entryAllId: identifiers.uuid,
            })
            return zenkitFetch.delete(url, payload, { query: { include: 'entries' } })
          },
          publishServerResponseAndReturnResource: publishEveryEntryInResponseAndReturnMainEntry,
          updateInMemoryDb: function (params) {
            var entries = _.compact(_.concat([params.resource.entry], params.resource.entries))
            return updateEveryEntrySeperately({ listEntries: entries, inMemoryDb: params.inMemoryDb }).then(
              function () {
                return updateInMemoryDbSubentryPathsForList({
                  listId: params.identifiers.listId,
                  inMemoryDb: params.inMemoryDb,
                  topLevelOrderWasAffected: !0,
                })
              },
            )
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.DEPRECATE_ENTRY_FAILED' + (listEntry ? '' : '_GENERIC'),
              translateValues: { displayString: listEntry ? utils.shorten(listEntry.displayString, 100) : '' },
            }
          },
        },
        DELETE_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.REMOVED,
          optimistic: function (data, identifiers, payload) {
            return resourceHandlers.LIST_ENTRY.set(data, identifiers, null)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/deprecated-entries/:entryAllId', {
              listAllId: identifiers.listId,
              entryAllId: identifiers.uuid,
            })
            return zenkitFetch.delete(url)
          },
          updateInMemoryDbIfValueIsNil: !0,
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.DELETE_ENTRY_FAILED' + (listEntry ? '' : '_GENERIC'),
              translateValues: { displayString: listEntry ? utils.shorten(listEntry.displayString, 100) : '' },
            }
          },
        },
        RESTORE_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: isListEntryCached,
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            return optimisticallyRestoreListEntry({
              data,
              listId: identifiers.listId,
              listEntryUuid: identifiers.uuid,
              markResourceAsUpdated,
            })
          },
          getUndoAction: function (data, identifiers, payload) {
            return { action: 'DEPRECATE_LIST_ENTRY', identifiers, payload: { deprecated_at: new Date() } }
          },
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId/restore', {
              listAllId: identifiers.listId,
              entryAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url, {}, { query: { include: 'entries' } })
          },
          publishServerResponseAndReturnResource: publishEveryEntryInResponseAndReturnMainEntry,
          updateInMemoryDb: function (params) {
            var entries = _.compact(_.concat([params.resource.entry], params.resource.entries))
            return updateEveryEntrySeperately({ listEntries: entries, inMemoryDb: params.inMemoryDb }).then(
              function () {
                return updateInMemoryDbSubentryPathsForList({
                  listId: params.identifiers.listId,
                  inMemoryDb: params.inMemoryDb,
                  topLevelOrderWasAffected: !0,
                })
              },
            )
          },
          getErrorMessage: function (data, identifiers) {
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return {
              translateId: 'LIST_ENTRIES.ERRORS.RESTORING_ONE_ENTRY_FAILED',
              translateValues: { entryName: utils.getListEntryNameForList({ list }) },
            }
          },
        },
        REORDER_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            elementIdX: { type: ['string', 'number', 'null'], default: null },
            elementIdY: { type: ['string', 'number', 'null'], default: null },
            beforeAnchorUuid: { type: ['string', 'null'], default: null },
            valuesX: { type: ['array'], default: [] },
            valuesY: { type: ['array'], default: [] },
            shouldBeLastInGroup: { type: 'boolean', default: !1 },
          },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            return (
              (!payload.beforeAnchorUuid ||
                !1 !== isListEntryCached(data, { listId: identifiers.listId, uuid: payload.beforeAnchorUuid })) &&
              isListEntryCached(data, identifiers) &&
              areListElementsCached(data, identifiers)
            )
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var listEntryReorderConfig = ZenkitControlsShared.listEntryReorderConfig,
              resourceHandler = resourceHandlers.LIST_ENTRY,
              oldListEntry = resourceHandler.get(data, identifiers)
            if (_.isNil(oldListEntry)) return data
            var step,
              start,
              foundListEntry,
              sortOrder,
              listEntry = _.assign({}, oldListEntry),
              listEntriesMap = data.entriesPerList[listEntry.listId],
              listElementsMap = data.elementsPerList[listEntry.listId],
              elementcategoriesById = _.keyBy(data.elementcategories, 'id'),
              getElementKey = function (listElement) {
                var ecName = elementcategoriesById[listElement.elementcategory].name
                if ('Categories' === ecName) return listElement.uuid + '_categories'
                if ('Persons' === ecName) return listElement.uuid + '_persons'
                throw new Error('Field type not supported. ' + listElement.elementcategory)
              },
              getElementSortKey = function (listElement) {
                return getElementKey(listElement) + '_sort'
              },
              getSortValueJS = function (listElement, ids) {
                var ecName = elementcategoriesById[listElement.elementcategory].name
                if ('Categories' === ecName) {
                  var categories = _.get(listElement, ['elementData', 'predefinedCategories'])
                  return _.map(ids, function (categoryId) {
                    return _.find(categories, { id: categoryId })
                  })
                }
                if ('Persons' === ecName)
                  return _.map(ids, function (userId) {
                    return (
                      resourceHandlers.USER.get(data, { id: userId }) || { id: userId, displayname: 'User not cached' }
                    )
                  })
                throw new Error('Field type not supported. ' + listElement.elementcategory)
              },
              elementX = payload.elementIdX ? _.find(listElementsMap, { id: payload.elementIdX }) : void 0,
              elementY = payload.elementIdY ? _.find(listElementsMap, { id: payload.elementIdY }) : void 0,
              keyX = elementX ? getElementKey(elementX) : void 0,
              keyY = elementY ? getElementKey(elementY) : void 0
            keyX &&
              ((listEntry[keyX] = payload.valuesX),
              (listEntry[getElementSortKey(elementX)] = getSortValueJS(elementX, payload.valuesX))),
              keyY &&
                ((listEntry[keyY] = payload.valuesY),
                (listEntry[getElementSortKey(elementY)] = getSortValueJS(elementY, payload.valuesY))),
              (listEntry.sortOrder = _.isNil(payload.beforeAnchorUuid)
                ? ((step = listEntryReorderConfig.step),
                  (start = listEntryReorderConfig.defaultStart),
                  (foundListEntry = _.chain(listEntriesMap)
                    .sortBy(function (listEntryToSort) {
                      var order = parseFloat(listEntryToSort.sortOrder)
                      return payload.shouldBeLastInGroup ? -order : order
                    })
                    .find(function (listEntryInQuestion) {
                      return !listEntryInQuestion.deprecated_at && listEntry.uuid !== listEntryInQuestion.uuid
                    })
                    .value()),
                  (sortOrder = foundListEntry && foundListEntry.sortOrder),
                  _.isNil(sortOrder)
                    ? start
                    : ((sortOrder = parseFloat(sortOrder)),
                      payload.shouldBeLastInGroup ? sortOrder + step : sortOrder - step))
                : (function (beforeAnchorUuid) {
                    var beforeAnchorEntry = listEntriesMap[beforeAnchorUuid],
                      sortOrderOfBeforeAnchor = NaN
                    !1 === _.isNil(beforeAnchorEntry) &&
                      (sortOrderOfBeforeAnchor = parseFloat(beforeAnchorEntry.sortOrder))
                    var listEntriesAboveAndBelow = _.chain(listEntriesMap)
                        .filter(function (listEntryInQuestion) {
                          return (
                            !listEntryInQuestion.deprecated_at &&
                            listEntry.uuid !== listEntryInQuestion.uuid &&
                            parseFloat(listEntryInQuestion.sortOrder) >= sortOrderOfBeforeAnchor
                          )
                        })
                        .sortBy(function (listEntryInQuestion) {
                          return parseFloat(listEntryInQuestion.sortOrder)
                        })
                        .take(2)
                        .value(),
                      listEntryAbove = listEntriesAboveAndBelow[0],
                      listEntryBelow = listEntriesAboveAndBelow[1]
                    if (0 === _.size(listEntriesAboveAndBelow)) throw new Error('Item not found. ' + beforeAnchorUuid)
                    return 1 === _.size(listEntriesAboveAndBelow)
                      ? parseFloat(listEntryAbove.sortOrder) + listEntryReorderConfig.step
                      : (parseFloat(listEntryAbove.sortOrder) + parseFloat(listEntryBelow.sortOrder)) / 2
                  })(payload.beforeAnchorUuid)),
              (listEntry.updated_at = new Date()),
              (data = resourceHandler.set(data, { listId: listEntry.listId, uuid: listEntry.uuid }, listEntry))
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId }),
              listElements = _.values(resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId })),
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
              subentriesEc = _.find(elementcategories, { name: 'Subentries' }),
              subentriesElement = _.find(listElements, { elementcategory: subentriesEc.id }),
              taskData = utils.getTaskData({ list, listElements, elementcategories, appType: globals.appType })
            return (
              taskData &&
                subentriesElement &&
                (data = handleSubtasksAfterCategoryValueChanged({
                  data,
                  taskData,
                  oldListEntry,
                  updatedListEntry: listEntry,
                  subentriesElement,
                  markResourceAsUpdated,
                })),
              data
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            var listElementsById = _.keyBy(
                resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
                'id',
              ),
              listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: identifiers.listId }),
              listEntry = listEntriesByUuid[identifiers.uuid],
              elementX = listElementsById[payload.elementIdX],
              elementY = listElementsById[payload.elementIdY],
              elementcategoriesById = _.keyBy(data.elementcategories, 'id'),
              getElementKey = function (listElement) {
                var ecName = elementcategoriesById[listElement.elementcategory].name
                if ('Categories' === ecName) return listElement.uuid + '_categories'
                if ('Persons' === ecName) return listElement.uuid + '_persons'
                throw new Error('Field type not supported. ' + listElement.elementcategory)
              },
              currentValuesX = elementX ? listEntry[getElementKey(elementX)] : void 0,
              currentValuesY = elementY ? listEntry[getElementKey(elementY)] : void 0,
              sortedListEntries = _.sortBy(listEntriesByUuid, function (listEntry) {
                return parseFloat(listEntry.sortOrder)
              }),
              beforeAnchor = sortedListEntries[_.findIndex(sortedListEntries, { uuid: identifiers.uuid }) - 1]
            return {
              action: 'REORDER_LIST_ENTRY',
              identifiers,
              payload: {
                elementIdX: payload.elementIdX,
                elementIdY: payload.elementIdY,
                valuesX: currentValuesX,
                valuesY: currentValuesY,
                beforeAnchorUuid: _.get(beforeAnchor, ['uuid'], null),
              },
            }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId/reorder', {
              listAllId: identifiers.listId,
              entryAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url, payload)
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.REORDER_ENTRIES_FAILED' + (listEntry ? '' : '_GENERIC'),
              translateValues: { displayString: listEntry ? utils.shorten(listEntry.displayString, 100) : '' },
            }
          },
        },
        SAVE_VOLATILE_LIST_SORT_ORDER: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.CHANGED,
          payloadValidation: { orderBy: { type: ['array', 'object'] } },
          isOptimisticUpdatePossible: function (data, identifiers) {
            return areListElementsCached(data, { listId: identifiers.listId })
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var listElements = _.values(resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId })),
              listEntries = _.values(resourceHandlers.LIST_ENTRIES.get(data, identifiers)),
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
              sortingHandler = utils.getListEntrySortingHandler({
                orderBy: payload.orderBy,
                listElements,
                elementcategories,
              }),
              updatedListEntries = _.chain(listEntries)
                .orderBy(sortingHandler.functions, sortingHandler.directions)
                .map(function (listEntry, index) {
                  return (
                    _.isNil(listEntry.deprecated_at) &&
                      ((listEntry.sortOrder = _.toString(index + 1)), (listEntry.updated_at = new Date())),
                    listEntry
                  )
                })
                .value()
            return (
              (data = resourceHandlers.LIST_ENTRIES.set(data, identifiers, updatedListEntries)),
              markResourceAsUpdated({
                resource: RESOURCES.LIST_ENTRIES,
                publishType: publishTypes.CHANGED,
                identifiers,
              }),
              data
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/save-volatile-sort-order', {
              listAllId: identifiers.listId,
            })
            return zenkitFetch.put(url, payload)
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.REORDER_ENTRIES_FAILED_GENERIC' }),
        },
        UPDATE_PATH_OF_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            beforeAnchorAllId: { type: ['string', 'number', 'null'] },
            elementAllId: { type: ['string', 'number'] },
            targetDepth: { type: 'number' },
            connected: { type: 'boolean' },
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
              listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: identifiers.listId }),
              targetDepth = payload.targetDepth,
              listEntryToSort = listEntriesByUuid[identifiers.uuid]
            if (_.isNil(listEntryToSort)) throw new Error('ListEntry ' + identifiers.uuid + ' could not be found.')
            var listElement =
              listElementsByUuid[payload.elementAllId] ||
              _.find(listElementsByUuid, function (listElement) {
                return _.includes([listElement.uuid, listElement.shortId, listElement.id], payload.elementAllId)
              })
            if (_.isNil(listElement)) throw new Error('ListElement ' + payload.elementAllId + ' could not be found.')
            var sortOrderKey = listElement.uuid + '_sortOrder',
              parentsKey = listElement.uuid + '_parents',
              connectedKey = listElement.uuid + '_connected',
              pathKey = listElement.uuid + '_path',
              referencesKey = listElement.uuid + '_references',
              referencesSortKey = listElement.uuid + '_references_sort',
              beforeAnchor = (function () {
                if (_.isNil(payload.beforeAnchorAllId)) return null
                var beforeAnchor =
                  listEntriesByUuid[payload.beforeAnchorAllId] ||
                  _.find(listEntriesByUuid, function (listEntry) {
                    return _.includes([listEntry.shortId, listEntry.id], payload.beforeAnchorAllId)
                  })
                if (_.isNil(beforeAnchor))
                  throw new Error('BeforeAnchor ' + payload.beforeAnchorAllId + ' could not be found.')
                return beforeAnchor
              })(),
              pathOfBeforeAnchor = _.get(beforeAnchor, [pathKey], null),
              topLevelEntries = _.filter(listEntriesByUuid, function (listEntry) {
                return _.isEmpty(listEntry[parentsKey])
              }),
              sortedTopLevelEntries = _.sortBy(topLevelEntries, sortOrderKey),
              maxSortOrder = _.last(sortedTopLevelEntries)[sortOrderKey],
              sortOrderBeforeAnchor = (function () {
                if (_.isNil(beforeAnchor) || targetDepth > 0) return null
                if (_.isEmpty(beforeAnchor[parentsKey])) return beforeAnchor
                var topLevelParentUuid = _.head(beforeAnchor[parentsKey]),
                  topLevelParent = listEntriesByUuid[topLevelParentUuid]
                if (_.isNil(topLevelParent))
                  throw new Error('Top level parent ' + topLevelParentUuid + ' could not be found.')
                return topLevelParent
              })(),
              sortOrderAfterAnchor =
                targetDepth > 0
                  ? null
                  : _.chain(sortedTopLevelEntries)
                      .reject({ uuid: listEntryToSort.uuid })
                      .find(function (listEntry) {
                        return !sortOrderBeforeAnchor || listEntry[sortOrderKey] > sortOrderBeforeAnchor[sortOrderKey]
                      })
                      .value(),
              newSortOrder =
                targetDepth > 0
                  ? null
                  : _.isNil(sortOrderAfterAnchor) && _.isNil(sortOrderBeforeAnchor)
                  ? 1
                  : _.isNil(sortOrderAfterAnchor)
                  ? sortOrderBeforeAnchor[sortOrderKey] + 1e-7
                  : _.isNil(sortOrderBeforeAnchor)
                  ? sortOrderAfterAnchor[sortOrderKey] - 1e-7
                  : (sortOrderAfterAnchor[sortOrderKey] + sortOrderBeforeAnchor[sortOrderKey]) / 2,
              isConnected = sortOrderBeforeAnchor ? sortOrderBeforeAnchor[connectedKey] : payload.connected,
              pathOfNewParent = (function () {
                if (0 === targetDepth) return null
                var depthOfBeforeAnchor = utils.subentryPathToDepth(pathOfBeforeAnchor)
                return targetDepth > depthOfBeforeAnchor || 0 === depthOfBeforeAnchor
                  ? pathOfBeforeAnchor
                  : _.chain(pathOfBeforeAnchor).split('.').take(targetDepth).join('.').value()
              })(),
              newParentOfListEntry = (function () {
                if (_.isNil(pathOfNewParent)) return null
                if (pathOfNewParent === pathOfBeforeAnchor) return beforeAnchor
                var parent = _.find(listEntriesByUuid, [pathKey, pathOfNewParent])
                if (_.isNil(parent)) throw new Error('Parent with path ' + pathOfNewParent + ' could not be found.')
                return parent
              })(),
              indexInNewParent = (function () {
                if (_.isNil(newParentOfListEntry)) return -1
                if (pathOfNewParent === pathOfBeforeAnchor) return 0
                var pathOfAncestor = _.chain(pathOfBeforeAnchor)
                    .split('.')
                    .take(targetDepth + 1)
                    .join('.')
                    .value(),
                  ancestor = _.find(listEntriesByUuid, [pathKey, pathOfAncestor])
                if (_.isNil(ancestor)) throw new Error('Ancestor with path ' + pathOfAncestor + ' could not be found.')
                var indexOfAncestor = _.indexOf(newParentOfListEntry[referencesKey], ancestor.uuid),
                  indexOfEntry = _.indexOf(newParentOfListEntry[referencesKey], listEntryToSort.uuid)
                return -1 === indexOfEntry || indexOfEntry > indexOfAncestor ? indexOfAncestor + 1 : indexOfAncestor
              })()
            ;(listEntryToSort[sortOrderKey] = newSortOrder),
              (listEntryToSort[connectedKey] = isConnected),
              (data = _markListEntryAsUpdated(data, listEntryToSort, publishTypes.CHANGED, markResourceAsUpdated))
            var newSortOrderOfParent,
              listEntryToSortWasOnTopLevel = _.isEmpty(listEntryToSort[parentsKey])
            return (
              (function () {
                if (!listEntryToSortWasOnTopLevel) {
                  var oldParentUuid = _.last(listEntryToSort[parentsKey]),
                    oldParent = listEntriesByUuid[oldParentUuid]
                  if (_.isNil(oldParent)) throw new Error('Old parent ' + oldParentUuid + ' could not be found.')
                  ;(oldParent[referencesKey] = _.without(oldParent[referencesKey], listEntryToSort.uuid)),
                    (oldParent[referencesSortKey] = _.reject(oldParent[referencesSortKey], {
                      uuid: listEntryToSort.uuid,
                    })),
                    (data = _markListEntryAsUpdated(data, oldParent, publishTypes.CHANGED, markResourceAsUpdated))
                }
              })(),
              -1 !== indexInNewParent &&
                ((newSortOrderOfParent =
                  0 === utils.subentryPathToDepth(newParentOfListEntry[pathKey])
                    ? newParentOfListEntry[sortOrderKey] || (maxSortOrder || 0) + 1
                    : null),
                newParentOfListEntry[referencesKey].splice(indexInNewParent, 0, listEntryToSort.uuid),
                newParentOfListEntry[referencesSortKey].splice(indexInNewParent, 0, listEntryToSort),
                (newParentOfListEntry[sortOrderKey] = newSortOrderOfParent),
                (data = _markListEntryAsUpdated(
                  data,
                  newParentOfListEntry,
                  publishTypes.CHANGED,
                  markResourceAsUpdated,
                ))),
              (data = evaluateSubentryPathsForElement({
                data,
                listElement,
                markResourceAsUpdated,
                topLevelOrderWasAffected: 0 === targetDepth || listEntryToSortWasOnTopLevel,
              }))
            )
          },
          optimisticServerResponse: function (data, identifiers, payload) {
            var listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
              listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: identifiers.listId }),
              listElement =
                listElementsByUuid[payload.elementAllId] ||
                _.find(listElementsByUuid, function (listElement) {
                  return _.includes([listElement.uuid, listElement.shortId, listElement.id], payload.elementAllId)
                }),
              listEntry = listEntriesByUuid[identifiers.uuid]
            if (_.isNil(listEntry)) return { entries: [] }
            if (_.isNil(listElement)) return { entries: [listEntry] }
            var parentsKey = listElement.uuid + '_parents',
              listEntriesToReturn = [listEntry],
              newParent = listEntriesByUuid[_.last(listEntry[parentsKey])]
            return newParent && listEntriesToReturn.push(newParent), { entries: listEntriesToReturn }
          },
          getUndoAction: function (data, identifiers, payload) {
            var listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
              listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: identifiers.listId }),
              listEntryToSort = listEntriesByUuid[identifiers.uuid],
              listElement =
                listElementsByUuid[payload.elementAllId] ||
                _.find(listElementsByUuid, function (listElement) {
                  return _.includes([listElement.uuid, listElement.shortId, listElement.id], payload.elementAllId)
                }),
              currentlyConnected = listEntryToSort[listElement.uuid + '_connected'],
              currentPath = listEntryToSort[listElement.uuid + '_path'],
              currentDepth = utils.subentryPathToDepth(currentPath),
              directParentUuid = _.last(listEntryToSort[listElement.uuid + '_parents']),
              beforeAnchorAllId = null
            if (directParentUuid) {
              var allChildUuidsOfParent = listEntriesByUuid[directParentUuid][listElement.uuid + '_references'],
                index = _.indexOf(allChildUuidsOfParent, listEntryToSort.uuid)
              beforeAnchorAllId = index > 0 ? allChildUuidsOfParent[index - 1] : directParentUuid
            }
            return {
              action: 'UPDATE_PATH_OF_LIST_ENTRY',
              identifiers,
              payload: {
                beforeAnchorAllId,
                elementAllId: payload.elementAllId,
                targetDepth: currentDepth,
                connected: currentlyConnected,
              },
            }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId/path', {
              listAllId: identifiers.listId,
              entryAllId: identifiers.uuid,
            })
            return (isListAvailableOffline(data, { id: identifiers.listId }) ? zenkitFetchPreventSockets : zenkitFetch)
              .put(url, payload)
              .then(function (response) {
                return _.get(response, ['entries'], [])
              })
          },
          updateInMemoryDb: function (params) {
            return updateEveryEntrySeperately({ listEntries: params.resource, inMemoryDb: params.inMemoryDb }).then(
              function () {
                return updateInMemoryDbSubentryPathsForList({
                  listId: params.identifiers.listId,
                  inMemoryDb: params.inMemoryDb,
                  topLevelOrderWasAffected: !0,
                })
              },
            )
          },
          publishServerResponseAndReturnResource: function (params) {
            var entries = params.serverResponse
            return (
              resourceHandlers.LIST_ENTRIES.publish({
                identifiers: { listId: params.identifiers.listId },
                resource: entries,
                publishType: publishTypes.CHANGED,
              }),
              _.find(entries, params.identifiers) || null
            )
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_ENTRY_FAILED',
              translateValues: { displayString: utils.shorten(listEntry.displayString, 100) },
            }
          },
        },
        ADD_FILES_TO_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          payloadValidation: { files: { type: 'array' }, elementUuid: { type: 'string' } },
          isOptimisticUpdatePossible: function (data, identifiers) {
            return isListEntryCached(data, identifiers) && areListElementsCached(data, identifiers)
          },
          optimistic: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers),
              listElement = resourceHandlers.LIST_ELEMENT.get(data, {
                listId: identifiers.listId,
                uuid: payload.elementUuid,
              }),
              filesProperty = listElement.uuid + '_files',
              filesDataProperty = listElement.uuid + '_filesData'
            return (
              (listEntry.updated_at = new Date()),
              (listEntry[filesProperty] = _.union(listEntry[filesProperty] || [], _.map(payload.files, 'id'))),
              (listEntry[filesDataProperty] = _.unionBy(listEntry[filesDataProperty] || [], payload.files, 'id')),
              resourceHandlers.LIST_ENTRY.set(data, identifiers, listEntry)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId', {
                listAllId: identifiers.listId,
                entryAllId: identifiers.uuid,
              }),
              listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers),
              filesProperty =
                resourceHandlers.LIST_ELEMENT.get(data, { listId: identifiers.listId, uuid: payload.elementUuid })
                  .uuid + '_files',
              updateParams = {}
            return (
              (updateParams[filesProperty] = _.union(listEntry[filesProperty] || [], _.map(payload.files, 'id'))),
              zenkitFetch.put(url, updateParams)
            )
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_ENTRY_FAILED',
              translateValues: { displayString: utils.shorten(listEntry.displayString, 100) },
            }
          },
        },
        UPDATE_LIST_ENTRY_FILE: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            elementUuid: { type: 'string' },
            fileId: { type: 'number' },
            updateParams: { type: 'object' },
          },
          isOptimisticUpdatePossible: isListEntryCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ENTRY,
              listEntry = resourceHandler.get(data, identifiers),
              dataKey = payload.elementUuid + '_filesData',
              file = _.find(listEntry[dataKey], { id: payload.fileId })
            return (
              _.assign(file, payload.updateParams),
              (listEntry.updated_at = new Date()),
              resourceHandler.set(data, identifiers, listEntry)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId/files/:fileAllId', {
              listAllId: identifiers.listId,
              elementAllId: payload.elementUuid,
              fileAllId: payload.fileId,
            })
            return zenkitFetch.post(url, _.pick(payload, ['updateParams'])).then(function () {
              var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId', {
                listAllId: identifiers.listId,
                entryAllId: identifiers.uuid,
              })
              return zenkitFetch.get(url)
            })
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers),
              dataKey = payload.elementUuid + '_filesData',
              file = _.find(_.get(listEntry, [dataKey]), { id: payload.fileId })
            return {
              translateId: 'CONTROLS.FILES.RENAMING_FILE_FAILED',
              translateValues: { fileName: _.get(file, ['fileName']) },
            }
          },
        },
        UPLOAD_FILE_FOR_LIST_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' }, file: { type: 'object' }, elementUUID: { type: 'string' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId/entries/:entryAllId/files', {
              listAllId: identifiers.listId,
              elementAllId: payload.elementUUID,
              entryAllId: identifiers.uuid,
            })
            return uploadFile(url, payload)
          },
        },
        DEPRECATE_LIST_ENTRY_FILE: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.CHANGED,
          payloadValidation: { elementUuid: { type: 'string' }, fileId: { type: 'number' } },
          isOptimisticUpdatePossible: isListEntryCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ENTRY,
              listEntry = resourceHandler.get(data, identifiers),
              key = payload.elementUuid + '_files',
              dataKey = payload.elementUuid + '_filesData'
            return (
              (listEntry[key] = _.without(listEntry[key], payload.fileId)),
              (listEntry[dataKey] = _.reject(listEntry[dataKey], { id: payload.fileId })),
              (listEntry.updated_at = new Date()),
              resourceHandler.set(data, identifiers, listEntry)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl(
              'lists/:listAllId/listentries/:entryAllId/elements/:elementAllId/files/:fileAllId',
              {
                listAllId: identifiers.listId,
                entryAllId: identifiers.uuid,
                elementAllId: payload.elementUuid,
                fileAllId: payload.fileId,
              },
            )
            return zenkitFetch.delete(url, payload).then(function () {
              var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId', {
                listAllId: identifiers.listId,
                entryAllId: identifiers.uuid,
              })
              return zenkitFetch.get(url)
            })
          },
          getErrorMessage: function (data, identifiers, payload) {
            var listEntry = resourceHandlers.LIST_ENTRY.get(data, identifiers),
              dataKey = payload.elementUuid + '_filesData',
              file = _.find(_.get(listEntry, [dataKey]), { id: payload.fileId })
            return {
              translateId: 'STORE.ERROR_MESSAGES.DEPRECATE_LIST_ENTRY_FILE_FAILED',
              translateValues: { file: _.get(file, ['fileName']) },
            }
          },
        },
        CREATE_LIST_COMMENT: makeCreateCommentAction(RESOURCES.LIST_ACTIVITY),
        CREATE_WORKSPACE_COMMENT: makeCreateCommentAction(RESOURCES.WORKSPACE_ACTIVITY),
        CREATE_LIST_ENTRY_COMMENT: makeCreateCommentAction(RESOURCES.LIST_ENTRY_ACTIVITY),
        COPY_LIST_ENTRY_COMMENT_FROM_ACTIVITY: {
          resource: RESOURCES.LIST_ENTRY_ACTIVITY,
          publishType: publishTypes.ADDED,
          payloadValidation: { sourceActivityIdentifiers: { type: 'object' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var sourceActivityIdentifiers = payload.sourceActivityIdentifiers
            return (
              isCommentCached(data, sourceActivityIdentifiers) &&
              isCurrentUserCached(data) &&
              isListCached(data, { id: identifiers.listId })
            )
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              list = resourceHandlers.LIST.get(data, { id: identifiers.listId }),
              sourceActivityIdentifiers = payload.sourceActivityIdentifiers,
              sourceActivityResource = sourceActivityIdentifiers.listId
                ? RESOURCES.LIST_ACTIVITY
                : RESOURCES.WORKSPACE_ACTIVITY,
              sourceActivity = resourceHandlers[sourceActivityResource].get(data, sourceActivityIdentifiers),
              copiedEnrichments = _.map(sourceActivity.enrichments, function (enrichment) {
                return _.defaults({ uuid: _.uniqueId('optimistic-uuid-') }, enrichment)
              }),
              copiedActivity = {
                uuid: identifiers.uuid,
                listId: identifiers.listId,
                listEntryUUID: identifiers.listEntryUuid,
                message: sourceActivity.message,
                enrichments: copiedEnrichments,
                listShortId: list.shortId,
                listName: list.name,
                type: ZenkitControlsShared.activityTypes.TYPE.COMMENT,
                created_in: ZenkitControlsShared.activityTypes.CREATED_IN.LIST_ENTRY,
                isBulk: !1,
                userId: currentUser.id,
                userInitials: currentUser.initials,
                userUsername: currentUser.username,
                userFullname: currentUser.fullname,
                userDisplayname: currentUser.displayname,
                userImagelink: currentUser.imageLink,
                userIsImagePreferred: currentUser.isImagePreferred,
                created_at: new Date(),
                updated_at: new Date(),
              },
              listEntry = resourceHandlers.LIST_ENTRY.get(data, {
                listId: identifiers.listId,
                uuid: identifiers.listEntryUuid,
              })
            return (
              listEntry &&
                ((listEntry.comment_count += 1),
                (data = _markListEntryAsUpdated(data, listEntry, publishTypes.CHANGED, markResourceAsUpdated))),
              resourceHandlers.LIST_ENTRY_ACTIVITY.set(data, identifiers, copiedActivity)
            )
          },
          save: function (data, identifiers, payload) {
            var sourceActivityIdentifiers = payload.sourceActivityIdentifiers,
              url = zenkitFetch.buildUrl('activities/:activityAllId/copy/lists/:listAllId/entries/:entryAllId', {
                listAllId: identifiers.listId,
                entryAllId: identifiers.listEntryUuid,
                activityAllId: sourceActivityIdentifiers.uuid,
              })
            return zenkitFetch.post(url, { uuid: identifiers.uuid })
          },
        },
        COPY_LIST_COMMENT_FROM_ACTIVITY: {
          resource: RESOURCES.LIST_ACTIVITY,
          publishType: publishTypes.ADDED,
          payloadValidation: { sourceActivityIdentifiers: { type: 'object' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var sourceActivityIdentifiers = payload.sourceActivityIdentifiers
            return (
              isCommentCached(data, sourceActivityIdentifiers) &&
              isCurrentUserCached(data) &&
              isListCached(data, { id: identifiers.listId })
            )
          },
          optimistic: function (data, identifiers, payload) {
            var currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              list = resourceHandlers.LIST.get(data, { id: identifiers.listId }),
              sourceActivityIdentifiers = payload.sourceActivityIdentifiers,
              sourceActivityResource = sourceActivityIdentifiers.listId
                ? RESOURCES.LIST_ACTIVITY
                : RESOURCES.WORKSPACE_ACTIVITY,
              sourceActivity = resourceHandlers[sourceActivityResource].get(data, sourceActivityIdentifiers),
              copiedEnrichments = _.map(sourceActivity.enrichments, function (enrichment) {
                return _.defaults({ uuid: _.uniqueId('optimistic-uuid-') }, enrichment)
              }),
              copiedActivity = {
                uuid: identifiers.uuid,
                listId: identifiers.listId,
                message: sourceActivity.message,
                enrichments: copiedEnrichments,
                listShortId: list.shortId,
                listName: list.name,
                type: ZenkitControlsShared.activityTypes.TYPE.COMMENT,
                created_in: ZenkitControlsShared.activityTypes.CREATED_IN.LIST,
                isBulk: !1,
                userId: currentUser.id,
                userInitials: currentUser.initials,
                userUsername: currentUser.username,
                userFullname: currentUser.fullname,
                userDisplayname: currentUser.displayname,
                userImagelink: currentUser.imageLink,
                userIsImagePreferred: currentUser.isImagePreferred,
                created_at: new Date(),
                updated_at: new Date(),
              }
            return resourceHandlers.LIST_ACTIVITY.set(data, identifiers, copiedActivity)
          },
          save: function (data, identifiers, payload) {
            var sourceActivityIdentifiers = payload.sourceActivityIdentifiers,
              url = zenkitFetch.buildUrl('activities/:activityAllId/copy/lists/:listAllId', {
                listAllId: identifiers.listId,
                activityAllId: sourceActivityIdentifiers.uuid,
              })
            return zenkitFetch.post(url, { uuid: identifiers.uuid })
          },
        },
        COPY_WORKSPACE_COMMENT_FROM_ACTIVITY: {
          resource: RESOURCES.WORKSPACE_ACTIVITY,
          publishType: publishTypes.ADDED,
          payloadValidation: { sourceActivityIdentifiers: { type: 'object' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var sourceActivityIdentifiers = payload.sourceActivityIdentifiers
            return (
              isCommentCached(data, sourceActivityIdentifiers) &&
              isCurrentUserCached(data) &&
              isWorkspaceCached(data, { id: identifiers.workspaceId })
            )
          },
          optimistic: function (data, identifiers, payload) {
            var currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              workspace = resourceHandlers.WORKSPACE.get(data, { id: identifiers.workspaceId }),
              sourceActivityIdentifiers = payload.sourceActivityIdentifiers,
              sourceActivityResource = sourceActivityIdentifiers.listId
                ? RESOURCES.LIST_ACTIVITY
                : RESOURCES.WORKSPACE_ACTIVITY,
              sourceActivity = resourceHandlers[sourceActivityResource].get(data, sourceActivityIdentifiers),
              copiedEnrichments = _.map(sourceActivity.enrichments, function (enrichment) {
                return _.defaults({ uuid: _.uniqueId('optimistic-uuid-') }, enrichment)
              }),
              copiedActivity = {
                uuid: identifiers.uuid,
                workspaceId: identifiers.workspaceId,
                message: sourceActivity.message,
                enrichments: copiedEnrichments,
                workspaceShortId: workspace.shortId,
                workspaceName: workspace.name,
                type: ZenkitControlsShared.activityTypes.TYPE.COMMENT,
                created_in: ZenkitControlsShared.activityTypes.CREATED_IN.WORKSPACE,
                isBulk: !1,
                userId: currentUser.id,
                userInitials: currentUser.initials,
                userUsername: currentUser.username,
                userFullname: currentUser.fullname,
                userDisplayname: currentUser.displayname,
                userImagelink: currentUser.imageLink,
                userIsImagePreferred: currentUser.isImagePreferred,
                created_at: new Date(),
                updated_at: new Date(),
              }
            return resourceHandlers.WORKSPACE_ACTIVITY.set(data, identifiers, copiedActivity)
          },
          save: function (data, identifiers, payload) {
            var sourceActivityIdentifiers = payload.sourceActivityIdentifiers,
              url = zenkitFetch.buildUrl('activities/:activityAllId/copy/workspaces/:workspaceAllId', {
                workspaceAllId: identifiers.workspaceId,
                activityAllId: sourceActivityIdentifiers.uuid,
              })
            return zenkitFetch.post(url, { uuid: identifiers.uuid })
          },
        },
        UPDATE_LIST_COMMENT: {
          resource: RESOURCES.LIST_ACTIVITY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isListCommentCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ACTIVITY,
              comment = resourceHandler.get(data, identifiers)
            return (
              _.assign(comment, { updated_at: new Date() }, payload), resourceHandler.set(data, identifiers, comment)
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            var comment = resourceHandlers.LIST_ACTIVITY.get(data, identifiers)
            return { action: 'UPDATE_LIST_COMMENT', identifiers, payload: _.pick(comment, _.keys(payload)) }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/activities/:activityAllId', {
              listAllId: identifiers.listId,
              activityAllId: identifiers.uuid,
            })
            return zenkitFetchPreventSockets.put(url, payload)
          },
          getErrorMessage: function (data, identifiers, payload) {
            var comment = resourceHandlers.LIST_ACTIVITY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_COMMENT_FAILED',
              translateValues: { message: _.get(comment, ['message']) },
            }
          },
        },
        ADD_LIST_COMMENT_REACTION: {
          resource: RESOURCES.LIST_ACTIVITY,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' }, emoji: { type: 'string' } },
          isOptimisticUpdatePossible: isListCommentCached,
          optimistic: function (data, identifiers, payload) {
            var currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              resourceHandler = resourceHandlers.LIST_ACTIVITY,
              comment = resourceHandler.get(data, identifiers),
              reaction = { userId: currentUser.id, emoji: payload.emoji }
            return _.some(comment.reactions, reaction)
              ? data
              : ((comment.updated_at = new Date()),
                (comment.reactions = comment.reactions || []),
                comment.reactions.push(_.defaults(reaction, payload)),
                resourceHandler.set(data, identifiers, comment))
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('activities/:activityAllId/reactions', { activityAllId: identifiers.uuid })
            return zenkitFetchPreventSockets.post(url, payload)
          },
          getErrorMessage: function (data, identifiers) {
            var comment = resourceHandlers.LIST_ACTIVITY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_COMMENT_FAILED',
              translateValues: { message: _.get(comment, ['message']) },
            }
          },
        },
        DEPRECATE_LIST_COMMENT_REACTION: {
          resource: RESOURCES.LIST_ACTIVITY,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' } },
          isOptimisticUpdatePossible: isListCommentCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ACTIVITY,
              comment = resourceHandler.get(data, identifiers),
              reactions = _.reject(comment.reactions, ['uuid', payload.uuid])
            return (
              _.assign(comment, { reactions, updated_at: new Date() }), resourceHandler.set(data, identifiers, comment)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('activities/:activityAllId/reactions/:reactionUUID', {
              activityAllId: identifiers.uuid,
              reactionUUID: payload.uuid,
            })
            return zenkitFetchPreventSockets.delete(url)
          },
          getErrorMessage: function (data, identifiers) {
            var comment = resourceHandlers.LIST_ACTIVITY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_COMMENT_FAILED',
              translateValues: { message: _.get(comment, ['message']) },
            }
          },
        },
        DEPRECATE_LIST_COMMENT: {
          resource: RESOURCES.LIST_ACTIVITY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isListCommentCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ACTIVITY,
              comment = resourceHandler.get(data, identifiers)
            return (
              (comment.message = null),
              (comment.enrichments = []),
              (comment.deprecated_at = new Date()),
              resourceHandler.set(data, identifiers, comment)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/activities/:activityAllId', {
              listAllId: identifiers.listId,
              activityAllId: identifiers.uuid,
            })
            return zenkitFetch.delete(url)
          },
          getErrorMessage: function (data, identifiers, payload) {
            var comment = resourceHandlers.LIST_ACTIVITY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.DEPRECATE_LIST_COMMENT_FAILED',
              translateValues: { message: _.get(comment, ['message']) },
            }
          },
        },
        UPDATE_WORKSPACE_COMMENT: {
          resource: RESOURCES.WORKSPACE_ACTIVITY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isWorkspaceCommentCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.WORKSPACE_ACTIVITY,
              comment = resourceHandler.get(data, identifiers)
            return (
              _.assign(comment, { updated_at: new Date() }, payload), resourceHandler.set(data, identifiers, comment)
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            var comment = resourceHandlers.WORKSPACE_ACTIVITY.get(data, identifiers)
            return { action: 'UPDATE_WORKSPACE_COMMENT', identifiers, payload: _.pick(comment, _.keys(payload)) }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/activities/:activityAllId', {
              workspaceAllId: identifiers.workspaceId,
              activityAllId: identifiers.uuid,
            })
            return zenkitFetchPreventSockets.put(url, payload)
          },
          getErrorMessage: function (data, identifiers, payload) {
            var comment = resourceHandlers.WORKSPACE_ACTIVITY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_COMMENT_FAILED',
              translateValues: { message: _.get(comment, ['message']) },
            }
          },
        },
        ADD_WORKSPACE_COMMENT_REACTION: {
          resource: RESOURCES.WORKSPACE_ACTIVITY,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' }, emoji: { type: 'string' } },
          isOptimisticUpdatePossible: isWorkspaceCommentCached,
          optimistic: function (data, identifiers, payload) {
            var currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              resourceHandler = resourceHandlers.WORKSPACE_ACTIVITY,
              comment = resourceHandler.get(data, identifiers),
              reaction = { userId: currentUser.id, emoji: payload.emoji }
            return _.some(comment.reactions, reaction)
              ? data
              : ((comment.updated_at = new Date()),
                (comment.reactions = comment.reactions || []),
                comment.reactions.push(_.defaults(reaction, payload)),
                resourceHandler.set(data, identifiers, comment))
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('activities/:activityAllId/reactions', { activityAllId: identifiers.uuid })
            return zenkitFetchPreventSockets.post(url, payload)
          },
          getErrorMessage: function (data, identifiers) {
            var comment = resourceHandlers.WORKSPACE_ACTIVITY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_COMMENT_FAILED',
              translateValues: { message: _.get(comment, ['message']) },
            }
          },
        },
        DEPRECATE_WORKSPACE_COMMENT_REACTION: {
          resource: RESOURCES.WORKSPACE_ACTIVITY,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' } },
          isOptimisticUpdatePossible: isWorkspaceCommentCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.WORKSPACE_ACTIVITY,
              comment = resourceHandler.get(data, identifiers),
              reactions = _.reject(comment.reactions, ['uuid', payload.uuid])
            return (
              _.assign(comment, { reactions, updated_at: new Date() }), resourceHandler.set(data, identifiers, comment)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('activities/:activityAllId/reactions/:reactionUUID', {
              activityAllId: identifiers.uuid,
              reactionUUID: payload.uuid,
            })
            return zenkitFetchPreventSockets.delete(url)
          },
          getErrorMessage: function (data, identifiers) {
            var comment = resourceHandlers.WORKSPACE_ACTIVITY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_COMMENT_FAILED',
              translateValues: { message: _.get(comment, ['message']) },
            }
          },
        },
        DEPRECATE_WORKSPACE_COMMENT: {
          resource: RESOURCES.WORKSPACE_ACTIVITY,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: isWorkspaceCommentCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.WORKSPACE_ACTIVITY,
              comment = resourceHandler.get(data, identifiers)
            return (
              (comment.message = null),
              (comment.enrichments = []),
              (comment.deprecated_at = new Date()),
              resourceHandler.set(data, identifiers, comment)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/activities/:activityAllId', {
              workspaceAllId: identifiers.workspaceId,
              activityAllId: identifiers.uuid,
            })
            return zenkitFetch.delete(url)
          },
          getErrorMessage: function (data, identifiers, payload) {
            var comment = resourceHandlers.WORKSPACE_ACTIVITY.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.DEPRECATE_LIST_COMMENT_FAILED',
              translateValues: { message: _.get(comment, ['message']) },
            }
          },
        },
        CONVERT_COMMENT_TO_ENTRY: {
          resource: RESOURCES.LIST_ENTRY,
          publishType: publishTypes.ADDED,
          payloadValidation: { activityIdentifiers: { type: 'object' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var activityIdentifiers = payload.activityIdentifiers
            return (
              isCommentCached(data, activityIdentifiers) && areListElementsCached(data, { listId: identifiers.listId })
            )
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var activityIdentifiers = payload.activityIdentifiers,
              activityResource = activityIdentifiers.listId ? RESOURCES.LIST_ACTIVITY : RESOURCES.WORKSPACE_ACTIVITY,
              activityResourceHandler = resourceHandlers[activityResource],
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data),
              activity = activityResourceHandler.get(data, activityIdentifiers),
              elements = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
              listEntryToAdd = _.pick(identifiers, ['uuid', 'listId'])
            if (
              (_.forEach(elements, function (element) {
                _.defaults(listEntryToAdd, utils.getEntryDefaultsForElement(element))
              }),
              !1 === _.isEmpty(activity.message))
            ) {
              var primaryElement = _.find(elements, ['isPrimary', !0])
              ;(listEntryToAdd.displayString = activity.message),
                (listEntryToAdd[primaryElement.uuid + '_text'] = activity.message),
                (listEntryToAdd[primaryElement.uuid + '_searchText'] = activity.message)
            }
            var fileEc = _.find(elementcategories, ['name', 'Files']),
              fileElement = _.find(elements, ['elementcategory', fileEc.id]),
              fileEnrichments = _.isNil(fileElement)
                ? []
                : _.filter(activity.enrichments, ['type', ZenkitControlsShared.enrichmentTypes.FILE])
            !1 === _.isEmpty(fileEnrichments) &&
              ((listEntryToAdd[fileElement.uuid + '_files'] = _.map(fileEnrichments, 'fileId')),
              (listEntryToAdd[fileElement.uuid + '_filesData'] = _.map(fileEnrichments, 'file')))
            var personEc = _.find(elementcategories, ['name', 'Persons']),
              personElement = _.find(elements, ['elementcategory', personEc.id]),
              mentions = _.isNil(personElement) ? [] : utils.parseMentionUsernames(activity.message)
            if (!1 === _.isEmpty(mentions)) {
              var usersByUsername = _.keyBy(resourceHandlers.USERS.get(data), 'username'),
                mentionedUsers = _.compact(
                  _.map(mentions, function (username) {
                    return usersByUsername[username]
                  }),
                )
              ;(listEntryToAdd[personElement.uuid + '_persons'] = _.map(mentionedUsers, 'id')),
                (listEntryToAdd[personElement.uuid + '_persons_sort'] = mentionedUsers)
            }
            data = _markListEntryAsUpdated(data, listEntryToAdd, publishTypes.ADDED, markResourceAsUpdated)
            var updatedEnrichments = _.differenceBy(activity.enrichments, fileEnrichments, 'uuid')
            updatedEnrichments.push({
              uuid: _.uniqueId('optimistic-uuid-'),
              type: ZenkitControlsShared.enrichmentTypes.LIST_ENTRY,
              listId: identifiers.listId,
              listEntryUUID: identifiers.uuid,
            })
            var updatedActivity = _.defaults({ message: '', enrichments: updatedEnrichments }, activity)
            return (
              markResourceAsUpdated({
                resource: activityResource,
                publishType: publishTypes.CHANGED,
                identifiers: activityIdentifiers,
              }),
              activityResourceHandler.set(data, activityIdentifiers, updatedActivity)
            )
          },
          save: function (data, identifiers, payload) {
            var activityIdentifiers = payload.activityIdentifiers,
              url = zenkitFetch.buildUrl('activities/:activityAllId/convert/lists/:listAllId/entries', {
                activityAllId: activityIdentifiers.uuid,
                listAllId: identifiers.listId,
              }),
              entryPrototype = { uuid: identifiers.uuid }
            return zenkitFetchPreventSockets.post(url, { entryPrototype })
          },
          updateInMemoryDb: function (params) {
            var entry = params.resource.entry,
              activity = params.resource.activity,
              inMemoryDb = params.inMemoryDb,
              whenListEntryUpdated = inMemoryDb.update(RESOURCES.LIST_ENTRY, _.pick(entry, ['listId', 'uuid']), entry),
              whenActivityUpdated = Promise.resolve()
            return (
              activity.listId
                ? (whenActivityUpdated = inMemoryDb.update(
                    RESOURCES.LIST_ACTIVITY,
                    _.pick(activity, ['listId', 'uuid']),
                    activity,
                  ))
                : activity.workspaceId &&
                  (whenActivityUpdated = inMemoryDb.update(
                    RESOURCES.WORKSPACE_ACTIVITY,
                    _.pick(activity, ['workspaceId', 'uuid']),
                    activity,
                  )),
              Promise.join(whenListEntryUpdated, whenActivityUpdated)
            )
          },
          publishServerResponseAndReturnResource: function (params) {
            var entry = params.serverResponse.entry,
              activity = params.serverResponse.activity
            return (
              resourceHandlers.LIST_ENTRY.publish({
                identifiers: _.pick(entry, ['listId', 'uuid']),
                publishType: publishTypes.ADDED,
                resource: entry,
              }),
              activity.listId
                ? resourceHandlers.LIST_ACTIVITY.publish({
                    identifiers: _.pick(activity, ['listId', 'uuid']),
                    publishType: publishTypes.CHANGED,
                    resource: activity,
                  })
                : activity.workspaceId &&
                  resourceHandlers.WORKSPACE_ACTIVITY.publish({
                    identifiers: _.pick(activity, ['workspaceId', 'uuid']),
                    publishType: publishTypes.CHANGED,
                    resource: activity,
                  }),
              entry
            )
          },
        },
        DEPRECATE_LIST_ENTRIES: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.REMOVED,
          payloadValidation: {
            listEntryUuids: { type: 'array' },
            shouldDeleteAll: { type: 'boolean', default: !1 },
            removeEntriesFromReferences: { type: 'boolean', default: !1 },
            filter: { type: ['object', 'undefined'] },
            deprecatedAt: { type: 'date', default: new Date() },
          },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            return areAffectedListEntriesCached({
              data,
              listId: identifiers.listId,
              listEntryUuids: payload.listEntryUuids,
              filter: payload.filter,
              invert: payload.shouldDeleteAll,
            })
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var listEntryUuidsToDeprecate = getAffectedListEntryUuids({
              data,
              listId: identifiers.listId,
              listEntryUuids: payload.listEntryUuids,
              filter: payload.filter,
              invert: payload.shouldDeleteAll,
              preFilterListEntries: function (listEntries) {
                return _.reject(listEntries, 'deprecated_at')
              },
            })
            return (
              _.forEach(listEntryUuidsToDeprecate, function (listEntryUuid) {
                data = optimisticallyDeprecateListEntry({
                  data,
                  listId: identifiers.listId,
                  listEntryUuid,
                  deprecatedAt: payload.deprecatedAt,
                  removeEntriesFromReferences: payload.removeEntriesFromReferences,
                  markResourceAsUpdated,
                })
              }),
              data
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            var listEntryUuidsToDeprecate = getAffectedListEntryUuids({
              data,
              listId: identifiers.listId,
              listEntryUuids: payload.listEntryUuids,
              filter: payload.filter,
              invert: payload.shouldDeleteAll,
              preFilterListEntries: function (listEntries) {
                return _.reject(listEntries, 'deprecated_at')
              },
            })
            if (_.isNil(listEntryUuidsToDeprecate))
              throw new Error('DEPRECATE_LIST_ENTRIES cannot be undone in this context.')
            return {
              action: 'RESTORE_LIST_ENTRIES',
              identifiers,
              payload: { listEntryUuids: listEntryUuidsToDeprecate },
            }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/delete/filter', { listAllId: identifiers.listId })
            return zenkitFetch.post(url, payload)
          },
          updateInMemoryDb: _ref12 => {
            var { resource, inMemoryDb } = _ref12
            return updateEveryEntrySeperately({ listEntries: resource, inMemoryDb })
          },
          getErrorMessage: function (data, identifiers) {
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return {
              translateId: 'LIST_ENTRIES.ERRORS.DEPRECATING_MULTIPLE_ENTRIES_FAILED',
              translateValues: { entryNamePlural: utils.getListEntryNameForList({ list, plural: !0 }) },
            }
          },
        },
        DELETE_LIST_ENTRIES: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.REMOVED,
          payloadValidation: {
            listEntryUuids: { type: 'array' },
            shouldDeleteAll: { type: 'boolean', default: !1 },
            filter: { type: ['object', 'undefined'] },
          },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/deprecated-entries/delete/filter', {
              listAllId: identifiers.listId,
            })
            return zenkitFetch.post(url, payload)
          },
          updateInMemoryDb: _ref13 => {
            var { resource, inMemoryDb } = _ref13
            return updateEveryEntrySeperately({ listEntries: resource, inMemoryDb })
          },
          updateInMemoryDbIfValueIsNil: !0,
          getErrorMessage: function (data, identifiers) {
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return {
              translateId: 'LIST_ENTRIES.ERRORS.DELETING_MULTIPLE_ENTRIES_FAILED',
              translateValues: { entryNamePlural: utils.getListEntryNameForList({ list, plural: !0 }) },
            }
          },
        },
        RESTORE_LIST_ENTRIES: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.ADDED,
          payloadValidation: {
            listEntryUuids: { type: 'array' },
            shouldRestoreAll: { type: 'boolean', default: !1 },
            filter: { type: ['object', 'undefined'] },
          },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            return areAffectedListEntriesCached({
              data,
              listId: identifiers.listId,
              listEntryUuids: payload.listEntryUuids,
              filter: payload.filter,
              invert: payload.shouldRestoreAll,
            })
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var listEntryUuidsToRestore = getAffectedListEntryUuids({
              data,
              listId: identifiers.listId,
              listEntryUuids: payload.listEntryUuids,
              filter: payload.filter,
              invert: payload.shouldRestoreAll,
              preFilterListEntries: function (listEntries) {
                return _.filter(listEntries, 'deprecated_at')
              },
            })
            return (
              _.forEach(listEntryUuidsToRestore, function (listEntryUuid) {
                data = optimisticallyRestoreListEntry({
                  data,
                  listId: identifiers.listId,
                  listEntryUuid,
                  markResourceAsUpdated,
                })
              }),
              data
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            var listEntryUuidsToRestore = getAffectedListEntryUuids({
              data,
              listId: identifiers.listId,
              listEntryUuids: payload.listEntryUuids,
              filter: payload.filter,
              invert: payload.shouldRestoreAll,
              preFilterListEntries: function (listEntries) {
                return _.filter(listEntries, 'deprecated_at')
              },
            })
            if (_.isNil(listEntryUuidsToRestore))
              throw new Error('RESTORE_LIST_ENTRIES cannot be undone in this context.')
            return {
              action: 'DEPRECATE_LIST_ENTRIES',
              identifiers,
              payload: { listEntryUuids: listEntryUuidsToRestore },
            }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/deprecated-entries/restore/filter', {
              listAllId: identifiers.listId,
            })
            return zenkitFetch.post(url, payload)
          },
          updateInMemoryDb: _ref14 => {
            var { resource, inMemoryDb } = _ref14
            return updateEveryEntrySeperately({ listEntries: resource, inMemoryDb })
          },
          getErrorMessage: function (data, identifiers) {
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return {
              translateId: 'LIST_ENTRIES.ERRORS.RESTORING_MULTIPLE_ENTRIES_FAILED',
              translateValues: { entryNamePlural: utils.getListEntryNameForList({ list, plural: !0 }) },
            }
          },
        },
        COPY_LIST_ENTRIES: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.ADDED,
          payloadValidation: {
            listEntryUuids: { type: 'array' },
            shouldCopyAll: { type: 'boolean', default: !1 },
            filter: { type: ['object', 'undefined'] },
          },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/copy/filter', { listAllId: identifiers.listId })
            return zenkitFetch.post(url, payload)
          },
          updateInMemoryDb: _ref15 => {
            var { resource, inMemoryDb } = _ref15
            return updateEveryEntrySeperately({ listEntries: resource, inMemoryDb })
          },
          getErrorMessage: function (data, identifiers) {
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return {
              translateId: 'LIST_ENTRIES.ERRORS.COPYING_MULTIPLE_ENTRIES_FAILED',
              translateValues: { entryNamePlural: utils.getListEntryNameForList({ list, plural: !0 }) },
            }
          },
        },
        MOVE_LIST_ENTRIES_TO_LIST: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.NONE,
          payloadValidation: {
            targetListId: { type: 'number' },
            listEntryUuids: { type: 'array' },
            suggestionsMap: { type: 'object', default: {} },
            deprecateSourceEntries: { type: 'boolean', default: !0 },
            shouldMoveAll: { type: 'boolean', default: !1 },
            filter: { type: ['object', 'null'], default: null },
            listEntryUuidMap: { type: ['object', 'null'], default: null },
          },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var isSupportedAction = !1 === payload.shouldMoveAll && !1 === _.isNil(payload.listEntryUuidMap),
              sourceCached =
                isListCached(data, { id: identifiers.listId }) &&
                areListElementsCached(data, { listId: identifiers.listId }),
              targetCached =
                isListCached(data, { id: payload.targetListId }) &&
                areListElementsCached(data, { listId: payload.targetListId })
            return isSupportedAction && sourceCached && targetCached
          },
          optimistic: function (data, identifiers, payload, markResourceAsUpdated) {
            var sourceList = resourceHandlers.LIST.get(data, { id: identifiers.listId }),
              targetList = resourceHandlers.LIST.get(data, { id: payload.targetListId }),
              sourceListElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
              targetListElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: targetList.id }),
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
              subentriesElementcategory = _.find(elementcategories, { name: 'Subentries' }),
              referencesElementcategory = _.find(elementcategories, { name: 'References' }),
              sourceListEntries = (function () {
                var sourceListEntries = resourceHandlers.LIST_ENTRIES.get(data, identifiers),
                  allListEntries = _.filter(sourceListEntries, function (listEntry) {
                    return _.isNil(listEntry.deprecated_at)
                  }),
                  isIncludedInPayloadUuids = function (listEntry) {
                    return _.includes(payload.listEntryUuids, listEntry.uuid)
                  }
                return payload.shouldMoveAll
                  ? _.reject(allListEntries, isIncludedInPayloadUuids)
                  : _.filter(allListEntries, isIncludedInPayloadUuids)
              })()
            if (_.size(sourceListEntries) !== _.size(payload.listEntryUuidMap)) return data
            var oldToNewListEntriesUuidMap = payload.listEntryUuidMap,
              elementMap = (function () {
                if (!1 === _.isEmpty(payload.suggestionsMap)) {
                  var sourceUuids = _.keys(payload.suggestionsMap),
                    targetUuids = _.reject(_.values(payload.suggestionsMap), _.isEmpty)
                  if (_.size(targetUuids) > _.size(_.uniq(targetUuids)))
                    throw new Error('MOVE_LIST_ENTRIES_TO_LIST: duplicate targetUuid in suggestionsMap')
                  var hasMissingSourceElements =
                      !1 === _.chain(sourceUuids).difference(_.keys(sourceListElementsByUuid)).isEmpty().value(),
                    hasMissingTargetElements =
                      !1 === _.chain(targetUuids).difference(_.keys(targetListElementsByUuid)).isEmpty().value()
                  if (hasMissingSourceElements || hasMissingTargetElements)
                    throw new Error('MOVE_LIST_ENTRIES_TO_LIST: could not find elements referenced by suggestionsMap')
                  return payload.suggestionsMap
                }
                return _.reduce(
                  sourceListElementsByUuid,
                  function (map, sourceListElement) {
                    var targetListElement = _.find(targetListElementsByUuid, function (targetListElement) {
                      if (_.includes(map, targetListElement.uuid)) return !1
                      var sameElementcategory = targetListElement.elementcategory === sourceListElement.elementcategory
                      return (
                        sourceListElement.elementcategory !== subentriesElementcategory.id &&
                        (sameElementcategory && targetListElement.elementcategory === referencesElementcategory.id
                          ? targetListElement.elementData.childListUUID === sourceListElement.elementData.childListUUID
                          : sameElementcategory)
                      )
                    })
                    return targetListElement && (map[sourceListElement.uuid] = targetListElement.uuid), map
                  },
                  {},
                )
              })(),
              createTargetListEntry = function (sourceListEntry) {
                var prototype = (function (sourceListEntry) {
                  var targetListEntry = _.assign(
                    _.pick(sourceListEntry, ['sortOrder', 'checklists', 'comment_count']),
                    {
                      uuid: oldToNewListEntriesUuidMap[sourceListEntry.uuid],
                      listId: targetList.id,
                      originData: _.assign(
                        _.pick(sourceListEntry, ['id', 'uuid', 'shortId', 'listId', 'displayString']),
                        {
                          listShortId: sourceList.shortId,
                          listName: sourceList.name,
                          listEntryShortId: sourceListEntry.shortId,
                          listEntryDisplayString: sourceListEntry.displayString,
                          isListEntryDeprecated: payload.deprecateSourceEntries,
                        },
                      ),
                      originProvider: 'zenkit',
                      origin_created_at: sourceListEntry.created_at,
                      origin_updated_at: sourceListEntry.updated_at,
                    },
                  )
                  return _.reduce(
                    _.values(sourceListElementsByUuid),
                    function (targetListEntry, sourceListElement) {
                      var targetListElement = targetListElementsByUuid[elementMap[sourceListElement.uuid]]
                      if (
                        _.isNil(targetListElement) ||
                        targetListElement.elementcategory !== sourceListElement.elementcategory
                      )
                        return targetListEntry
                      var elementcategory = _.find(elementcategories, { id: targetListElement.elementcategory }),
                        primaryKey = _.findKey(elementcategory.businessDataDefinition, { primary: !0 }),
                        sourceValue = sourceListEntry[sourceListElement.uuid + '_' + primaryKey],
                        targetValue = (function () {
                          var copyElementKey = function (suffix) {
                            targetListEntry[targetListElement.uuid + '_' + suffix] =
                              sourceListEntry[sourceListElement.uuid + '_' + suffix]
                          }
                          switch (elementcategory.name) {
                            case 'Date':
                              return (
                                copyElementKey('hasTime'),
                                copyElementKey('endDate'),
                                copyElementKey('duration'),
                                sourceValue
                              )
                            default:
                              return sourceValue
                          }
                        })()
                      return (targetListEntry[targetListElement.uuid + '_' + primaryKey] = targetValue), targetListEntry
                    },
                    targetListEntry,
                  )
                })(sourceListEntry)
                ;(prototype = computeListEntryPropertiesForOptimisticUpdate(
                  data,
                  { listId: targetList.id, uuid: prototype.uuid },
                  prototype,
                )),
                  _.forEach(targetListElementsByUuid, function (listElement) {
                    _.defaults(prototype, utils.getEntryDefaultsForElement(listElement))
                  }),
                  (data = _markListEntryAsUpdated(data, prototype, publishTypes.ADDED, markResourceAsUpdated)),
                  (data = updateMirrorReferencesForEntry({
                    data,
                    updatedListEntry: prototype,
                    listElements: _.values(targetListElementsByUuid),
                    markResourceAsUpdated,
                  }))
              }
            return (
              _.forEach(sourceListEntries, function (sourceListEntry) {
                var listEntry
                createTargetListEntry(sourceListEntry),
                  !0 === payload.deprecateSourceEntries &&
                    ((listEntry = sourceListEntry),
                    (data = optimisticallyDeprecateListEntry({
                      data,
                      listId: identifiers.listId,
                      listEntryUuid: listEntry.uuid,
                      removeEntriesFromReferences: !0,
                      markResourceAsUpdated,
                    })))
              }),
              data
            )
          },
          optimisticServerResponse: function (data, identifiers, payload) {
            var targetListEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: payload.targetListId }),
              targetListEntryUuids = _.values(payload.listEntryUuidMap)
            return _.chain(targetListEntriesByUuid).pick(targetListEntryUuids).values().value()
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:sourceListAllId/moveToList/:targetListAllId', {
              sourceListAllId: identifiers.listId,
              targetListAllId: payload.targetListId,
            })
            return zenkitFetch.put(url, _.omit(payload, ['targetListId']))
          },
          updateInMemoryDb: function (params) {
            return updateEveryEntrySeperately({ listEntries: params.resource, inMemoryDb: params.inMemoryDb }).then(
              function () {
                return updateInMemoryDbSubentryPathsForList({
                  listId: params.payload.targetListId,
                  inMemoryDb: params.inMemoryDb,
                  topLevelOrderWasAffected: !0,
                })
              },
            )
          },
          getErrorMessage: function (data, identifiers, payload) {
            var plural = _.size(payload.listEntryUuids) > 1 || payload.shouldMoveAll,
              list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return {
              translateId: payload.deprecateSourceEntries
                ? plural
                  ? 'LIST_ENTRIES.ERRORS.MOVING_MULTIPLE_ENTRIES_FAILED'
                  : 'LIST_ENTRIES.ERRORS.MOVING_ONE_ENTRY_FAILED'
                : plural
                ? 'LIST_ENTRIES.ERRORS.COPYING_MULTIPLE_ENTRIES_FAILED'
                : 'LIST_ENTRIES.ERRORS.COPYING_ONE_ENTRY_FAILED',
              translateValues: {
                entryName: utils.getListEntryNameForList({ list }),
                entryNamePlural: utils.getListEntryNameForList({ list, plural: !0 }),
              },
            }
          },
        },
        BULK_ACTION_LIST_ENTRIES: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            listElementId: { type: ['string', 'number'] },
            listEntryUuids: { type: 'array' },
            selectAll: { type: 'boolean' },
            filter: { type: 'object' },
            returnLimit: { type: 'number' },
            bulkAction: { type: 'string', customCheck: _.partial(_.includes, ['set', 'add', 'remove', 'replace']) },
            value: { type: 'any' },
            replaceWith: { type: ['any', 'undefined'] },
          },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var listElementId = payload.listElementId,
              bulkAction = payload.bulkAction,
              payloadRest = _.omit(payload, ['listElementId', 'bulkAction']),
              url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId/entries/filter/:bulkAction', {
                listAllId: identifiers.listId,
                elementAllId: listElementId,
                bulkAction,
              })
            return zenkitFetch.put(url, payloadRest)
          },
          updateInMemoryDb: _ref16 => {
            var { resource, inMemoryDb } = _ref16
            return updateEveryEntrySeperately({ listEntries: resource, inMemoryDb })
          },
          getErrorMessage: _.constant({ translateId: 'BULK_OPERATIONS.CHANGING_VALUES_FAILED' }),
        },
        ADJUST_DATES_FOR_DEPENDENCIES: {
          resource: RESOURCES.LIST_ENTRIES,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            dependencyElementAllId: { type: ['string', 'number'] },
            dateElementAllId: { type: ['string', 'number'] },
            strategy: { type: 'string' },
          },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var dependencyElementAllId = payload.dependencyElementAllId,
              dateElementAllId = payload.dateElementAllId,
              payloadRest = _.omit(payload, ['dependencyElementAllId', 'dateElementAllId']),
              url = zenkitFetch.buildUrl(
                'lists/:listAllId/dependencies/:dependencyElementAllId/dates/:dateElementAllId',
                { listAllId: identifiers.listId, dependencyElementAllId, dateElementAllId },
              )
            return zenkitFetch.put(url, payloadRest)
          },
          updateInMemoryDb: _ref17 => {
            var { resource, inMemoryDb } = _ref17
            return updateEveryEntrySeperately({ listEntries: resource, inMemoryDb })
          },
          getErrorMessage: _.constant({ translateId: 'BULK_OPERATIONS.CHANGING_VALUES_FAILED' }),
        },
        CREATE_LIST_VIEW: {
          resource: RESOURCES.VIEW,
          publishType: publishTypes.ADDED,
          payloadValidation: { name: { type: 'string' }, type: { type: 'number' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('users/me/lists/:listAllId/views', { listAllId: identifiers.listId })
            return zenkitFetch.post(url, _.defaults({ uuid: identifiers.uuid }, payload))
          },
          getErrorMessage: function (data, identifiers, payload) {
            return {
              translateId: 'STORE.ERROR_MESSAGES.CREATE_LIST_VIEW_FAILED',
              translateValues: { name: payload.name },
            }
          },
        },
        MIGRATE_MINDMAP_VIEW: {
          resource: RESOURCES.VIEW,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/mindmaps/:viewAllId/migrate', {
              listAllId: identifiers.listId,
              viewAllId: identifiers.uuid,
            })
            return zenkitFetch.post(url)
          },
          updateInMemoryDb: function (params) {
            var mindmapView = params.resource.mindmapView,
              subentriesElement = params.resource.subentriesElement,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            return Promise.all([
              inMemoryDb.update(RESOURCES.VIEW, identifiers, mindmapView),
              inMemoryDb.update(
                RESOURCES.LIST_ELEMENT,
                _.pick(subentriesElement, ['listId', 'uuid']),
                subentriesElement,
              ),
            ])
          },
          publishServerResponseAndReturnResource: function (params) {
            var identifiers = params.identifiers,
              mindmapView = params.serverResponse.mindmapView,
              subentriesElement = params.serverResponse.subentriesElement
            return (
              resourceHandlers.VIEW.publish({ identifiers, publishType: publishTypes.ADDED, resource: mindmapView }),
              resourceHandlers.LIST_ELEMENT.publish({
                identifiers: _.pick(subentriesElement, ['listId', 'uuid']),
                publishType: publishTypes.ADDED,
                resource: subentriesElement,
              }),
              mindmapView
            )
          },
        },
        UPDATE_LIST_VIEW: {
          resource: RESOURCES.VIEW,
          publishType: publishTypes.CHANGED,
          onlySaveLastQueuedAction: !0,
          payloadValidation: {
            name: { type: ['string', 'undefined'] },
            description: { type: ['string', 'null', 'undefined'] },
            settings: { type: ['object', 'undefined'] },
            isPublic: { type: ['boolean', 'undefined'] },
          },
          isOptimisticUpdatePossible: function (data, identifiers) {
            var view = resourceHandlers.VIEW.get(data, identifiers)
            return !1 === _.isNil(view)
          },
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.VIEW,
              newView = _.assign({}, resourceHandler.get(data, identifiers), payload)
            return resourceHandler.set(data, identifiers, newView)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/views/:viewAllId', {
              listAllId: identifiers.listId,
              viewAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url, payload)
          },
          getErrorMessage: function (data, identifiers, payload) {
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_VIEW_FAILED',
              translateValues: { name: payload.name },
            }
          },
        },
        REORDER_LIST_VIEW: {
          resource: RESOURCES.VIEWS,
          publishType: publishTypes.CHANGED,
          payloadValidation: { toSortUuid: { type: 'string' }, beforeAnchorUuid: { type: ['string', 'null'] } },
          isOptimisticUpdatePossible: function (data, identifiers) {
            var views = resourceHandlers.VIEWS.get(data, { listId: identifiers.listId })
            return !1 === _.isEmpty(views)
          },
          optimistic: function (data, identifiers, payload) {
            var views = _.values(resourceHandlers.VIEWS.get(data, identifiers))
            return (
              utils.moveObjectInArrayInFrontOfAnchor(views, payload.toSortUuid, payload.beforeAnchorUuid, 'uuid'),
              (views = _.map(views, function (view, index) {
                return (view.sortOrder = index), view
              })),
              resourceHandlers.VIEWS.set(data, identifiers, views)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/views/sort', { listAllId: identifiers.listId })
            return zenkitFetch.put(url, {
              beforeAnchorAllId: payload.beforeAnchorUuid,
              toSortAllId: payload.toSortUuid,
            })
          },
          getErrorMessage: function (data, identifiers, payload) {
            var view = resourceHandlers.VIEW.get(data, { listId: identifiers.listId, uuid: payload.toSortUuid })
            return {
              translateId: 'STORE.ERROR_MESSAGES.REORDER_LIST_VIEW_FAILED',
              translateValues: { name: _.get(view, ['name']) },
            }
          },
        },
        DEPRECATE_LIST_VIEW: {
          resource: RESOURCES.VIEW,
          publishType: publishTypes.REMOVED,
          optimistic: function (data, identifiers) {
            var view = resourceHandlers.VIEW.get(data, identifiers)
            return (view.deprecated_at = new Date()), resourceHandlers.VIEW.set(data, identifiers, view)
          },
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/views/:viewAllId', {
              listAllId: identifiers.listId,
              viewAllId: identifiers.uuid,
            })
            return zenkitFetch.delete(url)
          },
          getErrorMessage: function (data, identifiers) {
            var view = resourceHandlers.VIEW.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.DEPRECATE_LIST_VIEW_FAILED',
              translateValues: { name: _.get(view, ['name']) },
            }
          },
        },
        CREATE_USER_VIEW: {
          resource: RESOURCES.USER_VIEW,
          publishType: publishTypes.CHANGED,
          onlySaveLastQueuedAction: !0,
          payloadValidation: {
            type: { type: ['number'] },
            name: { type: ['string', 'undefined'] },
            settings: { type: ['object', 'undefined'] },
          },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('users/me/views', { viewAllId: identifiers.uuid })
            return zenkitFetch.post(url, _.defaults({ uuid: identifiers.uuid }, payload))
          },
        },
        UPDATE_USER_VIEW: {
          resource: RESOURCES.USER_VIEW,
          publishType: publishTypes.CHANGED,
          onlySaveLastQueuedAction: !0,
          payloadValidation: {
            name: { type: ['string', 'undefined'] },
            description: { type: ['string', 'null', 'undefined'] },
            settings: { type: ['object', 'undefined'] },
            isPublic: { type: ['boolean', 'undefined'] },
          },
          isOptimisticUpdatePossible: isUserViewCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.USER_VIEW,
              newView = _.assign({}, resourceHandler.get(data, identifiers), payload)
            return resourceHandler.set(data, identifiers, newView)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('users/me/views/:viewAllId/', { viewAllId: identifiers.uuid })
            return zenkitFetch.put(url, payload)
          },
          getErrorMessage: function (data, identifiers, payload) {
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_VIEW_FAILED',
              translateValues: { name: payload.name },
            }
          },
        },
        REORDER_USER_VIEW: {
          resource: RESOURCES.USER_VIEWS,
          publishType: publishTypes.CHANGED,
          payloadValidation: { toSortUuid: { type: 'string' }, beforeAnchorUuid: { type: ['string', 'null'] } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var viewsByUuid = resourceHandlers.USER_VIEWS.get(data, {})
            return Boolean(
              viewsByUuid[payload.toSortUuid] &&
                (_.isNil(payload.beforeAnchorUuid) || viewsByUuid[payload.beforeAnchorUuid]),
            )
          },
          optimistic: function (data, identifiers, payload) {
            var views = _.orderBy(resourceHandlers.USER_VIEWS.get(data, {}), ['sortOrder', 'uuid']),
              viewToSort = _.find(views, { uuid: payload.toSortUuid }),
              viewsWithoutViewToSort = _.reject(views, { uuid: payload.toSortUuid }),
              newViewIndex =
                (_.isNil(payload.beforeAnchorUuid)
                  ? -1
                  : _.findIndex(viewsWithoutViewToSort, { uuid: payload.beforeAnchorUuid })) + 1,
              viewsInUpdatedOrder = _.map(
                [
                  ...viewsWithoutViewToSort.slice(0, newViewIndex),
                  viewToSort,
                  ...viewsWithoutViewToSort.slice(newViewIndex),
                ],
                (view, index) => ((view.sortOrder = index), (view.updated_at = new Date()), view),
              )
            return resourceHandlers.USER_VIEWS.set(data, {}, viewsInUpdatedOrder)
          },
          save: function (data, identifiers, payload) {
            return zenkitFetch.put('users/me/views/sort', {
              toSortAllId: payload.toSortUuid,
              beforeAnchorAllId: payload.beforeAnchorUuid,
            })
          },
          getUndoAction: function (data, identifiers, payload) {
            var views = resourceHandlers.USER_VIEWS.get(data, {})
            if (_.isEmpty(views)) return null
            var sortedViews = _.orderBy(views, ['sortOrder', 'uuid']),
              currentBeforeAnchor = sortedViews[_.findIndex(sortedViews, { uuid: payload.toSortUuid }) - 1]
            return {
              action: 'REORDER_USER_VIEW',
              identifiers,
              payload: { toSortUuid: payload.toSortUuid, beforeAnchorUuid: _.get(currentBeforeAnchor, ['uuid'], null) },
            }
          },
        },
        DEPRECATE_USER_VIEW: {
          resource: RESOURCES.USER_VIEW,
          publishType: publishTypes.REMOVED,
          isOptimisticUpdatePossible: isUserViewCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.USER_VIEW,
              newView = _.defaults({ deprecated_at: new Date() }, resourceHandler.get(data, identifiers))
            return resourceHandler.set(data, identifiers, newView)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('users/me/views/:viewAllId/', { viewAllId: identifiers.uuid })
            return zenkitFetch.delete(url, payload)
          },
        },
        CREATE_LIST_FILTER: {
          resource: RESOURCES.LIST_FILTER,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('users/me/lists/:listAllId/filters', { listAllId: identifiers.listId })
            return zenkitFetch.post(url, _.defaults({ uuid: identifiers.uuid }, payload))
          },
          getErrorMessage: function (data, identifiers, payload) {
            return {
              translateId: 'STORE.ERROR_MESSAGES.CREATE_LIST_FILTER_FAILED',
              translateValues: { name: payload.name },
            }
          },
        },
        UPDATE_LIST_FILTER: {
          resource: RESOURCES.LIST_FILTER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: function (data, identifiers) {
            var filter = resourceHandlers.LIST_FILTER.get(data, identifiers)
            return !1 === _.isNil(filter)
          },
          optimistic: function (data, identifiers, payload) {
            var filter = resourceHandlers.LIST_FILTER.get(data, identifiers)
            return _.assign(filter, payload), resourceHandlers.LIST_FILTER.set(data, identifiers, filter)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/filters/:filterAllId', {
              listAllId: identifiers.listId,
              filterAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url, payload)
          },
          getErrorMessage: function (data, identifiers, payload) {
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_FILTER_FAILED',
              translateValues: { name: payload.name },
            }
          },
        },
        DEPRECATE_LIST_FILTER: {
          resource: RESOURCES.LIST_FILTER,
          publishType: publishTypes.REMOVED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/filters/:filterAllId', {
              listAllId: identifiers.listId,
              filterAllId: identifiers.uuid,
            })
            return zenkitFetch.delete(url)
          },
          getErrorMessage: function (data, identifiers, payload) {
            return {
              translateId: 'STORE.ERROR_MESSAGES.DEPRECATE_LIST_FILTER_FAILED',
              translateValues: { name: payload.name },
            }
          },
        },
        CREATE_LIST_ELEMENT: {
          resource: RESOURCES.LIST_ELEMENT,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var element = _.assign({}, payload, identifiers),
              url = zenkitFetch.buildUrl('lists/:listAllId/elements', { listAllId: identifiers.listId })
            return zenkitFetch.post(url, [element]).then(function (listElements) {
              return _.find(listElements, { uuid: identifiers.uuid })
            })
          },
          getErrorMessage: _.constant({ translateId: 'LIST_ELEMENTS.ERRORS.CREATING_ELEMENT_FAILED' }),
        },
        COPY_LIST_ELEMENT: {
          resource: RESOURCES.LIST_ELEMENT,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId/copy', {
                listAllId: identifiers.listId,
                elementAllId: payload.uuidOfElementToCopy,
              }),
              serverPayload = _.omit(payload, 'uuidOfElementToCopy')
            return zenkitFetch.post(url, serverPayload).then(function (listElements) {
              return _.find(listElements, { uuid: identifiers.uuid })
            })
          },
          getErrorMessage: _.constant({ translateId: 'LIST_ELEMENTS.ERRORS.COPYING_ELEMENT_FAILED' }),
        },
        UPDATE_LIST_ELEMENT: {
          resource: RESOURCES.LIST_ELEMENT,
          publishType: publishTypes.CHANGED,
          onlySaveLastQueuedAction: !0,
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var currentElement = resourceHandlers.LIST_ELEMENT.get(data, identifiers),
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
              categoriesEc = _.find(elementcategories, { name: 'Categories' })
            return (
              !_.isNil(currentElement) &&
              !_.isNil(categoriesEc) &&
              (currentElement.elementcategory !== categoriesEc.id ||
                !1 ===
                  _.chain(payload)
                    .get(['elementData', 'predefinedCategories'])
                    .find(function (category) {
                      return _.isNil(category.id)
                    })
                    .isObject()
                    .value())
            )
          },
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ELEMENT,
              updateParams = _.pick(payload, [
                'name',
                'description',
                'businessData',
                'elementData',
                'visibleInPublicList',
              ]),
              updatedListElement = _.assign({}, resourceHandler.get(data, identifiers), updateParams)
            return resourceHandler.set(data, identifiers, updatedListElement)
          },
          save: function (data, identifiers, payload) {
            var updateParams = _.pick(payload, [
                'name',
                'description',
                'businessData',
                'elementData',
                'visibleInPublicList',
              ]),
              predefinedCategories = _.get(payload, ['elementData', 'predefinedCategories'])
            !1 === _.isEmpty(predefinedCategories) &&
              ((updateParams = _.cloneDeep(updateParams)).elementData.predefinedCategories = _.map(
                predefinedCategories,
                function (category) {
                  return _.pick(category, [
                    'id',
                    'shortId',
                    'uuid',
                    'name',
                    'colorHex',
                    'sortOrder',
                    'elementId',
                    'listId',
                    'created_at',
                    'updated_at',
                    'deprecated_at',
                  ])
                },
              ))
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId', {
              listAllId: identifiers.listId,
              elementAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url, updateParams).then(function (updatedListElements) {
              return _.find(updatedListElements, identifiers)
            })
          },
          getErrorMessage: function (data, identifiers, payload, error) {
            var listElement = resourceHandlers.LIST_ELEMENT.get(data, identifiers),
              name = _.get(listElement, ['name']) || payload.name
            return _.get(error, ['code']) === ZenkitErrorCodes.LIST_ELEMENT_DESCRIPTION_TOO_LONG.code
              ? {
                  translateId: 'STORE.ERROR_MESSAGES.LIST_ELEMENT_DESCRIPTION_TOO_LONG',
                  translateValues: { name, description: payload.description },
                }
              : { translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_ELEMENT_FAILED', translateValues: { name } }
          },
        },
        UPDATE_MINDMAP: {
          resource: RESOURCES.LIST_ELEMENT,
          publishType: publishTypes.CHANGED,
          onlySaveLastQueuedAction: !0,
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var listElement = resourceHandlers.LIST_ELEMENT.get(data, identifiers)
            return !1 === _.isNil(listElement)
          },
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ELEMENT,
              listElement = resourceHandler.get(data, identifiers)
            return (
              (listElement.elementData.mindmapData = payload.mindmapData),
              resourceHandler.set(data, identifiers, listElement)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/mind-maps/:elementAllId', {
              listAllId: identifiers.listId,
              elementAllId: identifiers.uuid,
            })
            return zenkitFetchPreventSockets.put(url, payload).then(function (updatedListElements) {
              return _.find(updatedListElements, identifiers)
            })
          },
          getErrorMessage: _.constant({ translateId: 'STORE.ERROR_MESSAGES.UPDATE_MINDMAP_FAILED' }),
        },
        SET_LIST_ELEMENT_AS_PRIMARY: {
          resource: RESOURCES.LIST_ELEMENTS,
          publishType: publishTypes.CHANGED,
          onlySaveLastQueuedAction: !0,
          isOptimisticUpdatePossible: areListElementsCached,
          optimistic: function (data, identifiers, payload) {
            var resourceHandler = resourceHandlers.LIST_ELEMENTS,
              listElements = resourceHandler.get(data, identifiers),
              currentPrimaryElement = _.find(listElements, { isPrimary: !0 }),
              currentPrimaryElementSortOrder = currentPrimaryElement.sortOrder,
              newPrimaryElement = _.find(listElements, { uuid: payload.uuid })
            return (
              (currentPrimaryElement.isPrimary = !1),
              (currentPrimaryElement.sortOrder = newPrimaryElement.sortOrder),
              (newPrimaryElement.isPrimary = !0),
              (newPrimaryElement.sortOrder = currentPrimaryElementSortOrder),
              resourceHandler.set(data, identifiers, listElements)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId/setAsPrimary', {
              listAllId: identifiers.listId,
              elementAllId: payload.uuid,
            })
            return zenkitFetchPreventSockets.put(url)
          },
          getErrorMessage: _.constant({ translateId: 'LIST_ELEMENTS.ERRORS.SETTING_PRIMARY_FAILED' }),
        },
        SORT_LIST_ELEMENT: {
          resource: RESOURCES.LIST_ELEMENTS,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: areListElementsCached,
          optimistic: function (data, identifiers, payload) {
            var listElements = _.chain(resourceHandlers.LIST_ELEMENTS.get(data, identifiers))
              .values()
              .sortBy('sortOrder')
              .value()
            return (
              utils.moveObjectInArrayInFrontOfAnchor(listElements, payload.toSortId, payload.beforeAnchorId),
              (listElements = _.map(listElements, function (listElement, index) {
                return (listElement.sortOrder = index), (listElement.updated_at = new Date()), listElement
              })),
              resourceHandlers.LIST_ELEMENTS.set(data, identifiers, listElements)
            )
          },
          payloadValidation: { beforeAnchorId: { type: 'number' }, toSortId: { type: 'number' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/sort', { listAllId: identifiers.listId })
            return zenkitFetchPreventSockets.put(url, payload)
          },
          getErrorMessage: _.constant({ translateId: 'LIST_ELEMENTS.ERRORS.REORDERING_ELEMENT_FAILED' }),
        },
        MIGRATE_LIST_ELEMENT: {
          resource: RESOURCES.LIST_ELEMENT,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            newElementcategory: { type: 'number' },
            migrationParameters: { type: ['object', 'undefined'] },
          },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId/changeElementcategory', {
              listAllId: identifiers.listId,
              elementAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url, payload)
          },
          getErrorMessage: function (data, identifiers) {
            var listElement = resourceHandlers.LIST_ELEMENT.get(data, identifiers)
            return {
              translateId: 'STORE.ERROR_MESSAGES.UPDATE_LIST_ELEMENT_FAILED',
              translateValues: { name: _.get(listElement, ['name']) },
            }
          },
        },
        DEPRECATE_LIST_ELEMENT: {
          resource: RESOURCES.LIST_ELEMENT,
          publishType: publishTypes.REMOVED,
          isOptimisticUpdatePossible: isListElementCached,
          optimistic: function (data, identifiers, payload) {
            var listElement = resourceHandlers.LIST_ELEMENT.get(data, identifiers),
              now = new Date()
            return (
              (listElement.updated_at = now),
              (listElement.deprecated_at = now),
              resourceHandlers.LIST_ELEMENT.set(data, identifiers, listElement)
            )
          },
          getUndoAction: function (data, identifiers) {
            return { action: 'RESTORE_LIST_ELEMENT', identifiers, payload: {} }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId', {
              listAllId: identifiers.listId,
              elementAllId: identifiers.uuid,
            })
            return zenkitFetch.delete(url).then(function (listElements) {})
          },
          getErrorMessage: _.constant({ translateId: 'LIST_ELEMENTS.ERRORS.DELETING_ELEMENT_FAILED' }),
        },
        RESTORE_LIST_ELEMENT: {
          resource: RESOURCES.LIST_ELEMENT,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: isListElementCached,
          optimistic: function (data, identifiers, payload) {
            var listElement = resourceHandlers.LIST_ELEMENT.get(data, identifiers),
              now = new Date()
            return (
              (listElement.updated_at = now),
              (listElement.deprecated_at = null),
              resourceHandlers.LIST_ELEMENT.set(data, identifiers, listElement)
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            return { action: 'DEPRECATE_LIST_ELEMENT', identifiers }
          },
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId/restore', {
              listAllId: identifiers.listId,
              elementAllId: identifiers.uuid,
            })
            return zenkitFetch.put(url)
          },
          getErrorMessage: function (data, identifiers) {
            return {
              translateId: 'LIST_ELEMENTS.ERRORS.RESTORING_ELEMENT_FAILED',
              translateValues: { listElementName: resourceHandlers.LIST_ELEMENT.get(data, identifiers).name },
            }
          },
        },
        DELETE_LIST_ELEMENT: {
          resource: RESOURCES.LIST_ELEMENT,
          publishType: publishTypes.REMOVED,
          isOptimisticUpdatePossible: isListElementCached,
          optimistic: function (data, identifiers, payload) {
            return resourceHandlers.LIST_ELEMENT.set(data, identifiers, null)
          },
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/deprecated-elements/:elementAllId', {
              listAllId: identifiers.listId,
              elementAllId: identifiers.uuid,
            })
            return zenkitFetch.delete(url)
          },
          getErrorMessage: function (data, identifiers) {
            return {
              translateId: 'LIST_ELEMENTS.ERRORS.DELETE_ELEMENT_FAILED',
              translateValues: { listElementName: resourceHandlers.LIST_ELEMENT.get(data, identifiers).name },
            }
          },
        },
        UPDATE_LIST: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, identifiers)
            return !_.isNil(list)
          },
          optimistic: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, identifiers)
            return _.assign(list, payload), resourceHandlers.LIST.set(data, identifiers, list)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId', { listAllId: identifiers.id })
            return (
              (payload = _.pick(payload, [
                'name',
                'description',
                'iconClassNames',
                'iconColor',
                'iconBackgroundColor',
                'itemName',
                'itemNamePlural',
                'defaultViewModus',
                'settings',
              ])),
              zenkitFetch.put(url, payload)
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, identifiers)
            return { action: 'UPDATE_LIST', identifiers, payload: _.pick(list, _.keys(payload)) }
          },
          getErrorMessage: function (data, identifiers, payload) {
            return _.isString(payload.name)
              ? { translateId: 'LISTS.ERRORS.RENAMING_FAILED' }
              : _.isString(payload.iconClassNames)
              ? { translateId: 'LIST_SETTINGS_DIALOG.ERROR_MESSAGES.UPDATE_ICON_FAILED' }
              : _.isString(payload.defaultViewModus)
              ? { translateId: 'LIST_SETTINGS_DIALOG.ERROR_MESSAGES.UPDATE_DEFAULT_VIEW_MODUS_FAILED' }
              : { translateId: 'LISTS.ERRORS.UPDATING_FAILED' }
          },
        },
        UPDATE_LIST_VISIBILITY: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            visibility: {
              type: 'number',
              customCheck: function (visibility) {
                return _.includes(_.values(ZenkitControlsShared.listVisibilityTypes), visibility)
              },
            },
          },
          optimistic: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, identifiers)
            return _.assign(list, payload), resourceHandlers.LIST.set(data, identifiers, list)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/visibility', { listAllId: identifiers.id })
            return zenkitFetch.put(url, payload)
          },
          getUndoAction: function (data, identifiers, payload) {
            return {
              action: 'UPDATE_LIST_VISIBILITY',
              identifiers,
              payload: { visibility: resourceHandlers.LIST.get(data, identifiers).visibility },
            }
          },
          getErrorMessage: function (data, identifiers, payload) {
            return payload.visibility
              ? { translateId: 'LISTS.ERRORS.MAKE_PUBLIC_FAILED' }
              : { translateId: 'LISTS.ERRORS.MAKE_PRIVATE_FAILED' }
          },
        },
        UPDATE_LIST_BACKGROUND: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: { backgroundId: { type: ['number', 'null'] } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            if (_.isNil(payload.backgroundId)) return !0
            var background = resourceHandlers.BACKGROUND.get(data, { id: payload.backgroundId })
            return !1 === _.isNil(background)
          },
          optimistic: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, identifiers)
            return (list.backgroundId = payload.backgroundId), resourceHandlers.LIST.set(data, identifiers, list)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listId/background', { listId: identifiers.id })
            return zenkitFetch.put(url, payload)
          },
        },
        PUBLISH_LIST: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          optimistic: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, identifiers)
            return (list.isPublic = !0), resourceHandlers.LIST.set(data, identifiers, list)
          },
          getUndoAction: function (data, identifiers, payload) {
            return { action: 'UNPUBLISH_LIST', identifiers, payload: null }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listId/publish', { listId: identifiers.id })
            return zenkitFetch.put(url, payload)
          },
        },
        UNPUBLISH_LIST: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          optimistic: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, identifiers)
            return (list.isPublic = !1), resourceHandlers.LIST.set(data, identifiers, list)
          },
          getUndoAction: function (data, identifiers, payload) {
            return { action: 'PUBLISH_LIST', identifiers, payload: null }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listId/unpublish', { listId: identifiers.id })
            return zenkitFetch.put(url, payload)
          },
        },
        REORDER_LISTS_OF_WORKSPACE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.CHANGED,
          payloadValidation: { toSortId: { type: 'number' }, beforeAnchorId: { type: 'number' } },
          optimistic: function (data, identifiers, payload) {
            var workspace = resourceHandlers.WORKSPACE.get(data, identifiers)
            return (
              utils.moveObjectInArrayInFrontOfAnchor(workspace.lists, payload.toSortId, payload.beforeAnchorId),
              (workspace.lists = _.map(workspace.lists, function (list, index) {
                return (list.sortOrder = index + 1), list
              })),
              resourceHandlers.WORKSPACE.set(data, identifiers, workspace)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/lists/sort', { workspaceAllId: identifiers.id })
            return zenkitFetch.put(url, payload)
          },
          updateInMemoryDb: function (params) {
            var lists = params.resource,
              workspace = resourceHandlers.WORKSPACE.get(params.inMemoryDb.getData(), params.identifiers),
              updatedWorkspace = _.defaults({ lists }, workspace)
            return params.inMemoryDb.update(RESOURCES.WORKSPACE, params.identifiers, updatedWorkspace)
          },
          publishServerResponseAndReturnResource: function (params) {
            var workspace = resourceHandlers.WORKSPACE.get(params.data, params.identifiers)
            return (
              resourceHandlers.WORKSPACE.publish({
                identifiers: params.identifiers,
                resource: workspace,
                publishType: publishTypes.CHANGED,
              }),
              workspace
            )
          },
          getErrorMessage: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, { id: payload.toSortId })
            return {
              message:
                'Reordering the collection ' +
                utils.shorten(_.get(list, ['name']) || '', 50) +
                ' did not work as expected.',
            }
          },
        },
        MOVE_LIST_TO_WORKSPACE: {
          resource: RESOURCES.WORKSPACES_WITH_LISTS,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            listId: { type: 'number' },
            workspaceId: { type: 'number' },
            beforeAnchorId: { type: ['number', 'undefined'] },
          },
          optimistic: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, { id: payload.listId }),
              sourceWorkspaceId = list.workspaceId,
              targetWorkspaceId = payload.workspaceId,
              activitiesMap = resourceHandlers.ACTIVITIES.get(data, { listId: payload.listId }),
              updatedWorkspacesWithLists = _.map(
                resourceHandlers.WORKSPACES_WITH_LISTS.get(data, {}),
                function (workspace) {
                  return (
                    workspace.id === sourceWorkspaceId
                      ? (workspace.lists = _.reject(workspace.lists, { id: list.id }))
                      : workspace.id === targetWorkspaceId &&
                        ((list.workspaceId = workspace.id),
                        _.isNil(payload.beforeAnchorId)
                          ? ((list.sortOrder = parseInt(_.maxBy(workspace.lists, 'sortOrder').sortOrder) + 1),
                            (workspace.lists = _.unionBy(workspace.lists, [list], 'id')))
                          : ((workspace.lists = _.unionBy(workspace.lists, [list], 'id')),
                            utils.moveObjectInArrayInFrontOfAnchor(
                              workspace.lists,
                              payload.listId,
                              payload.beforeAnchorId,
                            ),
                            (workspace.lists = _.map(workspace.lists, function (list, index) {
                              return (list.sortOrder = index + 1), list
                            }))),
                        _.forEach(activitiesMap, function (activity) {
                          activity.workspaceId = workspace.id
                        })),
                    workspace
                  )
                },
              )
            return resourceHandlers.WORKSPACES_WITH_LISTS.set(data, {}, updatedWorkspacesWithLists)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/move/:workpaceAllId', {
              listAllId: payload.listId,
              workpaceAllId: payload.workspaceId,
            })
            return zenkitFetch.put(url, { beforeAnchorId: payload.beforeAnchorId }).then(_.constant(null))
          },
          getErrorMessage: function (data, identifiers, payload, error) {
            var list = resourceHandlers.LIST.get(data, { id: payload.listId }),
              workspace = resourceHandlers.WORKSPACE.get(data, { id: payload.workspaceId })
            return {
              translateId: 'STORE.ERROR_MESSAGES.MOVE_LIST_TO_WORKSPACE_FAILED',
              translateValues: { list: list.name, workspace: workspace.name },
            }
          },
        },
        DEPRECATE_LIST: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.REMOVED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('lists/:listAllId', { listAllId: identifiers.id })
            return zenkitFetch.delete(url)
          },
          updateInMemoryDb: function (params) {
            return params.inMemoryDb.update(RESOURCES.LIST, params.identifiers, null)
          },
          getUndoAction: function (data, identifiers, payload) {
            return { action: 'RESTORE_LIST', identifiers, payload: {} }
          },
          getErrorMessage: _.constant({ translateId: 'LISTS.ERRORS.DEPRECATION_FAILED' }),
        },
        RESTORE_LIST: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('deprecated-lists/:listAllId/restore', { listAllId: identifiers.id })
            return zenkitFetch.put(url)
          },
          getUndoAction: function (data, identifiers, payload) {
            return { action: 'DEPRECATE_LIST', identifiers, payload: {} }
          },
          getErrorMessage: _.constant({ translateId: 'LISTS.ERRORS.RESTORATION_FAILED' }),
        },
        DELETE_LIST: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.REMOVED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('deprecated-lists/:listAllId', { listAllId: identifiers.id })
            return zenkitFetch.delete(url)
          },
          updateInMemoryDb: function (params) {
            return params.inMemoryDb.update(RESOURCES.LIST, params.identifiers, null)
          },
          getErrorMessage: _.constant({ translateId: 'LISTS.ERRORS.DELETION_FAILED' }),
        },
        CLONE_LIST: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: {
            workspaceId: { type: 'number' },
            uuid: { type: ['string', 'undefined'] },
            name: { type: ['string', 'undefined'] },
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('clone/list/:listId/workspace/:workspaceId', {
                listId: identifiers.id,
                workspaceId: payload.workspaceId,
              }),
              list = _.pick(payload, ['uuid', 'name'])
            return zenkitFetch.post(url, list)
          },
          getErrorMessage: _.constant({ translateId: 'CLONE_LIST_DIALOG.ERROR_MESSAGES.CLONE_LIST_FAILED' }),
        },
        TRANSFER_LIST_RESOURCE_TAGS_OWNERSHIP: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: { targetAppType: { type: 'string' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/apps/:targetAppType/owner', {
              listAllId: identifiers.id,
              targetAppType: payload.targetAppType,
            })
            return zenkitFetch.put(url)
          },
        },
        CREATE_LIST_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            uuid: { type: 'string' },
            userId: { type: ['number', 'null'], default: null },
            groupId: { type: ['number', 'null'], default: null },
          },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            if (!1 === _.isNil(payload.userId)) {
              var user = resourceHandlers.USER.get(data, { id: payload.userId })
              return !1 === _.isNil(user)
            }
            if (!1 === _.isNil(payload.groupId)) {
              var group = resourceHandlers.GROUP.get(data, { id: payload.groupId })
              return !1 === _.isNil(group)
            }
            return !1
          },
          optimistic: function (data, identifiers, payload) {
            var roleId = ZenkitControlsShared.roles.listAdmin.id,
              access = _.defaults({ roleId, listId: identifiers.listId }, payload),
              accesses = resourceHandlers.ACCESSES_PER_LIST.get(data, identifiers),
              updatedAccesses = _.unionBy(accesses, [access], 'uuid')
            return resourceHandlers.ACCESSES_PER_LIST.set(data, identifiers, updatedAccesses)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/accesses', { listAllId: identifiers.listId })
            return zenkitFetch.post(url, payload)
          },
          updateInMemoryDb: function (params) {
            var resource = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            if (_.isNil(resource)) return Promise.resolve()
            var accesses = resourceHandlers.ACCESSES_PER_LIST.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.unionBy([resource.access], accesses, 'uuid'),
              groups = resourceHandlers.GROUPS.get(inMemoryDb.getData()),
              updatedGroups = _.unionBy(resource.groups, groups, 'id'),
              users = resourceHandlers.USERS.get(inMemoryDb.getData()),
              updatedUsers = _.unionBy(resource.users, users, 'id')
            return Promise.all([
              inMemoryDb.update(RESOURCES.USERS, {}, updatedUsers),
              inMemoryDb.update(RESOURCES.GROUPS, {}, updatedGroups),
              inMemoryDb.update(RESOURCES.ACCESSES_PER_LIST, identifiers, updatedAccesses),
            ])
          },
          publishServerResponseAndReturnResource: function (params) {
            var data = params.data,
              identifiers = params.identifiers,
              accesses = resourceHandlers.ACCESSES_PER_LIST.get(data, identifiers)
            return (
              resourceHandlers.ACCESSES_PER_LIST.publish({
                identifiers,
                publishType: publishTypes.CHANGED,
                resource: accesses,
              }),
              accesses
            )
          },
          getErrorMessage: _.constant({ translateId: 'SHARE_DIALOG.ERROR_MESSAGES.ADD_MEMBER_FAILED' }),
        },
        UPDATE_LIST_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' }, roleId: { type: 'string' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_LIST.get(data, identifiers)
            return _.some(accesses, ['uuid', payload.uuid])
          },
          optimistic: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_LIST.get(data, identifiers),
              updatedAccesses = _.map(accesses, function (access) {
                return access.uuid === payload.uuid && (access.roleId = payload.roleId), access
              })
            return resourceHandlers.ACCESSES_PER_LIST.set(data, identifiers, updatedAccesses)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listId/accesses/:accessAllId', {
              listId: identifiers.listId,
              accessAllId: payload.uuid,
            })
            return zenkitFetch.put(url, { roleId: payload.roleId })
          },
          updateInMemoryDb: function (params) {
            var resource = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            if (_.isNil(resource)) return Promise.resolve()
            var accesses = resourceHandlers.ACCESSES_PER_LIST.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.unionBy([resource.access], accesses, 'uuid')
            return inMemoryDb.update(RESOURCES.ACCESSES_PER_LIST, identifiers, updatedAccesses)
          },
          publishServerResponseAndReturnResource: function (params) {
            var data = params.data,
              identifiers = params.identifiers,
              accesses = resourceHandlers.ACCESSES_PER_LIST.get(data, identifiers)
            return (
              resourceHandlers.ACCESSES_PER_LIST.publish({
                identifiers,
                publishType: publishTypes.CHANGED,
                resource: accesses,
              }),
              accesses
            )
          },
          getErrorMessage: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_LIST.get(data, identifiers),
              access = _.find(accesses, ['uuid', payload.uuid])
            if (!_.isNil(access) && !1 === _.isNil(access.userId)) {
              var user = resourceHandlers.USER.get(data, { id: access.userId })
              if (_.isNil(user)) return
              return {
                translateId: 'STORE.ERROR_MESSAGES.ASSIGN_ROLE_FAILED',
                translateValues: { user: user.fullname },
              }
            }
          },
        },
        DELETE_LIST_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' } },
          optimistic: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_LIST.get(data, identifiers),
              updatedAccesses = _.reject(accesses, ['uuid', payload.uuid])
            return resourceHandlers.ACCESSES_PER_LIST.set(data, identifiers, updatedAccesses)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/accesses/:accessAllId', {
              listAllId: identifiers.listId,
              accessAllId: payload.uuid,
            })
            return zenkitFetch.delete(url)
          },
          updateInMemoryDb: function (params) {
            var inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers,
              access = params.resource && params.resource.access
            if (_.isNil(access)) return Promise.resolve()
            var accesses = resourceHandlers.ACCESSES_PER_LIST.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.reject(accesses, ['uuid', access.uuid])
            return inMemoryDb.update(RESOURCES.ACCESSES_PER_LIST, identifiers, updatedAccesses)
          },
          publishServerResponseAndReturnResource: function (params) {
            var data = params.data,
              identifiers = params.identifiers,
              accesses = resourceHandlers.ACCESSES_PER_LIST.get(data, identifiers)
            return (
              resourceHandlers.ACCESSES_PER_LIST.publish({
                identifiers,
                publishType: publishTypes.CHANGED,
                resource: accesses,
              }),
              accesses
            )
          },
        },
        REPLACE_LIST_USER: {
          resource: RESOURCES.ACCESSES_PER_LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: { userId: { type: 'number' }, replacementUserId: { type: 'number' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listId/users/:userId/replace', {
              listId: identifiers.listId,
              userId: payload.userId,
            })
            return zenkitFetch.put(url, { replacementUserId: payload.replacementUserId }).then(_.noop)
          },
          getErrorMessage: _.constant({ translateId: 'SHARE_DIALOG.ERROR_MESSAGES.REPLACE_MEMBER_FAILED' }),
        },
        CREATE_WORKSPACE_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_WORKSPACE,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            uuid: { type: 'string' },
            userId: { type: ['number', 'null'], default: null },
            groupId: { type: ['number', 'null'], default: null },
          },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            if (!1 === _.isNil(payload.userId)) {
              var user = resourceHandlers.USER.get(data, { id: payload.userId })
              return !1 === _.isNil(user)
            }
            if (!1 === _.isNil(payload.groupId)) {
              var group = resourceHandlers.GROUP.get(data, { id: payload.groupId })
              return !1 === _.isNil(group)
            }
            return !1
          },
          optimistic: function (data, identifiers, payload) {
            var roleId = ZenkitControlsShared.roles.workspaceAdmin.id,
              access = _.defaults({ roleId, workspaceId: identifiers.workspaceId }, payload),
              accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(data, identifiers),
              updatedAccesses = _.unionBy(accesses, [access], 'uuid')
            return resourceHandlers.ACCESSES_PER_WORKSPACE.set(data, identifiers, updatedAccesses)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/accesses', {
              workspaceAllId: identifiers.workspaceId,
            })
            return zenkitFetch.post(url, payload)
          },
          updateInMemoryDb: function (params) {
            var resource = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            if (_.isNil(resource)) return Promise.resolve()
            var accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.unionBy([resource.access], accesses, 'uuid'),
              groups = resourceHandlers.GROUPS.get(inMemoryDb.getData()),
              updatedGroups = _.unionBy(resource.groups, groups, 'id'),
              users = resourceHandlers.USERS.get(inMemoryDb.getData()),
              updatedUsers = _.unionBy(resource.users, users, 'id')
            return Promise.all([
              inMemoryDb.update(RESOURCES.USERS, {}, updatedUsers),
              inMemoryDb.update(RESOURCES.GROUPS, {}, updatedGroups),
              inMemoryDb.update(RESOURCES.ACCESSES_PER_WORKSPACE, identifiers, updatedAccesses),
            ])
          },
          publishServerResponseAndReturnResource: function (params) {
            var data = params.data,
              identifiers = params.identifiers,
              accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(data, identifiers)
            return (
              resourceHandlers.ACCESSES_PER_WORKSPACE.publish({
                identifiers,
                publishType: publishTypes.CHANGED,
                resource: accesses,
              }),
              accesses
            )
          },
          getErrorMessage: _.constant({ translateId: 'SHARE_DIALOG.ERROR_MESSAGES.ADD_MEMBER_FAILED' }),
        },
        UPDATE_WORKSPACE_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_WORKSPACE,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' }, roleId: { type: 'string' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(data, identifiers)
            return _.some(accesses, ['uuid', payload.uuid])
          },
          optimistic: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(data, identifiers),
              updatedAccesses = _.map(accesses, function (access) {
                return access.uuid === payload.uuid && (access.roleId = payload.roleId), access
              })
            return resourceHandlers.ACCESSES_PER_WORKSPACE.set(data, identifiers, updatedAccesses)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/accesses/:accessAllId', {
              workspaceAllId: identifiers.workspaceId,
              accessAllId: payload.uuid,
            })
            return zenkitFetch.put(url, { roleId: payload.roleId })
          },
          updateInMemoryDb: function (params) {
            var resource = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            if (_.isNil(resource)) return Promise.resolve()
            var accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.unionBy([resource.access], accesses, 'uuid')
            return inMemoryDb.update(RESOURCES.ACCESSES_PER_WORKSPACE, identifiers, updatedAccesses)
          },
          publishServerResponseAndReturnResource: function (params) {
            var data = params.data,
              identifiers = params.identifiers,
              accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(data, identifiers)
            return (
              resourceHandlers.ACCESSES_PER_WORKSPACE.publish({
                identifiers,
                publishType: publishTypes.CHANGED,
                resource: accesses,
              }),
              accesses
            )
          },
          getErrorMessage: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(data, identifiers),
              access = _.find(accesses, ['uuid', payload.uuid])
            if (!_.isNil(access) && !1 === _.isNil(access.userId)) {
              var user = resourceHandlers.USER.get(data, { id: access.userId })
              if (_.isNil(user)) return
              return {
                translateId: 'STORE.ERROR_MESSAGES.ASSIGN_ROLE_FAILED',
                translateValues: { user: user.fullname },
              }
            }
          },
        },
        DELETE_WORKSPACE_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_WORKSPACE,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' } },
          optimistic: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(data, identifiers),
              updatedAccesses = _.reject(accesses, ['uuid', payload.uuid])
            return resourceHandlers.ACCESSES_PER_WORKSPACE.set(data, identifiers, updatedAccesses)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/accesses/:accessAllId', {
              workspaceAllId: identifiers.workspaceId,
              accessAllId: payload.uuid,
            })
            return zenkitFetch.delete(url).then(_.noop)
          },
          updateInMemoryDb: function (params) {
            var inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers,
              access = params.resource && params.resource.access
            if (_.isNil(access)) return Promise.resolve()
            var accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.reject(accesses, ['uuid', access.uuid])
            return inMemoryDb.update(RESOURCES.ACCESSES_PER_WORKSPACE, identifiers, updatedAccesses)
          },
          publishServerResponseAndReturnResource: function (params) {
            var data = params.data,
              identifiers = params.identifiers,
              accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(data, identifiers)
            return (
              resourceHandlers.ACCESSES_PER_WORKSPACE.publish({
                identifiers,
                publishType: publishTypes.CHANGED,
                resource: accesses,
              }),
              accesses
            )
          },
        },
        INVITE_UNREGISTERED_USER: {
          resource: RESOURCES.USER,
          publishType: publishTypes.CHANGED,
          payloadValidation: { email: { type: 'string' }, name: { type: 'string' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('users/:userId/invite', { userId: identifiers.id })
            return zenkitFetch.post(url, payload)
          },
          getErrorMessage: _.constant({ translateId: 'SHARE_DIALOG.ERROR_MESSAGES.ADD_MEMBER_FAILED' }),
        },
        TRANSFER_LIST_OWNERSHIP: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: { userId: { type: 'number' } },
          optimistic: function (data, identifiers, payload) {
            var list = resourceHandlers.LIST.get(data, identifiers)
            return (
              (list.created_by = payload.userId),
              (list.updated_at = new Date()),
              resourceHandlers.LIST.set(data, identifiers, list)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/owner/:userAllId', {
              listAllId: identifiers.id,
              userAllId: payload.userId,
            })
            return zenkitFetch.put(url)
          },
          getErrorMessage: _.constant({ translateId: 'TRANSFER_OWNERSHIP_DIALOG.ERROR_MESSAGES.TRANSFER_FAILED' }),
        },
        TRANSFER_WORKSPACE_OWNERSHIP: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.CHANGED,
          payloadValidation: { userId: { type: 'number' } },
          optimistic: function (data, identifiers, payload) {
            var workspace = resourceHandlers.WORKSPACE.get(data, identifiers)
            return (
              (workspace.created_by = payload.userId),
              (workspace.updated_at = new Date()),
              resourceHandlers.WORKSPACE.set(data, identifiers, workspace)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/owner/:userAllId', {
              workspaceAllId: identifiers.id,
              userAllId: payload.userId,
            })
            return zenkitFetch.put(url)
          },
          getErrorMessage: _.constant({ translateId: 'TRANSFER_OWNERSHIP_DIALOG.ERROR_MESSAGES.TRANSFER_FAILED' }),
        },
        CREATE_LIST: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.ADDED,
          payloadValidation: {
            name: { type: 'string' },
            workspaceId: { type: 'number' },
            uuid: { type: ['string', 'undefined'] },
            defaultViewModus: { type: ['number', 'undefined'] },
          },
          identifierValidation: {},
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/lists', { workspaceAllId: payload.workspaceId })
            return zenkitFetch.post(url, { name: payload.name })
          },
          getErrorMessage: function (data, identifiers, payload, error) {
            return { translateId: 'STORE.ERROR_MESSAGES.CREATE_LIST_FAILED', translateValues: { list: payload.name } }
          },
        },
        CREATE_WORKSPACE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.ADDED,
          payloadValidation: { name: { type: 'string' } },
          identifierValidation: {},
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            return zenkitFetch.post('workspaces', { name: payload.name })
          },
          getErrorMessage: function (data, identifiers, payload, error) {
            return _.get(error, ['code']) === ZenkitErrorCodes.QUOTA_EXCEEDED.code
              ? {
                  translateId: 'STORE.ERROR_MESSAGES.WORKSPACE_NOT_CREATED_YET',
                  translateValues: { workspace: payload.name },
                }
              : {
                  translateId: 'STORE.ERROR_MESSAGES.WORKSPACE_CREATION_FAILED',
                  translateValues: { workspace: payload.name },
                }
          },
        },
        UPDATE_WORKSPACE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            name: { type: ['string', 'null', 'undefined'] },
            description: { type: ['string', 'null', 'undefined'] },
            settings: { type: ['object', 'undefined'] },
            iconClassNames: { type: ['string', 'null', 'undefined'] },
            iconColor: { type: ['string', 'null', 'undefined'] },
            iconBackgroundColor: { type: ['string', 'null', 'undefined'] },
          },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            return _.some(data.workspacesWithLists, { id: identifiers.id })
          },
          optimistic: function (data, identifiers, payload) {
            var workspace = resourceHandlers.WORKSPACE.get(data, identifiers)
            return (
              (payload = _.defaults({ settings: _.defaultsDeep({}, payload.settings, workspace.settings) }, payload)),
              _.assign(workspace, payload),
              data
            )
          },
          getUndoAction: function (data, identifiers, payload) {
            var workspace = resourceHandlers.WORKSPACE.get(data, identifiers)
            return { action: 'UPDATE_WORKSPACE', identifiers, payload: _.pick(workspace, _.keys(payload)) }
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId', { workspaceAllId: identifiers.id })
            return zenkitFetch.put(url, payload)
          },
        },
        DEPRECATE_WORKSPACE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.REMOVED,
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId', { workspaceAllId: identifiers.id })
            return zenkitFetch.delete(url, payload)
          },
        },
        CLONE_WORKSPACE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: { name: { type: ['string', 'undefined'] } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('clone/workspace/:workspaceId', { workspaceId: identifiers.id }),
              workspace = _.pick(payload, ['name'])
            return zenkitFetch.post(url, workspace)
          },
        },
        SORT_CATEGORIES: {
          resource: RESOURCES.CATEGORY_SORT_ORDER,
          publishType: publishTypes.CHANGED,
          payloadValidation: { beforeAnchorId: { type: ['array', 'number'] }, toSortId: { type: 'array' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/elements/:elementAllId/kanbanSort', {
              listAllId: identifiers.listId,
              elementAllId: identifiers.elementId,
            })
            return zenkitFetch.put(url, payload).then(function (sortedCategoryIds) {
              return _.assign({ sortedCategoryIds }, identifiers)
            })
          },
          getErrorMessage: function (data, identifiers) {
            var list = resourceHandlers.LIST.get(data, { id: identifiers.listId })
            return {
              translateId: 'LIST_ENTRIES.ERRORS.REORDER_FAILED',
              translateValues: { entryNamePlural: utils.getListEntryNameForList({ list, plural: !0 }) },
            }
          },
        },
        CREATE_REMINDER: {
          resource: RESOURCES.REMINDER,
          publishType: publishTypes.ADDED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: {
            listId: { type: 'number' },
            elementId: { type: ['number', 'null'], default: null },
            alarmDate: { type: ['string', 'null'], default: null },
            entryId: { type: 'number' },
            offset: { type: ['string', 'null'], default: null },
          },
          save: function (data, identifiers, payload) {
            if (!1 === (_.has(payload, ['elementId']) || _.has(payload, ['alarmDate'])))
              return Promise.reject('Reminder payload needs either an elementId or alarmDate.')
            var reminder = _.assign({}, identifiers, payload)
            return zenkitFetch.post('users/me/reminders', { reminders: [reminder] }).then(_.head)
          },
          getErrorMessage: _.constant({ translateId: 'REMINDERS.REMINDER_MODAL.SAVE_ERROR' }),
        },
        UPDATE_REMINDER: {
          resource: RESOURCES.REMINDER,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: {
            reminder: { type: ['object', 'undefined'] },
            timeToPostpone: { type: ['string', 'undefined'] },
            buildAlarmDates: { type: ['boolean', 'undefined'] },
            alarmDate: { type: ['string', 'undefined'] },
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('/reminders/:uuid', { uuid: identifiers.uuid })
            return zenkitFetch.put(url, payload)
          },
          getErrorMessage: _.constant({ translateId: 'REMINDERS.REMINDER_MODAL.SAVE_ERROR' }),
        },
        DEPRECATE_REMINDER: {
          resource: RESOURCES.REMINDER,
          publishType: publishTypes.REMOVED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('/reminders/:uuid', { uuid: identifiers.uuid })
            return zenkitFetch.delete(url)
          },
          getErrorMessage: _.constant({ translateId: 'REMINDERS.REMINDER_MODAL.DELETE_ERROR' }),
        },
        CREATE_RECURRENCE_RULE: {
          resource: RESOURCES.RECURRENCE_RULE,
          publishType: publishTypes.ADDED,
          identifierValidation: { listId: { type: 'number' } },
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: { elementId: { type: 'number' }, entryId: { type: 'number' }, rule: { type: 'object' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('/lists/:listId/elements/:elementId/entries/:entryId/recurrence/rules', {
              listId: identifiers.listId,
              elementId: payload.elementId,
              entryId: payload.entryId,
            })
            return zenkitFetch.post(url, payload.rule)
          },
        },
        DEPRECATE_RECURRENCE_RULE: {
          resource: RESOURCES.RECURRENCE_RULE,
          publishType: publishTypes.REMOVED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('/lists/:listId/recurrence/rules/:ruleId', {
              listId: identifiers.listId,
              ruleId: identifiers.id,
            })
            return zenkitFetch.delete(url, payload)
          },
        },
        ADD_GROUP_USER: {
          resource: RESOURCES.GROUP,
          publishType: publishTypes.CHANGED,
          payloadValidation: { userId: { type: 'number' } },
          identifierValidation: { id: { type: 'number' }, organizationId: { type: 'number' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id })
            return !_.isNil(group) && !group.isAllUsers && !_.includes(group.userIds, payload.userId)
          },
          optimistic: function (data, identifiers, payload) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id }),
              userIds = _.concat(group.userIds, [payload.userId]),
              updatedGroup = _.defaults({ userIds }, group)
            return resourceHandlers.GROUP.set(data, { id: identifiers.id }, updatedGroup)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/groups/:groupId/users', {
              organizationId: identifiers.organizationId,
              groupId: identifiers.id,
            })
            return zenkitFetch.post(url, payload)
          },
        },
        REMOVE_GROUP_USER: {
          resource: RESOURCES.GROUP,
          publishType: publishTypes.CHANGED,
          payloadValidation: { userId: { type: 'number' } },
          identifierValidation: { id: { type: 'number' }, organizationId: { type: 'number' } },
          isOptimisticUpdatePossible: function (data, identifiers) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id })
            return !_.isNil(group) && !0 !== group.isAllUsers
          },
          optimistic: function (data, identifiers, payload) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id }),
              userIds = _.without(group.userIds, payload.userId),
              updatedGroup = _.defaults({ userIds }, group)
            return resourceHandlers.GROUP.set(data, { id: identifiers.id }, updatedGroup)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/groups/:groupId/users/:userId', {
              organizationId: identifiers.organizationId,
              groupId: identifiers.id,
              userId: payload.userId,
            })
            return zenkitFetch.delete(url)
          },
        },
        ADD_GROUP_SUBGROUP: {
          resource: RESOURCES.GROUP,
          publishType: publishTypes.CHANGED,
          payloadValidation: { subgroupId: { type: 'number' } },
          identifierValidation: { id: { type: 'number' }, organizationId: { type: 'number' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id })
            if (_.isNil(group)) return !1
            if (group.isAllUsers) return !1
            var subgroupId = payload.subgroupId
            return group.id !== subgroupId && !_.includes(group.subgroupIds, subgroupId)
          },
          optimistic: function (data, identifiers, payload) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id }),
              subgroupIds = _.concat(group.subgroupIds, [payload.subgroupId]),
              updatedGroup = _.defaults({ subgroupIds }, group)
            return resourceHandlers.GROUP.set(data, { id: identifiers.id }, updatedGroup)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/groups/:groupId/subgroups', {
              organizationId: identifiers.organizationId,
              groupId: identifiers.id,
            })
            return zenkitFetch.post(url, payload)
          },
        },
        REMOVE_GROUP_SUBGROUP: {
          resource: RESOURCES.GROUP,
          publishType: publishTypes.CHANGED,
          payloadValidation: { subgroupId: { type: 'number' } },
          identifierValidation: { id: { type: 'number' }, organizationId: { type: 'number' } },
          isOptimisticUpdatePossible: function (data, identifiers) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id })
            return !_.isNil(group) && !0 !== group.isAllUsers
          },
          optimistic: function (data, identifiers, payload) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id }),
              subgroupIds = _.without(group.subgroupIds, payload.subgroupId),
              updatedGroup = _.defaults({ subgroupIds }, group)
            return resourceHandlers.GROUP.set(data, { id: identifiers.id }, updatedGroup)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/groups/:groupId/subgroups/:subgroupId', {
              organizationId: identifiers.organizationId,
              groupId: identifiers.id,
              subgroupId: payload.subgroupId,
            })
            return zenkitFetch.delete(url)
          },
        },
        CREATE_GROUP: {
          resource: RESOURCES.GROUPS,
          publishType: publishTypes.ADDED,
          payloadValidation: { name: { type: 'string' } },
          identifierValidation: { organizationId: { type: 'number' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/groups', {
              organizationId: identifiers.organizationId,
            })
            return zenkitFetch.post(url, payload)
          },
          updateInMemoryDb: function (params) {
            var resource = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            if (_.isNil(resource)) return Promise.resolve()
            var group = resource.group,
              accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.unionBy([resource.access], accesses, 'uuid')
            return Promise.all([
              inMemoryDb.update(RESOURCES.GROUP, { id: group.id }, group),
              inMemoryDb.update(
                RESOURCES.ACCESSES_PER_ORGANIZATION,
                { organizationId: identifiers.organizationId },
                updatedAccesses,
              ),
            ])
          },
          publishServerResponseAndReturnResource: function (params) {
            var data = params.data,
              identifiers = params.identifiers,
              group = params.serverResponse.group
            resourceHandlers.GROUP.publish({
              identifiers: { id: group.id },
              publishType: publishTypes.ADDED,
              resource: group,
            })
            var accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(data, {
              organizationId: identifiers.organizationId,
            })
            return (
              resourceHandlers.ACCESSES_PER_ORGANIZATION.publish({
                identifiers: { organizationId: identifiers.organizationId },
                publishType: publishTypes.CHANGED,
                resource: accesses,
              }),
              group
            )
          },
        },
        UPDATE_GROUP: {
          resource: RESOURCES.GROUP,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            name: { type: ['string', 'undefined'] },
            description: { type: ['string', 'null', 'undefined'] },
          },
          identifierValidation: { id: { type: 'number' }, organizationId: { type: 'number' } },
          isOptimisticUpdatePossible: function (data, identifiers) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id })
            return !_.isNil(group) && !0 !== group.isAllUsers
          },
          optimistic: function (data, identifiers, payload) {
            var group = resourceHandlers.GROUP.get(data, { id: identifiers.id }),
              name = payload.name || group.name,
              description = _.isUndefined(payload.description) ? group.description : payload.description,
              updatedGroup = _.defaults({ name, description }, group)
            return resourceHandlers.GROUP.set(data, { id: identifiers.id }, updatedGroup)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/groups/:groupId', {
              organizationId: identifiers.organizationId,
              groupId: identifiers.id,
            })
            return zenkitFetch.put(url, payload)
          },
        },
        DELETE_GROUP: {
          resource: RESOURCES.GROUP,
          publishType: publishTypes.REMOVED,
          identifierValidation: { id: { type: 'number' }, organizationId: { type: 'number' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/groups/:groupId', {
              organizationId: identifiers.organizationId,
              groupId: identifiers.id,
            })
            return zenkitFetch.delete(url)
          },
          updateInMemoryDb: function (params) {
            var inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            return inMemoryDb.update(RESOURCES.GROUP, { id: identifiers.id }, null)
          },
        },
        CREATE_ORGANIZATION_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_ORGANIZATION,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' }, userId: { type: 'number' }, roleId: { type: 'string' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/accesses', {
              organizationId: identifiers.organizationId,
            })
            return zenkitFetch.post(url, payload)
          },
          updateInMemoryDb: function (params) {
            var resource = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            if (_.isNil(resource)) return Promise.resolve()
            var users = resourceHandlers.USERS.get(inMemoryDb.getData(), {}),
              updatedUsers = _.unionBy(resource.users, users, 'id'),
              groups = resourceHandlers.GROUPS.get(inMemoryDb.getData(), {}),
              updatedGroups = _.unionBy(resource.groups, groups, 'id'),
              accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.unionBy([resource.access], accesses, 'uuid')
            return Promise.all([
              inMemoryDb.update(RESOURCES.USERS, {}, updatedUsers),
              inMemoryDb.update(RESOURCES.GROUPS, {}, updatedGroups),
              inMemoryDb.update(RESOURCES.ACCESSES_PER_ORGANIZATION, identifiers, updatedAccesses),
            ])
          },
          publishServerResponseAndReturnResource: function (params) {
            var resource = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(params.data, params.identifiers)
            return (
              !1 === _.isNil(resource) &&
                resourceHandlers.ACCESSES_PER_ORGANIZATION.publish({
                  identifiers: params.identifiers,
                  publishType: params.publishType || publishTypes.CHANGED,
                  resource,
                }),
              resource
            )
          },
        },
        UPDATE_ORGANIZATION_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_ORGANIZATION,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' }, roleId: { type: 'string' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(data, identifiers)
            return _.some(accesses, ['uuid', payload.uuid])
          },
          optimistic: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(data, identifiers),
              optimistic = _.map(accesses, function (access) {
                return access.uuid === payload.uuid && (access.roleId = payload.roleId), access
              })
            return resourceHandlers.ACCESSES_PER_ORGANIZATION.set(data, identifiers, optimistic)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/accesses/:accessAllId', {
              organizationId: identifiers.organizationId,
              accessAllId: payload.uuid,
            })
            return zenkitFetch.put(url, { roleId: payload.roleId })
          },
          updateInMemoryDb: function (params) {
            var resource = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            if (_.isNil(resource)) return Promise.resolve()
            var accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.unionBy([resource.access], accesses, 'uuid')
            return inMemoryDb.update(RESOURCES.ACCESSES_PER_ORGANIZATION, identifiers, updatedAccesses)
          },
          publishServerResponseAndReturnResource: function (params) {
            var resource = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(params.data, params.identifiers)
            return (
              !1 === _.isNil(resource) &&
                resourceHandlers.ACCESSES_PER_ORGANIZATION.publish({
                  identifiers: params.identifiers,
                  publishType: params.publishType || publishTypes.CHANGED,
                  resource,
                }),
              resource
            )
          },
        },
        DELETE_ORGANIZATION_ACCESS: {
          resource: RESOURCES.ACCESSES_PER_ORGANIZATION,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: 'string' } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(data, identifiers),
              access = _.find(accesses, ['uuid', payload.uuid])
            return !_.isNil(access) && !_.isNil(access.userId)
          },
          optimistic: function (data, identifiers, payload) {
            var accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(data, identifiers),
              optimistic = _.reject(accesses, ['uuid', payload.uuid])
            return resourceHandlers.ACCESSES_PER_ORGANIZATION.set(data, identifiers, optimistic)
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/accesses/:accessAllId', {
              organizationId: identifiers.organizationId,
              accessAllId: payload.uuid,
            })
            return zenkitFetch.delete(url)
          },
          updateInMemoryDb: function (params) {
            var resource = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers
            if (_.isNil(resource)) return Promise.resolve()
            var accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(inMemoryDb.getData(), identifiers),
              updatedAccesses = _.reject(accesses, ['uuid', resource.access.uuid])
            return inMemoryDb.update(RESOURCES.ACCESSES_PER_ORGANIZATION, identifiers, updatedAccesses)
          },
          publishServerResponseAndReturnResource: function (params) {
            var resource = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(params.data, params.identifiers)
            return (
              !1 === _.isNil(resource) &&
                resourceHandlers.ACCESSES_PER_ORGANIZATION.publish({
                  identifiers: params.identifiers,
                  publishType: params.publishType || publishTypes.CHANGED,
                  resource,
                }),
              resource
            )
          },
        },
        CREATE_USER_TAG: {
          resource: RESOURCES.USER_TAGS,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          payloadValidation: {
            name: {
              type: 'string',
              customCheck: function (name) {
                return !1 === _.isEmpty(name)
              },
            },
            colorHex: { type: 'string' },
          },
          save: function (data, identifiers, payload) {
            return zenkitFetch.post('/users/me/tags', payload)
          },
          updateInMemoryDb: function (params) {
            var tag = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers,
              tags = resourceHandlers.USER_TAGS.get(inMemoryDb.getData(), identifiers),
              updatedTagAssignments = _.sortBy(_.unionBy([tag], tags, 'uuid'), 'sortOrder')
            return inMemoryDb.update(RESOURCES.USER_TAGS, identifiers, updatedTagAssignments)
          },
          publishServerResponseAndReturnResource: function (params) {
            return (
              resourceHandlers.USER_TAGS.publish({
                identifiers: params.identifiers,
                publishType: publishTypes.CHANGED,
                resource: resourceHandlers.USER_TAGS.get(params.data, params.identifiers),
              }),
              params.serverResponse
            )
          },
          getErrorMessage: _.constant({ translateId: 'USER_ADD_ONS.USER_TAGS.FAILED.CREATE' }),
        },
        UPDATE_USER_TAGS: {
          resource: RESOURCES.USER_TAGS,
          publishType: publishTypes.CHANGED,
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            return zenkitFetch.put('/users/me/tags', { tags: payload })
          },
        },
        ASSIGN_USER_TAG: {
          resource: RESOURCES.USER_TAG_ASSIGNMENTS,
          publishType: publishTypes.CHANGED,
          payloadValidation: { listId: { type: 'number' }, listEntryId: { type: 'number' }, tagId: { type: 'number' } },
          optimistic: function (data, identifiers, payload) {
            var tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(data, {}),
              tagAssignment = _.find(tagAssignments, { listEntryId: payload.listEntryId, listId: payload.listId })
            return (
              _.isNil(tagAssignment)
                ? ((tagAssignment = {
                    listId: payload.listId,
                    listEntryId: payload.listEntryId,
                    tagIds: [payload.tagId],
                    userId: resourceHandlers.CURRENT_USER.get(data, {}).id,
                  }),
                  tagAssignments.push(tagAssignment))
                : (tagAssignment.tagIds = _.union(tagAssignment.tagIds, [payload.tagId])),
              resourceHandlers.USER_TAG_ASSIGNMENTS.set(data, identifiers, tagAssignments)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('/users/me/lists/:listAllId/entries/:listEntryAllId/tags/:tagAllId', {
              listAllId: payload.listId,
              listEntryAllId: payload.listEntryId,
              tagAllId: payload.tagId,
            })
            return zenkitFetch.post(url)
          },
          updateInMemoryDb: function (params) {
            var tagAssignment = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers,
              tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(inMemoryDb.getData(), identifiers),
              updatedTagAssignments = _.unionBy([tagAssignment], tagAssignments, 'uuid')
            return inMemoryDb.update(RESOURCES.USER_TAG_ASSIGNMENTS, identifiers, updatedTagAssignments)
          },
          publishServerResponseAndReturnResource: function (params) {
            var tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(params.data, params.identifiers)
            return (
              resourceHandlers.USER_TAG_ASSIGNMENTS.publish({
                identifiers: params.identifiers,
                publishType: publishTypes.CHANGED,
                resource: tagAssignments,
              }),
              tagAssignments
            )
          },
          getErrorMessage: _.constant({ translateId: 'USER_ADD_ONS.USER_TAGS.FAILED.ASSIGN' }),
        },
        REMOVE_USER_TAG: {
          resource: RESOURCES.USER_TAG_ASSIGNMENTS,
          publishType: publishTypes.CHANGED,
          payloadValidation: { listId: { type: 'number' }, listEntryId: { type: 'number' }, tagId: { type: 'number' } },
          optimistic: function (data, identifiers, payload) {
            var tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(data, {}),
              tagAssignment = _.find(tagAssignments, { listEntryId: payload.listEntryId, listId: payload.listId })
            return (
              (tagAssignment.tagIds = _.without(tagAssignment.tagIds, payload.tagId)),
              resourceHandlers.USER_TAG_ASSIGNMENTS.set(data, identifiers, tagAssignments)
            )
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('/users/me/lists/:listAllId/entries/:listEntryAllId/tags/:tagAllId', {
              listAllId: payload.listId,
              listEntryAllId: payload.listEntryId,
              tagAllId: payload.tagId,
            })
            return zenkitFetch.delete(url)
          },
          updateInMemoryDb: function (params) {
            var tagAssignment = params.resource,
              inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers,
              tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(inMemoryDb.getData(), identifiers),
              updatedTagAssignments = _.unionBy([tagAssignment], tagAssignments, 'uuid')
            return inMemoryDb.update(RESOURCES.USER_TAG_ASSIGNMENTS, identifiers, updatedTagAssignments)
          },
          publishServerResponseAndReturnResource: function (params) {
            var tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(params.data, params.identifiers)
            return (
              resourceHandlers.USER_TAG_ASSIGNMENTS.publish({
                identifiers: params.identifiers,
                publishType: publishTypes.CHANGED,
                resource: tagAssignments,
              }),
              tagAssignments
            )
          },
          getErrorMessage: _.constant({ translateId: 'USER_ADD_ONS.USER_TAGS.FAILED.REMOVE' }),
        },
        REMOVE_ALL_USER_TAGS_FROM_LIST: {
          resource: RESOURCES.USER_TAG_ASSIGNMENTS,
          publishType: publishTypes.CHANGED,
          payloadValidation: { listId: { type: 'number' } },
          isOptimisticUpdatePossible: _.constant(!1),
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('/users/me/lists/:listAllId/tags/', { listAllId: payload.listId })
            return zenkitFetch.delete(url)
          },
          updateInMemoryDb: function (params) {
            var inMemoryDb = params.inMemoryDb,
              identifiers = params.identifiers,
              tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(inMemoryDb.getData(), identifiers),
              updatedTagAssignments = _.unionBy(params.resource, tagAssignments, 'uuid')
            return inMemoryDb.update(RESOURCES.USER_TAG_ASSIGNMENTS, identifiers, updatedTagAssignments)
          },
          publishServerResponseAndReturnResource: function (params) {
            var tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(params.data, params.identifiers)
            return (
              resourceHandlers.USER_TAG_ASSIGNMENTS.publish({
                identifiers: params.identifiers,
                publishType: publishTypes.CHANGED,
                resource: tagAssignments,
              }),
              tagAssignments
            )
          },
        },
        MARK_NOTIFICATIONS_AS_READ: {
          resource: RESOURCES.MINIMAL_NEW_NOTIFICATIONS,
          publishType: publishTypes.CHANGED,
          payloadValidation: { where: { type: 'object' } },
          optimistic: function (data, identifiers, payload) {
            var filterParams = _.pick(payload.where, ['listId', 'listEntryId', 'workspaceId', 'activityType'])
            !1 === _.isNil(payload.where.notificationId) && (filterParams.id = payload.where.notificationId)
            var newNotifications = resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.get(data, {}),
              updatedNewNotifications = _.reject(newNotifications, filterParams)
            return (data = resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.set(data, identifiers, updatedNewNotifications))
          },
          save: function (data, identifiers, payload) {
            var newNotifications = resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.get(data, {})
            return zenkitFetch
              .put('users/me/notifications', { update: { isNew: !1, isRead: !0 }, where: payload.where })
              .then(function (updatedNotifications) {
                return _.isNil(updatedNotifications)
                  ? zenkitFetch.get('users/me/new-notifications-in-minimal-format')
                  : _.differenceBy(newNotifications, updatedNotifications, 'uuid')
              })
          },
        },
        MARK_NOTIFICATIONS_AS_NEW: {
          resource: RESOURCES.MINIMAL_NEW_NOTIFICATIONS,
          publishType: publishTypes.CHANGED,
          payloadValidation: { where: { type: 'object' }, minimalNewNotifications: { type: ['array', 'undefined'] } },
          isOptimisticUpdatePossible: function (data, identifiers, payload) {
            return !1 === _.isNil(payload.minimalNewNotifications)
          },
          optimistic: function (data, identifiers, payload) {
            var newNotifications = resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.get(data, {}),
              updatedNewNotifications = _.unionBy(newNotifications, payload.minimalNewNotifications, 'uuid')
            return (data = resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.set(data, identifiers, updatedNewNotifications))
          },
          save: function (data, identifiers, payload) {
            var newNotifications = resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.get(data, {})
            return zenkitFetch
              .put('users/me/notifications', { update: { isNew: !0, isRead: !1 }, where: payload.where })
              .then(function (updatedNotifications) {
                return _.isNil(updatedNotifications)
                  ? zenkitFetch.get('users/me/new-notifications-in-minimal-format')
                  : _.unionBy(newNotifications, updatedNotifications, 'uuid')
              })
          },
        },
        UPLOAD_ORGANIZATION_IMAGE: {
          resource: RESOURCES.ORGANIZATION,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: ['string', 'undefined'] }, file: { type: 'object' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/image', { organizationId: identifiers.id })
            return uploadFile(url, payload)
          },
        },
        UPLOAD_WORKSPACE_IMAGE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: ['string', 'undefined'] }, file: { type: 'object' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/image', { workspaceAllId: identifiers.id })
            return uploadFile(url, payload)
          },
        },
        UPLOAD_LIST_IMAGE: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: ['string', 'undefined'] }, file: { type: 'object' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/image', { listAllId: identifiers.id })
            return uploadFile(url, payload)
          },
        },
        DELETE_ORGANIZATION_IMAGE: {
          resource: RESOURCES.ORGANIZATION,
          publishType: publishTypes.CHANGED,
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/image', { organizationId: identifiers.id })
            return zenkitFetch.delete(url)
          },
        },
        DELETE_WORKSPACE_IMAGE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.CHANGED,
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/image', { workspaceAllId: identifiers.id })
            return zenkitFetch.delete(url)
          },
        },
        DELETE_LIST_IMAGE: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/image', { listAllId: identifiers.id })
            return zenkitFetch.delete(url)
          },
        },
        UPLOAD_CURRENT_USER_COVER_IMAGE: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: ['string', 'undefined'] }, file: { type: 'object' } },
          save: function (data, identifiers, payload) {
            return uploadFile('users/me/cover', payload)
          },
        },
        UPLOAD_ORGANIZATION_COVER_IMAGE: {
          resource: RESOURCES.ORGANIZATION,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: ['string', 'undefined'] }, file: { type: 'object' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/cover', { organizationId: identifiers.id })
            return uploadFile(url, payload)
          },
        },
        UPLOAD_WORKSPACE_COVER_IMAGE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: ['string', 'undefined'] }, file: { type: 'object' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/cover', { workspaceAllId: identifiers.id })
            return uploadFile(url, payload)
          },
        },
        UPLOAD_LIST_COVER_IMAGE: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          payloadValidation: { uuid: { type: ['string', 'undefined'] }, file: { type: 'object' } },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/cover', { listAllId: identifiers.id })
            return uploadFile(url, payload)
          },
        },
        DELETE_CURRENT_USER_COVER_IMAGE: {
          resource: RESOURCES.CURRENT_USER,
          publishType: publishTypes.CHANGED,
          save: function () {
            return zenkitFetch.delete('users/me/cover')
          },
        },
        DELETE_ORGANIZATION_COVER_IMAGE: {
          resource: RESOURCES.ORGANIZATION,
          publishType: publishTypes.CHANGED,
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/cover', { organizationId: identifiers.id })
            return zenkitFetch.delete(url)
          },
        },
        DELETE_WORKSPACE_COVER_IMAGE: {
          resource: RESOURCES.WORKSPACE,
          publishType: publishTypes.CHANGED,
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/cover', { workspaceAllId: identifiers.id })
            return zenkitFetch.delete(url)
          },
        },
        DELETE_LIST_COVER_IMAGE: {
          resource: RESOURCES.LIST,
          publishType: publishTypes.CHANGED,
          save: function (data, identifiers) {
            var url = zenkitFetch.buildUrl('lists/:listAllId/cover', { listAllId: identifiers.id })
            return zenkitFetch.delete(url)
          },
        },
        UPDATE_ORGANIZATION: {
          resource: RESOURCES.ORGANIZATION,
          publishType: publishTypes.CHANGED,
          payloadValidation: {
            name: { type: ['string', 'null', 'undefined'] },
            description: { type: ['string', 'null', 'undefined'] },
            iconClassNames: { type: ['string', 'null', 'undefined'] },
            iconColor: { type: ['string', 'null', 'undefined'] },
            iconBackgroundColor: { type: ['string', 'null', 'undefined'] },
          },
          save: function (data, identifiers, payload) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId', { organizationId: identifiers.id })
            return zenkitFetchPreventSockets.put(url, payload)
          },
        },
      }
    return _.reduce(
      actionHandlers,
      function (actionHandlers, actionHandler, key) {
        if (_.isNil(actions[key]))
          return (
            console.warn(
              'Action handler for non existent action found. Please add the action to constants.actions.',
              key,
              actionHandler,
            ),
            actionHandlers
          )
        var resourceHandler = resourceHandlers[actionHandler.resource]
        return (
          (actionHandlers[key] = utils.validateParameters(actionHandler, {
            resource: { type: 'string' },
            publishType: { type: 'string' },
            save: { type: 'function' },
            payloadValidation: { type: ['object', 'undefined'] },
            identifierValidation: { type: 'object', default: resourceHandler.identifierValidation },
            optimistic: { type: ['function', 'undefined'] },
            optimisticServerResponse: {
              type: 'function',
              default: function (data, identifiers, payload) {
                return resourceHandlers[actionHandler.resource].get(data, identifiers)
              },
            },
            isOptimisticUpdatePossible: {
              type: 'function',
              default: _.constant(_.isFunction(actionHandler.optimistic)),
            },
            getErrorMessage: {
              type: 'function',
              default: _.constant({ message: ZenkitErrorCodes.UNKNOWN_ERROR.description }),
            },
            getUndoAction: { type: 'function', default: _.constant(null) },
            onlySaveLastQueuedAction: { type: 'boolean', default: !1 },
            updateInMemoryDb: {
              type: 'function',
              default: function (params) {
                return (params = utils.validateParameters(params, {
                  inMemoryDb: { type: 'object' },
                  identifiers: { type: 'object' },
                  payload: { type: ['object', 'null'] },
                  resource: { type: ['object', 'null'] },
                })).inMemoryDb.update(actionHandler.resource, params.identifiers, params.resource)
              },
            },
            updateInMemoryDbIfValueIsNil: { type: 'boolean', default: !1 },
            publishServerResponseAndReturnResource: {
              type: 'function',
              default: function (params) {
                return (
                  (params = utils.validateParameters(params, {
                    data: { type: 'object' },
                    identifiers: { type: 'object' },
                    publishType: { type: 'string' },
                    serverResponse: { type: 'any', default: null },
                  })),
                  _.isNil(params.serverResponse)
                    ? null
                    : (resourceHandler.publish({
                        identifiers: params.identifiers,
                        publishType: params.publishType,
                        resource: params.serverResponse,
                      }),
                      params.serverResponse)
                )
              },
            },
          })),
          (actionHandlers[key].action = key),
          actionHandlers
        )
      },
      {},
    )
  }),
  (self.makeCommands = function (dependencies) {
    var _ = dependencies.lodash,
      utils = dependencies.utils,
      Promise = dependencies.Promise,
      zenkitFetch = dependencies.zenkitFetch,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      connectionChecker = dependencies.connectionChecker,
      inMemoryDb = dependencies.inMemoryDb,
      optimisticState = dependencies.optimisticState,
      resources = dependencies.resources,
      resourceHandlers = dependencies.resourceHandlers,
      SocketService = dependencies.SocketService,
      synchronization = dependencies.synchronization,
      publishTypes = dependencies.publishTypes,
      events = dependencies.events,
      emitEvent = dependencies.emitEvent,
      languageService = (dependencies.moment, dependencies.languageService),
      appType = dependencies.appType,
      zenkitIndexedDB = dependencies.zenkitIndexedDB,
      commands = {},
      loginLocally = function (data) {
        return Promise.all([
          inMemoryDb.update(resources.CURRENT_USER, {}, data.user),
          inMemoryDb.update(resources.ACCESS_TOKEN, {}, data.token),
        ]).then(_.constant(data))
      }
    ;(commands.login = function (params) {
      return zenkitFetch
        .post('auth/login', params)
        .catch(function (err) {
          return !1 === connectionChecker.isOnline()
            ? Promise.reject(
                _.defaults({ description: 'Login is not available offline.' }, ZenkitErrorCodes.NOT_AVAILABLE_OFFLINE),
              )
            : Promise.reject(err)
        })
        .then(loginLocally)
        .then(function (data) {
          return (
            resourceHandlers.ACCESS_TOKEN.publish({
              identifiers: {},
              publishType: publishTypes.CHANGED,
              resource: data.token,
            }),
            resourceHandlers.CURRENT_USER.publish({
              identifiers: {},
              publishType: publishTypes.CHANGED,
              resource: data.user,
            }),
            { user: data.user, token: data.token }
          )
        })
    }),
      (commands.loginViaToken = function (params) {
        return (
          (params = utils.validateParameters(params, { token: { type: 'string' } })),
          inMemoryDb
            .update(resources.ACCESS_TOKEN, {}, params.token)
            .then(function () {
              return (
                resourceHandlers.ACCESS_TOKEN.publish({
                  identifiers: {},
                  publishType: publishTypes.CHANGED,
                  resource: params.token,
                }),
                zenkitFetch.get('auth/currentuser', { query: { setCookie: !0 } })
              )
            })
            .then(function (user) {
              return inMemoryDb.update(resources.CURRENT_USER, {}, user).then(_.constant(user))
            })
            .then(function (user) {
              return (
                resourceHandlers.CURRENT_USER.publish({
                  identifiers: {},
                  publishType: publishTypes.CHANGED,
                  resource: user,
                }),
                user
              )
            })
        )
      }),
      (commands.register = function (params) {
        return zenkitFetch.post('auth/register', params).catch(function (err) {
          return !1 === connectionChecker.isOnline()
            ? Promise.reject(
                _.defaults(
                  { description: 'Register is not available offline.' },
                  ZenkitErrorCodes.NOT_AVAILABLE_OFFLINE,
                ),
              )
            : Promise.reject(err)
        })
      }),
      (commands.internalLogout = function () {
        return optimisticState
          .clear()
          .then(function () {
            return inMemoryDb.clear()
          })
          .then(function () {
            return (
              resourceHandlers.ACCESS_TOKEN.publish({
                identifiers: {},
                publishType: publishTypes.CHANGED,
                resource: null,
              }),
              resourceHandlers.CURRENT_USER.publish({
                identifiers: {},
                publishType: publishTypes.CHANGED,
                resource: null,
              }),
              emitEvent({ name: events.legacyEvent, args: ['zenkit-user-logged-out'] }),
              null
            )
          })
      }),
      (commands.logout = function (params) {
        return zenkitFetch
          .post('auth/logout', params)
          .catch(function (err) {
            return !1 === connectionChecker.isOnline()
              ? Promise.reject(
                  _.defaults(
                    { description: 'Logout is not available offline.' },
                    ZenkitErrorCodes.NOT_AVAILABLE_OFFLINE,
                  ),
                )
              : Promise.reject(err)
          })
          .then(commands.internalLogout)
      }),
      (commands.logoutOtherDevices = function (params) {
        return zenkitFetch.post('auth/logout-other-devices', params).then(function (result) {
          return commands.loginViaToken({ token: result.token })
        })
      }),
      (commands.getWebhooksForList = function (listId) {
        return !1 === _.isFinite(listId)
          ? Promise.reject(_.defaults({ description: 'Invalid listId' }, ZenkitErrorCodes.MISSING_PARAMETERS))
          : zenkitFetch('/webhooks/list/' + listId)
      }),
      (commands.createThirdPartyWebhook = function (params) {
        return Promise.resolve(params)
          .then(
            utils.validateParameters(params, {
              provider: { type: 'string', default: null },
              locale: { type: 'string', default: 'en' },
              triggerType: { type: 'number' },
              listId: { type: 'number' },
              url: { type: 'string' },
            }),
          )
          .then(function (params) {
            return zenkitFetch.post('/webhooks', params)
          })
      }),
      (commands.deleteThirdPartyWebhook = function (webhookId) {
        return !1 === _.isFinite(webhookId)
          ? Promise.reject(_.defaults({ description: 'Invalid webhookId.' }, ZenkitErrorCodes.MISSING_PARAMETERS))
          : zenkitFetch.delete('webhooks/' + webhookId)
      }),
      (commands.getThirdPartyWebhook = function (webhookId) {
        return !1 === _.isFinite(webhookId)
          ? Promise.reject(_.defaults({ description: 'Invalid webhookId.' }, ZenkitErrorCodes.MISSING_PARAMETERS))
          : zenkitFetch('/webhooks/' + webhookId)
      }),
      (commands.changeTimezone = function (timezone) {
        return zenkitFetch.put('users/me/changeTimezone', { timezone }).then(function (user) {
          return (
            resourceHandlers.CURRENT_USER.publish({
              identifiers: {},
              publishType: publishTypes.CHANGED,
              resource: user,
            }),
            user
          )
        })
      }),
      (commands.verifyEmail = function (params) {
        var url = zenkitFetch.buildUrl('emails/:emailAllId/verify', { emailAllId: params.emailAllId })
        return zenkitFetch.put(url, { timestamp: params.timestamp, hash: params.hash }).then(function (result) {
          var currentUser = resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {})
          return (
            !1 === _.isNil(currentUser) &&
              currentUser.id === result.user.id &&
              resourceHandlers.CURRENT_USER.publish({
                identifiers: {},
                publishType: publishTypes.CHANGED,
                resource: result.user,
              }),
            result
          )
        })
      }),
      (commands.setEmailToPrimary = function (params) {
        var url = zenkitFetch.buildUrl('emails/:emailAllId/setToPrimary', { emailAllId: params.emailId })
        return zenkitFetch.put(url).then(function (results) {
          return (
            resourceHandlers.ACCESS_TOKEN.get(optimisticState.getData(), {}) &&
              resourceHandlers.CURRENT_USER.publish({
                identifiers: {},
                publishType: publishTypes.CHANGED,
                resource: results.user,
              }),
            results
          )
        })
      }),
      (commands.completePasswordReset = function (params) {
        return zenkitFetch.put('auth/passwordreset/finish', params)
      }),
      (commands.confirmOrganizationInvite = function (params) {
        return zenkitFetch.post('organization-invites/confirm', params)
      }),
      (commands.getOrganizationAcquisition = function (params) {
        var url = zenkitFetch.buildUrl('users/me/organization-acquisition/:organizationId/:hash', {
          organizationId: params.organizationId,
          hash: params.hash,
        })
        return zenkitFetch.get(url)
      }),
      (commands.confirmOrganizationAcquisition = function (params) {
        return zenkitFetch.post('users/me/organization-acquisition/confirm', params)
      }),
      (commands.clearAccessToken = function () {
        return inMemoryDb.update(resources.ACCESS_TOKEN, {}, null).then(function () {
          return (
            resourceHandlers.ACCESS_TOKEN.publish({
              identifiers: {},
              publishType: publishTypes.CHANGED,
              resource: null,
            }),
            null
          )
        })
      }),
      (commands.clearOfflineStorage = function (params) {
        return inMemoryDb.clear({ stayLoggedIn: !0 })
      }),
      (commands.requestSocketRoom = SocketService.requestRoomByName),
      (commands.releaseSocketRoom = SocketService.releaseRoomByName),
      (commands.isSocketRoomActive = SocketService.isRoomActive),
      (commands.reconnect = SocketService.reconnect),
      (commands.disconnect = SocketService.close),
      (commands.checkConnection = connectionChecker.checkConnection),
      (commands.getListSynchronization = inMemoryDb.getListSynchronization),
      (commands.getAllListSynchronizations = inMemoryDb.getAllListSynchronizations),
      (commands.getWorkspaceSynchronization = inMemoryDb.getWorkspaceSynchronization),
      (commands.getAllWorkspaceSynchronizations = inMemoryDb.getAllWorkspaceSynchronizations),
      (commands.createListSynchronization = synchronization.createListSynchronization),
      (commands.deleteListSynchronization = synchronization.deleteListSynchronization),
      (commands.triggerListSynchronization = synchronization.triggerListSynchronization),
      (commands.ensureSynchronizations = synchronization.ensureSynchronizations),
      (commands.createWorkspaceSynchronization = synchronization.createWorkspaceSynchronization),
      (commands.deleteWorkspaceSynchronization = synchronization.deleteWorkspaceSynchronization),
      (commands.triggerWorkspaceSynchronization = synchronization.triggerWorkspaceSynchronization),
      (commands.startBackgroundSynchronization = synchronization.startBackgroundSynchronization),
      (commands.triggerBackgroundSynchronization = synchronization.triggerBackgroundSynchronization),
      (commands.getSyncStatus = synchronization.getSyncStatus)
    var updateAndPublishElements = function (listId, listElements, publishType) {
      return Promise.map(listElements, function (listElement) {
        return inMemoryDb.update(
          resources.LIST_ELEMENT,
          { listId: listElement.listId, uuid: listElement.uuid },
          publishType === publishTypes.REMOVED ? null : listElement,
        )
      }).then(function () {
        return resourceHandlers.LIST_ELEMENTS.publish({ identifiers: { listId }, publishType, resource: listElements })
      })
    }
    ;(commands.updateRecentlyChangedResourcesOfList = function (params) {
      var url = zenkitFetch.buildUrl('lists/:listId/recently-changed-resources', { listId: params.listId })
      return zenkitFetch.get(url, { query: { fromDate: params.fromDate } }).then(function (result) {
        var listEntriesDelta = result.listEntriesDelta,
          listElementsDelta = result.listElementsDelta,
          listActivitiesDelta = result.listActivitiesDelta,
          promises = []
        if (null === listEntriesDelta)
          resourceHandlers.LIST_ENTRIES.publish({
            identifiers: { listId: params.listId },
            publishType: publishTypes.CHANGED,
            resource: null,
          })
        else {
          var whenEntriesUpdated = optimisticState.onListEntriesArrived({
            listId: params.listId,
            listEntries: _.unionBy(
              _.get(listEntriesDelta, ['created'], []),
              _.get(listEntriesDelta, ['updated'], []),
              _.get(listEntriesDelta, ['deprecated'], []),
              'uuid',
            ),
            publishChanges: !0,
          })
          promises.push(whenEntriesUpdated)
        }
        if (null !== listActivitiesDelta) {
          var whenActivitiesUpdated = optimisticState.onListActivitiesArrived({
            listId: params.listId,
            listActivities: _.unionBy(
              _.get(listActivitiesDelta, ['created'], []),
              _.get(listActivitiesDelta, ['updated'], []),
              _.get(listActivitiesDelta, ['deprecated'], []),
              'uuid',
            ),
            publishChanges: !0,
          })
          promises.push(whenActivitiesUpdated)
        }
        return (
          listElementsDelta.created &&
            promises.push(
              updateAndPublishElements(params.listId, _.get(listElementsDelta, ['created'], []), publishTypes.ADDED),
            ),
          listElementsDelta.updated &&
            promises.push(
              updateAndPublishElements(params.listId, _.get(listElementsDelta, ['updated'], []), publishTypes.CHANGED),
            ),
          listElementsDelta.deprecated &&
            promises.push(
              updateAndPublishElements(
                params.listId,
                _.get(listElementsDelta, ['deprecated'], []),
                publishTypes.REMOVED,
              ),
            ),
          Promise.all(promises).return(null)
        )
      })
    }),
      (commands.retryAction = optimisticState.retryAction),
      (commands.dropAction = optimisticState.dropAction),
      (commands.getActionErrorDetails = optimisticState.getActionErrorDetails),
      (commands.getUndoAction = optimisticState.getUndoAction),
      (commands.getSizeOfStorageInBytes = inMemoryDb.getSizeOfStorageInBytes),
      (commands.isListAvailableOffline = inMemoryDb.isListAvailableOffline),
      (commands.isWorkspaceAvailableOffline = inMemoryDb.isWorkspaceAvailableOffline),
      (commands.isIndexedDBSupported = inMemoryDb.isIndexedDBSupported),
      (commands.getOrganizations = function () {
        return zenkitFetch
          .get('users/me/organizations')
          .then(function (organizations) {
            return inMemoryDb.update(resources.ORGANIZATIONS, {}, organizations), organizations
          })
          .catch(function (err) {
            return optimisticState.initialLoad.then(function () {
              var cachedOrganizations = resourceHandlers.ORGANIZATIONS.get(optimisticState.getData())
              return _.isNil(cachedOrganizations) ? Promise.reject(err) : cachedOrganizations
            })
          })
      }),
      (commands.getOrganizationUsers = function (params) {
        return Promise.resolve(params)
          .then(function (params) {
            return utils.validateParameters(params, { organizationId: { type: 'number' } })
          })
          .then(function (params) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/users', {
              organizationId: params.organizationId,
            })
            return zenkitFetch.get(url)
          })
          .then(function (result) {
            return result.users
          })
      }),
      (commands.createOrganizationUser = function (params) {
        return Promise.resolve(params)
          .then(function (params) {
            return utils.validateParameters(params, {
              organizationId: { type: 'number' },
              name: { type: 'string' },
              email: { type: 'string' },
            })
          })
          .then(function (params) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/users', {
                organizationId: params.organizationId,
              }),
              user = _.pick(params, ['name', 'email'])
            return zenkitFetch.post(url, user)
          })
      }),
      (commands.deleteOrganizationUser = function (params) {
        return Promise.resolve(params)
          .then(function (params) {
            return utils.validateParameters(params, { organizationId: { type: 'number' }, userId: { type: 'number' } })
          })
          .then(function (params) {
            var url = zenkitFetch.buildUrl('organizations/:organizationId/users/:userId', {
              organizationId: params.organizationId,
              userId: params.userId,
            })
            return zenkitFetch.delete(url)
          })
      }),
      (commands.getDefaultBackground = function (params) {
        var dark = Boolean(params && params.dark)
        return optimisticState.initialLoad.then(function () {
          var backgrounds = resourceHandlers.BACKGROUNDS.get(optimisticState.getData()),
            tag = _.get(ZenkitControlsShared.apps, [
              appType,
              'interfaces',
              'backgrounds',
              dark ? 'darkDefault' : 'lightDefault',
            ])
          return _.isNil(tag)
            ? _.head(backgrounds)
            : _.find(backgrounds, function (background) {
                return _.some(background.resourceTags, ['tag', tag])
              }) || _.head(backgrounds)
        })
      })
    commands.getBackground = function (params) {
      return (
        (params = utils.validateParameters(params, { backgroundId: { type: 'number', customCheck: _.isInteger } })),
        ((backgroundId = params.backgroundId),
        optimisticState.initialLoad.then(function () {
          var cachedBackground = resourceHandlers.BACKGROUND.get(optimisticState.getData(), { id: backgroundId })
          return _.isNil(cachedBackground) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : cachedBackground
        })).catch(function () {
          return (function (backgroundId) {
            var url = zenkitFetch.buildUrl('backgrounds/:backgroundId', { backgroundId })
            return zenkitFetch.get(url).tap(function (background) {
              return inMemoryDb.update(resources.BACKGROUND, { id: background.id }, background), background
            })
          })(params.backgroundId)
        })
      )
      var backgroundId
    }
    var currentPromise,
      syncWorkspacesWithLists =
        ((currentPromise = null),
        function () {
          return (
            _.isNil(currentPromise) &&
              (currentPromise = zenkitFetch
                .get('users/me/workspacesWithLists')
                .tap(function (workspacesWithLists) {
                  return optimisticState.onWorkspacesWithListsArrived({ workspacesWithLists })
                })
                .finally(function () {
                  currentPromise = null
                })),
            currentPromise
          )
        })
    ;(commands.syncWorkspacesWithLists = function () {
      return syncWorkspacesWithLists().then(_.constant(null))
    }),
      (commands.getWorkspacesWithListsForMe = function () {
        return inMemoryDb.initialLoad
          .then(function () {
            var cachedWorkspacesWithLists = resourceHandlers.WORKSPACES_WITH_LISTS.get(inMemoryDb.getData(), {})
            return _.isEmpty(cachedWorkspacesWithLists)
              ? Promise.reject(ZenkitErrorCodes.NOT_FOUND)
              : cachedWorkspacesWithLists
          })
          .catch(syncWorkspacesWithLists)
      })
    var someDifferenceBy = function (a, b, fn) {
        return _.some(a, function (value) {
          var check = fn(value)
          return (
            !1 ===
            _.some(b, function (other) {
              return check === fn(other)
            })
          )
        })
      },
      syncAccesses = function () {
        return zenkitFetch
          .get('/users/me/sync-accesses')
          .tap(function (accesses) {
            return (
              (function (accesses) {
                var byAccess = function (access) {
                    return access.resourceType + '-' + access.resourceId
                  },
                  current = resourceHandlers.ACCESSES.get(inMemoryDb.getData())
                ;(_.size(accesses) !== _.size(current) ||
                  someDifferenceBy(accesses, current, byAccess) ||
                  someDifferenceBy(current, accesses, byAccess)) &&
                  syncWorkspacesWithLists()
              })(accesses),
              inMemoryDb.update(resources.ACCESSES, {}, accesses)
            )
          })
          .tap(function (accesses) {
            resourceHandlers.ACCESSES.publish({ identifiers: {}, resource: accesses })
          })
      }
    commands.syncAccesses = syncAccesses
    var syncMinimalNewNotifications = function () {
      return zenkitFetch
        .get('users/me/new-notifications-in-minimal-format')
        .tap(function (notifications) {
          inMemoryDb.update(resources.MINIMAL_NEW_NOTIFICATIONS, {}, notifications)
        })
        .tap(function (notifications) {
          resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.publish({ identifiers: {}, resource: notifications })
        })
    }
    return (
      (commands.syncMinimalNewNotifications = syncMinimalNewNotifications),
      (commands.syncAllUserResources = function () {
        return zenkitFetch
          .get('users/me/resources-updated-at')
          .tap(function () {
            return inMemoryDb.initialLoad
          })
          .tap(function (timestamps) {
            emitEvent({ name: events.legacyEvent, args: ['zenkit-notifications-updated-at', timestamps.notifications] })
          })
          .tap(function (timestamps) {
            var data = inMemoryDb.getData(),
              lastTimestamps = resourceHandlers.USER_RESOURCES_SYNC_TIMESTAMPS.get(data, {}),
              isTimestampDifferentFor = function (key) {
                return lastTimestamps[key] !== timestamps[key]
              },
              whenAccessesSynced = Promise.resolve(),
              whenWorkspacesWithListsSynced = Promise.resolve(),
              whenUserViewsSynced = Promise.resolve(),
              whenUserTagsSynced = Promise.resolve(),
              whenUserTagAssignmentsSynced = Promise.resolve(),
              whenNewNotificationsSynced = Promise.resolve()
            return (
              isTimestampDifferentFor('accesses') && (whenAccessesSynced = syncAccesses()),
              (isTimestampDifferentFor('workspaces') ||
                isTimestampDifferentFor('lists') ||
                isTimestampDifferentFor('accesses')) &&
                (whenWorkspacesWithListsSynced = syncWorkspacesWithLists()),
              isTimestampDifferentFor('userViews') &&
                (whenUserViewsSynced = zenkitFetch
                  .get('/users/me/views')
                  .tap(userViews => optimisticState.onUserViewsArrived({ userViews }))),
              (isTimestampDifferentFor('userTags') || isTimestampDifferentFor('userTagAssignments')) &&
                (whenUserTagsSynced = zenkitFetch
                  .get('/users/me/tags-and-assignments')
                  .tap(function (result) {
                    return Promise.all([
                      inMemoryDb.update(resources.USER_TAGS, {}, result.tags),
                      inMemoryDb.update(resources.USER_TAG_ASSIGNMENTS, {}, result.tagAssignments),
                    ])
                  })
                  .tap(function (result) {
                    resourceHandlers.USER_TAGS.publish({ identifiers: {}, resource: result.tags }),
                      resourceHandlers.USER_TAG_ASSIGNMENTS.publish({
                        identifiers: {},
                        resource: result.tagAssignments,
                      })
                  })),
              isTimestampDifferentFor('notifications') && (whenNewNotificationsSynced = syncMinimalNewNotifications()),
              Promise.all([
                whenAccessesSynced,
                whenWorkspacesWithListsSynced,
                whenUserViewsSynced,
                whenUserTagsSynced,
                whenUserTagAssignmentsSynced,
                whenNewNotificationsSynced,
              ])
            )
          })
          .tap(function (timestamps) {
            return inMemoryDb.update(resources.USER_RESOURCES_SYNC_TIMESTAMPS, {}, timestamps)
          })
          .return(null)
      }),
      (commands.getOAuthAuthorizationRequestData = function (params) {
        params = utils.validateParameters(params, { requestKey: { type: 'string' } })
        var url = zenkitFetch.buildUrl('oauth/requestData/:requestKey', { requestKey: params.requestKey })
        return zenkitFetch.get(url)
      }),
      (commands.authorizeOAuthRequest = function (params) {
        params = utils.validateParameters(params, { requestKey: { type: 'string' } })
        var url = zenkitFetch.buildUrl('oauth/authorize')
        return zenkitFetch.post(url, { requestKey: params.requestKey })
      }),
      (commands.getOAuthClientsWithAccessToSelf = function () {
        var url = zenkitFetch.buildUrl('users/me/oauth/clients-with-access')
        return zenkitFetch.get(url)
      }),
      (commands.disconnectOAuthClientAccess = function (params) {
        params = utils.validateParameters(params, { clientId: { type: 'number' } })
        var url = zenkitFetch.buildUrl('users/me/oauth/client-access/:clientId', { clientId: params.clientId })
        return zenkitFetch.delete(url)
      }),
      (commands.getOAuthClientsForSelf = function () {
        var url = zenkitFetch.buildUrl('users/me/oauth/clients')
        return zenkitFetch.get(url)
      }),
      (commands.deleteOAuthClient = function (params) {
        params = utils.validateParameters(params, { clientId: { type: 'number' } })
        var url = zenkitFetch.buildUrl('oauth/clients/:clientId', { clientId: params.clientId })
        return zenkitFetch.delete(url)
      }),
      (commands.registerOAuthClient = function (params) {
        params = utils.validateParameters(params, {
          name: { type: 'string' },
          url: { type: ['string', 'undefined'] },
          redirectUri: { type: 'string' },
          isPublic: { type: 'boolean' },
          privacyPolicyUrl: { type: ['string', 'undefined'] },
          termsOfServiceUrl: { type: ['string', 'undefined'] },
        })
        var url = zenkitFetch.buildUrl('oauth/clients')
        return zenkitFetch.post(url, {
          clientName: params.name,
          clientUrl: params.url,
          redirectUri: params.redirectUri,
          isPublic: params.isPublic,
          privacyPolicyUrl: params.privacyPolicyUrl,
          termsOfServiceUrl: params.termsOfServiceUrl,
        })
      }),
      (commands.updateOAuthClient = function (params) {
        params = utils.validateParameters(params, {
          clientId: { type: 'number' },
          name: { type: ['string', 'undefined'] },
          redirectUri: { type: ['string', 'undefined'] },
          isPublic: { type: ['boolean', 'undefined'] },
          url: { type: ['string', 'undefined', 'null'] },
          privacyPolicyUrl: { type: ['string', 'undefined', 'null'] },
          termsOfServiceUrl: { type: ['string', 'undefined', 'null'] },
        })
        var url = zenkitFetch.buildUrl('oauth/clients/:clientId', { clientId: params.clientId })
        return zenkitFetch.put(url, {
          clientName: params.name,
          clientUrl: params.url,
          redirectUri: params.redirectUri,
          isPublic: params.isPublic,
          privacyPolicyUrl: params.privacyPolicyUrl,
          termsOfServiceUrl: params.termsOfServiceUrl,
        })
      }),
      (commands.resetOAuthClientSecret = function (params) {
        params = utils.validateParameters(params, { clientId: { type: 'number' } })
        var url = zenkitFetch.buildUrl('oauth/secrets/:clientId', { clientId: params.clientId })
        return zenkitFetch.delete(url)
      }),
      (commands.getExternalOembedSnippet = function (params) {
        return !1 === _.has(params, ['url'])
          ? Promise.reject(_.defaults({ description: 'Missing resource url.' }, ZenkitErrorCodes.MISSING_PARAMETERS))
          : zenkitFetch.post('/oembed', params)
      }),
      (commands.setLanguage = languageService.set),
      (commands.addResourceTags = function (resourceTags) {
        return zenkitFetch.post('/users/me/resource-tags', { resourceTags })
      }),
      (commands.removeResourceTags = function (resourceTags) {
        return zenkitFetch.delete('/users/me/resource-tags', { resourceTags })
      }),
      (commands.registerDevice = function (device) {
        return zenkitFetch.post('/users/me/devices', device)
      }),
      (commands.closeIndexedDB = function () {
        return inMemoryDb.initialLoad.then(function () {
          return zenkitIndexedDB.close()
        })
      }),
      (commands.syncCurrentUser = function () {
        return zenkitFetch
          .get('auth/currentuser')
          .tap(function (user) {
            return inMemoryDb.update(resources.CURRENT_USER, {}, user)
          })
          .tap(function (user) {
            resourceHandlers.CURRENT_USER.publish({
              identifiers: {},
              publishType: publishTypes.CHANGED,
              resource: user,
            })
          })
      }),
      (commands.handlePushNotificationData = function (params) {
        var groupedActivities = _.reduce(
            params.activities,
            function (grouped, activity) {
              return (
                activity.listId
                  ? (_.isNil(grouped.perList[activity.listId]) && (grouped.perList[activity.listId] = []),
                    grouped.perList[activity.listId].push(activity))
                  : activity.workspaceId &&
                    (_.isNil(grouped.perWorkspace[activity.workspaceId]) &&
                      (grouped.perWorkspace[activity.workspaceId] = []),
                    grouped.perWorkspace[activity.workspaceId].push(activity)),
                grouped
              )
            },
            { perList: {}, perWorkspace: {} },
          ),
          listPromises = _.map(groupedActivities.perList, function (activities, listIdAsString) {
            return optimisticState.onListActivitiesArrived({
              listId: parseInt(listIdAsString),
              listActivities: activities,
              publishChanges: !0,
            })
          }),
          workspacePromises = _.map(groupedActivities.perWorkspace, function (activities, workspaceIdAsString) {
            return optimisticState.onWorkspaceActivitiesArrived({
              workspaceId: parseInt(workspaceIdAsString),
              workspaceActivities: activities,
              publishChanges: !0,
            })
          })
        return Promise.all(_.concat(listPromises, workspacePromises)).return(null)
      }),
      (commands.getLinkMetadata = function (query) {
        return zenkitFetch.get('links/metadata', { query })
      }),
      (commands.getNotifications = function (query) {
        return zenkitFetch.get('users/me/notifications', { query })
      }),
      commands
    )
  }),
  (self.makeZenkitFetch = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      apiPrefix = _.trimEnd(_.trimStart(dependencies.apiPrefix, '/'), '/'),
      urlUtils = dependencies.urlUtils,
      clientVersion = dependencies.clientVersion,
      appType = dependencies.appType,
      getDynamicDefaultHeaders = dependencies.getDynamicDefaultHeaders || _.constant({}),
      pretendToBeOffline = dependencies.globals.pretendToBeOffline,
      defaultHeaders = {
        accept: 'application/json',
        'zenkit-client-version': clientVersion,
        'zenkit-app-type': appType,
      },
      normalizeHeaders = function (headers) {
        return _.mapKeys(headers, function (value, key) {
          return _.toLower(key)
        })
      },
      ZenkitFetch = function (url, conf) {
        return pretendToBeOffline
          ? (console.log('ZenkitFetch: pretend to be offline', _.isString(url) ? _.defaults({ url }, conf) : conf),
            Promise.reject(new Error('Network request failed')))
          : Promise.resolve(getDynamicDefaultHeaders())
              .then(normalizeHeaders)
              .then(function (dynamicDefaultHeaders) {
                !1 === _.isString(url) && (url = (conf = url).url),
                  (conf = conf || {}),
                  (url = (function (url) {
                    return _.startsWith(url, 'http')
                      ? url
                      : ((url = _.trimStart(url, '/')), urlUtils.getAbsolutePath(apiPrefix + '/' + url))
                  })(url || conf.url)),
                  _.unset(conf, ['url']),
                  conf.query && ((url += urlUtils.stringifyQueryParams(conf.query)), _.unset(conf, ['query']))
                var config = _.defaults({ credentials: 'same-origin' }, conf, { method: 'get' })
                return (
                  (config.headers = _.defaults(
                    normalizeHeaders(config.headers),
                    dynamicDefaultHeaders,
                    defaultHeaders,
                  )),
                  fetch(url, config)
                )
              })
              .then(function (response) {
                var contentType = response.headers.get('Content-Type'),
                  isJSON = _.startsWith(contentType, 'application/json')
                return !1 === response.ok
                  ? isJSON
                    ? response.json().then(function (data) {
                        return Promise.reject(_.get(data, ['error']))
                      })
                    : Promise.reject(new Error('Unexpected non-json error.'))
                  : 204 === response.status || _.isNil(contentType)
                  ? null
                  : isJSON
                  ? response.json()
                  : response.text()
              })
      }
    return (
      (ZenkitFetch.buildUrl = function (url, params) {
        return _.replace(url, /\/:([^/]+)/g, function (match, key) {
          return '/' + params[key]
        })
      }),
      _.forEach(['get'], function (method) {
        ZenkitFetch[method] = function (url, conf) {
          var config = _.defaults({ method, url }, conf)
          return ZenkitFetch(config)
        }
      }),
      _.forEach(['post', 'put', 'delete'], function (method) {
        ZenkitFetch[method] = function (url, data, conf) {
          var config = _.defaults({ method, url, body: JSON.stringify(data) }, conf)
          return (
            (config.headers = _.defaults(
              { 'content-type': 'application/json;charset=UTF-8' },
              normalizeHeaders(config.headers),
            )),
            ZenkitFetch(config)
          )
        }
      }),
      ZenkitFetch
    )
  }),
  (self.makeInMemoryDb = function (dependencies) {
    var currentSavePromise,
      _ = dependencies.lodash,
      Promise = dependencies.Promise,
      produceState = dependencies.produceState,
      zenkitFetch = dependencies.zenkitFetch,
      utils = dependencies.utils,
      resources = dependencies.resources,
      resourceHandlers = dependencies.resourceHandlers,
      zenkitIndexedDB = dependencies.zenkitIndexedDB,
      storageHandlers = dependencies.storageHandlers,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      emitEvent = dependencies.emitEvent,
      events = dependencies.events,
      workerErrors = dependencies.workerErrors,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      changeCallbackFns = utils.ChangeCallbackMixin(),
      onAfterResourceUpdatedChangeFns = utils.ChangeCallbackMixin(),
      persistentState = {
        data: {
          accessToken: void 0,
          accesses: [],
          elementcategories: void 0,
          backgrounds: void 0,
          defaultBackground: void 0,
          organizations: void 0,
          users: [],
          accessesPerOrganization: {},
          userResourcesSyncTimestamps: {},
          workspacesWithLists: void 0,
          currentUser: void 0,
          lastUsedViewIdPerList: {},
          listSynchronizations: {},
          workspaceSynchronizations: {},
          userTags: [],
          userTagAssignments: [],
          userViews: {},
          minimalNewNotifications: [],
          accessesPerWorkspace: {},
          activitiesPerWorkspace: {},
          entriesPerList: {},
          elementsPerList: {},
          filtersPerList: {},
          viewsPerList: {},
          activitiesPerList: {},
          categorySortOrdersPerList: {},
          accessesPerList: {},
          recurrenceRulesPerList: {},
        },
      },
      saveResource =
        ((currentSavePromise = Promise.resolve()),
        function (resource, identifiers, value) {
          return (currentSavePromise = currentSavePromise.finally(function () {
            identifiers = utils.validateParameters(identifiers || {}, resourceHandlers[resource].identifierValidation)
            var storageHandler = storageHandlers[resource]
            return _.isNil(storageHandler)
              ? (console.warn('Storage handler for resource ' + resource + ' not found.'),
                Promise.reject(ZenkitErrorCodes.NOT_FOUND))
              : storageHandlers[resource].save(identifiers, value)
          }))
        }),
      loadResource = function (resource, identifiers) {
        return (
          (identifiers = utils.validateParameters(identifiers || {}, resourceHandlers[resource].identifierValidation)),
          storageHandlers[resource].load(identifiers)
        )
      },
      whenElementcategoriesLoaded = zenkitFetch.get('elementcategories', { headers: {} }),
      whenBackgroundsLoaded = zenkitFetch.get('backgrounds', { headers: {} }),
      loadInitialState = function () {
        return Promise.props({
          USERS: loadResource(resources.USERS),
          GROUPS: loadResource(resources.GROUPS),
          ACCESS_TOKEN: loadResource(resources.ACCESS_TOKEN),
          USER_RESOURCES_SYNC_TIMESTAMPS: loadResource(resources.USER_RESOURCES_SYNC_TIMESTAMPS),
          ACCESSES: loadResource(resources.ACCESSES),
          ELEMENTCATEGORIES: loadResource(resources.ELEMENTCATEGORIES).then(function (elementcategories) {
            return _.isEmpty(elementcategories) ? whenElementcategoriesLoaded : elementcategories
          }),
          WORKSPACES_WITH_LISTS: loadResource(resources.WORKSPACES_WITH_LISTS),
          USER_VIEWS: loadResource(resources.USER_VIEWS),
          CURRENT_USER: loadResource(resources.CURRENT_USER),
          LIST_SYNCHRONIZATIONS: loadResource(resources.LIST_SYNCHRONIZATIONS),
          WORKSPACE_SYNCHRONIZATIONS: loadResource(resources.WORKSPACE_SYNCHRONIZATIONS),
          BACKGROUNDS: loadResource(resources.BACKGROUNDS).then(function (backgrounds) {
            return _.isEmpty(backgrounds) ? whenBackgroundsLoaded : backgrounds
          }),
          ORGANIZATIONS: loadResource(resources.ORGANIZATIONS),
          USER_TAGS: loadResource(resources.USER_TAGS),
          USER_TAG_ASSIGNMENTS: loadResource(resources.USER_TAG_ASSIGNMENTS),
          MINIMAL_NEW_NOTIFICATIONS: loadResource(resources.MINIMAL_NEW_NOTIFICATIONS),
        }).then(function (cachedData) {
          return _.reduce(
            cachedData,
            function (data, value, resourceName) {
              return resourceHandlers[resourceName].set(data, {}, value)
            },
            {
              accessToken: void 0,
              accesses: [],
              elementcategories: void 0,
              backgrounds: void 0,
              defaultBackground: void 0,
              organizations: void 0,
              users: [],
              accessesPerOrganization: {},
              userResourcesSyncTimestamps: {},
              workspacesWithLists: void 0,
              currentUser: void 0,
              lastUsedViewIdPerList: {},
              listSynchronizations: {},
              workspaceSynchronizations: {},
              userTags: [],
              userTagAssignments: [],
              userViews: {},
              minimalNewNotifications: [],
              accessesPerWorkspace: {},
              activitiesPerWorkspace: {},
              entriesPerList: {},
              elementsPerList: {},
              filtersPerList: {},
              viewsPerList: {},
              activitiesPerList: {},
              categorySortOrdersPerList: {},
              accessesPerList: {},
              recurrenceRulesPerList: {},
            },
          )
        })
      },
      resetStorage = function () {
        return !1 === zenkitIndexedDB.isSupported()
          ? Promise.resolve(void 0)
          : zenkitIndexedDB
              .clear()
              .then(function () {
                return storageHandlers.DB_VERSION.save({}, 29)
              })
              .then(_.constant(void 0))
      },
      initialLoad = zenkitIndexedDB.initialLoad
        .then(function () {
          return storageHandlers.DB_VERSION.load()
        })
        .then(function (version) {
          if (29 !== version)
            return !1 === zenkitIndexedDB.isSupported()
              ? Promise.resolve(void 0)
              : zenkitIndexedDB.keyValueStore
                  .getItem('zenkit-offline-storage-queue')
                  .tap(resetStorage)
                  .tap(function (oldQueue) {
                    if (!_.isEmpty(oldQueue))
                      return zenkitIndexedDB.keyValueStore.setItem('zenkit-offline-storage-queue', oldQueue)
                  })
                  .then(_.constant(void 0))
        })
        .then(loadInitialState)
        .catch(function (err) {
          return (
            console.error('Loading intial state failed.', err),
            resetStorage()
              .then(loadInitialState)
              .catch(function () {
                return console.error('Second attempt to load intial state failed.', err), Promise.reject(err)
              })
          )
        })
        .then(function (cachedState) {
          ;(persistentState.data = cachedState), changeCallbackFns.triggerChange()
        })
    initialLoad
      .then(function () {
        whenElementcategoriesLoaded
          .then(function (elementcategories) {
            return storageHandlers[resources.ELEMENTCATEGORIES]
              .save({}, elementcategories)
              .then(_.constant(elementcategories))
          })
          .catch(_.noop),
          whenBackgroundsLoaded
            .then(function (backgrounds) {
              return storageHandlers[resources.BACKGROUNDS].save({}, backgrounds).then(_.constant(backgrounds))
            })
            .catch(_.noop)
      })
      .catch(_.noop)
    var loadWorkspaceStatePromises,
      loadListStatePromises,
      inMemoryDb = {
        initialLoad,
        onChange: changeCallbackFns.onChange,
        onAfterResourceUpdated: onAfterResourceUpdatedChangeFns.onChange,
        isIndexedDBSupported: zenkitIndexedDB.isSupported,
        getData: function () {
          return persistentState.data
        },
        getSizeOfStorageInBytes: function () {
          return _.isFunction(_.get(navigator, ['webkitTemporaryStorage', 'queryUsageAndQuota']))
            ? new Promise(function (resolve, reject) {
                navigator.webkitTemporaryStorage.queryUsageAndQuota(resolve, reject)
              })
            : Promise.resolve(utils.sizeOfObjectInBytes(persistentState.data))
        },
        update: function (resource, identifiers, value, options) {
          return (
            (options = utils.validateParameters(options, {
              forcePersist: { type: 'boolean', default: !1 },
              triggerChange: { type: 'boolean', default: !0 },
            })),
            inMemoryDb.initialLoad
              .then(function () {
                if (void 0 === value)
                  throw (
                    (console.error(
                      'inMemoryDb.update: value cannot be undefined. Use null to remove a resource instead.',
                    ),
                    new Error(ZenkitErrorCodes.BAD_REQUEST))
                  )
                if (options.forcePersist && !1 === zenkitIndexedDB.isSupported())
                  return zenkitIndexedDB.rejectWithIndexedDBNotSupportedError()
                var shouldPersist =
                    zenkitIndexedDB.isSupported() &&
                    !1 === _.isNil(storageHandlers[resource]) &&
                    (options.forcePersist ||
                      _.isNil(identifiers) ||
                      _.isNil(identifiers.listId) ||
                      resource === resources.LAST_USED_VIEW_UUID_PER_LIST ||
                      resource === resources.USER_TAG_ASSIGNMENTS ||
                      inMemoryDb.isListAvailableOffline({ listId: identifiers.listId })),
                  dataBefore = persistentState.data
                return (
                  (persistentState.data = produceState(persistentState.data, function (data) {
                    return resourceHandlers[resource].set(data, identifiers, value)
                  })),
                  options.triggerChange && changeCallbackFns.triggerChange(),
                  !1 === shouldPersist
                    ? persistentState.data
                    : saveResource(resource, identifiers, value)
                        .then(function () {
                          return persistentState.data
                        })
                        .catch(function (err) {
                          return (
                            console.error(
                              'Could not update offline storage',
                              { resource, identifiers, value, options },
                              err,
                            ),
                            utils.isQuotaExceededError(err) &&
                              emitEvent({ name: events.workerError, error: { type: workerErrors.QUOTA_EXCEEDED } }),
                            (persistentState.data = dataBefore),
                            options.triggerChange && changeCallbackFns.triggerChange(),
                            Promise.reject(err)
                          )
                        })
                        .finally(function () {
                          dataBefore = void 0
                        })
                )
              })
              .tap(function () {
                onAfterResourceUpdatedChangeFns.triggerChange({ resource, identifiers, value })
              })
          )
        },
        updateMultiple: function (arrayOfParams) {
          return Promise.mapSeries(arrayOfParams, function (params, index) {
            var isLast = index === _.size(arrayOfParams) - 1
            return inMemoryDb.update(
              params.resource,
              params.identifiers,
              params.value,
              _.assign({}, params.options, { triggerChange: isLast }),
            )
          })
        },
        clear: function (params) {
          params = utils.validateParameters(params, { stayLoggedIn: { type: 'boolean', default: !1 } })
          var accessToken = resourceHandlers.ACCESS_TOKEN.get(inMemoryDb.getData(), {}) || null
          return resetStorage()
            .then(loadInitialState)
            .then(function (data) {
              params.stayLoggedIn &&
                (zenkitIndexedDB.isSupported() && storageHandlers.ACCESS_TOKEN.save({}, accessToken),
                (data = produceState(data, function (data) {
                  return resourceHandlers.ACCESS_TOKEN.set(data, {}, accessToken)
                }))),
                (persistentState.data = data),
                changeCallbackFns.triggerChange()
            })
        },
        isListAvailableOffline: function (params) {
          return (
            (params = utils.validateParameters(params, { listId: { type: 'number', customCheck: _.isInteger } })),
            !0 === _.get(inMemoryDb.getData(), ['listSynchronizations', params.listId, 'wasSynchronizedAtLeastOnce'])
          )
        },
        isWorkspaceAvailableOffline: function (params) {
          return (
            (params = utils.validateParameters(params, { workspaceId: { type: 'number', customCheck: _.isInteger } })),
            !0 ===
              _.get(inMemoryDb.getData(), [
                'workspaceSynchronizations',
                params.workspaceId,
                'wasSynchronizedAtLeastOnce',
              ])
          )
        },
        areListActivitiesAvailableOffline: function (params) {
          var synchronization = inMemoryDb.getAllListSynchronizations()[params.listId]
          return (
            !_.isNil(synchronization) &&
            !0 === synchronization.wasSynchronizedAtLeastOnce &&
            (synchronization.activitiesFilter === ZenkitControlsShared.activityTypes.FILTER.NONE ||
              synchronization.activitiesFilter === params.activitiesFilter)
          )
        },
        areWorkspaceActivitiesAvailableOffline: function (params) {
          var synchronization = inMemoryDb.getAllWorkspaceSynchronizations()[params.workspaceId]
          return (
            !_.isNil(synchronization) &&
            !0 === synchronization.wasSynchronizedAtLeastOnce &&
            (synchronization.activitiesFilter === ZenkitControlsShared.activityTypes.FILTER.NONE ||
              synchronization.activitiesFilter === params.activitiesFilter)
          )
        },
        getListSynchronization: function (params) {
          return inMemoryDb.getAllListSynchronizations()[params.listId]
        },
        getAllListSynchronizations: function () {
          return inMemoryDb.getData().listSynchronizations || {}
        },
        getWorkspaceSynchronization: function (params) {
          return inMemoryDb.getAllWorkspaceSynchronizations()[params.workspaceId]
        },
        getAllWorkspaceSynchronizations: function () {
          return inMemoryDb.getData().workspaceSynchronizations || {}
        },
        ensureListStateIsLoaded:
          ((loadListStatePromises = {}),
          function (params) {
            return (
              (params = utils.validateParameters(params, { listId: { type: 'number', customCheck: _.isInteger } })),
              inMemoryDb.initialLoad.then(function () {
                return !1 === inMemoryDb.isListAvailableOffline(params)
                  ? loadResource(resources.LAST_USED_VIEW_UUID_PER_LIST, { listId: params.listId }).then(function (
                      uuid,
                    ) {
                      ;(persistentState.data = produceState(persistentState.data, function (data) {
                        return resourceHandlers.LAST_USED_VIEW_UUID_PER_LIST.set(data, { listId: params.listId }, uuid)
                      })),
                        changeCallbackFns.triggerChange()
                    })
                  : (_.isNil(loadListStatePromises[params.listId]) &&
                      (loadListStatePromises[params.listId] = ((listId = params.listId),
                      Promise.all([
                        loadResource(resources.LIST_ENTRIES, { listId }),
                        loadResource(resources.LIST_ELEMENTS, { listId }),
                        loadResource(resources.VIEWS, { listId }),
                        loadResource(resources.ACTIVITIES, { listId }),
                        loadResource(resources.LAST_USED_VIEW_UUID_PER_LIST, { listId }),
                        loadResource(resources.CATEGORY_SORT_ORDERS_PER_LIST, { listId }),
                        loadResource(resources.ACCESSES_PER_LIST, { listId }),
                        loadResource(resources.LIST_FILTERS, { listId }),
                        loadResource(resources.RECURRENCE_RULES, { listId }),
                      ])).then(function (listState) {
                        ;(persistentState.data = (function (currentState, listId, listState) {
                          var list = _.chain(currentState.workspacesWithLists)
                            .flatMap('lists')
                            .find({ id: listId })
                            .value()
                          return _.isNil(list)
                            ? currentState
                            : produceState(currentState, function (data) {
                                return (
                                  (data = resourceHandlers.LIST_ENTRIES.set(data, { listId }, listState[0])),
                                  (data = resourceHandlers.LIST_ELEMENTS.set(data, { listId }, listState[1])),
                                  (data = resourceHandlers.VIEWS.set(data, { listId }, listState[2])),
                                  (data = resourceHandlers.ACTIVITIES.set(data, { listId }, listState[3])),
                                  (data = resourceHandlers.LAST_USED_VIEW_UUID_PER_LIST.set(
                                    data,
                                    { listId },
                                    listState[4],
                                  )),
                                  (data = resourceHandlers.CATEGORY_SORT_ORDERS_PER_LIST.set(
                                    data,
                                    { listId },
                                    listState[5],
                                  )),
                                  (data = resourceHandlers.ACCESSES_PER_LIST.set(data, { listId }, listState[6])),
                                  (data = resourceHandlers.LIST_FILTERS.set(data, { listId }, listState[7])),
                                  resourceHandlers.RECURRENCE_RULES.set(data, { listId }, listState[8])
                                )
                              })
                        })(persistentState.data, params.listId, listState)),
                          changeCallbackFns.triggerChange()
                      })),
                    loadListStatePromises[params.listId])
                var listId
              })
            )
          }),
        ensureWorkspaceStateIsLoaded:
          ((loadWorkspaceStatePromises = {}),
          function (params) {
            return inMemoryDb.initialLoad.then(function () {
              var workspaceId
              return (
                _.isNil(loadWorkspaceStatePromises[params.workspaceId]) &&
                  (loadWorkspaceStatePromises[params.workspaceId] = ((workspaceId = params.workspaceId),
                  Promise.props({
                    accesses: loadResource(resources.ACCESSES_PER_WORKSPACE, { workspaceId }),
                    activities: loadResource(resources.ACTIVITIES_PER_WORKSPACE, { workspaceId }),
                  })).then(function (workspaceState) {
                    ;(persistentState.data = (function (currentState, workspaceId, workspaceState) {
                      return produceState(currentState, function (data) {
                        return (
                          (data = resourceHandlers.ACCESSES_PER_WORKSPACE.set(
                            data,
                            { workspaceId },
                            workspaceState.accesses,
                          )),
                          resourceHandlers.ACTIVITIES_PER_WORKSPACE.set(
                            data,
                            { workspaceId },
                            workspaceState.activities,
                          )
                        )
                      })
                    })(persistentState.data, params.workspaceId, workspaceState)),
                      changeCallbackFns.triggerChange()
                  })),
                loadWorkspaceStatePromises[params.workspaceId]
              )
            })
          }),
        loadAllActivities: function () {
          return Promise.all([
            zenkitIndexedDB.getAll(zenkitIndexedDB.OBJECT_STORES.ACTIVITIES),
            zenkitIndexedDB.getAll(zenkitIndexedDB.OBJECT_STORES.ACTIVITIES_PER_WORKSPACE),
          ]).then(function (results) {
            return _.concat(results[0], results[1])
          })
        },
      }
    return inMemoryDb
  }),
  (self.makeOptimisticState = function (dependencies) {
    var current,
      trxChangeFns,
      triggerTransactionEnd,
      queueChangeFns,
      state,
      initialLoad,
      currentQueuePromise,
      modifyQueue,
      modifyAction,
      dropAction,
      dropActionAndRevertOptimisticUpdate,
      errorCodesForWhichAutomaticRetryMakesNoSense,
      isActionBlockedByRunningActions,
      tryToRunTheNextAction,
      tryToRunNextActionInBackground,
      actionUuidToUndoAction,
      {
        lodash: _,
        Promise,
        utils,
        produceState,
        bowser,
        ZenkitErrorCodes,
        ZenkitControlsShared,
        resources,
        resourceHandlers,
        publishTypes,
        publishTypeCounterparts,
        actions,
        actionPayloadMayContainFiles,
        actionHandlers,
        zenkitIndexedDB,
        inMemoryDb,
        connectionChecker,
        isMobileApp,
      } = dependencies,
      internalState = { data: void 0, updatedResourcesPerAction: {} },
      serializeError = function (error) {
        return _.pick(error, ['name', 'stack', 'message', 'code', 'description'])
      },
      getHandlers = function (action) {
        var actionHandler = actionHandlers[action]
        if (_.isNil(actionHandler)) throw new Error('Unkown action: ' + action)
        var resourceHandler = resourceHandlers[actionHandler.resource]
        if (_.isNil(actionHandler)) throw new Error('Unkown resource: ' + actionHandler.resource)
        return { actionHandler, resourceHandler }
      },
      isActionAvailableOffline = function (actionObject) {
        var listId = _.get(actionObject.identifiers, ['listId']),
          optimisticUpdateIsPossible = actionHandlers[actionObject.action].isOptimisticUpdatePossible(
            internalState.data,
            actionObject.identifiers,
            actionObject.payload,
          )
        return _.isNil(listId)
          ? optimisticUpdateIsPossible
          : optimisticUpdateIsPossible && inMemoryDb.isListAvailableOffline({ listId })
      },
      isResourceAffectedByOptimisticUpdates = function (params) {
        params = utils.validateParameters(params, { resource: { type: 'string' }, identifiers: { type: 'object' } })
        var updatedResources = _.flatMap(internalState.updatedResourcesPerAction)
        return _.some(updatedResources, function (update) {
          return update.resource === params.resource && _.isEqual(update.identifiers, params.identifiers)
        })
      },
      consolidateResourceUpdates = function (updates) {
        return _.reject(updates, function (update) {
          return (
            update.publishType === publishTypes.CHANGED &&
            _.some(updates, function (queuedUpdate) {
              return (
                queuedUpdate.publishType !== publishTypes.CHANGED &&
                queuedUpdate.resource === update.resource &&
                _.isEqual(queuedUpdate.identifiers, update.identifiers)
              )
            })
          )
        })
      },
      publishResourceUpdates = function (data, allUpdates) {
        try {
          var updatesPerResource = _.groupBy(allUpdates, 'resource')
          _.forEach(updatesPerResource, function (updates, resourceType) {
            var updatesByPublishType = _.groupBy(updates, 'publishType')
            _.forEach(updatesByPublishType, function (updates, publishType) {
              if (resourceType !== resources.LIST_ENTRY)
                _.forEach(updates, function (update) {
                  resourceHandlers[resourceType].publish({
                    identifiers: update.identifiers,
                    publishType: update.publishType,
                    resource: resourceHandlers[resourceType].get(data, update.identifiers),
                  })
                })
              else {
                var listEntries = _.chain(updates)
                  .map(function (update) {
                    var listEntry = resourceHandlers.LIST_ENTRY.get(data, update.identifiers)
                    return (
                      _.isNil(listEntry) && console.warn('publishResourceUpdates: ListEntry was not in cache', update),
                      listEntry
                    )
                  })
                  .compact()
                  .uniqBy('uuid')
                  .value()
                if (_.isEmpty(listEntries)) return
                var groupedEntries = _.groupBy(listEntries, 'listId')
                _.forEach(groupedEntries, function (listEntries, listId) {
                  resourceHandlers.LIST_ENTRIES.publish({
                    identifiers: { listId: parseInt(listId) },
                    publishType,
                    resource: listEntries,
                  })
                })
              }
            })
          })
        } catch (err) {
          console.error('Could not publish resource updates.', err, allUpdates)
        }
      },
      ensureRequiredStateIsLoadedForAction = function (actionObject) {
        var listId = actionObject.identifiers.listId,
          workspaceId = actionObject.identifiers.workspaceId,
          promises = [inMemoryDb.initialLoad]
        return (
          listId && promises.push(inMemoryDb.ensureListStateIsLoaded({ listId })),
          workspaceId && promises.push(inMemoryDb.ensureWorkspaceStateIsLoaded({ workspaceId })),
          _.get(actionObject.payload, ['targetListId']) &&
            promises.push(inMemoryDb.ensureListStateIsLoaded({ listId: actionObject.payload.targetListId })),
          Promise.all(promises)
        )
      },
      transactionHandler =
        ((current = null),
        (trxChangeFns = utils.ChangeCallbackMixin()),
        (triggerTransactionEnd = trxChangeFns.triggerChange),
        {
          start: function () {
            var end
            return (
              (current = new Promise(function (resolve) {
                end = function () {
                  ;(current = null), triggerTransactionEnd(), resolve()
                }
              })),
              end
            )
          },
          inProgress: function () {
            return !1 === _.isNil(current)
          },
          awaitCompletion: function () {
            return current || Promise.resolve()
          },
          onTransactionEnd: trxChangeFns.onChange,
        }),
      SafariIndexedDbFileFix = (function () {
        var fileKeys = ['name', 'size', 'type', 'lastModified', 'lastModifiedDate', 'webkitRelativePath'],
          fixIsNeeded = Boolean(bowser.ios),
          NativeFile = File
        !(function () {
          if (!0 === isMobileApp && 'undefined' != typeof document) {
            var iframe = document.createElement('iframe')
            ;(iframe.style.display = 'none'),
              document.documentElement.appendChild(iframe),
              (NativeFile = iframe.contentWindow.File),
              document.documentElement.removeChild(iframe)
          }
        })()
        var fakeFileToRealFile = function (fakeFile) {
            var file = new NativeFile([fakeFile.arrayBuffer], fakeFile.fileValues.name, fakeFile.fileValues)
            return Promise.resolve(file)
          },
          realFileToFakeFile = function (file) {
            return new Promise((resolve, reject) => {
              var reader = new FileReader()
              ;(reader.onloadend = function () {
                return reader.error
                  ? reject(reader.error)
                  : resolve({
                      arrayBuffer: reader.result,
                      fileValues: _.pick(file, fileKeys),
                      _SafariIndexedDbFileFix: !0,
                    })
              }),
                reader.readAsArrayBuffer(file)
            })
          },
          prepareActionObjectAfterRead = actionObject =>
            actionPayloadMayContainFiles[actionObject.action]
              ? utils
                  .asyncReplaceValuesThatMatchRecursively({
                    Promise,
                    input: actionObject.payload,
                    condition: value => !0 === _.get(value, '_SafariIndexedDbFileFix'),
                    replace: fakeFileToRealFile,
                  })
                  .then(preparedPayload =>
                    produceState(actionObject, actionObject => {
                      actionObject.payload = preparedPayload
                    }),
                  )
              : actionObject,
          prepareActionObjectBeforeWrite = actionObject =>
            actionPayloadMayContainFiles[actionObject.action]
              ? utils
                  .asyncReplaceValuesThatMatchRecursively({
                    Promise,
                    input: actionObject.payload,
                    condition: value => value instanceof Blob && 'File' === value.constructor.name,
                    replace: realFileToFakeFile,
                  })
                  .then(preparedPayload =>
                    produceState(actionObject, actionObject => {
                      actionObject.payload = preparedPayload
                    }),
                  )
              : actionObject
        return {
          prepareQueueAfterRead: queue =>
            !1 === fixIsNeeded || _.isEmpty(queue)
              ? Promise.resolve(queue)
              : Promise.map(queue, prepareActionObjectAfterRead),
          prepareQueueBeforeWrite: queue =>
            !1 === fixIsNeeded || _.isEmpty(queue)
              ? Promise.resolve(queue)
              : Promise.map(queue, prepareActionObjectBeforeWrite),
        }
      })(),
      queueHandler =
        ((queueChangeFns = utils.ChangeCallbackMixin()),
        (state = { queue: [], running: [], actionResponseHandlers: {} }),
        (initialLoad = zenkitIndexedDB.initialLoad
          .then(function () {
            return zenkitIndexedDB.keyValueStore.getItem('zenkit-offline-storage-queue')
          })
          .then(SafariIndexedDbFileFix.prepareQueueAfterRead)
          .then(function (cachedQueue) {
            return _.isNil(cachedQueue)
              ? []
              : Promise.map(cachedQueue, ensureRequiredStateIsLoadedForAction).then(_.constant(cachedQueue))
          })
          .then(function (cachedQueue) {
            ;(state.queue = cachedQueue || []), queueChangeFns.triggerChange(queueHandler.getQueue())
          })),
        (currentQueuePromise = initialLoad),
        (modifyQueue = function (modifier, params) {
          params = utils.validateParameters(params || {}, { triggerChange: { type: 'boolean', default: !0 } })
          var updatePromise = currentQueuePromise.then(function () {
            var newQueue = produceState(queueHandler.getQueue(), modifier),
              applyQueue = function () {
                ;(state.queue = newQueue), params.triggerChange && queueChangeFns.triggerChange(queueHandler.getQueue())
              }
            if (!1 !== zenkitIndexedDB.isSupported())
              return SafariIndexedDbFileFix.prepareQueueBeforeWrite(newQueue)
                .then(queueToWrite =>
                  zenkitIndexedDB.keyValueStore.setItem('zenkit-offline-storage-queue', queueToWrite),
                )
                .then(applyQueue)
                .return(void 0)
            applyQueue()
          })
          return (currentQueuePromise = updatePromise.catch(_.noop)), updatePromise
        }),
        (modifyAction = function (uuid, updateParams) {
          return modifyQueue(function (queue) {
            return _.map(queue, function (action) {
              return action.uuid === uuid ? _.defaults(updateParams, action) : action
            })
          })
        }),
        (dropAction = function (params) {
          return (
            (params = utils.validateParameters(params || {}, {
              uuid: { type: 'string' },
              triggerChange: { type: 'boolean', default: !0 },
            })),
            modifyQueue(
              function (queue) {
                return _.reject(queue, { uuid: params.uuid })
              },
              { triggerChange: params.triggerChange },
            )
          )
        }),
        (dropActionAndRevertOptimisticUpdate = function (params) {
          var updatedResources = consolidateResourceUpdates(internalState.updatedResourcesPerAction[params.uuid]),
            updatesToPublishBeforeDroppingTheAction = _.filter(updatedResources, { publishType: publishTypes.ADDED }),
            updatesToPublishAfterDroppingTheAction = _.reject(updatedResources, { publishType: publishTypes.ADDED }),
            revertPublishTypeOfUpdate = function (update) {
              return _.defaults({ publishType: publishTypeCounterparts[update.publishType] }, update)
            }
          return (
            publishResourceUpdates(
              internalState.data,
              _.map(updatesToPublishBeforeDroppingTheAction, revertPublishTypeOfUpdate),
            ),
            dropAction({ uuid: params.uuid })
              .then(function () {
                publishResourceUpdates(
                  internalState.data,
                  _.map(updatesToPublishAfterDroppingTheAction, revertPublishTypeOfUpdate),
                )
              })
              .tap(function () {
                var uuid, error, handler
                ;(uuid = params.uuid),
                  (error = params.tooManyAttemptsError),
                  (handler = state.actionResponseHandlers[uuid]) &&
                    (handler.reject(error), delete state.actionResponseHandlers[uuid])
              })
          )
        }),
        (errorCodesForWhichAutomaticRetryMakesNoSense = _.chain(ZenkitErrorCodes)
          .pick([
            'QUOTA_EXCEEDED',
            'API_LIMIT_EXCEEDED',
            'LIST_ELEMENT_DESCRIPTION_TOO_LONG',
            'RESOURCE_ALREADY_EXISTS',
            'DEPENDENCIES_CYCLE',
          ])
          .map('code')
          .value()),
        (isActionBlockedByRunningActions = function (action) {
          return (
            (function (action) {
              return _.some(state.running, { uuid: action.uuid })
            })(action) ||
            _.some(state.running, function (runningAction) {
              return runningAction.priority >= action.priority
            })
          )
        }),
        (tryToRunTheNextAction = function tryToRunTheNextAction() {
          var queue = _.reject(queueHandler.getQueue(), function (action) {
            var skipOptimisticAction = !1 === connectionChecker.isOnline() && action.availableOffline,
              skipManualErrorHandling = action.error && action.manualErrorHandling
            return skipOptimisticAction || skipManualErrorHandling
          })
          if (_.isEmpty(queue)) return Promise.resolve()
          var queuedAction = _.head(_.orderBy(queue, ['priority'], ['desc']))
          if (isActionBlockedByRunningActions(queuedAction)) return Promise.resolve()
          if (queuedAction.error) return Promise.reject(queuedAction.error)
          if (queuedAction.attemptCount > 1) {
            var tooManyAttemptsError = new Error('Too many attempts without manual retry.')
            return queuedAction.failSilently
              ? dropActionAndRevertOptimisticUpdate({ uuid: queuedAction.uuid, error: tooManyAttemptsError })
              : modifyAction(queuedAction.uuid, { error: serializeError(tooManyAttemptsError) })
          }
          var action,
            handlers = getHandlers(queuedAction.action),
            actionHandler = handlers.actionHandler,
            resourceHandler = handlers.resourceHandler
          return actionHandler.onlySaveLastQueuedAction &&
            (function (action, queue) {
              return (
                _.indexOf(queue, action) <
                _.findLastIndex(queue, function (queuedAction) {
                  return (
                    queuedAction.action === action.action &&
                    queuedAction.resource === action.resource &&
                    _.isEqual(queuedAction.identifiers, action.identifiers)
                  )
                })
              )
            })(queuedAction, queue)
            ? dropAction({ uuid: queuedAction.uuid })
            : ((action = queuedAction),
              (state.running = _.concat(state.running, [action])),
              modifyAction(queuedAction.uuid, { attemptCount: (queuedAction.attemptCount || 0) + 1 })
                .then(function () {
                  return Promise.try(function () {
                    return actionHandler.save(
                      internalState.data,
                      queuedAction.identifiers,
                      queuedAction.payload,
                      function (payload) {
                        return modifyAction(queuedAction.uuid, { payload }).tap(function () {
                          var updatedResources = consolidateResourceUpdates(
                            internalState.updatedResourcesPerAction[queuedAction.uuid],
                          )
                          publishResourceUpdates(internalState.data, updatedResources)
                        })
                      },
                    )
                  }).catch(function (serverError) {
                    var errorCode = _.get(serverError, ['code']),
                      onLine = connectionChecker.isOnline()
                    if (errorCode === ZenkitErrorCodes.RESOURCE_ALREADY_EXISTS.code) {
                      var alreadyExistingResource = resourceHandler.get(inMemoryDb.getData(), queuedAction.identifiers)
                      if (alreadyExistingResource) return alreadyExistingResource
                    }
                    var error = serverError || ZenkitErrorCodes.UNKNOWN_ERROR,
                      retryCount = queuedAction.retryCount || 0
                    if (
                      !0 !== queuedAction.manualErrorHandling &&
                      retryCount < 1 &&
                      !1 === _.includes(errorCodesForWhichAutomaticRetryMakesNoSense, errorCode)
                    )
                      return modifyAction(queuedAction.uuid, { retryCount: retryCount + 1 }).then(function () {
                        return Promise.reject(error)
                      })
                    if (!1 === onLine) {
                      if (queuedAction.availableOffline) return Promise.reject(error)
                      error = ZenkitErrorCodes.NOT_AVAILABLE_OFFLINE
                    }
                    return queuedAction.failSilently
                      ? dropActionAndRevertOptimisticUpdate({ uuid: queuedAction.uuid, error }).then(function () {
                          return Promise.reject(error)
                        })
                      : modifyAction(queuedAction.uuid, { error: serializeError(error) })
                          .tapCatch(function (modifyActionError) {
                            console.error('Could not save error for action', {
                              errorToSave: error,
                              modifyActionError,
                              action: queuedAction,
                            })
                          })
                          .then(function () {
                            return Promise.reject(error)
                          })
                  })
                })
                .tap(function (updatedResource) {
                  if (_.isNil(updatedResource) && !1 === actionHandler.updateInMemoryDbIfValueIsNil)
                    return dropAction({ uuid: queuedAction.uuid })
                  var identifiers = queuedAction.identifiers
                  if (_.isPlainObject(updatedResource)) {
                    var identifiersFromResource = _.pick(
                      updatedResource,
                      _.keys(handlers.resourceHandler.identifierValidation),
                    )
                    identifiers = _.assign(identifiersFromResource, identifiers)
                  }
                  var currentlyDisplayedResource = null
                  try {
                    currentlyDisplayedResource = resourceHandler.get(internalState.data, identifiers)
                  } catch (err) {
                    console.error('Could not get currently displayed resource', err)
                  }
                  return dropAction({ uuid: queuedAction.uuid, triggerChange: !1 })
                    .then(function () {
                      return actionHandler.updateInMemoryDb({
                        inMemoryDb,
                        identifiers,
                        payload: queuedAction.payload,
                        resource: updatedResource,
                      })
                    })
                    .then(function () {
                      if (
                        !(queueChangeFns.triggerChange(queueHandler.getQueue()),
                        _.isNil(updatedResource) ||
                          _.isEqual(currentlyDisplayedResource, updatedResource) ||
                          isResourceAffectedByOptimisticUpdates({
                            resource: actionHandlers[queuedAction.action].resource,
                            identifiers,
                          }))
                      )
                        return actionHandler.publishServerResponseAndReturnResource({
                          data: internalState.data,
                          identifiers,
                          publishType: actionHandler.publishType,
                          serverResponse: updatedResource,
                        })
                    })
                })
                .finally(function () {
                  !(function (action) {
                    state.running = _.reject(state.running, { uuid: action.uuid })
                  })(queuedAction)
                })
                .tap(function (result) {
                  !(function (uuid, result) {
                    var handler = state.actionResponseHandlers[uuid]
                    handler && (handler.resolve(result), delete state.actionResponseHandlers[uuid])
                  })(queuedAction.uuid, result)
                })
                .catch(_.noop)
                .then(_.constant(void 0))
                .finally(tryToRunTheNextAction))
        }),
        (tryToRunNextActionInBackground = function () {
          tryToRunTheNextAction().catch(_.noop)
        }),
        {
          initialLoad,
          onChange: queueChangeFns.onChange,
          modifyQueue,
          getQueue: function () {
            return state.queue
          },
          isQueueEmpty: function () {
            return _.isEmpty(state.queue)
          },
          isActionQueuedFor: function (params) {
            return (
              (params = utils.validateParameters(params, {
                resource: { type: 'string' },
                identifiers: { type: 'object' },
              })),
              _.some(queueHandler.getQueue(), function (actionObject) {
                return (
                  _.isEqual(actionHandlers[actionObject.action].resource, params.resource) &&
                  _.isEqual(actionObject.identifiers, params.identifiers)
                )
              })
            )
          },
          add: function (actionObject, params) {
            return modifyQueue(function (queue) {
              return _.get(params, ['unshift']) ? _.concat([actionObject], queue) : _.concat(queue, [actionObject])
            }).tap(tryToRunNextActionInBackground)
          },
          tryToRunTheNextAction,
          clear: function () {
            return modifyQueue(_.constant([])).return(void 0)
          },
          waitForActionResponse: function (uuid) {
            return new Promise(function (resolve, reject) {
              state.actionResponseHandlers[uuid] = { resolve, reject }
            })
          },
          retryFailedAction: function (params) {
            return modifyAction(params.uuid, { error: null, attemptCount: 0 })
              .tap(tryToRunNextActionInBackground)
              .catch(_.noop)
          },
          dropFailedAction: function (params) {
            var action = _.find(state.queue, { uuid: params.uuid }),
              error = _.get(action, ['error']) || new Error('dropFailedAction: Unexpected lack of error for action.')
            return dropActionAndRevertOptimisticUpdate({ uuid: params.uuid, error }).tap(tryToRunNextActionInBackground)
          },
        }),
      fallbackUndoHandler =
        ((actionUuidToUndoAction = {}),
        {
          registerUndoAction: function (params) {
            return (
              (actionUuidToUndoAction[params.action.uuid] = { action: params.action, undoAction: params.undoAction }),
              Promise.resolve()
            )
          },
          getUndoAction: function (params) {
            var undoAction = _.get(actionUuidToUndoAction, [params.uuid, 'undoAction'], null)
            return _.isNil(undoAction)
              ? Promise.reject(new Error('This action cannot be undone.'))
              : Promise.resolve(undoAction)
          },
        }),
      undoHandler = {
        registerUndoAction: function (params) {
          return !1 === zenkitIndexedDB.isSupported()
            ? fallbackUndoHandler.registerUndoAction(params)
            : zenkitIndexedDB.setItem(
                zenkitIndexedDB.OBJECT_STORES.ACTIONS,
                { uuid: params.action.uuid },
                {
                  uuid: params.action.uuid,
                  action: _.omit(params.action, ['error', 'attemptCount', 'retryCount']),
                  undoAction: params.undoAction,
                },
              )
        },
        getUndoAction: function (params) {
          return !1 === zenkitIndexedDB.isSupported()
            ? fallbackUndoHandler.getUndoAction(params)
            : zenkitIndexedDB
                .getItem(zenkitIndexedDB.OBJECT_STORES.ACTIONS, { uuid: params.uuid })
                .then(function (result) {
                  var undoAction = _.get(result, ['undoAction'], null)
                  return _.isNil(undoAction) ? Promise.reject(new Error('This action cannot be undone.')) : undoAction
                })
        },
      },
      updateOptimisticState = function (params) {
        if (transactionHandler.inProgress()) return internalState.data
        var queue = _.get(params, ['queue']) || queueHandler.getQueue(),
          baseData = _.get(params, ['data']) || inMemoryDb.getData()
        try {
          ;(internalState.updatedResourcesPerAction = {}),
            (internalState.data = _.reduce(
              queue,
              function (data, queuedAction) {
                var actionHandler = getHandlers(queuedAction.action).actionHandler
                return produceState(data, function (data) {
                  var updatedResourcesDuringCurrentAction = []
                  if (
                    ((internalState.updatedResourcesPerAction[queuedAction.uuid] = updatedResourcesDuringCurrentAction),
                    !1 ===
                      actionHandler.isOptimisticUpdatePossible(data, queuedAction.identifiers, queuedAction.payload))
                  )
                    return data
                  var markResourceAsUpdated = function (params) {
                    ;(params = utils.validateParameters(params, {
                      resource: { type: 'string' },
                      identifiers: { type: 'object' },
                      publishType: { type: 'string' },
                    })),
                      updatedResourcesDuringCurrentAction.push(params)
                  }
                  actionHandler.resource !== resources.LIST_ENTRIES &&
                    markResourceAsUpdated({
                      identifiers: queuedAction.identifiers,
                      resource: actionHandler.resource,
                      publishType: actionHandler.publishType,
                    })
                  try {
                    return actionHandler.optimistic(
                      data,
                      queuedAction.identifiers,
                      queuedAction.payload,
                      markResourceAsUpdated,
                    )
                  } catch (err) {
                    return console.warn('Optimistic update failed.', queuedAction, err), data
                  }
                })
              },
              baseData,
            ))
        } catch (err) {
          console.warn('updateOptimisticState failed.', err)
        }
        return internalState.data
      }
    inMemoryDb.onChange(updateOptimisticState)
    var lastQueue = queueHandler.getQueue()
    queueHandler.onChange(function (queue) {
      var params,
        sizeOfNewQueue = _.size(queue),
        sizeOfLastQueue = _.size(lastQueue)
      sizeOfNewQueue > sizeOfLastQueue &&
        _.every(lastQueue, function (lastQueuedAction, index) {
          return lastQueuedAction === queue[index]
        }) &&
        (params = { queue: queue.slice(sizeOfLastQueue), data: internalState.data })
      updateOptimisticState(params), (lastQueue = queue)
    }),
      transactionHandler.onTransactionEnd(updateOptimisticState),
      updateOptimisticState()
    var clearOfflineErrors = function () {
      return queueHandler.isQueueEmpty()
        ? Promise.resolve()
        : queueHandler.modifyQueue(function (queue) {
            return _.map(queue, function (action) {
              return _.get(action.error, ['code']) === ZenkitErrorCodes.NOT_AVAILABLE_OFFLINE.code
                ? _.defaults({ error: null, attemptCount: 0 }, action)
                : action
            })
          })
    }
    queueHandler.initialLoad
      .tap(function () {
        if (connectionChecker.isOnline()) return clearOfflineErrors()
      })
      .then(function () {
        var wasOnline = connectionChecker.isOnline()
        return (
          connectionChecker.onConnectionChanged(function (connection) {
            !0 === connection.onLine &&
              !1 === wasOnline &&
              clearOfflineErrors().then(queueHandler.tryToRunTheNextAction).catch(_.noop),
              (wasOnline = connection.onLine)
          }),
          queueHandler.tryToRunTheNextAction()
        )
      })
      .catch(_.noop)
    var optimisticState = {
      actions,
      initialLoad: Promise.all([inMemoryDb.initialLoad, queueHandler.initialLoad]),
      isQueueEmpty: queueHandler.isQueueEmpty,
      isActionQueuedFor: queueHandler.isActionQueuedFor,
      getActionErrorDetails: function (params) {
        var actionObject = _.find(queueHandler.getQueue(), { uuid: params.uuid })
        if (_.isNil(actionObject)) return Promise.reject('This action is not in the queue.')
        if (_.isNil(actionObject.error)) return Promise.reject('This action does not have an error attached to it.')
        var serverError = _.get(actionObject.error, ['code']) ? actionObject.error : ZenkitErrorCodes.UNKNOWN_ERROR
        return Promise.try(function () {
          return actionHandlers[actionObject.action].getErrorMessage(
            internalState.data,
            actionObject.identifiers,
            actionObject.payload,
            actionObject.error,
          )
        })
          .catchReturn(null)
          .then(function (translateParamsOrNull) {
            return _.defaults({}, translateParamsOrNull, {
              translateId: ZenkitErrorCodes.UNKNOWN_ERROR.nameTranslateId,
              code: serverError.code,
              serverSideErrorMessage: serverError.message || serverError.description,
              actionIsAvailableOffline: isActionAvailableOffline(actionObject),
            })
          })
      },
      onQueueChange: queueHandler.onChange,
      isListAvailableOffline: inMemoryDb.isListAvailableOffline,
      isWorkspaceAvailableOffline: inMemoryDb.isWorkspaceAvailableOffline,
      ensureListStateIsLoaded: inMemoryDb.ensureListStateIsLoaded,
      ensureWorkspaceStateIsLoaded: inMemoryDb.ensureWorkspaceStateIsLoaded,
      getData: function () {
        return internalState.data
      },
      dispatch: function (actionObject) {
        ;((actionObject = utils.validateParameters(actionObject, {
          action: { type: 'string' },
          identifiers: { type: 'object' },
          payload: { type: ['object', 'undefined'] },
          uuid: { type: 'string' },
          failSilently: { type: 'boolean', default: !1 },
          manualErrorHandling: { type: 'boolean', default: !1 },
          waitForServerResponse: { type: 'boolean', default: !1 },
          priority: { type: 'number', default: 0 },
          isUndo: { type: 'boolean', default: !1 },
          batchId: { type: ['string', 'undefined'] },
          error: { type: ['object', 'null'], default: null },
        })).timestamp = new Date()),
          (actionObject.retryCount = 0),
          (actionObject.attemptCount = 0),
          (actionObject.resource = actionHandlers[actionObject.action].resource)
        var actionHandler = getHandlers(actionObject.action).actionHandler
        return (
          (actionObject.identifiers = utils.validateParameters(
            actionObject.identifiers,
            actionHandler.identifierValidation,
          )),
          actionHandler.payloadValidation &&
            (actionObject.payload = utils.validateParameters(actionObject.payload, actionHandler.payloadValidation)),
          ensureRequiredStateIsLoadedForAction(actionObject)
            .tap(function () {
              if (!actionObject.isUndo)
                return Promise.try(function () {
                  var undoAction = actionHandler.getUndoAction(
                    internalState.data,
                    actionObject.identifiers,
                    actionObject.payload,
                  )
                  return undoHandler.registerUndoAction({ action: actionObject, undoAction })
                }).catch(function (err) {
                  console.error('Error when preparing undo', actionObject, err)
                })
            })
            .then(function () {
              var optimisticUpdateIsPossible = actionHandler.isOptimisticUpdatePossible(
                internalState.data,
                actionObject.identifiers,
                actionObject.payload,
              )
              return (
                (actionObject.availableOffline = optimisticUpdateIsPossible),
                queueHandler.add(actionObject).return(actionObject)
              )
            })
            .then(function (actionObject) {
              if (actionObject.availableOffline && !1 === actionObject.waitForServerResponse) {
                var updatedResources = consolidateResourceUpdates(
                  internalState.updatedResourcesPerAction[actionObject.uuid],
                )
                return (
                  publishResourceUpdates(internalState.data, updatedResources),
                  actionHandler.optimisticServerResponse(
                    internalState.data,
                    actionObject.identifiers,
                    actionObject.payload,
                  )
                )
              }
              return queueHandler.waitForActionResponse(actionObject.uuid)
            })
        )
      },
      getUndoAction: undoHandler.getUndoAction,
      clear: queueHandler.clear,
      retryAction: queueHandler.retryFailedAction,
      dropAction: queueHandler.dropFailedAction,
      onListEntriesArrived: function (params) {
        if (
          ((params = utils.validateParameters(params, {
            listId: { type: 'number' },
            listEntries: { type: 'array' },
            user: { type: ['object', 'undefined'] },
            forcePersist: { type: ['boolean', 'undefined'] },
            publishChanges: { type: 'boolean', default: !0 },
          })),
          _.isEmpty(params.listEntries))
        )
          return Promise.resolve()
        var identifiers = { listId: params.listId }
        return inMemoryDb.ensureListStateIsLoaded(identifiers).then(function () {
          var added = [],
            changed = [],
            removed = [],
            updateParameters = _.map(params.listEntries, function (updatedEntry) {
              var identifiers = { listId: params.listId, uuid: updatedEntry.uuid },
                currentEntry = resourceHandlers.LIST_ENTRY.get(inMemoryDb.getData(), identifiers),
                updateParameters = {
                  resource: resources.LIST_ENTRY,
                  identifiers,
                  value: updatedEntry,
                  options: { forcePersist: params.forcePersist },
                }
              return (
                _.isNil(updatedEntry.deprecated_at)
                  ? _.isNil(currentEntry)
                    ? added.push(updatedEntry)
                    : changed.push(updatedEntry)
                  : _.isNil(currentEntry) || _.isNil(currentEntry.deprecated_at)
                  ? removed.push(updatedEntry)
                  : changed.push(updatedEntry),
                updateParameters
              )
            })
          return inMemoryDb.updateMultiple(updateParameters).then(function () {
            if (!1 !== params.publishChanges) {
              var getFromOptimisticState = function (listEntries) {
                return _.map(listEntries, function (possiblyOutdatedListEntry) {
                  return (
                    resourceHandlers.LIST_ENTRY.get(
                      optimisticState.getData(),
                      _.pick(possiblyOutdatedListEntry, ['uuid', 'listId']),
                    ) || possiblyOutdatedListEntry
                  )
                })
              }
              !1 === _.isEmpty(added) &&
                resourceHandlers.LIST_ENTRIES.publish({
                  identifiers,
                  publishType: publishTypes.ADDED,
                  resource: getFromOptimisticState(added),
                  user: params.user,
                }),
                !1 === _.isEmpty(changed) &&
                  resourceHandlers.LIST_ENTRIES.publish({
                    identifiers,
                    publishType: publishTypes.CHANGED,
                    resource: getFromOptimisticState(changed),
                    user: params.user,
                  }),
                !1 === _.isEmpty(removed) &&
                  resourceHandlers.LIST_ENTRIES.publish({
                    identifiers,
                    publishType: publishTypes.REMOVED,
                    resource: getFromOptimisticState(removed),
                    user: params.user,
                  })
            }
          })
        })
      },
      onMinimalListEntriesArrived: function (params) {
        if (
          ((params = utils.validateParameters(params, {
            listId: { type: 'number' },
            listEntries: { type: 'array' },
            user: { type: ['object', 'undefined'] },
            forcePersist: { type: ['boolean', 'undefined'] },
            publishChanges: { type: 'boolean', default: !0 },
          })),
          _.isEmpty(params.listEntries))
        )
          return Promise.resolve()
        var identifiers = { listId: params.listId },
          minimalListEntries = _.reject(params.listEntries, function (listEntry) {
            return _.isNil(
              resourceHandlers.LIST_ENTRY.get(optimisticState.getData(), {
                listId: params.listId,
                uuid: listEntry.uuid,
              }),
            )
          })
        return inMemoryDb
          .ensureListStateIsLoaded(identifiers)
          .then(function () {
            var updateParameters = _.map(minimalListEntries, function (minimalUpdatedListEntry) {
              var identifiers = { listId: params.listId, uuid: minimalUpdatedListEntry.uuid },
                currentEntry = resourceHandlers.LIST_ENTRY.get(inMemoryDb.getData(), identifiers)
              return _.isNil(currentEntry)
                ? null
                : {
                    resource: resources.LIST_ENTRY,
                    identifiers,
                    value: produceState(currentEntry, function (currentEntry) {
                      return _.assign(currentEntry, minimalUpdatedListEntry)
                    }),
                    options: { forcePersist: params.forcePersist },
                  }
            })
            return inMemoryDb.updateMultiple(updateParameters)
          })
          .then(function () {
            var fullListEntries = _.map(minimalListEntries, function (listEntry) {
              return resourceHandlers.LIST_ENTRY.get(optimisticState.getData(), {
                listId: params.listId,
                uuid: listEntry.uuid,
              })
            })
            resourceHandlers.LIST_ENTRIES.publish({
              identifiers,
              publishType: publishTypes.CHANGED,
              resource: fullListEntries,
              user: params.user,
            })
          })
      },
      onListActivitiesArrived: function (params) {
        if (
          ((params = utils.validateParameters(params, {
            listId: { type: 'number' },
            listActivities: { type: 'array' },
            forcePersist: { type: ['boolean', 'undefined'] },
            publishChanges: { type: 'boolean', default: !0 },
          })),
          _.isEmpty(params.listActivities))
        )
          return Promise.resolve()
        var map,
          identifiers = { listId: params.listId },
          activitiesByPublishType = (((map = {})[publishTypes.ADDED] = []), (map[publishTypes.CHANGED] = []), map)
        return inMemoryDb
          .ensureListStateIsLoaded(identifiers)
          .then(function () {
            var currentActivitesByUuid = resourceHandlers.ACTIVITIES.get(optimisticState.getData(), identifiers) || {}
            _.forEach(params.listActivities, function (updatedActivity) {
              var currentActivity = currentActivitesByUuid[updatedActivity.uuid]
              _.isNil(updatedActivity.deprecated_at) && _.isNil(currentActivity)
                ? activitiesByPublishType[publishTypes.ADDED].push(updatedActivity)
                : activitiesByPublishType[publishTypes.CHANGED].push(updatedActivity)
            })
          })
          .then(function () {
            var updateParams = [],
              listSynchronization = inMemoryDb.getListSynchronization({ listId: params.listId }),
              activitiesFilter = _.get(
                listSynchronization,
                ['activitiesFilter'],
                ZenkitControlsShared.activityTypes.FILTER.NONE,
              )
            return (
              _.forEach(params.listActivities, function (activity) {
                ;(activitiesFilter === ZenkitControlsShared.activityTypes.FILTER.COMMENTS &&
                  activity.type !== ZenkitControlsShared.activityTypes.TYPE.COMMENT) ||
                  (activitiesFilter === ZenkitControlsShared.activityTypes.FILTER.SYSTEM_MESSAGES &&
                    activity.type === ZenkitControlsShared.activityTypes.TYPE.COMMENT) ||
                  (activity.created_in === ZenkitControlsShared.activityTypes.CREATED_IN.LIST_ENTRY
                    ? _.isNil(activity.listEntryUUID)
                      ? console.error('Expected activity ' + activity.id + ' to have a listEntryUuid.')
                      : updateParams.push({
                          resource: resources.LIST_ENTRY_ACTIVITY,
                          identifiers: {
                            listId: activity.listId,
                            listEntryUuid: activity.listEntryUUID,
                            uuid: activity.uuid,
                          },
                          value: activity,
                          options: { forcePersist: params.forcePersist },
                        })
                    : activity.created_in === ZenkitControlsShared.activityTypes.CREATED_IN.LIST &&
                      updateParams.push({
                        resource: resources.LIST_ACTIVITY,
                        identifiers: { listId: activity.listId, uuid: activity.uuid },
                        value: activity,
                        options: { forcePersist: params.forcePersist },
                      }))
              }),
              inMemoryDb.updateMultiple(updateParams)
            )
          })
          .then(function () {
            if (!1 !== params.publishChanges) {
              var optimisticActivitiesByUuid =
                resourceHandlers.ACTIVITIES.get(optimisticState.getData(), identifiers) || {}
              _.forEach(activitiesByPublishType, function (activities, publishType) {
                _.isEmpty(activities) ||
                  resourceHandlers.ACTIVITIES.publish({
                    identifiers,
                    publishType,
                    resource: _.map(activities, function (activity) {
                      return optimisticActivitiesByUuid[activity.uuid] || activity
                    }),
                  })
              })
            }
          })
      },
      onWorkspaceActivitiesArrived: function (params) {
        if (
          ((params = utils.validateParameters(params, {
            workspaceId: { type: 'number' },
            workspaceActivities: { type: 'array' },
            forcePersist: { type: ['boolean', 'undefined'] },
            publishChanges: { type: 'boolean', default: !0 },
          })),
          _.isEmpty(params.workspaceActivities))
        )
          return Promise.resolve()
        var identifiers = { workspaceId: params.workspaceId }
        return inMemoryDb
          .ensureWorkspaceStateIsLoaded(identifiers)
          .then(function () {
            var map,
              currentActivitesByUuid =
                resourceHandlers.ACTIVITIES_PER_WORKSPACE.get(optimisticState.getData(), identifiers) || {},
              activitiesByPublishType = (((map = {})[publishTypes.ADDED] = []), (map[publishTypes.CHANGED] = []), map)
            return (
              _.forEach(params.workspaceActivities, function (updatedActivity) {
                var currentActivity = currentActivitesByUuid[updatedActivity.uuid]
                _.isNil(updatedActivity.deprecated_at) && _.isNil(currentActivity)
                  ? activitiesByPublishType[publishTypes.ADDED].push(updatedActivity)
                  : activitiesByPublishType[publishTypes.CHANGED].push(updatedActivity)
              }),
              activitiesByPublishType
            )
          })
          .tap(function () {
            var updateParams = _.map(params.workspaceActivities, function (activity) {
              return {
                resource: resources.WORKSPACE_ACTIVITY,
                identifiers: { workspaceId: activity.workspaceId, uuid: activity.uuid },
                value: activity,
                options: { forcePersist: params.forcePersist },
              }
            })
            return inMemoryDb.updateMultiple(updateParams)
          })
          .then(function (activitiesByPublishType) {
            if (!1 !== params.publishChanges) {
              var optimisticActivitiesByUuid =
                resourceHandlers.ACTIVITIES_PER_WORKSPACE.get(optimisticState.getData(), identifiers) || {}
              _.forEach(activitiesByPublishType, function (activities, publishType) {
                _.isEmpty(activities) ||
                  resourceHandlers.ACTIVITIES_PER_WORKSPACE.publish({
                    identifiers,
                    publishType,
                    resource: _.map(activities, function (activity) {
                      return optimisticActivitiesByUuid[activity.uuid] || activity
                    }),
                  })
              })
            }
          })
      },
      onListElementsArrived: function (params) {
        var identifiers = {
          listId: (params = utils.validateParameters(params, {
            listId: { type: 'number' },
            listElements: { type: 'array' },
            user: { type: ['object', 'undefined'] },
            forcePersist: { type: ['boolean', 'undefined'] },
            publishChanges: { type: 'boolean', default: !0 },
          })).listId,
        }
        return inMemoryDb.ensureListStateIsLoaded(identifiers).then(function () {
          var delta = _.reduce(
              params.listElements,
              function (delta, updatedElement) {
                var identifiers = { listId: params.listId, uuid: updatedElement.uuid },
                  currentElement = resourceHandlers.LIST_ELEMENT.get(inMemoryDb.getData(), identifiers),
                  resourceIsAffectedByAnotherQueuedAction = isResourceAffectedByOptimisticUpdates({
                    resource: resources.LIST_ELEMENT,
                    identifiers,
                  })
                return (
                  !1 === params.publishChanges ||
                    resourceIsAffectedByAnotherQueuedAction ||
                    _.isEqual(currentElement, updatedElement) ||
                    (_.isNil(updatedElement.deprecated_at)
                      ? _.isNil(currentElement)
                        ? delta.added.push(updatedElement)
                        : delta.changed.push(updatedElement)
                      : _.isNil(currentElement) || _.isNil(currentElement.deprecated_at)
                      ? delta.removed.push(updatedElement)
                      : delta.changed.push(updatedElement)),
                  delta
                )
              },
              { added: [], changed: [], removed: [] },
            ),
            cachedElementsByUUID = resourceHandlers.LIST_ELEMENTS.get(inMemoryDb.getData(), { listId: params.listId }),
            moreRemovedElements = _.filter(cachedElementsByUUID, function (listElement) {
              var newVersion = _.find(params.listElements, { uuid: listElement.uuid })
              return _.isNil(newVersion)
            })
          return (
            (delta.removed = _.unionBy(delta.removed, moreRemovedElements, 'uuid')),
            inMemoryDb
              .update(resources.LIST_ELEMENTS, identifiers, params.listElements, { forcePersist: params.forcePersist })
              .then(function () {
                !1 === _.isEmpty(delta.added) &&
                  resourceHandlers.LIST_ELEMENTS.publish({
                    identifiers,
                    publishType: publishTypes.ADDED,
                    resource: delta.added,
                    user: params.user,
                  }),
                  !1 === _.isEmpty(delta.changed) &&
                    resourceHandlers.LIST_ELEMENTS.publish({
                      identifiers,
                      publishType: publishTypes.CHANGED,
                      resource: delta.changed,
                      user: params.user,
                    }),
                  !1 === _.isEmpty(delta.removed) &&
                    resourceHandlers.LIST_ELEMENTS.publish({
                      identifiers,
                      publishType: publishTypes.REMOVED,
                      resource: delta.removed,
                      user: params.user,
                    })
              })
          )
        })
      },
      onListViewsArrived: function (params) {
        if (
          ((params = utils.validateParameters(params, {
            listId: { type: 'number' },
            listViews: { type: 'array' },
            user: { type: ['object', 'undefined'] },
            forcePersist: { type: ['boolean', 'undefined'] },
            publishChanges: { type: 'boolean', default: !0 },
          })),
          _.isEmpty(params.listViews))
        )
          return Promise.resolve()
        var identifiers = { listId: params.listId }
        return inMemoryDb.ensureListStateIsLoaded(identifiers).then(function () {
          var added = [],
            changed = [],
            removed = [],
            updateParameters = _.map(params.listViews, function (updatedListView) {
              var identifiers = { listId: params.listId, uuid: updatedListView.uuid },
                currentListView = resourceHandlers.VIEW.get(inMemoryDb.getData(), identifiers),
                updateParameters = {
                  resource: resources.VIEW,
                  identifiers,
                  value: updatedListView,
                  options: { forcePersist: params.forcePersist },
                },
                resourceIsAffectedByAnotherQueuedAction = isResourceAffectedByOptimisticUpdates({
                  resource: resources.VIEW,
                  identifiers,
                })
              return (
                !1 === params.publishChanges ||
                  resourceIsAffectedByAnotherQueuedAction ||
                  _.isEqual(currentListView, updatedListView) ||
                  (_.isNil(updatedListView.deprecated_at)
                    ? _.isNil(currentListView)
                      ? added.push(updatedListView)
                      : changed.push(updatedListView)
                    : _.isNil(currentListView) || _.isNil(currentListView.deprecated_at)
                    ? removed.push(updatedListView)
                    : changed.push(updatedListView)),
                updateParameters
              )
            })
          return inMemoryDb.updateMultiple(updateParameters).then(function () {
            var getFromOptimisticState = function (listViews) {
              return _.map(listViews, function (listView) {
                return resourceHandlers.VIEW.get(optimisticState.getData(), _.pick(listView, ['uuid', 'listId']))
              })
            }
            !1 === _.isEmpty(added) &&
              resourceHandlers.VIEWS.publish({
                identifiers,
                publishType: publishTypes.ADDED,
                resource: getFromOptimisticState(added),
                user: params.user,
              }),
              !1 === _.isEmpty(changed) &&
                resourceHandlers.VIEWS.publish({
                  identifiers,
                  publishType: publishTypes.CHANGED,
                  resource: getFromOptimisticState(changed),
                  user: params.user,
                }),
              !1 === _.isEmpty(removed) &&
                resourceHandlers.VIEWS.publish({
                  identifiers,
                  publishType: publishTypes.REMOVED,
                  resource: getFromOptimisticState(removed),
                  user: params.user,
                })
          })
        })
      },
      onUserViewsArrived: function (params) {
        return (
          (params = utils.validateParameters(params, {
            userViews: { type: 'array' },
            user: { type: ['object', 'undefined'] },
            forcePersist: { type: ['boolean', 'undefined'] },
            publishChanges: { type: 'boolean', default: !0 },
          })),
          inMemoryDb.initialLoad
            .then(() => {
              var currentViews = _.values(resourceHandlers.USER_VIEWS.get(inMemoryDb.getData(), {})),
                added = _.differenceBy(params.userViews, currentViews, 'uuid'),
                removed = _.differenceBy(currentViews, params.userViews, 'uuid'),
                changed = _.reject(
                  params.userViews,
                  view => _.some(added, { uuid: view.uuid }) || _.some(removed, { uuid: view.uuid }),
                )
              return { added, removed, changed }
            })
            .tap(() =>
              inMemoryDb.update(resources.USER_VIEWS, {}, params.userViews, { forcePersist: params.forcePersist }),
            )
            .then(_ref18 => {
              var { added, removed, changed } = _ref18,
                getFromOptimisticState = function (userViews) {
                  return _.map(userViews, function (userView) {
                    return resourceHandlers.USER_VIEW.get(optimisticState.getData(), { uuid: userView.uuid })
                  })
                }
              !1 === _.isEmpty(added) &&
                resourceHandlers.USER_VIEWS.publish({
                  identifiers: {},
                  publishType: publishTypes.ADDED,
                  resource: getFromOptimisticState(added),
                  user: params.user,
                }),
                !1 === _.isEmpty(changed) &&
                  resourceHandlers.USER_VIEWS.publish({
                    identifiers: {},
                    publishType: publishTypes.CHANGED,
                    resource: getFromOptimisticState(changed),
                    user: params.user,
                  }),
                !1 === _.isEmpty(removed) &&
                  resourceHandlers.USER_VIEWS.publish({
                    identifiers: {},
                    publishType: publishTypes.REMOVED,
                    resource: getFromOptimisticState(removed),
                    user: params.user,
                  })
            })
        )
      },
      onCategorySortOrdersArrived: function (params) {
        var listIdentifiers = {
            listId: (params = utils.validateParameters(params, {
              listId: { type: 'number' },
              categorySortOrders: { type: 'array' },
              forcePersist: { type: ['boolean', 'undefined'] },
            })).listId,
          },
          categorySortOrders = _.map(params.categorySortOrders, function (sortOrder) {
            return {
              listId: params.listId,
              elementId: sortOrder.elementId,
              sortedCategoryIds: sortOrder.sortedCategoryIds,
            }
          }),
          oldCategorySortOrdersByElementId = _.keyBy(
            resourceHandlers.CATEGORY_SORT_ORDERS_PER_LIST.get(inMemoryDb.getData(), listIdentifiers),
            'elementId',
          )
        return inMemoryDb
          .ensureListStateIsLoaded(listIdentifiers)
          .then(function () {
            return inMemoryDb.update(resources.CATEGORY_SORT_ORDERS_PER_LIST, listIdentifiers, categorySortOrders, {
              forcePersist: params.forcePersist,
            })
          })
          .then(function () {
            var updatedCategorySortOrders = _.reject(categorySortOrders, function (sortOrder) {
              return _.isEqual(sortOrder, oldCategorySortOrdersByElementId[sortOrder.elementId])
            })
            _.forEach(updatedCategorySortOrders, function (sortOrder) {
              resourceHandlers.CATEGORY_SORT_ORDER.publish({
                resource: sortOrder,
                publishType: publishTypes.CHANGED,
                identifiers: { listId: sortOrder.listId, elementId: sortOrder.elementId },
              })
            })
          })
      },
      onWorkspacesWithListsArrived: function (params) {
        return (
          (params = utils.validateParameters(params, { workspacesWithLists: { type: 'array' } })),
          inMemoryDb.initialLoad.then(function () {
            var cachedWorkspaces = resourceHandlers.WORKSPACES_WITH_LISTS.get(inMemoryDb.getData(), {}),
              workspacesWereCached = !1 === _.isNil(cachedWorkspaces)
            cachedWorkspaces = cachedWorkspaces || []
            var cachedWorkspacesById = _.keyBy(cachedWorkspaces, 'id'),
              cachedLists = _.flatMap(cachedWorkspaces, 'lists'),
              cachedListsById = _.keyBy(cachedLists, 'id'),
              updatePromise = inMemoryDb.update(resources.WORKSPACES_WITH_LISTS, {}, params.workspacesWithLists),
              delta = _.reduce(
                params.workspacesWithLists,
                function (delta, workspace) {
                  var cachedWorkspace = cachedWorkspacesById[workspace.id]
                  return (
                    workspace.deprecated_at
                      ? cachedWorkspace && cachedWorkspace.deprecated_at
                        ? !1 === _.isEqual(workspace, cachedWorkspace) && delta.changed.push(workspace)
                        : delta.removed.push(workspace)
                      : _.isNil(cachedWorkspace)
                      ? delta.added.push(workspace)
                      : !1 === _.isEqual(workspace, cachedWorkspace) && delta.changed.push(workspace),
                    delta.all.push(workspace),
                    delta
                  )
                },
                { added: [], changed: [], removed: [], all: [] },
              ),
              moreRemovedWorkspaces = _.filter(cachedWorkspaces, function (workspace) {
                var newVersion = _.find(params.workspacesWithLists, { id: workspace.id })
                return _.isNil(newVersion) || !1 === _.isNil(workspace.deprecated_at)
              })
            delta.removed = _.concat(delta.removed, moreRemovedWorkspaces)
            var listsDelta = _.reduce(
              _.flatMap(params.workspacesWithLists, 'lists'),
              function (delta, list) {
                var cachedList = cachedListsById[list.id]
                return (
                  list.deprecated_at
                    ? cachedList && cachedList.deprecated_at
                      ? !1 === _.isEqual(list, cachedList) && delta.changed.push(list)
                      : delta.removed.push(list)
                    : _.isNil(cachedList)
                    ? delta.added.push(list)
                    : !1 === _.isEqual(list, cachedList) && delta.changed.push(list),
                  delta.all.push(list),
                  delta
                )
              },
              { added: [], changed: [], removed: [], all: [] },
            )
            return updatePromise.then(function () {
              !1 !== workspacesWereCached &&
                (_.forEach(delta.added, function (workspace) {
                  resourceHandlers.WORKSPACE.publish({
                    identifiers: { id: workspace.id },
                    publishType: publishTypes.ADDED,
                    resource: workspace,
                  })
                }),
                _.forEach(delta.changed, function (workspace) {
                  resourceHandlers.WORKSPACE.publish({
                    identifiers: { id: workspace.id },
                    publishType: publishTypes.CHANGED,
                    resource: workspace,
                  })
                }),
                _.forEach(delta.removed, function (workspace) {
                  resourceHandlers.WORKSPACE.publish({
                    identifiers: { id: workspace.id },
                    publishType: publishTypes.REMOVED,
                    resource: workspace,
                  })
                }),
                _.forEach(listsDelta.added, function (list) {
                  resourceHandlers.LIST.publish({
                    identifiers: { id: list.id },
                    publishType: publishTypes.ADDED,
                    resource: list,
                  })
                }),
                _.forEach(listsDelta.changed, function (list) {
                  resourceHandlers.LIST.publish({
                    identifiers: { id: list.id },
                    publishType: publishTypes.CHANGED,
                    resource: list,
                  })
                }),
                _.forEach(listsDelta.removed, function (list) {
                  resourceHandlers.LIST.publish({
                    identifiers: { id: list.id },
                    publishType: publishTypes.REMOVED,
                    resource: list,
                  })
                }))
            })
          })
        )
      },
      onAccessChanged: function (params) {
        params = utils.validateParameters(params, {
          resource: { type: 'string' },
          identifiers: { type: 'object' },
          publishType: { type: 'string' },
          access: { type: 'object' },
          users: { type: 'array', default: [] },
          groups: { type: 'array', default: [] },
        })
        var users = resourceHandlers.USERS.get(inMemoryDb.getData(), {}),
          updatedUsers = _.unionBy(params.users, users, 'id'),
          groups = resourceHandlers.GROUPS.get(inMemoryDb.getData(), {}),
          updatedGroups = _.unionBy(params.groups, groups, 'id'),
          resourceHandler = resourceHandlers[params.resource],
          accesses = resourceHandler.get(inMemoryDb.getData(), params.identifiers),
          updatedAccesses =
            params.publishType === publishTypes.REMOVED
              ? _.reject(accesses, ['uuid', params.access.uuid])
              : _.unionBy([params.access], accesses, 'uuid')
        return Promise.all([
          inMemoryDb.update(resources.USERS, {}, updatedUsers),
          inMemoryDb.update(resources.GROUPS, {}, updatedGroups),
          inMemoryDb.update(params.resource, params.identifiers, updatedAccesses),
        ]).then(function () {
          var accesses = resourceHandler.get(optimisticState.getData(), params.identifiers)
          return (
            resourceHandler.publish({
              identifiers: params.identifiers,
              publishType: publishTypes.CHANGED,
              resource: accesses,
            }),
            accesses
          )
        })
      },
      onNotificationsArrived: function (params) {
        if (_.isEmpty(params.notifications)) return Promise.resolve(null)
        var currentNewNotifications = resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.get(inMemoryDb.getData(), {}),
          pushedNewNotifications = _.filter(params.notifications, { isNew: !0 }),
          pushedNonNewNotifications = _.filter(params.notifications, { isNew: !1 }),
          updatedNewNotifications = _.chain(pushedNewNotifications)
            .map(function (notification) {
              return _.pick(notification, ZenkitControlsShared.minimalNewNotificationColumns)
            })
            .unionBy(currentNewNotifications, 'id')
            .differenceBy(pushedNonNewNotifications, 'id')
            .value()
        return inMemoryDb.update(resources.MINIMAL_NEW_NOTIFICATIONS, {}, updatedNewNotifications).then(function () {
          return (
            resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.publish({ identifiers: {}, resource: updatedNewNotifications }),
            null
          )
        })
      },
    }
    return optimisticState
  }),
  (self.makeSynchronization = function (dependencies) {
    var changeFns,
      currentSyncStatus,
      removeFromQueue,
      onSyncStarted,
      onSyncDone,
      onSyncFailed,
      getListWrapper,
      getWorkspaceWrapper,
      _ = dependencies.lodash,
      Promise = dependencies.Promise,
      moment = dependencies.moment,
      inMemoryDb = dependencies.inMemoryDb,
      optimisticState = dependencies.optimisticState,
      utils = dependencies.utils,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      zenkitFetch = dependencies.zenkitFetch,
      resources = dependencies.resources,
      connectionChecker = dependencies.connectionChecker,
      globals = dependencies.globals,
      resourceHandlers = dependencies.resourceHandlers,
      syncStatusHandler =
        ((changeFns = utils.ChangeCallbackMixin()),
        (currentSyncStatus = { inProgress: !1, current: void 0, todo: [], done: [], failed: [] }),
        (removeFromQueue = function (wrappers) {
          ;(currentSyncStatus = _.assign(currentSyncStatus, {
            todo: _.differenceBy(currentSyncStatus.todo, wrappers, 'key'),
          })),
            changeFns.triggerChange()
        }),
        (onSyncStarted = function (wrapper) {
          ;(currentSyncStatus = _.assign(currentSyncStatus, { current: wrapper, inProgress: !0 })),
            changeFns.triggerChange()
        }),
        (onSyncDone = function (wrapper) {
          ;(currentSyncStatus = _.assign(currentSyncStatus, {
            current: void 0,
            inProgress: !0,
            todo: _.reject(currentSyncStatus.todo, { key: wrapper.key }),
            done: _.unionBy(currentSyncStatus.done, [wrapper], 'key'),
            failed: _.reject(currentSyncStatus.failed, { key: wrapper.key }),
          })),
            changeFns.triggerChange()
        }),
        (onSyncFailed = function (wrapper) {
          ;(currentSyncStatus = _.assign(currentSyncStatus, {
            current: void 0,
            inProgress: !0,
            todo: _.reject(currentSyncStatus.todo, { key: wrapper.key }),
            done: _.reject(currentSyncStatus.done, { key: wrapper.key }),
            failed: _.unionBy(currentSyncStatus.failed, wrapper, 'key'),
          })),
            changeFns.triggerChange()
        }),
        (getListWrapper = function (id) {
          return { key: 'list-' + id, listId: id }
        }),
        (getWorkspaceWrapper = function (id) {
          return { key: 'workspace-' + id, workspaceId: id }
        }),
        {
          removeListIdsFromQueue: function (listIds) {
            removeFromQueue(_.map(listIds, getListWrapper))
          },
          onListSyncStarted: function (listId) {
            onSyncStarted(getListWrapper(listId))
          },
          onListSyncDone: function (listId) {
            onSyncDone(getListWrapper(listId))
          },
          onListSyncFailed: function (listId) {
            onSyncFailed(getListWrapper(listId))
          },
          removeWorkspaceIdsFromQueue: function (listIds) {
            removeFromQueue(_.map(listIds, getWorkspaceWrapper))
          },
          onWorkspaceSyncStarted: function (workspaceId) {
            onSyncStarted(getWorkspaceWrapper(workspaceId))
          },
          onWorkspaceSyncDone: function (workspaceId) {
            onSyncDone(getWorkspaceWrapper(workspaceId))
          },
          onWorkspaceSyncFailed: function (workspaceId) {
            onSyncFailed(getWorkspaceWrapper(workspaceId))
          },
          queueIds: function (params) {
            var listIdsToSync = params.listIds,
              workspaceIdsToSync = params.workspaceIds
            if (!_.isEmpty(listIdsToSync) || !_.isEmpty(workspaceIdsToSync)) {
              currentSyncStatus.current &&
                currentSyncStatus.current.listId &&
                (listIdsToSync = _.without(listIdsToSync, currentSyncStatus.current.listId))
              var listWrappers = _.map(listIdsToSync, getListWrapper)
              currentSyncStatus.current &&
                currentSyncStatus.current.workspaceId &&
                (workspaceIdsToSync = _.without(workspaceIdsToSync, currentSyncStatus.current.workspaceId))
              var workspaceWrappers = _.map(workspaceIdsToSync, getWorkspaceWrapper)
              !(function (wrappers, params) {
                ;(currentSyncStatus = _.assign(currentSyncStatus, {
                  todo: params.prioritize
                    ? _.unionBy(wrappers, currentSyncStatus.todo, 'key')
                    : _.unionBy(currentSyncStatus.todo, wrappers, 'key'),
                  done: _.differenceBy(currentSyncStatus.done, wrappers, 'key'),
                  failed: _.differenceBy(currentSyncStatus.failed, wrappers, 'key'),
                })),
                  changeFns.triggerChange()
              })(_.concat(listWrappers, workspaceWrappers), { prioritize: params.prioritize })
            }
          },
          sortQueueBy: function (sortByFn) {
            ;(currentSyncStatus.todo = _.sortBy(currentSyncStatus.todo, sortByFn)), changeFns.triggerChange()
          },
          onSyncEnded: function () {
            ;(currentSyncStatus = _.assign(currentSyncStatus, {
              current: void 0,
              inProgress: !1,
              todo: [],
              done: [],
              failed: [],
            })),
              changeFns.triggerChange()
          },
          getStatus: function () {
            return currentSyncStatus
          },
          onChange: changeFns.onChange,
        }),
      listSynchronizationsChangeFns = utils.ChangeCallbackMixin(),
      workspaceSynchronizationsChangeFns = utils.ChangeCallbackMixin(),
      SynchronizationService = {
        getSyncStatus: syncStatusHandler.getStatus,
        onListSynchronizationChanged: listSynchronizationsChangeFns.onChange,
        onWorkspaceSynchronizationChanged: workspaceSynchronizationsChangeFns.onChange,
        onSyncStatusChanged: syncStatusHandler.onChange,
      },
      serializeError = function (error) {
        return _.pick(error, ['name', 'stack', 'message', 'code', 'description'])
      },
      getActivityTimestampKey = function (synchronization) {
        return synchronization.activitiesFilter === ZenkitControlsShared.activityTypes.FILTER.COMMENTS
          ? 'comments'
          : 'activities'
      },
      updateListSynchronization = function (listId, updateParams) {
        var synchronization = resourceHandlers.LIST_SYNCHRONIZATION.get(inMemoryDb.getData(), { listId })
        return (
          (synchronization = null === updateParams ? null : _.assign(synchronization, updateParams)) &&
            _.isError(synchronization.error) &&
            (synchronization.error = serializeError(synchronization.error)),
          inMemoryDb
            .update(resources.LIST_SYNCHRONIZATION, { listId }, synchronization, { forcePersist: !0 })
            .then(function () {
              return inMemoryDb.getListSynchronization({ listId })
            })
            .tap(function (synchronization) {
              listSynchronizationsChangeFns.triggerChange({ listId, synchronization })
            })
        )
      },
      createListSynchronization = function (params) {
        return updateListSynchronization(params.listId, {
          listId: params.listId,
          created_at: new Date(),
          last_completed_at: null,
          wasSynchronizedAtLeastOnce: !1,
          activitiesFilter: _.isNil(params.activitiesFilter)
            ? ZenkitControlsShared.activityTypes.FILTER.COMMENTS
            : params.activitiesFilter,
        }).return(void 0)
      },
      deleteListSynchronization = function (params) {
        return inMemoryDb
          .ensureListStateIsLoaded({ listId: params.listId })
          .then(function () {
            return Promise.all([
              inMemoryDb.update(resources.LIST_ENTRIES, { listId: params.listId }, null, { forcePersist: !0 }),
              inMemoryDb.update(resources.CATEGORY_SORT_ORDERS_PER_LIST, { listId: params.listId }, null, {
                forcePersist: !0,
              }),
              inMemoryDb.update(resources.ACTIVITIES, { listId: params.listId }, null, { forcePersist: !0 }),
              inMemoryDb.update(resources.VIEWS, { listId: params.listId }, null, { forcePersist: !0 }),
              inMemoryDb.update(resources.LIST_FILTERS, { listId: params.listId }, null, { forcePersist: !0 }),
              inMemoryDb.update(resources.ACCESSES_PER_LIST, { listId: params.listId }, null, { forcePersist: !0 }),
              inMemoryDb.update(resources.RECURRENCE_RULES, { listId: params.listId }, null, { forcePersist: !0 }),
            ])
          })
          .then(function () {
            return updateListSynchronization(params.listId, null)
          })
          .return(void 0)
      }
    ;(SynchronizationService.createListSynchronization = function (params) {
      return createListSynchronization(params).tap(function () {
        SynchronizationService.triggerListSynchronization({ listId: params.listId })
      })
    }),
      (SynchronizationService.deleteListSynchronization = deleteListSynchronization)
    var setIncrementalSyncWatermarkParamsValidation,
      setFullSyncWatermarkParamsValidation,
      synchronizeCategorySortOrders,
      synchronizeDeletedEntries,
      synchronizeActivities,
      synchronizeViews,
      synchronizeFilters,
      synchronizeRecurrenceRules,
      synchronizeElements,
      synchronizeEntries,
      synchronizeListAccesses,
      shouldSyncResource,
      synchronizeList =
        ((setIncrementalSyncWatermarkParamsValidation = {
          listId: { type: 'number' },
          nextWatermark: {
            type: ['object'],
            customCheck: function (watermark) {
              return _.conformsTo(watermark, {
                id: _.isInteger,
                updated_at: function (timestamp) {
                  return _.isString(timestamp) && moment(timestamp).isValid()
                },
              })
            },
          },
        }),
        (setFullSyncWatermarkParamsValidation = {
          listId: { type: 'number' },
          nextWatermark: {
            type: 'string',
            customCheck: function (timestamp) {
              return _.isString(timestamp) && moment(timestamp).isValid()
            },
          },
        }),
        (synchronizeCategorySortOrders = function (listId, nextWatermark) {
          var url = zenkitFetch.buildUrl('lists/:listAllId/category-sort-orders', { listAllId: listId })
          return zenkitFetch.post(url, {}).then(function (categorySortOrders) {
            return (
              optimisticState.onCategorySortOrdersArrived({ listId, categorySortOrders, forcePersist: !0 }),
              (params = { listId, nextWatermark }),
              (params = utils.validateParameters(params, setFullSyncWatermarkParamsValidation)),
              updateListSynchronization(params.listId, { nextCategorySortOrderWatermark: params.nextWatermark })
            )
            var params
          })
        }),
        (synchronizeDeletedEntries = function (listId) {
          var synchronization = inMemoryDb.getListSynchronization({ listId })
          if (_.isNil(synchronization)) return Promise.resolve()
          var url = zenkitFetch.buildUrl('lists/:listAllId/deleted-entries/sync', { listAllId: listId })
          return zenkitFetch
            .post(url, {
              excludeDeletedBefore: synchronization.created_at,
              watermark: synchronization.nextDeletedEntriesWatermark,
            })
            .then(function (_ref19) {
              var { listEntries, nextWatermark } = _ref19
              if (_.isEmpty(listEntries)) return { listEntries, nextWatermark }
              var updateParams = _.map(listEntries, entry => ({
                resource: resources.LIST_ENTRY,
                identifiers: { uuid: entry.uuid, listId },
                value: null,
                options: { forcePersist: !0 },
              }))
              return inMemoryDb.updateMultiple(updateParams).then(_.constant({ listEntries, nextWatermark }))
            })
            .then(function (_ref20) {
              var { nextWatermark } = _ref20
              return _.isNil(nextWatermark)
                ? null
                : (function (params) {
                    var { listId, nextWatermark } = utils.validateParameters(
                      params,
                      setIncrementalSyncWatermarkParamsValidation,
                    )
                    return updateListSynchronization(listId, { nextDeletedEntriesWatermark: nextWatermark })
                  })({ listId, nextWatermark })
            })
        }),
        (synchronizeActivities = function synchronizeActivities(listId) {
          var synchronization = inMemoryDb.getListSynchronization({ listId })
          if (_.isNil(synchronization)) return Promise.resolve()
          var url = zenkitFetch.buildUrl('lists/:listAllId/activities/sync', { listAllId: listId })
          return zenkitFetch
            .post(url, {
              filter: synchronization.activitiesFilter,
              limit: 500,
              watermark: synchronization.nextActivitiesWatermark,
              excludeDeprecatedBefore: synchronization.created_at,
            })
            .tap(function (container) {
              var activities = container.activities
              if (!_.isEmpty(activities))
                return optimisticState.onListActivitiesArrived({
                  listId,
                  listActivities: activities,
                  forcePersist: !0,
                  publishChanges: inMemoryDb.isListAvailableOffline({ listId }),
                })
            })
            .then(function (container) {
              var params,
                activities = container.activities
              return _.isEmpty(activities)
                ? container
                : ((params = { listId, nextWatermark: container.nextWatermark }),
                  (params = utils.validateParameters(params, setIncrementalSyncWatermarkParamsValidation)),
                  updateListSynchronization(params.listId, { nextActivitiesWatermark: params.nextWatermark })).then(
                    _.constant(container),
                  )
            })
            .then(function (container) {
              if (!(_.isEmpty(container.activities) || _.size(container.activities) < 500))
                return synchronizeActivities(listId)
            })
        }),
        (synchronizeViews = function (listId, nextWatermark) {
          var url = zenkitFetch.buildUrl('users/me/lists/:listAllId/views', { listAllId: listId })
          return zenkitFetch.get(url).then(function (listViews) {
            return inMemoryDb.update(resources.VIEWS, { listId }, listViews, { forcePersist: !0 }).then(function () {
              return (
                (params = { listId, nextWatermark }),
                (params = utils.validateParameters(params, setFullSyncWatermarkParamsValidation)),
                updateListSynchronization(params.listId, { nextViewWatermark: params.nextWatermark })
              )
              var params
            })
          })
        }),
        (synchronizeFilters = function (listId, nextWatermark) {
          var url = zenkitFetch.buildUrl('users/me/lists/:listAllId/filters', { listAllId: listId })
          return zenkitFetch.get(url).then(function (listFilters) {
            return inMemoryDb
              .update(resources.LIST_FILTERS, { listId }, listFilters, { forcePersist: !0 })
              .then(function () {
                return (
                  (params = { listId, nextWatermark }),
                  (params = utils.validateParameters(params, setFullSyncWatermarkParamsValidation)),
                  updateListSynchronization(params.listId, { nextFilterWatermark: params.nextWatermark })
                )
                var params
              })
          })
        }),
        (synchronizeRecurrenceRules = function (listId, nextWatermark) {
          var url = zenkitFetch.buildUrl('/lists/:listId/recurrence/rules', { listId })
          return zenkitFetch.get(url).then(function (rules) {
            return inMemoryDb
              .update(resources.RECURRENCE_RULES, { listId }, rules, { forcePersist: !0 })
              .then(function () {
                return (
                  (params = { listId, nextWatermark }),
                  (params = utils.validateParameters(params, setFullSyncWatermarkParamsValidation)),
                  updateListSynchronization(params.listId, { nextRecurrenceRuleWatermark: params.nextWatermark })
                )
                var params
              })
          })
        }),
        (synchronizeElements = function (listId, nextWatermark) {
          var url = zenkitFetch.buildUrl('lists/:listAllId/elements', { listAllId: listId })
          return zenkitFetch.get(url).then(function (listElements) {
            return (
              optimisticState.onListElementsArrived({ listId, listElements, forcePersist: !0, publishChanges: !0 }),
              (params = { listId, nextWatermark }),
              (params = utils.validateParameters(params, setFullSyncWatermarkParamsValidation)),
              updateListSynchronization(params.listId, { nextElementWatermark: params.nextWatermark })
            )
            var params
          })
        }),
        (synchronizeEntries = function synchronizeEntries(listId, synchronization) {
          var url = zenkitFetch.buildUrl('lists/:listAllId/entries/sync', { listAllId: listId })
          return zenkitFetch
            .post(url, {
              watermark: synchronization.nextWatermark,
              excludeDeprecatedBefore: synchronization.created_at,
              limit: 500,
            })
            .then(function (result) {
              if (!_.isEmpty(result.listEntries) || !_.isNil(result.nextWatermark)) {
                var isDone = _.isEmpty(result.listEntries) || _.size(result.listEntries) < 500,
                  whenWatermarkUpdated = optimisticState
                    .onListEntriesArrived({
                      listId,
                      listEntries: result.listEntries,
                      forcePersist: !0,
                      publishChanges: inMemoryDb.isListAvailableOffline({ listId }),
                    })
                    .then(function () {
                      return (
                        (params = { listId, nextWatermark: result.nextWatermark }),
                        (params = utils.validateParameters(params, setIncrementalSyncWatermarkParamsValidation)),
                        updateListSynchronization(params.listId, { nextWatermark: params.nextWatermark })
                      )
                      var params
                    })
                return isDone
                  ? whenWatermarkUpdated
                  : whenWatermarkUpdated.then(function (updatedSynchronization) {
                      return synchronizeEntries(listId, updatedSynchronization)
                    })
              }
            })
        }),
        (synchronizeListAccesses = function (listId, nextWatermark) {
          var url = zenkitFetch.buildUrl('lists/:listAllId/accesses', { listAllId: listId })
          return zenkitFetch.get(url).then(function (result) {
            var cachedUsers = resourceHandlers.USERS.get(inMemoryDb.getData(), {}),
              cachedGroups = resourceHandlers.GROUPS.get(inMemoryDb.getData(), {})
            return Promise.all([
              inMemoryDb.update(resources.USERS, {}, _.unionBy(result.users, cachedUsers, 'id')),
              inMemoryDb.update(resources.GROUPS, {}, _.unionBy(result.groups, cachedGroups, 'id')),
              inMemoryDb.update(resources.ACCESSES_PER_LIST, { listId }, result.accesses, { forcePersist: !0 }),
            ]).then(function () {
              return (
                (params = { listId, nextWatermark }),
                (params = utils.validateParameters(params, setFullSyncWatermarkParamsValidation)),
                updateListSynchronization(params.listId, { nextListAccessesWatermark: params.nextWatermark })
              )
              var params
            })
          })
        }),
        (shouldSyncResource = function (_ref21) {
          var { timestamp, watermark } = _ref21
          return (
            null !== timestamp && (void 0 === timestamp || !!_.isNil(watermark) || moment(timestamp).isAfter(watermark))
          )
        }),
        function (params) {
          var listId = (params = utils.validateParameters(params, {
              listId: { type: 'number' },
              timestamps: { type: ['object', 'undefined'] },
            })).listId,
            synchronization = inMemoryDb.getListSynchronization({ listId: params.listId })
          return (
            params.timestamps
              ? Promise.resolve(params.timestamps)
              : zenkitFetch.get(zenkitFetch.buildUrl('lists/:listAllId/updated-at', { listAllId: listId }))
          )
            .then(function (timestamps) {
              var shouldSyncEntries = shouldSyncResource({
                  timestamp: timestamps.listEntries,
                  watermark: _.get(synchronization, ['nextWatermark', 'updated_at']),
                }),
                shouldSyncElements = shouldSyncResource({
                  timestamp: timestamps.listElements,
                  watermark: _.get(synchronization, ['nextElementWatermark']),
                }),
                shouldSyncCategorySortOrders = shouldSyncResource({
                  timestamp: timestamps.categorySortOrders,
                  watermark: _.get(synchronization, ['nextCategorySortOrderWatermark']),
                }),
                shouldSyncViews = shouldSyncResource({
                  timestamp: timestamps.views,
                  watermark: _.get(synchronization, ['nextViewWatermark']),
                }),
                shouldSyncFilters = shouldSyncResource({
                  timestamp: timestamps.filters,
                  watermark: _.get(synchronization, ['nextFilterWatermark']),
                }),
                shouldSyncRules = shouldSyncResource({
                  timestamp: timestamps.recurrenceRules,
                  watermark: _.get(synchronization, ['nextRecurrenceRuleWatermark']),
                }),
                shouldSyncDeletedEntries = shouldSyncResource({
                  timestamp: timestamps.deletedListEntries,
                  watermark: _.get(synchronization, ['nextDeletedEntriesWatermark', 'updated_at']),
                }),
                shouldSyncActivities = shouldSyncResource({
                  timestamp: timestamps[getActivityTimestampKey(synchronization)],
                  watermark: _.get(synchronization, ['nextActivitiesWatermark', 'updated_at']),
                }),
                shouldSyncListAccesses = shouldSyncResource({
                  timestamp: timestamps.listAccesses,
                  watermark: _.get(synchronization, ['nextListAccessesWatermark']),
                }),
                promises = _.compact([
                  shouldSyncEntries ? synchronizeEntries(listId, synchronization) : null,
                  shouldSyncElements ? synchronizeElements(listId, timestamps.listElements) : null,
                  shouldSyncCategorySortOrders
                    ? synchronizeCategorySortOrders(listId, timestamps.categorySortOrders)
                    : null,
                  shouldSyncViews ? synchronizeViews(listId, timestamps.views) : null,
                  shouldSyncFilters ? synchronizeFilters(listId, timestamps.filters) : null,
                  shouldSyncRules ? synchronizeRecurrenceRules(listId, timestamps.recurrenceRules) : null,
                  shouldSyncDeletedEntries ? synchronizeDeletedEntries(listId) : null,
                  shouldSyncActivities ? synchronizeActivities(listId) : null,
                  shouldSyncListAccesses ? synchronizeListAccesses(listId, timestamps.listAccesses) : null,
                ])
              if (!_.isEmpty(promises)) return syncStatusHandler.onListSyncStarted(listId), Promise.all(promises)
            })
            .then(function () {
              return (function (listId) {
                return updateListSynchronization(listId, {
                  wasSynchronizedAtLeastOnce: !0,
                  last_completed_at: new Date(),
                  error: null,
                })
              })(listId)
            })
            .tap(function () {
              syncStatusHandler.onListSyncDone(listId)
            })
            .catch(function (err) {
              var errorCodesOnWhichToRemoveSynchronization = [
                ZenkitErrorCodes.NOT_FOUND.code,
                ZenkitErrorCodes.LIST_IS_DEPRECATED.code,
                ZenkitErrorCodes.FORBIDDEN.code,
              ]
              return _.includes(errorCodesOnWhichToRemoveSynchronization, _.get(err, ['code']))
                ? Promise.all([
                    inMemoryDb.update(resources.LIST, { id: listId }, null, { forcePersist: !0 }),
                    inMemoryDb.update(resources.LIST_ELEMENTS, { listId }, null, { forcePersist: !0 }),
                    deleteListSynchronization({ listId }),
                  ])
                : (console.error('Synchronization failed: ', err),
                  syncStatusHandler.onListSyncFailed(listId),
                  updateListSynchronization(listId, { error: err }).throw(err))
            })
        })
    SynchronizationService.triggerListSynchronization = function (params) {
      ;(params = utils.validateParameters(params, { listId: { type: 'number' } })),
        syncStatusHandler.queueIds({ listIds: [params.listId], prioritize: !0 })
    }
    var updateWorkspaceSynchronization = function (workspaceId, updateParams) {
        var synchronization = resourceHandlers.WORKSPACE_SYNCHRONIZATION.get(inMemoryDb.getData(), { workspaceId })
        return (
          (synchronization = null === updateParams ? null : _.assign(synchronization, updateParams)) &&
            _.isError(synchronization.error) &&
            (synchronization.error = serializeError(synchronization.error)),
          inMemoryDb
            .update(resources.WORKSPACE_SYNCHRONIZATION, { workspaceId }, synchronization, { forcePersist: !0 })
            .then(function () {
              return inMemoryDb.getWorkspaceSynchronization({ workspaceId })
            })
            .tap(function (synchronization) {
              workspaceSynchronizationsChangeFns.triggerChange({ workspaceId, synchronization })
            })
        )
      },
      synchronizeWorkspace = (function () {
        var setIncrementalSyncWatermarkParamsValidation = {
            workspaceId: { type: 'number' },
            nextWatermark: {
              type: ['object'],
              customCheck: function (watermark) {
                return _.conformsTo(watermark, {
                  id: _.isInteger,
                  updated_at: function (timestamp) {
                    return _.isString(timestamp) && moment(timestamp).isValid()
                  },
                })
              },
            },
          },
          setFullSyncWatermarkParamsValidation = {
            workspaceId: { type: 'number' },
            nextWatermark: {
              type: 'string',
              customCheck: function (timestamp) {
                return _.isString(timestamp) && moment(timestamp).isValid()
              },
            },
          },
          synchronizeWorkspaceActivities = function synchronizeWorkspaceActivities(workspaceId) {
            var synchronization = inMemoryDb.getWorkspaceSynchronization({ workspaceId })
            if (_.isNil(synchronization)) return Promise.resolve()
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/activities/sync', {
              workspaceAllId: workspaceId,
            })
            return zenkitFetch
              .post(url, {
                filter: synchronization.activitiesFilter,
                limit: 500,
                watermark: synchronization.nextActivitiesWatermark,
                excludeDeprecatedBefore: synchronization.created_at,
              })
              .tap(function (container) {
                var activities = container.activities
                if (!_.isEmpty(activities))
                  return optimisticState.onWorkspaceActivitiesArrived({
                    workspaceId,
                    workspaceActivities: activities,
                    forcePersist: !0,
                    publishChanges: inMemoryDb.isWorkspaceAvailableOffline({ workspaceId }),
                  })
              })
              .then(function (container) {
                var params,
                  activities = container.activities
                return _.isEmpty(activities)
                  ? container
                  : ((params = { workspaceId, nextWatermark: container.nextWatermark }),
                    (params = utils.validateParameters(params, setIncrementalSyncWatermarkParamsValidation)),
                    updateWorkspaceSynchronization(params.workspaceId, {
                      nextActivitiesWatermark: params.nextWatermark,
                    })).then(_.constant(container))
              })
              .then(function (container) {
                if (!(_.isEmpty(container.activities) || _.size(container.activities) < 500))
                  return synchronizeWorkspaceActivities(workspaceId)
              })
          },
          synchronizeWorkspaceAccesses = function (workspaceId, nextWatermark) {
            var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/accesses', { workspaceAllId: workspaceId })
            return zenkitFetch.get(url).then(function (result) {
              var cachedUsers = resourceHandlers.USERS.get(inMemoryDb.getData(), {}),
                cachedGroups = resourceHandlers.GROUPS.get(inMemoryDb.getData(), {})
              return Promise.all([
                inMemoryDb.update(resources.USERS, {}, _.unionBy(result.users, cachedUsers, 'id')),
                inMemoryDb.update(resources.GROUPS, {}, _.unionBy(result.groups, cachedGroups, 'id')),
                inMemoryDb.update(resources.ACCESSES_PER_WORKSPACE, { workspaceId }, result.accesses, {
                  forcePersist: !0,
                }),
              ]).then(function () {
                return (
                  (params = { workspaceId, nextWatermark }),
                  (params = utils.validateParameters(params, setFullSyncWatermarkParamsValidation)),
                  updateWorkspaceSynchronization(params.workspaceId, {
                    nextWorkspaceAccessesWatermark: params.nextWatermark,
                  })
                )
                var params
              })
            })
          }
        return function (params) {
          var workspaceId = (params = utils.validateParameters(params, {
              workspaceId: { type: 'number' },
              timestamps: { type: ['object', 'undefined'] },
            })).workspaceId,
            synchronization = inMemoryDb.getWorkspaceSynchronization({ workspaceId }),
            whenTimestampsLoaded = params.timestamps
              ? Promise.resolve(params.timestamps)
              : zenkitFetch.get(zenkitFetch.buildUrl('workspaces/:workspaceId/updated-at', { workspaceId }))
          return _.isNil(synchronization)
            ? Promise.resolve()
            : whenTimestampsLoaded
                .then(function (timestamps) {
                  var activityTimestampKey = getActivityTimestampKey(synchronization),
                    shouldSyncActivities =
                      null !== timestamps[activityTimestampKey] &&
                      (void 0 === timestamps[activityTimestampKey] ||
                        _.isNil(_.get(synchronization, ['nextActivitiesWatermark', 'updated_at'])) ||
                        moment(timestamps[activityTimestampKey]).isAfter(
                          moment(synchronization.nextActivitiesWatermark.updated_at),
                        )),
                    shouldSyncWorkspaceAccesses =
                      null !== timestamps.accesses &&
                      (void 0 === timestamps.accesses ||
                        _.isNil(_.get(synchronization, ['nextWorkspaceAccessesWatermark'])) ||
                        moment(timestamps.accesses).isAfter(moment(synchronization.nextWorkspaceAccessesWatermark))),
                    promises = _.compact([
                      shouldSyncActivities ? synchronizeWorkspaceActivities(workspaceId) : null,
                      shouldSyncWorkspaceAccesses
                        ? synchronizeWorkspaceAccesses(workspaceId, timestamps.accesses)
                        : null,
                    ])
                  if (!_.isEmpty(promises))
                    return syncStatusHandler.onWorkspaceSyncStarted(workspaceId), Promise.all(promises)
                })
                .then(function () {
                  return (function (workspaceId) {
                    return updateWorkspaceSynchronization(workspaceId, {
                      wasSynchronizedAtLeastOnce: !0,
                      last_completed_at: new Date(),
                      error: null,
                    })
                  })(workspaceId)
                })
                .tap(function () {
                  syncStatusHandler.onWorkspaceSyncDone(workspaceId)
                })
                .catch(function (err) {
                  var errorCodesOnWhichToRemoveSynchronization = [
                    ZenkitErrorCodes.NOT_FOUND.code,
                    ZenkitErrorCodes.FORBIDDEN.code,
                  ]
                  return _.includes(errorCodesOnWhichToRemoveSynchronization, _.get(err, ['code']))
                    ? SynchronizationService.deleteWorkspaceSynchronization({ workspaceId })
                    : (console.error('Workspace synchronization failed: ', err),
                      syncStatusHandler.onWorkspaceSyncFailed(workspaceId),
                      updateWorkspaceSynchronization(workspaceId, { error: err }).throw(err))
                })
        }
      })()
    SynchronizationService.triggerWorkspaceSynchronization = function (params) {
      ;(params = utils.validateParameters(params, { workspaceId: { type: 'number' } })),
        syncStatusHandler.queueIds({ workspaceIds: [params.workspaceId], prioritize: !0 })
    }
    var deleteWorkspaceSynchronization = function (params) {
        return inMemoryDb
          .ensureWorkspaceStateIsLoaded({ workspaceId: params.workspaceId })
          .then(function () {
            return Promise.all([
              inMemoryDb.update(resources.ACCESSES_PER_WORKSPACE, { workspaceId: params.workspaceId }, null, {
                forcePersist: !0,
              }),
              inMemoryDb.update(resources.ACTIVITIES_PER_WORKSPACE, { workspaceId: params.workspaceId }, null, {
                forcePersist: !0,
              }),
            ])
          })
          .then(function () {
            return updateWorkspaceSynchronization(params.workspaceId, null)
          })
          .return(void 0)
      },
      createWorkspaceSynchronization = function (params) {
        return updateWorkspaceSynchronization(params.workspaceId, {
          workspaceId: params.workspaceId,
          created_at: new Date(),
          last_completed_at: null,
          wasSynchronizedAtLeastOnce: !1,
          activitiesFilter: _.isNil(params.activitiesFilter)
            ? ZenkitControlsShared.activityTypes.FILTER.COMMENTS
            : params.activitiesFilter,
        }).return(void 0)
      }
    ;(SynchronizationService.deleteWorkspaceSynchronization = deleteWorkspaceSynchronization),
      (SynchronizationService.createWorkspaceSynchronization = function (params) {
        return createWorkspaceSynchronization(params).tap(function () {
          syncStatusHandler.queueIds({ workspaceIds: [params.workspaceId], prioritize: !0 })
        })
      })
    var currentExecution,
      currentSynchronizationRun = null,
      ensureTimestampsForNextSyncActionsWillBePrecached = function () {
        var promises = [inMemoryDb.initialLoad]
        return currentSynchronizationRun && promises.push(currentSynchronizationRun), Promise.all(promises)
      }
    syncStatusHandler.onChange(function () {
      if (currentSynchronizationRun) return currentSynchronizationRun
      if (!1 === connectionChecker.isOnline()) return Promise.reject(new Error('Cannot sync lists when offline.'))
      if (_.isEmpty(syncStatusHandler.getStatus().todo)) return Promise.resolve()
      var todo, listIds, workspaceIds
      return (currentSynchronizationRun = ((todo = syncStatusHandler.getStatus().todo),
      (listIds = _.compact(_.map(todo, 'listId'))),
      (workspaceIds = _.compact(_.map(todo, 'workspaceId'))),
      Promise.props({
        perList: _.isEmpty(listIds)
          ? {}
          : zenkitFetch.post('multiple-lists/updated-at', { listIds }).catch(_.constant({})),
        perWorkspace: _.isEmpty(workspaceIds)
          ? {}
          : zenkitFetch.post('multiple-workspaces/updated-at', { workspaceIds }).catch(_.constant({})),
      }).tap(function (timestamps) {
        syncStatusHandler.sortQueueBy(function (wrapper) {
          var timestamp
          return (
            wrapper.workspaceId
              ? (timestamp = _.get(timestamps, ['perWorkspace', wrapper.workspaceId, 'activities']))
              : wrapper.listId && (timestamp = _.get(timestamps, ['perList', wrapper.listId, 'activities'])),
            timestamp ? -1 * new Date(timestamp).valueOf() : 0
          )
        })
      }))
        .then(function runNextSyncAction(timestampsContainer) {
          var todo = syncStatusHandler.getStatus().todo
          if (_.isEmpty(todo)) return syncStatusHandler.onSyncEnded(), Promise.resolve(null)
          var params,
            listId,
            synchronization,
            wrapper = _.head(todo)
          return (
            wrapper.listId
              ? ((params = { listId: wrapper.listId, timestamps: timestampsContainer.perList[wrapper.listId] }),
                (listId = params.listId),
                (synchronization = inMemoryDb.getListSynchronization({ listId })),
                _.isNil(synchronization)
                  ? (syncStatusHandler.removeListIdsFromQueue([listId]), Promise.resolve())
                  : synchronizeList(params))
              : (function (params) {
                  var workspaceId = params.workspaceId,
                    synchronization = inMemoryDb.getWorkspaceSynchronization({ workspaceId })
                  return _.isNil(synchronization)
                    ? (syncStatusHandler.removeWorkspaceIdsFromQueue([workspaceId]), Promise.resolve())
                    : synchronizeWorkspace(params)
                })({
                  workspaceId: wrapper.workspaceId,
                  timestamps: timestampsContainer.perWorkspace[wrapper.workspaceId],
                })
          )
            .catch(_.noop)
            .then(function () {
              return runNextSyncAction(timestampsContainer)
            })
        })
        .finally(function () {
          currentSynchronizationRun = null
        }))
    }),
      (SynchronizationService.ensureSynchronizations =
        ((currentExecution = null),
        function (params) {
          return !1 === inMemoryDb.isIndexedDBSupported()
            ? Promise.reject('SynchronizationService.ensureSynchronizations: IndexedDB not supported.')
            : (currentExecution = Promise.all([inMemoryDb.initialLoad, currentExecution])
                .then(function () {
                  var newWorkspaceIds = params.workspaceIds,
                    newListIds = params.listIds,
                    syncOptionsByWorkspaceId = params.syncOptionsByWorkspaceId,
                    syncOptionsByListId = params.syncOptionsByListId,
                    currentListIds = _.map(_.keys(inMemoryDb.getAllListSynchronizations()), Number),
                    createListSyncFor = _.difference(newListIds, currentListIds),
                    deleteListSnycFor = _.difference(currentListIds, newListIds),
                    currentWorkspaceIds = _.map(_.keys(inMemoryDb.getAllWorkspaceSynchronizations()), Number),
                    createWorkspaceSyncFor = _.difference(newWorkspaceIds, currentWorkspaceIds),
                    deleteWorkspaceSyncFor = _.difference(currentWorkspaceIds, newWorkspaceIds)
                  return Promise.all([
                    Promise.map(createListSyncFor, function (listId) {
                      return createListSynchronization(_.defaults({ listId }, _.get(syncOptionsByListId, listId)))
                    }),
                    Promise.map(deleteListSnycFor, function (listId) {
                      return deleteListSynchronization({ listId })
                    }),
                    Promise.map(createWorkspaceSyncFor, function (workspaceId) {
                      return createWorkspaceSynchronization(
                        _.defaults({ workspaceId }, _.get(syncOptionsByWorkspaceId, workspaceId)),
                      )
                    }),
                    Promise.map(deleteWorkspaceSyncFor, function (workspaceId) {
                      return deleteWorkspaceSynchronization({ workspaceId })
                    }),
                  ])
                    .tap(function () {
                      if (globals.appType === ZenkitControlsShared.apps.chat.type) {
                        var listIds = createListSyncFor,
                          workspaceIds = createWorkspaceSyncFor
                        if (!_.isEmpty(listIds) || !_.isEmpty(workspaceIds))
                          return zenkitFetch
                            .post('latest-activities', {
                              listIds,
                              workspaceIds,
                              filter: ZenkitControlsShared.activityTypes.FILTER.COMMENTS,
                            })
                            .tap(function (container) {
                              var listPromises = _.map(listIds, function (listId) {
                                  var comment = _.get(container, ['byList', listId])
                                  return _.isNil(comment)
                                    ? null
                                    : optimisticState.onListActivitiesArrived({
                                        listId,
                                        listActivities: [comment],
                                        forcePersist: !0,
                                        publishChanges: !0,
                                      })
                                }),
                                workspacePromises = _.map(workspaceIds, function (workspaceId) {
                                  var comment = _.get(container, ['byWorkspace', workspaceId])
                                  return _.isNil(comment)
                                    ? null
                                    : optimisticState.onWorkspaceActivitiesArrived({
                                        workspaceId,
                                        workspaceActivities: [comment],
                                        forcePersist: !0,
                                        publishChanges: !0,
                                      })
                                })
                              return Promise.all(_.compact(_.concat(listPromises, workspacePromises)))
                            })
                            .catch(_.noop)
                      }
                    })
                    .tap(ensureTimestampsForNextSyncActionsWillBePrecached)
                    .tap(function () {
                      ;(_.isEmpty(createListSyncFor) && _.isEmpty(createWorkspaceSyncFor)) ||
                        syncStatusHandler.queueIds({ listIds: createListSyncFor, workspaceIds: createWorkspaceSyncFor })
                    })
                })
                .finally(function () {
                  currentExecution = null
                }))
        }))
    var active,
      wasOnline,
      synchronizeAllDownloadedListsAndWorkspaces = function () {
        return ensureTimestampsForNextSyncActionsWillBePrecached().then(function () {
          var listIds = _.map(_.keys(inMemoryDb.getAllListSynchronizations()), Number),
            workspaceIds = _.map(_.keys(inMemoryDb.getAllWorkspaceSynchronizations()), Number)
          syncStatusHandler.queueIds({ listIds, workspaceIds })
        })
      }
    return (
      (SynchronizationService.startBackgroundSynchronization =
        ((active = !1),
        (wasOnline = connectionChecker.isOnline()),
        function () {
          return active
            ? null
            : ((active = !0),
              synchronizeAllDownloadedListsAndWorkspaces().then(function () {
                return (
                  setInterval(synchronizeAllDownloadedListsAndWorkspaces, 3e5),
                  connectionChecker.onConnectionChanged(function () {
                    var isOnline = connectionChecker.isOnline()
                    isOnline && !1 === wasOnline && synchronizeAllDownloadedListsAndWorkspaces(), (wasOnline = isOnline)
                  }),
                  null
                )
              }))
        })),
      (SynchronizationService.triggerBackgroundSynchronization = synchronizeAllDownloadedListsAndWorkspaces),
      SynchronizationService
    )
  }),
  (self.makeSocketService = function (dependencies) {
    var SocketService,
      joinRoomQueue,
      leaveRoomQueue,
      debouncedFlushQueues,
      _ = dependencies.lodash,
      Promise = dependencies.Promise,
      getAccessToken = dependencies.getAccessToken,
      appType = dependencies.appType,
      Primus = dependencies.Primus,
      utils = dependencies.utils,
      urlUtils = dependencies.urlUtils,
      connectionChecker = dependencies.connectionChecker,
      pretendToBeOffline = dependencies.globals.pretendToBeOffline,
      changeFns = utils.ChangeCallbackMixin(),
      emitEvent = changeFns.triggerChange,
      privateState = {
        currentRooms: [],
        roomRequestCounts: {},
        isOpen: !1,
        openRequestPending: !1,
        connectionWasOpenAtLeastOnce: !1,
      },
      ROOM_ACTIONS_JOIN = 'join',
      ROOM_ACTIONS_LEAVE = 'leave',
      setIsOpen = function (isOpen) {
        var wasOpen = privateState.isOpen
        ;(privateState.isOpen = isOpen),
          wasOpen !== isOpen && emitEvent(isOpen ? { type: 'online' } : { type: 'offline' }),
          isOpen && (privateState.connectionWasOpenAtLeastOnce = !0)
      },
      buildRoomName = function (base, id, postfix) {
        var roomName = 'zenkit_room_' + base
        return !1 === _.isNil(id) && (roomName += '_' + id), postfix && (roomName += '_' + postfix), roomName
      },
      leaveRoomInternally = function (state, roomName) {
        return (
          (state.currentRooms = _.without(state.currentRooms, roomName)),
          delete state.roomRequestCounts[roomName],
          state
        )
      },
      primus = (function () {
        var url = urlUtils.getAbsolutePath()
        url += '?appType=' + appType
        var primus = Primus.connect(url, {
          strategy: ['timeout', 'disconnect'],
          reconnect: { max: 1 / 0, min: 2e3, retries: 10 },
          timeout: 2e4,
          pingTimeout: 6e4,
          manual: !0,
        })
        return (
          primus.on('data', function (message) {
            var messageType = message.messagetype
            if (!_.isNil(messageType)) {
              if ((console.debug('socket::' + messageType + '::' + message.modelName), 'push' === messageType)) {
                var pushEventType = 'socket::push::' + message.modelName
                return emitEvent({ type: pushEventType, detail: message })
              }
              if ('sync' === messageType) {
                var syncEventType = 'socket::sync::' + message.modelName
                return emitEvent({ type: syncEventType, detail: message })
              }
              if ('broadcast' === messageType) {
                var broadcastEventType = 'socket::broadcast::' + message.modelName
                return emitEvent({ type: broadcastEventType, detail: message })
              }
              return 'error' === messageType
                ? message.data
                  ? emitEvent({ type: 'error', detail: message.data })
                  : void (message.error && console.error(message.error))
                : void 0
            }
            console.error('SocketService :: Socket message was malformed and could not be read!', message)
          }),
          primus.on('open', function () {
            setIsOpen(!0), (privateState.openRequestPending = !1), console.info('Connection is alive and kicking')
          }),
          primus.on('reconnect scheduled', function (opts) {
            setIsOpen(!1), console.info('Reconnecting. This is attempt %d out of %d', opts.attempt, opts.retries)
          }),
          primus.on('end', function () {
            setIsOpen(!1), (privateState.openRequestPending = !1), console.info('Disconnected')
          }),
          primus
        )
      })()
    ;(SocketService = {
      on: function (type, callback) {
        return changeFns.onChange(function (event) {
          if (event.type === type) return callback(event)
        })
      },
      isOnline: function () {
        return privateState.isOpen
      },
      write: function (data) {
        return getAccessToken().then(function (accessToken) {
          ;(data.accessToken = accessToken), primus.write(data)
        })
      },
      writeRooms:
        ((joinRoomQueue = []),
        (leaveRoomQueue = []),
        (debouncedFlushQueues = _.debounce(function () {
          !1 === SocketService.isOpen && console.warn('Wanted to join rooms but the connection is not open, yet'),
            !1 === _.isEmpty(joinRoomQueue) &&
              (SocketService.write({ messagetype: 'rooms', action: ROOM_ACTIONS_JOIN, rooms: joinRoomQueue }),
              (joinRoomQueue = [])),
            !1 === _.isEmpty(leaveRoomQueue) &&
              (SocketService.write({ messagetype: 'rooms', action: ROOM_ACTIONS_LEAVE, rooms: leaveRoomQueue }),
              (leaveRoomQueue = []))
        }, 0)),
        function (action, roomName) {
          action === ROOM_ACTIONS_JOIN
            ? (joinRoomQueue.push(roomName), (leaveRoomQueue = _.without(leaveRoomQueue, roomName)))
            : action === ROOM_ACTIONS_LEAVE &&
              (leaveRoomQueue.push(roomName), (joinRoomQueue = _.without(joinRoomQueue, roomName))),
            debouncedFlushQueues()
        }),
      isRoomActive: function (roomName) {
        return _.includes(privateState.currentRooms, roomName)
      },
      requestRoomByName: function (roomName) {
        privateState.currentRooms = _.union(privateState.currentRooms, [roomName])
        var countBefore = Math.max(0, privateState.roomRequestCounts[roomName]) || 0
        ;(privateState.roomRequestCounts[roomName] = countBefore + 1),
          0 === countBefore && SocketService.writeRooms(ROOM_ACTIONS_JOIN, roomName)
      },
      releaseRoomByName: function (roomName) {
        ;(privateState.roomRequestCounts[roomName] = Math.max(0, (privateState.roomRequestCounts[roomName] || 0) - 1)),
          0 === privateState.roomRequestCounts[roomName] &&
            ((privateState = leaveRoomInternally(privateState, roomName)),
            _.startsWith(roomName, 'zenkit_room_useractivities_')
              ? _.forEach(privateState.currentRooms, function (activeRoom) {
                  _.startsWith(activeRoom, 'zenkit_room_list_') &&
                    _.endsWith(activeRoom, '_activities') &&
                    (privateState = leaveRoomInternally(privateState, activeRoom))
                })
              : _.startsWith(roomName, 'zenkit_room_userlistentries_') &&
                _.forEach(privateState.currentRooms, function (activeRoom) {
                  _.startsWith(activeRoom, 'zenkit_room_list_') &&
                    _.endsWith(activeRoom, '_listentries') &&
                    (privateState = leaveRoomInternally(privateState, activeRoom))
                }),
            SocketService.writeRooms(ROOM_ACTIONS_LEAVE, roomName))
      },
      requestRoom: function (room, id, postfix) {
        if (_.isNil(id)) console.error('SocketService.requestRoom: Invalid id ' + id)
        else {
          var roomName = buildRoomName(room, id, postfix)
          SocketService.requestRoomByName(roomName)
        }
      },
      releaseRoom: function (room, id, postfix) {
        var roomName = buildRoomName(room, id, postfix)
        SocketService.releaseRoomByName(roomName)
      },
      getSparkId: function () {
        return !1 === privateState.isOpen
          ? Promise.resolve(void 0)
          : new Promise(function (resolve, reject) {
              var cancelled = !1,
                timeout = setTimeout(function () {
                  resolve(void 0), (cancelled = !0)
                }, 50)
              primus.id(function (id) {
                cancelled || (resolve(id), clearTimeout(timeout))
              })
            })
      },
      reconnect: function () {
        setIsOpen(!1), primus.end(), SocketService.startup()
      },
      startup: function () {
        pretendToBeOffline ||
          (!1 === privateState.isOpen &&
            !1 === privateState.openRequestPending &&
            ((privateState.openRequestPending = !0), primus.open()))
      },
      close: function () {
        !0 === privateState.isOpen && (primus.end(), setIsOpen(!1))
      },
    }),
      connectionChecker.onConnectionChanged(function (connection) {
        connection.onLine === privateState.isOpen || privateState.openRequestPending || SocketService.reconnect()
      })
    var sendDisconnectTimeout,
      debouncedReJoinRooms = _.debounce(
        function () {
          privateState.isOpen &&
            _.forEach(privateState.currentRooms, function (name) {
              SocketService.writeRooms(ROOM_ACTIONS_JOIN, name)
            })
        },
        1e4,
        { leading: !0, trailing: !0 },
      ),
      onSocketConnectionStatusChanged =
        ((sendDisconnectTimeout = null),
        function (isConnected) {
          !1 !== privateState.connectionWasOpenAtLeastOnce &&
            (isConnected
              ? sendDisconnectTimeout
                ? (clearTimeout(sendDisconnectTimeout), (sendDisconnectTimeout = null))
                : emitEvent({ type: 'reconnected' })
              : (sendDisconnectTimeout = setTimeout(function () {
                  emitEvent({ type: 'disconnected' }), (sendDisconnectTimeout = null)
                }, 3e4)))
        })
    return (
      SocketService.on('online', function () {
        onSocketConnectionStatusChanged(!0), debouncedReJoinRooms()
      }),
      SocketService.on('offline', function () {
        onSocketConnectionStatusChanged(!1)
      }),
      SocketService
    )
  }),
  (self.initSocketHandlers = function (dependencies) {
    var _ = dependencies.lodash,
      inMemoryDb = (dependencies.Promise, dependencies.inMemoryDb),
      optimisticState = dependencies.optimisticState,
      resources = dependencies.resources,
      resourceHandlers = dependencies.resourceHandlers,
      publishTypes = dependencies.publishTypes,
      SocketService = dependencies.SocketService,
      emitEvent = dependencies.emitEvent,
      events = dependencies.events,
      workerErrors = dependencies.workerErrors,
      commands = dependencies.commands,
      CompactJSON = dependencies.CompactJSON,
      globals = dependencies.globals,
      messageActionToPublishTypeMap = {
        create: publishTypes.ADDED,
        update: publishTypes.CHANGED,
        delete: publishTypes.REMOVED,
        sort: publishTypes.REORDERED,
        activate: publishTypes.ACTIVATED,
      }
    SocketService.on('socket::push::minimal-entries', function (event) {
      var message = event.detail
      if (!1 !== _.isString(message.data) && 'update' === message.action) {
        var user = message.user,
          listId = message.listIdentifier,
          minimalListEntries = CompactJSON.parse(message.data)
        optimisticState.onMinimalListEntriesArrived({
          user,
          listId,
          listEntries: minimalListEntries,
          publishChanges: !0,
        })
      }
    }),
      SocketService.on('socket::push::entries', function (event) {
        var message = event.detail,
          listEntries = message.data,
          listId = message.listIdentifier,
          user = message.user
        null !== listEntries
          ? optimisticState.onListEntriesArrived({ user, listId, listEntries, publishChanges: !0 })
          : resourceHandlers.LIST_ENTRIES.publish({
              identifiers: { listId },
              publishType: publishTypes.CHANGED,
              resource: null,
              user,
            })
      }),
      SocketService.on('socket::push::activities', function (event) {
        var message = event.detail,
          listId = message.listIdentifier,
          workspaceId = message.workspaceIdentifier,
          activities = message.data
        if (listId) {
          if (null === activities)
            return void resourceHandlers.ACTIVITIES.publish({
              identifiers: { listId },
              publishType: publishTypes.CHANGED,
              resource: null,
            })
          if (_.isEmpty(activities)) return
          optimisticState.onListActivitiesArrived({ listId, listActivities: activities, publishChanges: !0 })
        } else if (workspaceId) {
          if (_.isEmpty(activities)) return
          optimisticState.onWorkspaceActivitiesArrived({
            workspaceId,
            workspaceActivities: activities,
            publishChanges: !0,
          })
        }
      }),
      SocketService.on('socket::push::views', function (event) {
        var message = event.detail
        if (!1 !== _.includes(['create', 'update', 'delete'], message.action)) {
          var listViews = message.data,
            listId = message.listIdentifier,
            user = message.user
          optimisticState.onListViewsArrived({ user, listId, listViews, publishChanges: !0 })
        }
      }),
      SocketService.on('socket::push::lists', function (event) {
        var message = event.detail,
          list = message.data
        _.isEmpty(list) ||
          inMemoryDb
            .update(resources.LIST, { id: list.id }, 'delete' === message.action ? null : list)
            .then(function () {
              return resourceHandlers.LIST.publish({
                identifiers: { id: list.id },
                publishType: messageActionToPublishTypeMap[message.action],
                resource: list,
                user: message.user,
                sortData: message.sortData,
                beforeAnchorId: message.beforeAnchorId,
              })
            })
            .catch(_.noop)
      }),
      SocketService.on('socket::push::workspace', function (event) {
        var message = event.detail,
          workspace = message.data
        _.isEmpty(workspace) ||
          inMemoryDb
            .update(resources.WORKSPACE, { id: workspace.id }, 'delete' === message.action ? null : workspace)
            .then(function () {
              return resourceHandlers.WORKSPACE.publish({
                identifiers: { id: workspace.id },
                publishType: messageActionToPublishTypeMap[message.action],
                resource: workspace,
                user: message.user,
              })
            })
            .catch(_.noop)
      }),
      SocketService.on('socket::push::listelements', function (event) {
        var message = event.detail,
          listElements = message.data
        if (!_.isEmpty(listElements)) {
          var listId = _.head(listElements).listId
          return inMemoryDb
            .updateMultiple(
              _.map(listElements, function (listElement) {
                return {
                  resource: resources.LIST_ELEMENT,
                  identifiers: { listId: listElement.listId, uuid: listElement.uuid },
                  value: 'delete' === message.action ? null : listElement,
                }
              }),
            )
            .then(function () {
              return resourceHandlers.LIST_ELEMENTS.publish({
                identifiers: { listId },
                publishType: messageActionToPublishTypeMap[message.action],
                resource: listElements,
                user: message.user,
              })
            })
            .catch(_.noop)
        }
      }),
      SocketService.on('socket::push::categories-sort-order', function (event) {
        var message = event.detail,
          sortOrder = message.data,
          identifiers = _.pick(sortOrder, ['listId', 'elementId'])
        return inMemoryDb.update(resources.CATEGORY_SORT_ORDER, identifiers, sortOrder).then(function () {
          resourceHandlers.CATEGORY_SORT_ORDER.publish({
            resource: sortOrder,
            identifiers,
            publishType: publishTypes.CHANGED,
            user: message.user,
          })
        })
      }),
      SocketService.on('socket::push::tags', function (event) {
        var message = event.detail,
          tags = resourceHandlers.USER_TAGS.get(inMemoryDb.getData(), {}),
          newTags = _.sortBy(_.unionBy([message.data], tags, 'uuid'), 'sortOrder')
        return inMemoryDb.update(resources.USER_TAGS, {}, newTags).tap(function () {
          resourceHandlers.USER_TAGS.publish({
            resource: resourceHandlers.USER_TAGS.get(optimisticState.getData(), {}),
            identifiers: {},
            publishType: publishTypes.CHANGED,
          })
        })
      }),
      SocketService.on('socket::push::tagAssignments', function (event) {
        var updatedTagAssignments = event.detail.data
        if (null !== updatedTagAssignments) {
          var tagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(inMemoryDb.getData(), {}),
            newTagAssignments = _.unionBy(updatedTagAssignments, tagAssignments, 'uuid')
          return inMemoryDb.update(resources.USER_TAG_ASSIGNMENTS, {}, newTagAssignments).tap(function () {
            resourceHandlers.USER_TAG_ASSIGNMENTS.publish({
              resource: resourceHandlers.USER_TAG_ASSIGNMENTS.get(optimisticState.getData(), {}),
              identifiers: {},
              publishType: publishTypes.CHANGED,
            })
          })
        }
      }),
      SocketService.on('socket::sync::organization', function (event) {
        var organizationId = event.detail.organizationId
        !1 !== _.isFinite(organizationId)
          ? emitEvent({ name: events.legacyEvent, args: ['zenkit-organization-changed', organizationId] })
          : console.warn('Invalid organization socket update')
      }),
      SocketService.on('socket::push::workspace', function (event) {
        var message = event.detail
        emitEvent({ name: events.legacyEvent, args: ['socket::push::workspace-users', message] })
      }),
      SocketService.on('socket::push::notifications', function (event) {
        var message = event.detail,
          notifications = message.data
        null !== notifications
          ? ('create' !== message.action && 'update' !== message.action) ||
            ((notifications = _.filter(notifications, { appType: globals.appType })),
            _.isEmpty(notifications) ||
              optimisticState
                .onNotificationsArrived({ notifications })
                .then(function () {
                  emitEvent({ name: events.legacyEvent, args: ['socket::push::notifications', message] })
                })
                .catch(_.noop))
          : commands.syncMinimalNewNotifications()
      }),
      SocketService.on('socket::push::subscriptions', function (event) {
        var message = event.detail
        emitEvent({ name: events.legacyEvent, args: ['socket::push::subscriptions', message] })
      }),
      SocketService.on('socket::push::reminders', function (event) {
        var message = event.detail,
          reminder = message.data
        resourceHandlers.REMINDERS.publish({
          identifiers: {},
          resource: reminder ? [reminder] : null,
          publishType: messageActionToPublishTypeMap[message.action],
        })
      }),
      SocketService.on('socket::push::recurrence-rule', function (event) {
        var message = event.detail,
          rule = message.data,
          publishType = messageActionToPublishTypeMap[message.action],
          user = message.user
        publishType !== publishTypes.ADDED
          ? publishType !== publishTypes.REMOVED ||
            emitEvent({ name: events.legacyEvent, args: ['zenkit-recurrence-rule-removed', rule, user] })
          : emitEvent({ name: events.legacyEvent, args: ['zenkit-recurrence-rule-added', rule, user] })
      })
    var syncAccesses = commands.syncAccesses
    SocketService.on('socket::sync::accesses', function () {
      var currentUser = resourceHandlers.CURRENT_USER.get(inMemoryDb.getData(), {})
      if (!_.isNil(currentUser)) return syncAccesses()
    }),
      SocketService.on('socket::push::list-accesses', function (event) {
        var message = event.detail
        optimisticState.onAccessChanged({
          resource: resources.ACCESSES_PER_LIST,
          identifiers: { listId: message.listIdentifier },
          publishType: messageActionToPublishTypeMap[message.action],
          access: message.data.access,
          users: message.data.users,
          groups: message.data.groups,
        })
      }),
      SocketService.on('socket::push::workspace-accesses', function (event) {
        var message = event.detail
        optimisticState.onAccessChanged({
          resource: resources.ACCESSES_PER_WORKSPACE,
          identifiers: { workspaceId: message.workspaceIdentifier },
          publishType: messageActionToPublishTypeMap[message.action],
          access: message.data.access,
          users: message.data.users,
          groups: message.data.groups,
        })
      }),
      SocketService.on('socket::sync::me', function () {
        commands.syncCurrentUser()
      })
    var debouncedSyncAllUserResources = _.debounce(commands.syncAllUserResources, 6e4, { leading: !0, trailing: !0 })
    SocketService.on('reconnected', function () {
      return (
        emitEvent({ name: events.reconnectSucceeded }),
        inMemoryDb.initialLoad.then(function () {
          var currentUser = resourceHandlers.CURRENT_USER.get(inMemoryDb.getData(), {})
          if (!_.isNil(currentUser)) return debouncedSyncAllUserResources()
        })
      )
    }),
      SocketService.on('disconnected', function () {
        emitEvent({ name: events.reconnectFailed })
      }),
      SocketService.on('error', function (event) {
        var error = event.detail
        emitEvent({
          name: events.workerError,
          error: { type: workerErrors.SOCKET_ERROR, name: error.name, message: error.message || error.description },
        })
      }),
      SocketService.on('socket::broadcast::workspace', function (event) {
        var message = event.detail
        return emitEvent({
          name: events.broadcastMessage,
          resource: resources.WORKSPACE,
          identifiers: { id: message.workspaceId },
          message: message.data,
        })
      }),
      SocketService.on('socket::broadcast::list', function (event) {
        var message = event.detail
        return emitEvent({
          name: events.broadcastMessage,
          resource: resources.LIST,
          identifiers: { id: message.listId },
          message: message.data,
        })
      }),
      SocketService.on('socket::broadcast::entry', function (event) {
        var message = event.detail
        return emitEvent({
          name: events.broadcastMessage,
          resource: resources.LIST_ENTRY,
          identifiers: { listId: message.listId, uuid: message.listEntryUuid },
          message: message.data,
        })
      })
  }),
  (self.makeConnectionChecker = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      globals = dependencies.globals,
      utils = dependencies.utils,
      urlUtils = dependencies.urlUtils,
      emitEvent = dependencies.emitEvent,
      events = dependencies.events,
      connectionChecker = {},
      connectionChangeFns = utils.ChangeCallbackMixin()
    connectionChecker.onConnectionChanged = connectionChangeFns.onChange
    var isDevelopment = 'development' === globals.environment,
      pretendToBeOffline = globals.pretendToBeOffline,
      state = {
        onLine: !pretendToBeOffline && (!!isDevelopment || navigator.onLine),
        status: pretendToBeOffline ? -1 : isDevelopment || navigator.onLine ? 200 : -1,
      }
    connectionChecker.isOnline = function () {
      return state.onLine
    }
    var currentConnectionCheckId = 0,
      recursiveConnectionCheck = function recursiveConnectionCheck(params) {
        return (
          (params = _.defaults(params || {}, { failedAttempts: 0 })),
          (function () {
            if (pretendToBeOffline) return Promise.resolve(!1)
            var url = urlUtils.getAbsolutePath('/alive?nostatus=true')
            return Promise.resolve(fetch(url))
              .timeout(5e3)
              .catch(function (err) {
                return { status: err instanceof Promise.TimeoutError ? 408 : -1, ok: !1 }
              })
              .then(function (response) {
                return (
                  (state.onLine = response.ok),
                  (state.status = response.status),
                  connectionChangeFns.triggerChange(state),
                  state.onLine
                )
              })
          })().then(function (onLine) {
            var failedAttempts, delay
            params.connectionCheckId === currentConnectionCheckId &&
              (onLine
                ? ((failedAttempts = 0), (delay = 15e3))
                : ((delay = 200 * Math.pow(2, params.failedAttempts)),
                  (delay = Math.min(delay, 15e3)),
                  (failedAttempts = params.failedAttempts + 1)),
              setTimeout(function () {
                params.connectionCheckId === currentConnectionCheckId &&
                  recursiveConnectionCheck({ failedAttempts, connectionCheckId: params.connectionCheckId })
              }, delay))
          })
        )
      }
    return (
      (connectionChecker.checkConnection = function () {
        recursiveConnectionCheck({ connectionCheckId: (currentConnectionCheckId += 1) })
      }),
      connectionChecker.checkConnection(),
      connectionChecker.onConnectionChanged(function (connection) {
        emitEvent({ name: events.onlineStatusChanged, onLine: connection.onLine, status: connection.status })
      }),
      connectionChecker
    )
  }),
  (self.makeEntriesUtils = function (dependencies) {
    var zenkitFetch = dependencies.zenkitFetch,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      entriesUtils = {
        loadEntryFromServerUsingAllId: function (listId, listEntryAllId) {
          var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId', {
            listAllId: listId,
            entryAllId: listEntryAllId,
          })
          return zenkitFetch
            .get(url)
            .tap(function (listEntry) {
              return optimisticState.onListEntriesArrived({ listId, listEntries: [listEntry], publishChanges: !1 })
            })
            .then(function (listEntry) {
              return (
                resourceHandlers.LIST_ENTRY.get(optimisticState.getData(), {
                  uuid: listEntry.uuid,
                  listId: listEntry.listId,
                }) || listEntry
              )
            })
        },
      }
    return entriesUtils
  }),
  (self.makeCurrentUserLoader = function (dependencies) {
    var Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      inMemoryDb = dependencies.inMemoryDb,
      resourceHandlers = dependencies.resourceHandlers,
      resources = dependencies.resources,
      zenkitFetch = dependencies.zenkitFetch,
      publishTypes = dependencies.publishTypes,
      utils = dependencies.utils,
      optimisticState = dependencies.optimisticState,
      moment = dependencies.moment,
      zenkitIndexedDB = dependencies.zenkitIndexedDB,
      currentUserLoader = {},
      resource = resources.CURRENT_USER,
      resourceHandler = resourceHandlers[resource]
    ;(currentUserLoader.load = function (identifiers) {
      var whenUserLoadedFromServer = zenkitFetch.get('auth/currentuser').tap(function (user) {
        return inMemoryDb.update(resources.CURRENT_USER, identifiers, user)
      })
      return (function (identifiers) {
        return inMemoryDb.initialLoad
          .then(function () {
            return resourceHandler.get(inMemoryDb.getData(), identifiers)
          })
          .tap(function (user) {
            if (_.isNil(user)) return Promise.reject(ZenkitErrorCodes.NOT_FOUND)
          })
      })()
        .tap(function () {
          whenUserLoadedFromServer.tap(function (user) {
            resourceHandler.publish({ identifiers: {}, publishType: publishTypes.CHANGED, resource: user })
          })
        })
        .catch(_.constant(whenUserLoadedFromServer))
    }),
      (currentUserLoader.loadMatchingAccesses = function (identifiers, params) {
        var url = zenkitFetch.buildUrl('users/me/matching-accesses/:userAllId', { userAllId: params.userId })
        return zenkitFetch.get(url)
      }),
      (currentUserLoader.loadNewsletterStatus = function () {
        return zenkitFetch.get('users/me/newsletterStatus')
      }),
      (currentUserLoader.loadUserCalendarView = function () {
        return zenkitFetch.get('users/me/calendar/preferred')
      }),
      (currentUserLoader.loadUserTagsView = function () {
        return zenkitFetch.get('users/me/views/tags/preferred')
      }),
      (currentUserLoader.loadUserAssignmentsView = function () {
        return zenkitFetch.get('users/me/views/user-assignments/preferred')
      })
    var CREATED_IN = ZenkitControlsShared.activityTypes.CREATED_IN,
      loadActivitiesFromOfflineStorage = function (identifiers, params) {
        return inMemoryDb
          .loadAllActivities()
          .then(function (activities) {
            var query = _.toLower(params.query),
              includeWorkspaceActivities =
                _.isEmpty(params.created_in) || _.includes(params.created_in, CREATED_IN.WORKSPACE),
              includeListActivities = _.isEmpty(params.created_in) || _.includes(params.created_in, CREATED_IN.LIST),
              includeListEntryActivities =
                _.isEmpty(params.created_in) || _.includes(params.created_in, CREATED_IN.LIST_ENTRY)
            return _.chain(activities)
              .filter(function (activity) {
                return (
                  (!1 !== _.isEmpty(query) || !1 !== _.includes(_.toLower(activity.message), query)) &&
                  (params.filter !== ZenkitControlsShared.activityTypes.FILTER.COMMENTS ||
                    activity.type === ZenkitControlsShared.activityTypes.TYPE.COMMENT) &&
                  (params.filter !== ZenkitControlsShared.activityTypes.FILTER.SYSTEM_MESSAGES ||
                    activity.type !== ZenkitControlsShared.activityTypes.TYPE.COMMENT) &&
                  (activity.created_in === CREATED_IN.WORKSPACE
                    ? includeWorkspaceActivities
                    : activity.created_in === CREATED_IN.LIST
                    ? includeListActivities
                    : activity.created_in === CREATED_IN.LIST_ENTRY && includeListEntryActivities)
                )
              })
              .orderBy(function (activity) {
                return new Date(activity.created_at).valueOf()
              }, 'desc')
              .value()
          })
          .then(function (activities) {
            var total = _.size(activities),
              end = params.limit + params.skip
            return { activities: _.slice(activities, params.skip, end), thereAreMoreResults: total > end, total }
          })
      }
    currentUserLoader.loadActivities = function (identifiers, params) {
      return (params = utils.validateParameters(
        params,
        _.defaults(
          { query: { type: ['string', 'undefined'] }, created_in: { type: ['array', 'null'], default: null } },
          utils.getValidationForActivityLoader(),
        ),
      )).loadFromCache
        ? loadActivitiesFromOfflineStorage(0, params)
        : zenkitFetch
            .get('users/me/activities', {
              query: {
                filter: params.filter,
                skip: params.skip,
                limit: params.limit,
                created_in: _.isEmpty(params.created_in) ? void 0 : params.created_in,
              },
            })
            .catch(function () {
              return loadActivitiesFromOfflineStorage(0, params)
            })
    }
    currentUserLoader.loadActivityEnrichments = function (identifiers, params) {
      var whenActivitiesLoaded = Promise.resolve([])
      return (
        params.workspaceId
          ? (whenActivitiesLoaded = inMemoryDb
              .ensureWorkspaceStateIsLoaded({ workspaceId: params.workspaceId })
              .then(function () {
                return resourceHandlers.ACTIVITIES_PER_WORKSPACE.get(optimisticState.getData(), {
                  workspaceId: params.workspaceId,
                })
              }))
          : params.listId &&
            ((whenActivitiesLoaded = inMemoryDb.ensureListStateIsLoaded({ listId: params.listId }).then(function () {
              return resourceHandlers.ACTIVITIES.get(optimisticState.getData(), { listId: params.listId })
            })),
            params.listEntryUUID &&
              (whenActivitiesLoaded = whenActivitiesLoaded.then(function (activities) {
                return _.filter(activities, { listEntryUUID: params.listEntryUUID })
              }))),
        whenActivitiesLoaded.then(function (activities) {
          return _.chain(activities)
            .flatMap('enrichments')
            .compact()
            .filter(function (enrichment) {
              return _.includes(params.enrichmentTypes, enrichment.type)
            })
            .orderBy(function (enrichment) {
              return moment(enrichment.created_at).valueOf()
            }, 'desc')
            .value()
        })
      )
    }
    return (
      (currentUserLoader.loadLatestActivities = function (identifiers, params) {
        if (!1 === zenkitIndexedDB.isSupported())
          return zenkitFetch.post('latest-activities', {
            listIds: params.listIds,
            workspaceIds: params.workspaceIds,
            filter: params.filter,
          })
        var filter,
          matchesFilter =
            ((filter = params.filter),
            function (activity) {
              return filter === ZenkitControlsShared.activityTypes.FILTER.COMMENTS
                ? activity.type === ZenkitControlsShared.activityTypes.TYPE.COMMENT
                : filter !== ZenkitControlsShared.activityTypes.FILTER.SYSTEM_MESSAGES ||
                    activity.type !== ZenkitControlsShared.activityTypes.TYPE.COMMENT
            }),
          whenListIdsDetermined = inMemoryDb.initialLoad.then(function () {
            var workspacesById = _.keyBy(resourceHandlers.WORKSPACES_WITH_LISTS.get(inMemoryDb.getData(), {}), 'id'),
              workspaces = _.pick(workspacesById, params.workspaceIds),
              listIdsOfWorkspaces = _.flatMap(workspaces, function (workspace) {
                return _.map(workspace.lists, 'id')
              })
            return _.union(params.listIds, listIdsOfWorkspaces)
          }),
          byList = whenListIdsDetermined
            .then(function (listIds) {
              return Promise.map(listIds, function (listId) {
                var storeConfig = zenkitIndexedDB.OBJECT_STORES.ACTIVITIES
                return zenkitIndexedDB
                  .getFirstItemFromIndex({
                    storeConfig,
                    index: storeConfig.indices.created_at,
                    identifier: listId,
                    direction: 'desc',
                    accepts: matchesFilter,
                  })
                  .then(function (comment) {
                    return [listId, comment]
                  })
              })
            })
            .then(_.fromPairs),
          byListAndEntry = Promise.map(params.listEntryIdentifiers, function (identifiers) {
            var storeConfig = zenkitIndexedDB.OBJECT_STORES.ACTIVITIES
            return zenkitIndexedDB
              .getFirstItemFromIndex({
                storeConfig,
                index: storeConfig.indices.created_at,
                identifier: identifiers.listId,
                direction: 'desc',
                accepts: function (activity) {
                  return activity.listEntryUUID === identifiers.uuid && matchesFilter(activity)
                },
              })
              .then(function (activity) {
                return { identifiers, activity }
              })
          }).then(function (wrappedActivities) {
            return _.reduce(
              wrappedActivities,
              function (byListAndEntry, container) {
                return (
                  _.setWith(
                    byListAndEntry,
                    [container.identifiers.listId, container.identifiers.uuid],
                    container.activity,
                    Object,
                  ),
                  byListAndEntry
                )
              },
              {},
            )
          }),
          byWorkspace = Promise.map(params.workspaceIds, function (workspaceId) {
            var storeConfig = zenkitIndexedDB.OBJECT_STORES.ACTIVITIES_PER_WORKSPACE
            return zenkitIndexedDB
              .getFirstItemFromIndex({
                storeConfig,
                index: storeConfig.indices.created_at,
                identifier: workspaceId,
                direction: 'desc',
                accepts: matchesFilter,
              })
              .then(function (comment) {
                return [workspaceId, comment]
              })
          }).then(_.fromPairs)
        return Promise.props({ listIds: whenListIdsDetermined, byList, byWorkspace, byListAndEntry }).then(function (
          container,
        ) {
          return _.reduce(
            container.listIds,
            function (container, listId) {
              var latestForList = container.byList[listId]
              if (latestForList) {
                var latestForWorkspace = container.byWorkspace[latestForList.workspaceId]
                ;(_.isNil(latestForWorkspace) ||
                  moment(latestForList.created_at).isAfter(latestForWorkspace.created_at)) &&
                  (container.byWorkspace[latestForList.workspaceId] = latestForList)
              }
              return container
            },
            container,
          )
        })
      }),
      currentUserLoader
    )
  }),
  (self.makeUserLoader = function (dependencies) {
    var _ = dependencies.lodash,
      zenkitFetch = dependencies.zenkitFetch,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      userLoader = {
        load: function (identifiers) {
          return optimisticState.initialLoad
            .then(function () {
              return resourceHandlers.USER.get(optimisticState.getData(), identifiers)
            })
            .then(function (cachedUser) {
              if (!1 === _.isNil(cachedUser)) return cachedUser
              var url = zenkitFetch.buildUrl('users/:userAllId/public', { userAllId: identifiers.id })
              return zenkitFetch.get(url)
            })
        },
      }
    return userLoader
  }),
  (self.makeUsersLoader = function (_ref22) {
    var { zenkitFetch, inMemoryDb, optimisticState, resourceHandlers, resources, connectionChecker, utils } = _ref22,
      usersLoader = {},
      loadUsersFromOfflineStorage = function () {
        return optimisticState.initialLoad.then(function () {
          return resourceHandlers.USERS.get(optimisticState.getData(), {})
        })
      }
    ;(usersLoader.load = loadUsersFromOfflineStorage),
      (usersLoader.search = function (identifiers, params) {
        return !1 === connectionChecker.isOnline()
          ? loadUsersFromOfflineStorage().then(function (users) {
              var currentUser = resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {})
              return _.filter(users, function (user) {
                return (
                  (!1 !== params.includeSelf || user.id !== currentUser.id) &&
                  (_.isEmpty(params.query) || _.includes(_.toLower(user.fullname), _.toLower(params.query)))
                )
              })
            })
          : zenkitFetch.get('users', { query: params }).then(function (data) {
              var users = resourceHandlers.USERS.get(inMemoryDb.getData(), {})
              return inMemoryDb.update(resources.USERS, {}, _.unionBy(data.users, users, 'id')), data.users
            })
      })
    var loadSuggestionsForAssignmentsViewFromOfflineStorage = function (_ref23) {
      var { limit, skip } = _ref23
      return loadUsersFromOfflineStorage()
        .then(allCachedUsers => {
          var currentUser = resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {})
          return currentUser ? _.reject(allCachedUsers, { id: currentUser.id }) : allCachedUsers
        })
        .then(users => {
          var sorted = _.orderBy(users, [user => _.toLower(user.fullname), 'id'])
          return _.slice(sorted, skip, limit + skip)
        })
    }
    usersLoader.loadSuggestionsForAssignmentsView = function (identifiers, params) {
      return !1 === connectionChecker.isOnline()
        ? loadSuggestionsForAssignmentsViewFromOfflineStorage(params)
        : zenkitFetch
            .get('users/me/views/user-assignments/suggested-users', { query: params })
            .then(function (suggestedUsers) {
              var users = resourceHandlers.USERS.get(inMemoryDb.getData(), {})
              return inMemoryDb.update(resources.USERS, {}, _.unionBy(suggestedUsers, users, 'id')), suggestedUsers
            })
            .catch(loadSuggestionsForAssignmentsViewFromOfflineStorage)
    }
    var loadAllCollaborators = function loadAllCollaborators(params) {
      return (
        (params = utils.validateParameters(params, {
          limit: { type: 'number', default: 500 },
          skip: { type: 'number', default: 0 },
          allUsers: { type: 'array', default: [] },
        })),
        usersLoader
          .loadSuggestionsForAssignmentsView({}, { limit: params.limit, skip: params.skip })
          .then(function (users) {
            var needToLoadMore = _.size(users) === params.limit,
              allUsers = _.unionBy(params.allUsers, users, 'id')
            return needToLoadMore
              ? loadAllCollaborators({ limit: params.limit, skip: params.skip + params.limit, allUsers })
              : allUsers
          })
      )
    }
    return (usersLoader.loadAllCollaborators = () => loadAllCollaborators()), usersLoader
  }),
  (self.makeElementcategoriesLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      optimisticState = dependencies.optimisticState,
      elementcategoriesModel = {},
      resourceHandler = dependencies.resourceHandlers.ELEMENTCATEGORIES
    return (
      (elementcategoriesModel.load = function (identifiers) {
        return optimisticState.initialLoad
          .then(function () {
            return resourceHandler.get(optimisticState.getData(), identifiers)
          })
          .then(function (elementcategories) {
            return _.isNil(elementcategories)
              ? Promise.reject(ZenkitErrorCodes.NOT_FOUND)
              : _.map(elementcategories, function (ec) {
                  return _.defaults(
                    {
                      translateId: 'ELEMENTCATEGORIES.' + _.toUpper(ec.name),
                      explanationTranslateId: 'ELEMENTCATEGORIES_EXPLANATIONS.' + _.toUpper(ec.name),
                    },
                    ec,
                  )
                })
          })
      }),
      elementcategoriesModel
    )
  }),
  (self.makeAccessesPerListLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      resources = dependencies.resources,
      resourceHandlers = dependencies.resourceHandlers,
      optimisticState = dependencies.optimisticState,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      loadFromMemory = function (identifiers) {
        var listId = identifiers.listId
        return inMemoryDb.ensureListStateIsLoaded({ listId }).then(function () {
          var accesses = resourceHandlers.ACCESSES_PER_LIST.get(optimisticState.getData(), { listId })
          return _.isNil(accesses) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : accesses
        })
      },
      accessesPerListLoader = {}
    return (
      (accessesPerListLoader.load = function (identifiers) {
        return optimisticState.initialLoad.then(function () {
          return optimisticState.isListAvailableOffline(identifiers)
            ? loadFromMemory(identifiers)
            : (function (identifiers) {
                var listId = identifiers.listId,
                  url = zenkitFetch.buildUrl('lists/:listAllId/accesses', { listAllId: listId })
                return zenkitFetch.get(url).then(function (data) {
                  return inMemoryDb.ensureListStateIsLoaded({ listId }).then(function () {
                    var cachedUsers = resourceHandlers.USERS.get(inMemoryDb.getData(), {})
                    inMemoryDb.update(resources.USERS, {}, _.unionBy(data.users, cachedUsers, 'id'))
                    var cachedGroups = resourceHandlers.GROUPS.get(inMemoryDb.getData(), {})
                    return (
                      inMemoryDb.update(resources.GROUPS, {}, _.unionBy(data.groups, cachedGroups, 'id')),
                      inMemoryDb.update(resources.ACCESSES_PER_LIST, { listId }, data.accesses),
                      data.accesses
                    )
                  })
                })
              })(identifiers).catch(function () {
                return loadFromMemory(identifiers)
              })
        })
      }),
      accessesPerListLoader
    )
  }),
  (self.makeAccessesPerWorkspaceLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      resources = dependencies.resources,
      resourceHandlers = dependencies.resourceHandlers,
      optimisticState = dependencies.optimisticState,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      loadFromMemory = function (identifiers) {
        var workspaceId = identifiers.workspaceId
        return inMemoryDb.ensureWorkspaceStateIsLoaded({ workspaceId: identifiers.workspaceId }).then(function () {
          var accesses = resourceHandlers.ACCESSES_PER_WORKSPACE.get(optimisticState.getData(), { workspaceId })
          return _.isNil(accesses) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : accesses
        })
      },
      loader = {}
    return (
      (loader.load = function (identifiers) {
        return optimisticState.initialLoad.then(function () {
          return optimisticState.isWorkspaceAvailableOffline(identifiers)
            ? loadFromMemory(identifiers)
            : (function (identifiers) {
                var workspaceId = identifiers.workspaceId,
                  url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/accesses', { workspaceAllId: workspaceId })
                return zenkitFetch.get(url).then(function (data) {
                  return inMemoryDb.ensureWorkspaceStateIsLoaded({ workspaceId }).then(function () {
                    var users = resourceHandlers.USERS.get(inMemoryDb.getData(), {})
                    inMemoryDb.update(resources.USERS, {}, _.unionBy(data.users, users, 'id'))
                    var groups = resourceHandlers.GROUPS.get(optimisticState.getData(), {})
                    return (
                      inMemoryDb.update(resources.GROUPS, {}, _.unionBy(data.groups, groups, 'id')),
                      inMemoryDb.update(resources.ACCESSES_PER_WORKSPACE, { workspaceId }, data.accesses),
                      data.accesses
                    )
                  })
                })
              })(identifiers).catch(function () {
                return loadFromMemory(identifiers)
              })
        })
      }),
      loader
    )
  }),
  (self.makeAccessesPerOrganizationLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = (dependencies.utils, dependencies.Promise),
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      resources = dependencies.resources,
      resourceHandlers = dependencies.resourceHandlers,
      optimisticState = dependencies.optimisticState,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      loader = {}
    return (
      (loader.load = function (identifiers) {
        return (function (identifiers) {
          var organizationId = identifiers.organizationId
          return inMemoryDb.initialLoad.then(function () {
            var accesses = resourceHandlers.ACCESSES_PER_ORGANIZATION.get(optimisticState.getData(), { organizationId })
            return !1 === _.isNil(accesses) ? accesses : Promise.reject(ZenkitErrorCodes.NOT_FOUND)
          })
        })(identifiers).catch(function () {
          return (function (identifiers) {
            var organizationId = identifiers.organizationId,
              url = zenkitFetch.buildUrl('organizations/:organizationId/accesses', { organizationId })
            return zenkitFetch.get(url).then(function (data) {
              return inMemoryDb.initialLoad.then(function () {
                var users = resourceHandlers.USERS.get(inMemoryDb.getData(), {})
                inMemoryDb.update(resources.USERS, {}, _.unionBy(data.users, users, 'id'))
                var groups = resourceHandlers.GROUPS.get(optimisticState.getData(), {})
                return (
                  inMemoryDb.update(resources.GROUPS, {}, _.unionBy(data.groups, groups, 'id')),
                  inMemoryDb.update(resources.ACCESSES_PER_ORGANIZATION, { organizationId }, data.accesses),
                  data.accesses
                )
              })
            })
          })(identifiers)
        })
      }),
      loader
    )
  }),
  (self.makeElementsLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      SocketService = dependencies.SocketService,
      zenkitFetch = dependencies.zenkitFetch,
      socketTimeoutMs = dependencies.socketTimeoutMs,
      elementsLoader = {},
      resourceHandler = resourceHandlers.LIST_ELEMENTS,
      loadFromServer = function (optimisticState, identifiers) {
        var url = zenkitFetch.buildUrl('/lists/:listAllId/elements', { listAllId: identifiers.listId })
        return zenkitFetch.get(url).then(function (listElements) {
          return (
            optimisticState.onListElementsArrived({ listId: identifiers.listId, listElements, publishChanges: !1 }),
            listElements
          )
        })
      },
      loadFromOfflineStorage = function (optimisticState, identifiers) {
        return optimisticState.ensureListStateIsLoaded(identifiers).then(function () {
          var cachedListElementsByUUID = resourceHandler.get(optimisticState.getData(), identifiers)
          return _.isNil(cachedListElementsByUUID)
            ? Promise.reject(ZenkitErrorCodes.NOT_FOUND)
            : _.chain(cachedListElementsByUUID)
                .filter(function (listElement) {
                  return _.isNil(listElement.deprecated_at)
                })
                .sortBy('sortOrder')
                .value()
        })
      }
    return (
      (elementsLoader.load = function (identifiers) {
        var roomName = resourceHandler.getSocketRoom(optimisticState.getData(), identifiers),
          roomWasAlreadyActive = roomName && SocketService.isRoomActive(roomName)
        return (
          roomName &&
            (SocketService.requestRoomByName(roomName),
            setTimeout(function () {
              SocketService.releaseRoomByName(roomName)
            }, socketTimeoutMs)),
          optimisticState.isListAvailableOffline(identifiers) || roomWasAlreadyActive
            ? loadFromOfflineStorage(optimisticState, identifiers).catch(function () {
                return loadFromServer(optimisticState, identifiers)
              })
            : loadFromServer(optimisticState, identifiers).catch(function () {
                return loadFromOfflineStorage(optimisticState, identifiers)
              })
        )
      }),
      (elementsLoader.loadDeprecated = function (identifiers) {
        var url = zenkitFetch.buildUrl('/lists/:listAllId/deprecated-elements', { listAllId: identifiers.listId })
        return zenkitFetch.get(url)
      }),
      elementsLoader
    )
  }),
  (self.makeElementLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      elementsLoader = dependencies.elementsLoader,
      elementLoader = {
        load: function (identifiers) {
          return elementsLoader.load({ listId: identifiers.listId }).then(function (elements) {
            var element = _.find(elements, { uuid: identifiers.uuid })
            return _.isNil(element) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : element
          })
        },
      }
    return elementLoader
  }),
  (self.makeEntriesLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      moment = dependencies.moment,
      utils = dependencies.utils,
      zenkitFetch = dependencies.zenkitFetch,
      resourceHandlers = dependencies.resourceHandlers,
      resourceHandler = resourceHandlers.LIST_ENTRIES,
      optimisticState = dependencies.optimisticState,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      entriesUtils = dependencies.entriesUtils,
      entryLoader = dependencies.entryLoader,
      connectionChecker = dependencies.connectionChecker,
      inMemoryDb = dependencies.inMemoryDb,
      resources = dependencies.resources,
      entriesLoader = {
        loadEntryUsingAllId: function (identifiers, params) {
          return (
            (params = utils.validateParameters(params, { listEntryAllId: { type: ['string', 'number'] } })),
            optimisticState
              .ensureListStateIsLoaded({ listId: identifiers.listId })
              .then(function () {
                var allId,
                  listEntriesMap = resourceHandler.get(optimisticState.getData(), { listId: identifiers.listId })
                return _.find(
                  listEntriesMap,
                  ((allId = params.listEntryAllId),
                  function (resource) {
                    return allId === resource.id || allId === resource.shortId || allId === resource.uuid
                  }),
                )
              })
              .then(function (cachedListEntryThatMightBeOutdated) {
                return cachedListEntryThatMightBeOutdated
                  ? entryLoader.load({ listId: identifiers.listId, uuid: cachedListEntryThatMightBeOutdated.uuid })
                  : entriesUtils.loadEntryFromServerUsingAllId(identifiers.listId, params.listEntryAllId)
              })
          )
        },
      }
    entriesLoader.loadViaUUID = function (identifiers, params) {
      params = utils.validateParameters(params, {
        uuids: { type: 'array' },
        allowDeprecated: { type: 'boolean', default: !1 },
      })
      return optimisticState.initialLoad.then(function () {
        return !optimisticState.isListAvailableOffline(identifiers) ||
          (!1 !== params.allowDeprecated && !1 !== connectionChecker.isOnline())
          ? ((url = zenkitFetch.buildUrl('lists/:listAllId/entriesViaUUIDs', { listAllId: identifiers.listId })),
            zenkitFetch
              .get(url, { query: { uuids: params.uuids, allowDeprecated: params.allowDeprecated } })
              .then(function (listEntries) {
                return (
                  optimisticState.onListEntriesArrived({ listId: identifiers.listId, listEntries, publishChanges: !1 }),
                  listEntries
                )
              }))
          : (function (identifiers, params) {
              return optimisticState.ensureListStateIsLoaded(identifiers).then(function () {
                var listEntryByUUID = resourceHandler.get(optimisticState.getData(), identifiers)
                return _.reduce(
                  params.uuids,
                  function (listEntries, uuid) {
                    var listEntry = listEntryByUUID[uuid]
                    return (
                      listEntry &&
                        (params.allowDeprecated || _.isNil(listEntry.deprecated_at)) &&
                        listEntries.push(listEntry),
                      listEntries
                    )
                  },
                  [],
                )
              })
            })(identifiers, params)
        var url
      })
    }
    ;(entriesLoader.search = function (identifiers, params) {
      params = utils.validateParameters(params, {
        elementId: { type: 'number' },
        query: { type: 'string' },
        limit: { type: 'number', default: 5 },
      })
      return optimisticState.initialLoad.then(function () {
        return optimisticState.isListAvailableOffline(identifiers)
          ? (function (identifiers, params) {
              return optimisticState.ensureListStateIsLoaded(identifiers).then(function () {
                var data = optimisticState.getData(),
                  listEntriesMap = resourceHandler.get(data, identifiers)
                return _.isNil(listEntriesMap)
                  ? []
                  : _.chain(listEntriesMap)
                      .filter(function (listEntry) {
                        return (
                          !1 !== _.isNil(listEntry.deprecated_at) &&
                          (!!_.isEmpty(params.query) ||
                            utils.matchesSearchQuery(
                              listEntry,
                              params.query,
                              ZenkitControlsShared.filterTermModi.CONTAINS,
                              resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }),
                              resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
                            ))
                        )
                      })
                      .sort(function (a, b) {
                        var sortOrderA = parseFloat(a.sortOrder),
                          sortOrderB = parseFloat(b.sortOrder)
                        return sortOrderA === sortOrderB ? a.id - b.id : sortOrderA - sortOrderB
                      })
                      .take(params.limit)
                      .value()
              })
            })(identifiers, params)
          : ((url = zenkitFetch.buildUrl('lists/:listAllId/entries/search', { listAllId: identifiers.listId })),
            zenkitFetch
              .get(url, { query: { limit: params.limit, query: params.query, elementId: params.elementId } })
              .tap(function (listEntries) {
                optimisticState.onListEntriesArrived({ listId: identifiers.listId, listEntries, publishChanges: !1 })
              }))
        var url
      })
    }),
      (entriesLoader.applyFilter = function (identifiers, params) {
        if (
          ((params = utils.validateParameters(params, {
            listEntries: { type: 'array' },
            filter: { type: ['object', 'null'], default: null },
          })),
          utils.isFilterEmpty(params.filter) || _.isEmpty(params.listEntries))
        )
          return Promise.resolve(params.listEntries)
        var cachedElementcategories = resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {}),
          cachedElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), {
            listId: identifiers.listId,
          })
        if (cachedElementcategories && cachedElementsByUuid)
          return Promise.resolve(
            utils.filterListEntries({
              listEntries: params.listEntries,
              filter: params.filter,
              listElementsByUuid: cachedElementsByUuid,
              elementcategories: cachedElementcategories,
              currentUser: resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {}),
              userTagAssignments: resourceHandlers.USER_TAG_ASSIGNMENTS.get(optimisticState.getData(), {}),
            }),
          )
        var listEntryIds = _.compact(_.map(params.listEntries, 'id'))
        if (_.isEmpty(listEntryIds)) return Promise.resolve([])
        var url = zenkitFetch.buildUrl('lists/:listAllId/filter/listEntryIds', { listAllId: identifiers.listId })
        return zenkitFetch.post(url, { listEntryIds, filter: params.filter }).then(function (filteredListEntryIds) {
          return _.map(filteredListEntryIds, function (id) {
            return _.find(params.listEntries, { id })
          })
        })
      })
    entriesLoader.tryToMatchFilter = function (identifiers, params) {
      params = utils.validateParameters(params, { listEntry: { type: 'object' }, filter: { type: 'object' } })
      var elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {}),
        listElementsMap = resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), identifiers),
        textfieldEc = _.find(elementcategories, { name: 'Textfield' }),
        modiToSetValueFor = [
          ZenkitControlsShared.filterTermModi.EQUALS,
          ZenkitControlsShared.filterTermModi.CONTAINS,
          ZenkitControlsShared.filterTermModi.GREATER_OR_EQUAL,
          ZenkitControlsShared.filterTermModi.LESS_OR_EQUAL,
          ZenkitControlsShared.filterTermModi.STARTS_WITH,
          ZenkitControlsShared.filterTermModi.ENDS_WITH,
        ],
        unsupportedElementcategories = ['Files'],
        filterTerms = utils.getAllFilterTerms(params.filter)
      return _.reduce(
        filterTerms,
        function (listEntry, term) {
          var modusServerName = term.modus || ZenkitControlsShared.filterTermModi.EQUALS
          if (_.isNil(term.elementId)) return listEntry
          if (term.elementId === ZenkitControlsShared.allElementsFilterId) {
            var firstTextfieldWithoutAValue = _.find(listElementsMap, function (listElement) {
              return (
                listElement.elementcategory === textfieldEc.id &&
                !1 !== _.isEmpty(listEntry[listElement.uuid + '_text'])
              )
            })
            return (
              firstTextfieldWithoutAValue &&
                (_.includes(modiToSetValueFor, modusServerName) && !1 === term.negated
                  ? (listEntry[firstTextfieldWithoutAValue.uuid + '_text'] = term.text)
                  : modusServerName === ZenkitControlsShared.filterTermModi.EMPTY &&
                    !0 === term.negated &&
                    (listEntry[firstTextfieldWithoutAValue.uuid + '_text'] = 'Not empty')),
              listEntry
            )
          }
          var element = _.find(listElementsMap, { id: term.elementId }),
            elementcategory = _.find(elementcategories, { id: element.elementcategory }),
            primaryColumn = _.findKey(elementcategory.businessDataDefinition, { primary: !0 })
          if (!1 === _.isEmpty(listEntry[element.uuid + '_' + primaryColumn])) return listEntry
          if ('Subentries' === elementcategory.name)
            return _.isBoolean(term.connected) && (listEntry[element.uuid + '_connected'] = term.connected), listEntry
          if (_.includes(modiToSetValueFor, modusServerName) && !1 === term.negated) {
            var filterKey = utils.getFilterKeyForTerm(term, listElementsMap, elementcategories),
              primaryKey = element.uuid + '_' + primaryColumn
            if ('Checkbox' === elementcategory.name) listEntry[primaryKey] = 'selected' === term[filterKey]
            else if ('Date' === elementcategory.name)
              listEntry[primaryKey] = (function (params) {
                var term = params.term,
                  filterKey = params.filterKey,
                  dateTimeFilterModi = ZenkitControlsShared.dateTimeFilterModi,
                  modiToSetTodayFor = [
                    dateTimeFilterModi.TODAY,
                    dateTimeFilterModi.THIS_YEAR,
                    dateTimeFilterModi.THIS_MONTH,
                    dateTimeFilterModi.THIS_WEEK,
                    dateTimeFilterModi.FILLED,
                  ],
                  modus = term[filterKey]
                return _.includes(modiToSetTodayFor, modus)
                  ? moment().toISOString()
                  : modus === dateTimeFilterModi.YESTERDAY || modus === dateTimeFilterModi.OVERDUE
                  ? moment().subtract(1, 'day').toISOString()
                  : modus === dateTimeFilterModi.LAST_WEEK
                  ? moment().subtract(1, 'week').toISOString()
                  : modus === dateTimeFilterModi.LAST_MONTH
                  ? moment().subtract(1, 'month').toISOString()
                  : modus === dateTimeFilterModi.LAST_YEAR
                  ? moment().subtract(1, 'year').toISOString()
                  : modus === dateTimeFilterModi.TOMORROW
                  ? moment().add(1, 'day').toISOString()
                  : modus === dateTimeFilterModi.NEXT_WEEK
                  ? moment().add(1, 'week').toISOString()
                  : modus === dateTimeFilterModi.NEXT_MONTH
                  ? moment().add(1, 'month').toISOString()
                  : modus === dateTimeFilterModi.NEXT_YEAR
                  ? moment().add(1, 'year').toISOString()
                  : modus === dateTimeFilterModi.CUSTOM
                  ? moment(term.dateFrom || term.dateTo).toISOString()
                  : null
              })({ term, filterKey })
            else if (!1 === _.includes(unsupportedElementcategories, elementcategory.name)) {
              var onlyUseFirst =
                ('Categories' === elementcategory.name && !1 === _.get(element, ['elementData', 'multiple'])) ||
                (_.isArray(term[filterKey]) && modusServerName === ZenkitControlsShared.filterTermModi.CONTAINS)
              listEntry[primaryKey] = onlyUseFirst ? _.take(term[filterKey], 1) : term[filterKey]
            }
            'Categories' === elementcategory.name
              ? (listEntry[primaryKey + '_sort'] = _.compact(
                  _.map(listEntry[primaryKey], function (id) {
                    return _.find(_.get(element, ['elementData', 'predefinedCategories']), { id })
                  }),
                ))
              : 'Persons' === elementcategory.name
              ? (listEntry[primaryKey + '_sort'] = _.compact(
                  _.map(listEntry[primaryKey], function (id) {
                    return resourceHandlers.USER.get(optimisticState.getData(), { id })
                  }),
                ))
              : 'References' === elementcategory.name &&
                (listEntry[primaryKey + '_sort'] = _.compact(
                  _.map(listEntry[primaryKey], function (uuid) {
                    return resourceHandlers.LIST_ENTRY.get(optimisticState.getData(), {
                      listId: element.elementData.childList.id,
                      uuid,
                    })
                  }),
                ))
          } else
            modusServerName === ZenkitControlsShared.filterTermModi.EMPTY &&
              !0 === term.negated &&
              element.elementcategory === textfieldEc.id &&
              (listEntry[element.uuid + '_text'] = 'Not empty')
          return listEntry
        },
        params.listEntry,
      )
    }
    ;(entriesLoader.load = function (identifiers, params) {
      if (
        (!1 ===
          (params = utils.validateParameters(params, {
            filter: { type: ['object', 'null'], default: null },
            limit: { type: 'number', default: 100 },
            skip: { type: 'number', default: 0 },
            orderBy: { type: ['array', 'object', 'null'], default: null },
            allowDeprecated: { type: 'boolean', default: !1 },
            onlyDeprecated: { type: 'boolean', default: !1 },
            excludeListEntryUUIDs: { type: ['array', 'undefined'] },
            loadFromCache: { type: 'boolean', default: !1 },
          })).onlyDeprecated &&
          optimisticState.isListAvailableOffline(identifiers)) ||
        params.loadFromCache
      )
        return (function (identifiers, params) {
          return optimisticState.ensureListStateIsLoaded(identifiers).then(function () {
            var orderBy,
              listEntries = _.values(resourceHandlers.LIST_ENTRIES.get(optimisticState.getData(), identifiers)),
              listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), identifiers),
              listElementsById = _.keyBy(listElementsByUuid, 'id'),
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {})
            !1 === params.allowDeprecated
              ? (listEntries = _.filter(listEntries, function (listEntry) {
                  return _.isNil(listEntry.deprecated_at)
                }))
              : !0 === params.onlyDeprecated &&
                (listEntries = _.filter(listEntries, function (listEntry) {
                  return !1 === _.isNil(listEntry.deprecated_at)
                })),
              _.isArray(params.excludeListEntryUUIDs) &&
                (listEntries = _.filter(listEntries, function (listEntry) {
                  return !1 === _.includes(params.excludeListEntryUUIDs, listEntry.uuid)
                })),
              (listEntries = utils.filterListEntries({
                listEntries,
                filter: params.filter,
                listElementsByUuid,
                elementcategories,
                currentUser: resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {}),
                userTagAssignments: resourceHandlers.USER_TAG_ASSIGNMENTS.get(optimisticState.getData(), {}),
              })),
              (orderBy = _.isArray(params.orderBy)
                ? params.orderBy
                : _.isPlainObject(params.orderBy)
                ? [params.orderBy]
                : []).push({ column: 'id', direction: 'asc' })
            var sortingHandler = utils.getListEntrySortingHandler({
              orderBy,
              listElements: _.values(listElementsById),
              elementcategories,
            })
            return _.chain(listEntries)
              .orderBy(sortingHandler.functions, sortingHandler.directions)
              .drop(params.skip)
              .take(params.limit)
              .value()
          })
        })(identifiers, params)
      var url = zenkitFetch.buildUrl('lists/:listAllId/entries/filter', { listAllId: identifiers.listId })
      return zenkitFetch
        .post(url, {
          filter: params.filter,
          limit: params.limit,
          skip: params.skip,
          orderBy: params.orderBy,
          allowDeprecated: params.allowDeprecated,
          onlyDeprecated: params.onlyDeprecated,
          excludeListEntryUUIDs: params.excludeListEntryUUIDs,
        })
        .tap(function (listEntries) {
          optimisticState.onListEntriesArrived({ listId: identifiers.listId, listEntries, publishChanges: !1 })
        })
    }),
      (entriesLoader.count = function (identifiers, params) {
        return (
          (params = utils.validateParameters(params, {
            filter: { type: ['object', 'null'], default: null },
            allowDeprecated: { type: 'boolean', default: !1 },
          })),
          optimisticState.initialLoad.then(function () {
            if (optimisticState.isListAvailableOffline(identifiers))
              return buildTotalAndFilteredTotalForList(identifiers, params)
            var url = zenkitFetch.buildUrl('lists/:listAllId/entries/filter/total', { listAllId: identifiers.listId })
            return zenkitFetch.post(url, { filter: params.filter, allowDeprecated: params.allowDeprecated })
          })
        )
      })
    entriesLoader.loadForListView = function (identifiers, params) {
      params = utils.validateParameters(params, {
        filter: { type: ['object', 'null'], default: null },
        skip: { type: 'number', customCheck: _.isInteger, default: 0 },
        limit: { type: 'number', customCheck: _.isInteger, default: 100 },
        sort: { type: ['object', 'undefined'] },
        taskData: { type: ['object', 'null', 'undefined'] },
      })
      return optimisticState.initialLoad.then(function () {
        return optimisticState.isListAvailableOffline(identifiers)
          ? (function (identifiers, params) {
              return optimisticState.ensureListStateIsLoaded(identifiers).then(function () {
                var countDataPerGroup,
                  listEntries = _.filter(
                    resourceHandlers.LIST_ENTRIES.get(optimisticState.getData(), identifiers),
                    function (listEntry) {
                      return _.isNil(listEntry.deprecated_at)
                    },
                  ),
                  filtereredListEntries = utils.filterListEntries({
                    listEntries,
                    filter: params.filter,
                    listElementsByUuid: resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), {
                      listId: identifiers.listId,
                    }),
                    elementcategories: resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {}),
                    currentUser: resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {}),
                    userTagAssignments: resourceHandlers.USER_TAG_ASSIGNMENTS.get(optimisticState.getData(), {}),
                  })
                if (
                  ((filtereredListEntries = _.sortBy(filtereredListEntries, function (listEntry) {
                    return parseFloat(listEntry.sortOrder)
                  })),
                  !1 === _.isNil(params.taskData))
                ) {
                  countDataPerGroup = { todo: { total: 0, filteredTotal: 0 }, done: { total: 0, filteredTotal: 0 } }
                  var taskElementKey = params.taskData.listElementKey,
                    doneCategoryId = params.taskData.done.id
                  ;(filtereredListEntries = _.sortBy(filtereredListEntries, function (listEntry) {
                    return _.head(listEntry[taskElementKey]) === doneCategoryId ? 1 : 0
                  })),
                    (countDataPerGroup = _.reduce(
                      listEntries,
                      function (countDataPerGroup, listEntry) {
                        return (
                          _.head(listEntry[taskElementKey]) === doneCategoryId
                            ? (countDataPerGroup.done.total += 1)
                            : (countDataPerGroup.todo.total += 1),
                          countDataPerGroup
                        )
                      },
                      countDataPerGroup,
                    )),
                    (countDataPerGroup = _.reduce(
                      filtereredListEntries,
                      function (countDataPerGroup, listEntry) {
                        return (
                          _.head(listEntry[taskElementKey]) === doneCategoryId
                            ? (countDataPerGroup.done.filteredTotal += 1)
                            : (countDataPerGroup.todo.filteredTotal += 1),
                          countDataPerGroup
                        )
                      },
                      countDataPerGroup,
                    ))
                }
                return {
                  listEntries: _.take(_.drop(filtereredListEntries, params.skip), params.limit),
                  countData: { total: _.size(listEntries), filteredTotal: _.size(filtereredListEntries) },
                  countDataPerGroup,
                }
              })
            })(identifiers, params)
          : ((url = zenkitFetch.buildUrl('lists/:listAllId/entries/filter/list', { listAllId: identifiers.listId })),
            zenkitFetch
              .post(url, {
                filter: params.filter,
                skip: params.skip,
                limit: params.limit,
                sort: params.sort,
                taskStyle: !1 === _.isNil(params.taskData),
              })
              .tap(function (container) {
                optimisticState.onListEntriesArrived({
                  listId: identifiers.listId,
                  listEntries: container.listEntries,
                  publishChanges: !1,
                })
              }))
        var url
      })
    }
    var buildKanbanViewData = function (identifiers, params) {
      return optimisticState.ensureListStateIsLoaded(identifiers).then(function () {
        var optimisticStateData = optimisticState.getData(),
          listJS = resourceHandlers.LIST.get(optimisticStateData, { id: identifiers.listId }),
          listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), {
            listId: identifiers.listId,
          }),
          elementsById = _.keyBy(listElementsByUuid, 'id'),
          elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(optimisticStateData, {}),
          categorySortOrdersPerList = resourceHandlers.CATEGORY_SORT_ORDERS_PER_LIST.get(
            optimisticStateData,
            identifiers,
          ),
          elementX = elementsById[params.elementIdX],
          elementcategoriesByName = _.keyBy(elementcategories, 'name'),
          elementXIsCategory = elementX.elementcategory === elementcategoriesByName.Categories.id,
          categorySortOrder = _.find(categorySortOrdersPerList, { elementId: params.elementIdX }),
          sortedCategoryIdsX = _.get(categorySortOrder, ['sortedCategoryIds']) || []
        if (!1 === elementXIsCategory) {
          var listAccesses = resourceHandlers.ACCESSES_PER_LIST.get(optimisticStateData, identifiers),
            workspaceAccesses =
              listJS.visibility === ZenkitControlsShared.listVisibilityTypes.LIST_AND_WORKSPACE_MEMBERS
                ? resourceHandlers.ACCESSES_PER_WORKSPACE.get(optimisticStateData, { workspaceId: listJS.workspaceId })
                : [],
            idsFromAccesses = _.chain(listAccesses)
              .concat(workspaceAccesses)
              .filter('userId')
              .uniqBy('userId')
              .map(function (access) {
                return [access.userId]
              })
              .value()
          sortedCategoryIdsX = _.unionBy(sortedCategoryIdsX || [], idsFromAccesses, _.toString)
        }
        var listEntries = _.filter(
            resourceHandlers.LIST_ENTRIES.get(optimisticState.getData(), identifiers),
            function (listEntry) {
              return _.isNil(listEntry.deprecated_at)
            },
          ),
          filtereredListEntries = utils.filterListEntries({
            listEntries,
            filter: params.filter,
            listElementsByUuid,
            elementcategories: resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {}),
            currentUser: resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {}),
            userTagAssignments: resourceHandlers.USER_TAG_ASSIGNMENTS.get(optimisticState.getData(), {}),
          })
        if (_.some([listJS, elementX, elementcategories, listEntries], _.isNil)) throw ZenkitErrorCodes.NOT_FOUND
        var validElementcategoryIds = [elementcategoriesByName.Persons.id, elementcategoriesByName.Categories.id]
        if (!1 === _.includes(validElementcategoryIds, elementX.elementcategory)) throw ZenkitErrorCodes.BAD_REQUEST
        var elementXKey = elementXIsCategory ? elementX.uuid + '_categories' : elementX.uuid + '_persons'
        _.isArray(params.orderBy) && params.orderBy.push({ column: 'id', direction: 'asc' })
        var innerSortedMultipleCategories,
          sortingHandler = utils.getListEntrySortingHandler({
            orderBy: params.orderBy,
            listElements: _.values(listElementsByUuid),
            elementcategories,
          }),
          groupAndSort = function (listEntries) {
            return _.chain(listEntries)
              .orderBy(sortingHandler.functions, sortingHandler.directions)
              .groupBy(function (listEntry) {
                var value = listEntry[elementXKey]
                return _.isEmpty(value) ? '_' : _.join(value, '-')
              })
              .value()
          },
          sumAggregation = function (listEntries, aggregateElementKey) {
            return _.reduce(
              listEntries,
              function (sum, listEntry) {
                return sum + (listEntry[aggregateElementKey] || 0)
              },
              0,
            )
          },
          groupedListEntries = groupAndSort(listEntries),
          filteredGroupedListEntries = groupAndSort(filtereredListEntries),
          categoryCombinationsToAdd = [],
          countData = _.reduce(
            groupedListEntries,
            function (countData, group, idsAsString) {
              var filteredGroup = filteredGroupedListEntries[idsAsString],
                size = _.size(group),
                filteredSize = _.size(filteredGroup),
                groupCountData = { total: size, filteredTotal: filteredSize },
                ids = '_' === idsAsString ? [] : _.map(_.split(idsAsString, '-'), Number)
              if (_.size(ids) > 1) {
                var foundInSortedIds = _.find(sortedCategoryIdsX, function (arr) {
                  return _.isEqual(_.orderBy(arr), _.orderBy(ids))
                })
                _.isNil(foundInSortedIds) && categoryCombinationsToAdd.push(ids)
              }
              return (
                (groupCountData[elementXKey] = ids),
                countData.totalPerCell.push(groupCountData),
                countData.totalPerColumn.push(groupCountData),
                (countData.total += size),
                (countData.filteredTotal += filteredSize),
                countData
              )
            },
            { total: 0, filteredTotal: 0, totalPerSection: [], totalPerColumn: [], totalPerCell: [] },
          )
        ;(innerSortedMultipleCategories = _.invokeMap(categoryCombinationsToAdd, 'sort', function (a, b) {
          return sortedCategoryIdsX.indexOf([a]) - sortedCategoryIdsX.indexOf([b])
        })).sort(function (a, b) {
          if (a.length !== b.length) return a.length - b.length
          for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return a[i] - b[i]
        }),
          (sortedCategoryIdsX = _.chain(sortedCategoryIdsX)
            .reject(function (idsArray) {
              return _.size(idsArray) > 1 && _.isEmpty(_.get(groupedListEntries, [_.join(idsArray, '-')]))
            })
            .concat(innerSortedMultipleCategories)
            .value())
        var aggregationData = (function () {
          var aggregationData = { aggregationsPerCell: [], aggregationsPerColumn: [], aggregationsPerSection: [] }
          if (_.isNil(params.aggregateParams)) return aggregationData
          var aggregateElement = elementsById[params.aggregateParams.elementId]
          if (_.isNil(aggregateElement) || aggregateElement.elementcategory !== elementcategoriesByName.Number.id)
            return console.warn('Aggregation field not found.'), aggregationData
          if (params.aggregateParams.aggregateModus !== ZenkitControlsShared.aggegrateModi.SUM)
            return (
              console.warn('Aggregation mode not supported.', params.aggregateParams.aggregateModus), aggregationData
            )
          var aggregateElementKey = aggregateElement.uuid + '_number'
          return _.reduce(
            groupedListEntries,
            function (aggregationData, group, idsAsString) {
              var filteredGroup = filteredGroupedListEntries[idsAsString],
                groupAggregationData = {
                  aggregation: sumAggregation(group, aggregateElementKey),
                  filteredAggregation: sumAggregation(filteredGroup, aggregateElementKey),
                },
                ids = '_' === idsAsString ? [] : _.map(_.split(idsAsString, '-'), Number)
              return (
                (groupAggregationData[elementXKey] = ids),
                aggregationData.aggregationsPerCell.push(groupAggregationData),
                aggregationData.aggregationsPerColumn.push(groupAggregationData),
                aggregationData
              )
            },
            aggregationData,
          )
        })()
        return {
          kanbanData: _.flatMap(filteredGroupedListEntries, function (group) {
            return _.take(_.drop(group, params.skipPerCategory), params.limitPerCategory)
          }),
          elementX,
          elementY: null,
          kanbanCountData: countData,
          kanbanAggregationData: aggregationData,
          kanbanSortedCategoryIdsX: sortedCategoryIdsX,
          kanbanSortedCategoryIdsY: [],
        }
      })
    }
    entriesLoader.loadForKanbanView = function (identifiers, params) {
      params = utils.validateParameters(params, {
        filter: { type: ['object', 'null'], default: null },
        skipPerCategory: { type: 'number', customCheck: _.isInteger, default: 0 },
        limitPerCategory: { type: 'number', customCheck: _.isInteger, default: 100 },
        elementIdX: { type: 'number', customCheck: _.isInteger },
        elementIdY: { type: ['number', 'null'], default: null },
        aggregateParams: { type: ['object', 'null'], default: null },
        orderBy: { type: ['array', 'null'], default: null },
      })
      return optimisticState.initialLoad.then(function () {
        return optimisticState.isListAvailableOffline(identifiers) && _.isNil(params.elementIdY)
          ? buildKanbanViewData(identifiers, params)
          : ((url = zenkitFetch.buildUrl('lists/:listAllId/entries/filter/kanban', { listAllId: identifiers.listId })),
            zenkitFetch
              .post(url, {
                filter: params.filter,
                skipPerCategory: params.skipPerCategory,
                limitPerCategory: params.limitPerCategory,
                elementIdX: params.elementIdX,
                elementIdY: params.elementIdY,
                aggregateParams: params.aggregateParams,
                orderBy: params.orderBy,
              })
              .then(function (container) {
                return (
                  optimisticState.onListEntriesArrived({
                    listId: identifiers.listId,
                    listEntries: container.kanbanData,
                    publishChanges: !1,
                  }),
                  inMemoryDb.update(
                    resources.CATEGORY_SORT_ORDER,
                    { listId: identifiers.listId, elementId: params.elementIdX },
                    {
                      listId: identifiers.listId,
                      elementId: params.elementIdX,
                      sortedCategoryIds: container.kanbanSortedCategoryIdsX,
                    },
                  ),
                  params.elementIdY &&
                    inMemoryDb.update(
                      resources.CATEGORY_SORT_ORDER,
                      { listId: identifiers.listId, elementId: params.elementIdY },
                      {
                        listId: identifiers.listId,
                        elementId: params.elementIdY,
                        sortedCategoryIds: container.kanbanSortedCategoryIdsY,
                      },
                    ),
                  container
                )
              })
              .catch(function (err) {
                throw (console.log(err), err)
              }))
        var url
      })
    }
    entriesLoader.loadAggregationsForKanbanView = function (identifiers, params) {
      return (
        (params = utils.validateParameters(params, {
          filter: { type: ['object', 'null'], default: null },
          elementIdX: { type: 'number', customCheck: _.isInteger },
          elementIdY: { type: ['number', 'null'], default: null },
          aggregateParams: { type: ['object', 'null'], default: null },
          orderBy: { type: ['object', 'array', 'null'], default: null },
        })),
        optimisticState.initialLoad.then(function () {
          if (optimisticState.isListAvailableOffline(identifiers) && _.isNil(params.elementIdY))
            return (function (identifiers, params) {
              return buildKanbanViewData(identifiers, params).then(function (result) {
                return _.pick(result, ['kanbanAggregationData', 'kanbanCountData'])
              })
            })(identifiers, params)
          var url = zenkitFetch.buildUrl('lists/:listAllId/entries/filter/kanban-aggregations', {
            listAllId: identifiers.listId,
          })
          return zenkitFetch.post(url, {
            filter: params.filter,
            elementIdX: params.elementIdX,
            elementIdY: params.elementIdY,
            aggregateParams: params.aggregateParams,
          })
        })
      )
    }
    var makeAggregationReducerModusTable = function (elementcategories, listEntries, aggregateSettings) {
      var tableViewNumberAggregations = ZenkitControlsShared.tableViewNumberAggregations,
        tableViewAggregations = ZenkitControlsShared.tableViewAggregations,
        ecMap = _.keyBy(elementcategories, 'id')
      return function (aggregations, listElement) {
        var aggregationId = aggregateSettings[listElement.uuid],
          ec = _.find(resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {}), {
            id: listElement.elementcategory,
          }),
          aggregatedValue = 0,
          values = _.map(listEntries, function (listEntry) {
            return listEntry[
              utils.getPrimaryColumn({ listElement, elementcategory: ecMap[listElement.elementcategory] })
            ]
          })
        return (
          _.includes(['Number', 'Formula'], ec.name)
            ? ((aggregationId = aggregationId || tableViewNumberAggregations.SUM.id) ===
              tableViewNumberAggregations.MIN.id
                ? (aggregatedValue = _.min(values))
                : aggregationId === tableViewNumberAggregations.MAX.id
                ? (aggregatedValue = _.max(values))
                : aggregationId === tableViewNumberAggregations.AVG.id
                ? (aggregatedValue = _.isEmpty(values) ? 0 : _.sum(values) / _.size(values))
                : aggregationId === tableViewNumberAggregations.SUM.id
                ? (aggregatedValue = _.sum(values))
                : console.warn('Unknown number aggregation:', aggregationId),
              (aggregations[listElement.uuid + '_number_agg'] = aggregatedValue))
            : ((aggregationId = aggregationId || tableViewAggregations.NOT_EMPTY.id) === tableViewAggregations.EMPTY.id
                ? (aggregatedValue = _.size(_.filter(values, _.isEmpty)))
                : aggregationId === tableViewAggregations.NOT_EMPTY.id
                ? (aggregatedValue = _.size(_.reject(values, _.isEmpty)))
                : console.warn('Unknown aggregation:', aggregationId),
              (aggregations[listElement.uuid + '_agg'] = aggregatedValue)),
          aggregations
        )
      }
    }
    entriesLoader.loadAggregationsForTableView = function (identifiers, params) {
      return (
        (params = utils.validateParameters(params, {
          aggregate: { type: 'object', default: {} },
          filter: { type: ['object', 'null'], default: null },
          allowDeprecated: { type: 'boolean', default: !1 },
          onlyDeprecated: { type: 'boolean', default: !1 },
          excludeListEntryUUIDs: { type: ['array', 'undefined'] },
          loadFromCache: { type: 'boolean', default: !1 },
        })),
        optimisticState.initialLoad.then(function () {
          if (
            (!1 === params.onlyDeprecated && optimisticState.isListAvailableOffline(identifiers)) ||
            params.loadFromCache
          )
            return (function (identifiers, params) {
              return optimisticState.ensureListStateIsLoaded(identifiers).then(function () {
                var listEntries = _.values(resourceHandlers.LIST_ENTRIES.get(optimisticState.getData(), identifiers)),
                  listElementsByUUID = resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), identifiers) || [],
                  elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {})
                !1 === params.allowDeprecated
                  ? (listEntries = _.filter(listEntries, function (listEntry) {
                      return _.isNil(listEntry.deprecated_at)
                    }))
                  : !0 === params.onlyDeprecated &&
                    (listEntries = _.filter(listEntries, function (listEntry) {
                      return !1 === _.isNil(listEntry.deprecated_at)
                    })),
                  _.isArray(params.excludeListEntryUUIDs) &&
                    !1 === _.isEmpty(params.excludeListEntryUUIDs) &&
                    (listEntries = _.filter(listEntries, function (listEntry) {
                      return !1 === _.includes(params.excludeListEntryUUIDs, listEntry.uuid)
                    }))
                var filteredListEntries = utils.filterListEntries({
                    listEntries,
                    filter: params.filter,
                    listElementsByUuid: resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), {
                      listId: identifiers.listId,
                    }),
                    elementcategories,
                    currentUser: resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {}),
                    userTagAssignments: resourceHandlers.USER_TAG_ASSIGNMENTS.get(optimisticState.getData(), {}),
                  }),
                  total = _.size(listEntries),
                  filteredTotal = _.size(filteredListEntries),
                  aggregateBefore = _.reduce(
                    listElementsByUUID,
                    makeAggregationReducerModusTable(elementcategories, listEntries, params.aggregate),
                    {},
                  ),
                  aggregateAfter = aggregateBefore
                params.filter &&
                  !1 === utils.isFilterEmpty(params.filter) &&
                  (aggregateAfter = _.reduce(
                    listElementsByUUID,
                    makeAggregationReducerModusTable(elementcategories, filteredListEntries, params.aggregate),
                    {},
                  ))
                var aggregatePercent = _.reduce(
                  aggregateBefore,
                  function (aggregatePercent, value, key) {
                    var valueBefore = parseFloat(value) || 0,
                      valueAfter = parseFloat(aggregateAfter[key] || 0),
                      valuePercent = 100
                    return (
                      0 !== valueBefore && (valuePercent = (valueAfter / valueBefore) * 100),
                      (aggregatePercent[key] = Math.round(100 * valuePercent) / 100),
                      aggregatePercent
                    )
                  },
                  {},
                )
                return { aggregateBefore, aggregateAfter, aggregatePercent, total, filteredTotal }
              })
            })(identifiers, params).tapCatch(function (err) {
              console.error('loadAggregationsForTableView', err)
            })
          var url = zenkitFetch.buildUrl('lists/:listAllId/entries/filter/table-aggregations', {
            listAllId: identifiers.listId,
          })
          return zenkitFetch.post(url, {
            aggregate: params.aggregate,
            filter: params.filter,
            allowDeprecated: params.allowDeprecated,
            onlyDeprecated: params.onlyDeprecated,
            excludeListEntryUUIDs: params.excludeListEntryUUIDs,
          })
        })
      )
    }
    var buildTotalAndFilteredTotalForList = function (identifiers, params) {
      return optimisticState.ensureListStateIsLoaded(identifiers).then(function () {
        var listEntries = _.values(resourceHandlers.LIST_ENTRIES.get(optimisticState.getData(), identifiers))
        !1 === params.allowDeprecated &&
          (listEntries = _.filter(listEntries, function (listEntry) {
            return _.isNil(listEntry.deprecated_at)
          }))
        var filteredListEntries = utils.filterListEntries({
          listEntries,
          filter: params.filter,
          listElementsByUuid: resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), {
            listId: identifiers.listId,
          }),
          elementcategories: resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {}),
          currentUser: resourceHandlers.CURRENT_USER.get(optimisticState.getData(), {}),
          userTagAssignments: resourceHandlers.USER_TAG_ASSIGNMENTS.get(optimisticState.getData(), {}),
        })
        return { total: _.size(listEntries), filteredTotal: _.size(filteredListEntries) }
      })
    }
    return entriesLoader
  }),
  (self.makeEntryLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      entriesUtils = dependencies.entriesUtils,
      utils = dependencies.utils,
      moment = dependencies.moment,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      entryLoader = {},
      loadFromOfflineStorage = function (identifiers) {
        return optimisticState.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
          var entriesMap = resourceHandlers.LIST_ENTRIES.get(optimisticState.getData(), { listId: identifiers.listId }),
            entry = _.get(entriesMap, identifiers.uuid)
          return _.isNil(entry) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : entry
        })
      }
    entryLoader.load = function (identifiers, params) {
      return optimisticState.initialLoad.then(function () {
        return optimisticState.isListAvailableOffline({ listId: identifiers.listId }) ||
          _.get(params, ['loadFromCache'])
          ? loadFromOfflineStorage(identifiers)
          : entriesUtils.loadEntryFromServerUsingAllId(identifiers.listId, identifiers.uuid).catch(function () {
              return loadFromOfflineStorage(identifiers)
            })
      })
    }
    var loadActivitiesFromOfflineStorage = function (identifiers, params) {
      return inMemoryDb.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
        var activitiesByUUID = resourceHandlers.ACTIVITIES.get(optimisticState.getData(), {
            listId: identifiers.listId,
          }),
          query = _.toLower(params.query)
        if (_.isNil(activitiesByUUID)) return Promise.reject(ZenkitErrorCodes.NOT_FOUND)
        var sortedActivities = _.chain(activitiesByUUID)
            .filter(function (activity) {
              return (
                (!1 !== _.isEmpty(query) || !1 !== _.includes(_.toLower(activity.message), query)) &&
                (params.filter !== ZenkitControlsShared.activityTypes.FILTER.COMMENTS ||
                  activity.type === ZenkitControlsShared.activityTypes.TYPE.COMMENT) &&
                (params.filter !== ZenkitControlsShared.activityTypes.FILTER.SYSTEM_MESSAGES ||
                  activity.type !== ZenkitControlsShared.activityTypes.TYPE.COMMENT) &&
                activity.listId === identifiers.listId &&
                activity.listEntryUUID === identifiers.uuid
              )
            })
            .orderBy(
              [
                function (activity) {
                  var created_at = activity.origin_created_at || activity.created_at
                  return moment(created_at).valueOf()
                },
                'id',
              ],
              ['desc', 'desc'],
            )
            .value(),
          total = _.size(sortedActivities)
        return {
          activities: _.take(_.drop(sortedActivities, params.skip), params.limit),
          thereAreMoreResults: total - params.skip > params.limit,
          total,
        }
      })
    }
    return (
      (entryLoader.loadActivities = function (identifiers, params) {
        return (
          (params = utils.validateParameters(
            params,
            _.defaults({ query: { type: ['string', 'undefined'] } }, utils.getValidationForActivityLoader()),
          )),
          optimisticState.initialLoad.then(function () {
            var resultIsCached = inMemoryDb.areListActivitiesAvailableOffline({
              listId: identifiers.listId,
              activitiesFilter: params.filter,
            })
            return params.loadFromCache || resultIsCached
              ? loadActivitiesFromOfflineStorage(identifiers, params)
              : (function (identifiers, params) {
                  var url = zenkitFetch.buildUrl('lists/:listAllId/entries/:entryAllId/activities', {
                    listAllId: identifiers.listId,
                    entryAllId: identifiers.uuid,
                  })
                  return zenkitFetch
                    .get(url, { query: { filter: params.filter, skip: params.skip, limit: params.limit } })
                    .tap(function (response) {
                      optimisticState.onListActivitiesArrived({
                        listId: identifiers.listId,
                        listActivities: response.activities,
                        publishChanges: !1,
                      })
                    })
                })(identifiers, params).catch(function () {
                  return loadActivitiesFromOfflineStorage(identifiers, params)
                })
          })
        )
      }),
      entryLoader
    )
  }),
  (self.makeListViewsLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      utils = dependencies.utils,
      zenkitFetch = dependencies.zenkitFetch,
      optimisticState = dependencies.optimisticState,
      inMemoryDb = dependencies.inMemoryDb,
      resourceHandlers = dependencies.resourceHandlers,
      resources = dependencies.resources,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      listViewsLoader = {},
      loadListViewsFromServer = function (identifiers) {
        var url = zenkitFetch.buildUrl('users/me/lists/:listAllId/views', { listAllId: identifiers.listId })
        return zenkitFetch.get(url).then(function (views) {
          return inMemoryDb.update(resources.VIEWS, identifiers, views), views
        })
      },
      loadViewsFromOfflineStorage = function (identifiers) {
        return inMemoryDb.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
          var cachedListViewsByUuid = resourceHandlers.VIEWS.get(optimisticState.getData(), identifiers)
          return _.isNil(cachedListViewsByUuid)
            ? Promise.reject(ZenkitErrorCodes.NOT_FOUND)
            : _.chain(cachedListViewsByUuid)
                .filter(function (view) {
                  return _.isNil(view.deprecated_at)
                })
                .sortBy('sortOrder')
                .value()
        })
      }
    listViewsLoader.load = function (identifiers) {
      return optimisticState.initialLoad.then(function () {
        return optimisticState.isListAvailableOffline({ listId: identifiers.listId })
          ? (function (identifiers) {
              return loadViewsFromOfflineStorage(identifiers).catch(function () {
                return loadListViewsFromServer(identifiers)
              })
            })(identifiers)
          : (function (identifiers) {
              return loadListViewsFromServer(identifiers).catch(function () {
                return loadViewsFromOfflineStorage(identifiers)
              })
            })(identifiers)
      })
    }
    var loadPreferredViewFromServer = function (identifiers, params) {
        var similarViewAllId,
          preferedViewUrl = zenkitFetch.buildUrl('users/me/lists/:listAllId/views/preferred', {
            listAllId: identifiers.listId,
          }),
          lastUsedViewUuid = resourceHandlers.LAST_USED_VIEW_UUID_PER_LIST.get(optimisticState.getData(), {
            listId: identifiers.listId,
          })
        return (
          params.similarViewAllId
            ? (similarViewAllId = params.similarViewAllId)
            : _.isNil(params.viewType) && (similarViewAllId = lastUsedViewUuid),
          zenkitFetch
            .get(preferedViewUrl, {
              query: {
                viewType: params.viewType,
                similarViewAllId,
                autoCreatePreferredViewType: params.autoCreatePreferredViewType,
              },
            })
            .catch(function (err) {
              var allCachedViewsByUUUID = resourceHandlers.VIEWS.get(optimisticState.getData(), {
                listId: identifiers.listId,
              })
              return _.head(_.values(allCachedViewsByUUUID)) || Promise.reject(err)
            })
        )
      },
      loadPreferredViewFromOfflineStorage = function (identifiers, params) {
        return inMemoryDb.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
          var cachedPreferedView,
            lastUsedViewUuid = resourceHandlers.LAST_USED_VIEW_UUID_PER_LIST.get(optimisticState.getData(), {
              listId: identifiers.listId,
            }),
            allCachedViewsByUUUID = resourceHandlers.VIEWS.get(optimisticState.getData(), {
              listId: identifiers.listId,
            })
          if (
            (!1 === _.isNil(allCachedViewsByUUUID) &&
              ('any' !== params.viewType
                ? (cachedPreferedView = _.find(allCachedViewsByUUUID, { type: params.viewType }))
                : params.similarViewAllId &&
                  (cachedPreferedView = _.find(allCachedViewsByUUUID, function (cachedView) {
                    return (
                      cachedView.id === params.similarViewAllId ||
                      cachedView.shortId === params.similarViewAllId ||
                      cachedView.uuid === params.similarViewAllId
                    )
                  })),
              _.isNil(cachedPreferedView) &&
                lastUsedViewUuid &&
                (cachedPreferedView = allCachedViewsByUUUID[lastUsedViewUuid])),
            _.isNil(cachedPreferedView))
          )
            return Promise.reject(ZenkitErrorCodes.NOT_FOUND)
          if (cachedPreferedView.id) {
            var preferedViewUrl = zenkitFetch.buildUrl('users/me/lists/:listAllId/views/preferred', {
              listAllId: identifiers.listId,
            })
            zenkitFetch.put(preferedViewUrl, { viewId: cachedPreferedView.id }).catch(_.noop)
          }
          return Promise.resolve(cachedPreferedView)
        })
      }
    return (
      (listViewsLoader.loadPreferred = function (identifiers, params) {
        return (
          (params = utils.validateParameters(params, {
            viewType: { type: ['string', 'number', 'undefined'] },
            similarViewAllId: { type: ['string', 'number', 'undefined'] },
            autoCreatePreferredViewType: { type: ['boolean', 'undefined'] },
          })),
          optimisticState.initialLoad
            .then(function () {
              return inMemoryDb.isListAvailableOffline({ listId: identifiers.listId })
                ? (function (identifiers, params) {
                    return loadPreferredViewFromOfflineStorage(identifiers, params)
                      .then(function (view) {
                        if (
                          'any' !== params.viewType &&
                          view.type !== params.viewType &&
                          params.autoCreatePreferredViewType
                        )
                          throw new Error('Preferred view type was not in cache.')
                        return view
                      })
                      .catch(function () {
                        return loadPreferredViewFromServer(identifiers, params)
                      })
                  })(identifiers, params)
                : (function (identifiers, params) {
                    return loadPreferredViewFromServer(identifiers, params).catch(function (err) {
                      return loadPreferredViewFromOfflineStorage(identifiers, params).catchReturn(Promise.reject(err))
                    })
                  })(identifiers, params)
            })
            .then(function (view) {
              return (
                inMemoryDb.update(resources.LAST_USED_VIEW_UUID_PER_LIST, { listId: identifiers.listId }, view.uuid),
                view
              )
            })
        )
      }),
      listViewsLoader
    )
  }),
  (self.makeListFilterLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      resources = dependencies.resources,
      listFilterLoader = {}
    return (
      (listFilterLoader.load = function (identifiers) {
        return optimisticState.initialLoad
          .then(function () {
            return optimisticState.isListAvailableOffline({ listId: identifiers.listId })
              ? (function (identifiers) {
                  return optimisticState.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
                    var filter = resourceHandlers.LIST_FILTER.get(optimisticState.getData(), identifiers)
                    return _.isNil(filter) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : filter
                  })
                })(identifiers)
              : Promise.reject(ZenkitErrorCodes.NOT_FOUND)
          })
          .catch(function () {
            return (function (identifiers) {
              var url = zenkitFetch.buildUrl('lists/:listAllId/filters/:filterAllId', {
                listAllId: identifiers.listId,
                filterAllId: identifiers.uuid,
              })
              return zenkitFetch.get(url).then(function (filter) {
                return inMemoryDb.update(resources.LIST_FILTER, identifiers, filter), filter
              })
            })(identifiers)
          })
      }),
      listFilterLoader
    )
  }),
  (self.makeListFiltersLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      zenkitFetch = dependencies.zenkitFetch,
      optimisticState = dependencies.optimisticState,
      inMemoryDb = dependencies.inMemoryDb,
      resourceHandlers = dependencies.resourceHandlers,
      resources = dependencies.resources,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      listFiltersLoader = {},
      loadListFiltersFromServer = function (identifiers) {
        var url = zenkitFetch.buildUrl('users/me/lists/:listAllId/filters', { listAllId: identifiers.listId })
        return zenkitFetch.get(url).then(function (filters) {
          return inMemoryDb.update(resources.LIST_FILTERS, identifiers, filters), filters
        })
      },
      loadListFiltersFromOfflineStorage = function (identifiers) {
        return inMemoryDb.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
          var cachedListFiltersByUuid = resourceHandlers.LIST_FILTERS.get(optimisticState.getData(), identifiers)
          return _.isNil(cachedListFiltersByUuid)
            ? Promise.reject(ZenkitErrorCodes.NOT_FOUND)
            : _.chain(cachedListFiltersByUuid)
                .filter(function (filter) {
                  return _.isNil(filter.deprecated_at)
                })
                .sortBy('sortOrder')
                .value()
        })
      }
    return (
      (listFiltersLoader.load = function (identifiers) {
        return optimisticState.initialLoad.then(function () {
          return optimisticState.isListAvailableOffline({ listId: identifiers.listId })
            ? (function (identifiers) {
                return loadListFiltersFromOfflineStorage(identifiers).catch(function () {
                  return loadListFiltersFromServer(identifiers)
                })
              })(identifiers)
            : (function (identifiers) {
                return loadListFiltersFromServer(identifiers).catch(function () {
                  return loadListFiltersFromOfflineStorage(identifiers)
                })
              })(identifiers)
        })
      }),
      listFiltersLoader
    )
  }),
  (self.makeListFileLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      resources = dependencies.resources,
      listFileLoader = {}
    return (
      (listFileLoader.load = function (identifiers) {
        return optimisticState.initialLoad
          .then(function () {
            return (function (identifiers) {
              return optimisticState.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
                var data = optimisticState.getData(),
                  filesEc = _.find(resourceHandlers.ELEMENTCATEGORIES.get(data, {}), { name: 'Files' }),
                  listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: identifiers.listId }),
                  fileElements = _.filter(resourceHandlers.LIST_ELEMENTS.get(data, { listId: identifiers.listId }), {
                    elementcategory: filesEc.id,
                  }),
                  files = _.flatMap(fileElements, function (fileElement) {
                    var filesDataKey = fileElement.uuid + '_filesData'
                    return _.flatMap(listEntriesByUuid, filesDataKey)
                  }),
                  file = _.find(files, identifiers)
                return _.isNil(file) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : file
              })
            })(identifiers)
          })
          .catch(function () {
            return (function (identifiers) {
              var url = zenkitFetch.buildUrl('lists/:listAllId/files/:fileAllId/model', {
                listAllId: identifiers.listId,
                fileAllId: identifiers.id,
              })
              return zenkitFetch.get(url).then(function (file) {
                return inMemoryDb.update(resources.LIST_FILE, identifiers, file), file
              })
            })(identifiers)
          })
      }),
      listFileLoader
    )
  }),
  (self.makeGlobalEntriesLoader = function (dependencies) {
    var _ = dependencies.lodash,
      moment = dependencies.moment,
      utils = dependencies.utils,
      connectionChecker = dependencies.connectionChecker,
      Promise = dependencies.Promise,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      zenkitFetch = dependencies.zenkitFetch,
      appType = dependencies.appType,
      globalEntriesLoader = {},
      onMixedListEntriesLoaded = function (listEntries) {
        var listEntriesByListId = _.groupBy(listEntries, 'listId')
        _.forEach(listEntriesByListId, function (listEntries, listIdAsString) {
          var listId = parseInt(listIdAsString)
          optimisticState.onListEntriesArrived({ listId, listEntries, publishChanges: !1 })
        })
      }
    globalEntriesLoader.search = function (identifiers, params) {
      return optimisticState.initialLoad.then(function () {
        return (params = utils.validateParameters(params, {
          query: { type: 'string' },
          listIds: { type: ['array', 'undefined'] },
          preferedListId: { type: ['number', 'undefined'] },
          searchInArchive: { type: 'boolean', default: !1 },
          searchInAllApps: { type: 'boolean', default: !1 },
          excludeListEntryUUIDs: { type: 'array', default: [] },
          includeRelatedLists: { type: 'boolean', default: !0 },
          includeRelatedWorkspaces: { type: 'boolean', default: !0 },
          includeRelatedListElements: { type: 'boolean', default: !0 },
          limit: { type: 'number', default: 20 },
          skip: { type: 'number', default: 0 },
          loadFromCache: { type: 'boolean', default: !1 },
        })).loadFromCache || !1 === connectionChecker.isOnline()
          ? (function (params) {
              var workspacesById = _.keyBy(optimisticState.getData().workspacesWithLists, 'id'),
                listsById = _.keyBy(_.flatMap(optimisticState.getData().workspacesWithLists, 'lists'), 'id'),
                listIdsOfSynchronizedLists = _.map(_.keys(optimisticState.getData().listSynchronizations), Number),
                listIds = params.listIds
                  ? _.intersection(listIdsOfSynchronizedLists, params.listIds)
                  : listIdsOfSynchronizedLists
              return (
                !1 === params.searchInAllApps &&
                  (listIds = _.filter(listIds, listId =>
                    _.some(_.get(listsById, [listId, 'resourceTags']), { appType }),
                  )),
                params.preferedListId &&
                  (listIds = _.sortBy(listIds, function (id) {
                    return id === params.preferedListId ? 0 : 1
                  })),
                Promise.map(listIds, function (listId) {
                  return optimisticState.ensureListStateIsLoaded({ listId })
                }).then(function () {
                  var internalLimit = params.limit + params.skip + 1,
                    result = _.reduce(
                      listIds,
                      function (result, listId) {
                        if (_.size(result.listEntries) >= internalLimit) return result
                        var listEntries = _.filter(
                          resourceHandlers.LIST_ENTRIES.get(optimisticState.getData(), { listId }),
                          function (listEntry) {
                            if (_.includes(params.excludeListEntryUUIDs, listEntry.uuid)) return !1
                            var isDeprecated = !1 === _.isNil(listEntry.deprecated_at)
                            return (
                              (!1 !== params.searchInArchive || !0 !== isDeprecated) &&
                              (!0 !== params.searchInArchive || !1 !== isDeprecated) &&
                              (!!_.isEmpty(params.query) ||
                                utils.matchesSearchQuery(
                                  listEntry,
                                  params.query,
                                  ZenkitControlsShared.filterTermModi.CONTAINS,
                                  resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), {
                                    listId: listEntry.listId,
                                  }),
                                  resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {}),
                                ))
                            )
                          },
                        )
                        return (result.listEntries = _.concat(result.listEntries, listEntries)), result
                      },
                      { listEntries: [], listElements: [], lists: [], workspaces: [], thereAreMoreResults: !1 },
                    )
                  _.size(result.listEntries) > params.limit && (result.thereAreMoreResults = !0),
                    (result.listEntries = _.take(_.drop(result.listEntries, params.skip), params.limit))
                  var relatedListIds = _.uniq(_.map(result.listEntries, 'listId')),
                    relatedLists = _.compact(
                      _.map(relatedListIds, function (listId) {
                        return listsById[listId]
                      }),
                    )
                  if (
                    (params.includeRelatedLists && (result.lists = relatedLists),
                    params.includeRelatedListElements &&
                      (result.listElements = _.flatMap(relatedListIds, function (listId) {
                        return _.values(resourceHandlers.LIST_ELEMENTS.get(optimisticState.getData(), { listId }))
                      })),
                    params.includeRelatedWorkspaces)
                  ) {
                    var relatedWorkspaceIds = _.map(relatedLists, 'workspaceId')
                    result.workspaces = _.compact(
                      _.map(relatedWorkspaceIds, function (workspaceId) {
                        return workspacesById[workspaceId]
                      }),
                    )
                  }
                  return result
                })
              )
            })(params)
          : ((postParams = _.omit(params, ['loadFromCache'])),
            zenkitFetch.get('entries/search', { query: postParams }).then(function (result) {
              var promises = [],
                listEntriesByListId = _.groupBy(result.listEntries, 'listId')
              _.forEach(listEntriesByListId, function (listEntries, listIdAsString) {
                var listId = parseInt(listIdAsString)
                promises.push(optimisticState.onListEntriesArrived({ listId, listEntries, publishChanges: !1 }))
              })
              var listElementsById = _.groupBy(result.listElements, 'listId')
              return (
                _.forEach(listElementsById, function (listElements, listIdAsString) {
                  var listId = parseInt(listIdAsString)
                  promises.push(optimisticState.onListElementsArrived({ listId, listElements, publishChanges: !1 }))
                }),
                Promise.all(promises).then(_.constant(result))
              )
            }))
        var postParams
      })
    }
    globalEntriesLoader.load = function (identifiers, params) {
      var listIds = _.map(params.sources, 'listId')
      return _.every(listIds, function (listId) {
        return optimisticState.isListAvailableOffline({ listId })
      })
        ? (function (params) {
            if (_.isEmpty(params.sources)) return Promise.resolve({ filteredTotal: 0, listEntries: [] })
            var listIds = _.map(params.sources, 'listId')
            return Promise.map(listIds, function (listId) {
              return optimisticState.ensureListStateIsLoaded({ listId })
            })
              .then(function () {
                return _.reduce(
                  params.sources,
                  function (result, source) {
                    var data = optimisticState.getData(),
                      listId = source.listId,
                      userTagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(data, {}),
                      currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
                      elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
                      list = resourceHandlers.LIST.get(data, { id: listId }),
                      listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId }),
                      listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId }),
                      listEntries = _.values(listEntriesByUuid),
                      filteredEntries = utils.filterListEntries({
                        listEntries,
                        filter: source.filter,
                        listElementsByUuid,
                        elementcategories,
                        currentUser,
                        userTagAssignments,
                      })
                    return (
                      (filteredEntries = _.filter(filteredEntries, function (listEntry) {
                        return _.isNil(listEntry.deprecated_at)
                      })),
                      (result.listEntriesByListId[listId] = filteredEntries),
                      (result.listElementsByListId[listId] = _.values(listElementsByUuid)),
                      (result.taskDataByListId[listId] = utils.getTaskData({
                        list,
                        listElements: _.values(listElementsByUuid),
                        elementcategories,
                        appType,
                      })),
                      result
                    )
                  },
                  { listEntriesByListId: {}, listElementsByListId: {}, taskDataByListId: {} },
                )
              })
              .then(function (result) {
                var elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(optimisticState.getData(), {}),
                  sortingHandler = utils.getListEntrySortingHandlerForSources({
                    sources: params.sources,
                    listElementsByListId: result.listElementsByListId,
                    elementcategories,
                    taskDataByListId: result.taskDataByListId,
                  })
                return _.chain(result.listEntriesByListId)
                  .values()
                  .flatten()
                  .orderBy(sortingHandler.functions, sortingHandler.directions)
                  .value()
              })
              .then(function (listEntries) {
                return {
                  filteredTotal: _.size(listEntries),
                  listEntries: listEntries.slice(params.skip, params.skip + params.limit),
                }
              })
          })(params)
        : zenkitFetch.post('users/me/entries', params).then(function (container) {
            return onMixedListEntriesLoaded(container.listEntries), container
          })
    }
    var toMinimalCalendarSource = function (source) {
        return { listId: source.listId, dateElementId: source.dateElementId, filter: source.filter }
      },
      validateCalendarSource = function (source) {
        return utils.validateParameters(source, {
          listId: { type: 'number' },
          dateElementId: { type: 'number' },
          filter: { type: ['object', 'null'], default: null },
          color: { type: ['string', 'undefined', 'null'] },
          visible: { type: 'boolean', default: !0 },
        })
      }
    ;(globalEntriesLoader.loadForCalendarView = function (identifiers, params) {
      ;(params = utils.validateParameters(params, {
        range: { type: 'object' },
        limitPerDay: { type: 'number', default: 20 },
        skipPerDay: { type: 'number', default: 0 },
        sources: { type: 'array', default: [] },
      })).sources = _.map(params.sources, validateCalendarSource)
      var visibleSources = _.filter(params.sources, 'visible')
      if (_.isEmpty(visibleSources))
        return Promise.resolve({ listEntries: [], listEntriesTotalPerDay: {}, listEntriesFilteredTotalPerDay: {} })
      var sourcesToSendToServer = _.map(visibleSources, toMinimalCalendarSource)
      return zenkitFetch
        .post('users/me/entries/calendar', {
          sources: sourcesToSendToServer,
          dateFrom: params.range.start,
          dateTo: params.range.end,
          limitPerDay: params.limitPerDay,
          skipPerDay: params.skipPerDay,
        })
        .then(function (container) {
          return onMixedListEntriesLoaded(container.listEntries), container
        })
    }),
      (globalEntriesLoader.loadAggregationsForCalendarView = function (identifiers, params) {
        ;(params = utils.validateParameters(params, {
          range: { type: 'object' },
          sources: { type: 'array', default: [] },
        })).sources = _.map(params.sources, validateCalendarSource)
        var visibleSources = _.filter(params.sources, 'visible')
        if (_.isEmpty(visibleSources))
          return Promise.resolve({ listEntries: [], listEntriesTotalPerDay: {}, listEntriesFilteredTotalPerDay: {} })
        var sourcesToSendToServer = _.map(visibleSources, toMinimalCalendarSource)
        return zenkitFetch.post('users/me/entries/calendar-aggregations', {
          sources: sourcesToSendToServer,
          dateFrom: params.range.start,
          dateTo: params.range.end,
        })
      }),
      (globalEntriesLoader.loadForTagsView = function (identifiers, params) {
        return zenkitFetch.post('users/me/entries/tags', params).then(function (container) {
          return onMixedListEntriesLoaded(container.listEntries), container
        })
      }),
      (globalEntriesLoader.loadForAssignmentsView = function (identifiers, params) {
        var url = zenkitFetch.buildUrl('users/me/entries/assigned-to/:assignedToUserAllId', {
          assignedToUserAllId: params.assignedToUserAllId,
        })
        return zenkitFetch.post(url, { limit: params.limit, skip: params.skip }).then(function (container) {
          return onMixedListEntriesLoaded(container.listEntries), container
        })
      })
    var todosAppStatisticsCache = {},
      todosAppStatisticsLatestRun = null
    ;(globalEntriesLoader.loadStatisticsForTodosApp = function () {
      var userViewModi = ZenkitControlsShared.userViewModi,
        todosApp = ZenkitControlsShared.apps.todos,
        todosResourceTags = todosApp.resourceTags
      return (todosAppStatisticsLatestRun = (todosAppStatisticsLatestRun || optimisticState.initialLoad)
        .then(function () {
          var data = optimisticState.getData()
          return _.flatMap(resourceHandlers.WORKSPACES_WITH_LISTS.get(data, {}), 'lists')
        })
        .filter(function (list) {
          return !list.isBuilding && optimisticState.isListAvailableOffline({ listId: list.id })
        })
        .tap(function (lists) {
          return Promise.map(lists, function (list) {
            return optimisticState.ensureListStateIsLoaded({ listId: list.id })
          })
        })
        .then(function (lists) {
          return Promise.map(lists, function (list) {
            var data = optimisticState.getData(),
              currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              userTagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(data, {}),
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
              listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: list.id }),
              listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: list.id }),
              listElements = _.values(listElementsByUuid),
              taskData = utils.getTaskData({ list, listElements, elementcategories, appType: todosApp.type })
            if (_.isNil(taskData))
              return (
                console.warn('globalEntriesLoader.loadStatisticsForTodosApp: Unexpected lack of task data.', list.id),
                null
              )
            var dueDateElement = _.find(listElements, function (listElement) {
                return _.some(listElement.resourceTags, { tag: todosResourceTags.listElements.dueDate })
              }),
              assignmentsElement = _.find(listElements, function (listElement) {
                return _.some(listElement.resourceTags, { tag: todosResourceTags.listElements.assignments })
              }),
              filterBuilder = utils.makeFilterTreeBuilder({ listElements, elementcategories }),
              doneTerm = filterBuilder.term({
                elementId: taskData.listElement.id,
                modus: ZenkitControlsShared.filterTermModi.EQUALS,
                value: [taskData.done.id],
              }),
              assignedToMeTerm = filterBuilder.term({
                elementId: assignmentsElement.id,
                modus: ZenkitControlsShared.filterTermModi.CONTAINS,
                value: [currentUser.id],
              }),
              overdueTerm = filterBuilder.dateTerm({
                elementId: dueDateElement.id,
                dateType: ZenkitControlsShared.dateTimeFilterModi.CUSTOM,
                dateTo: moment().subtract(1, 'day').endOf('day'),
              }),
              dueTodayTerm = filterBuilder.dateTerm({
                elementId: dueDateElement.id,
                dateType: ZenkitControlsShared.dateTimeFilterModi.CUSTOM,
                dateTo: moment().endOf('day'),
              }),
              dueThisWeekTerm = filterBuilder.dateTerm({
                elementId: dueDateElement.id,
                dateType: ZenkitControlsShared.dateTimeFilterModi.CUSTOM,
                dateTo: moment().add(6, 'days').endOf('day'),
              }),
              userTagsTerm = { type: 'userTags', modus: ZenkitControlsShared.filterTermModi.EMPTY, negated: !0 },
              doneFilterTree = filterBuilder.filterTree({ terms: [doneTerm] }),
              overdueFilterTree = filterBuilder.filterTree({ terms: [overdueTerm] }),
              isDueTodayFilterTree = filterBuilder.filterTree({ terms: [dueTodayTerm] }),
              isDueThisWeekFilterTree = filterBuilder.filterTree({ terms: [dueThisWeekTerm] }),
              assignedToMeFilterTree = filterBuilder.filterTree({ terms: [assignedToMeTerm] }),
              hasUserTagsFilterTree = filterBuilder.filterTree({ terms: [userTagsTerm] }),
              emptyStats = { list: { total: 0, overdue: 0 } }
            ;(emptyStats[userViewModi.USER_ALL] = { total: 0, overdue: 0 }),
              (emptyStats[userViewModi.USER_TODAY] = { total: 0, overdue: 0 }),
              (emptyStats[userViewModi.USER_AGENDA] = { total: 0, overdue: 0 }),
              (emptyStats[userViewModi.USER_ASSIGNMENTS] = { total: 0, overdue: 0 }),
              (emptyStats[userViewModi.USER_TAGS] = { total: 0, overdue: 0 }),
              (emptyStats[userViewModi.USER_DONE] = { total: 0, overdue: 0 })
            var increaseStats = function (stats, key, isOverdue) {
                return (stats[key].total += 1), isOverdue && (stats[key].overdue += 1), stats
              },
              matchesFilter = function (listEntry, filter) {
                return (
                  _.size(
                    utils.filterListEntries({
                      listEntries: [listEntry],
                      filter,
                      listElementsByUuid,
                      elementcategories,
                      currentUser,
                      userTagAssignments,
                    }),
                  ) > 0
                )
              },
              getFilterResults = function (listEntry) {
                var path = [listEntry.listId, listEntry.uuid],
                  cached = _.get(todosAppStatisticsCache, path)
                if (cached && cached.updated_at === listEntry.updated_at) return cached
                var result = (function (listEntry) {
                  var result = {
                    updated_at: listEntry.updated_at,
                    isOverdue: !1,
                    isDueThisWeek: !1,
                    isDueToday: !1,
                    isAssignedToMe: !1,
                    hasUserTags: !1,
                  }
                  return (
                    (result.isDone = matchesFilter(listEntry, doneFilterTree)),
                    result.isDone ||
                      ((result.isOverdue = matchesFilter(listEntry, overdueFilterTree)),
                      (result.isDueThisWeek = matchesFilter(listEntry, isDueThisWeekFilterTree)),
                      result.isDueThisWeek && (result.isDueToday = matchesFilter(listEntry, isDueTodayFilterTree)),
                      (result.isAssignedToMe = matchesFilter(listEntry, assignedToMeFilterTree)),
                      (result.hasUserTags = matchesFilter(listEntry, hasUserTagsFilterTree))),
                    result
                  )
                })(listEntry)
                return _.setWith(todosAppStatisticsCache, path, result, Object), result
              },
              stats = _.reduce(
                listEntriesByUuid,
                function (stats, listEntry) {
                  if (!1 === _.isNil(listEntry.deprecated_at)) return stats
                  var { isDone, isOverdue, isDueThisWeek, isDueToday, isAssignedToMe, hasUserTags } =
                    getFilterResults(listEntry)
                  return isDone
                    ? (stats = increaseStats(stats, userViewModi.USER_DONE, !1))
                    : ((stats = increaseStats(stats, 'list', isOverdue)),
                      (stats = increaseStats(stats, userViewModi.USER_ALL, isOverdue)),
                      isDueThisWeek &&
                        ((stats = increaseStats(stats, userViewModi.USER_AGENDA, isOverdue)),
                        isDueToday && (stats = increaseStats(stats, userViewModi.USER_TODAY, isOverdue))),
                      isAssignedToMe && (stats = increaseStats(stats, userViewModi.USER_ASSIGNMENTS, isOverdue)),
                      hasUserTags && (stats = increaseStats(stats, userViewModi.USER_TAGS, isOverdue)),
                      stats)
                },
                emptyStats,
              )
            return [list.id, stats]
          })
            .then(_.compact)
            .then(_.fromPairs)
        })
        .then(function (stats) {
          return _.reduce(
            stats,
            function (result, statsOfList, listId) {
              return (
                (result.byListId[listId] = statsOfList.list),
                _.forEach(userViewModi, function (viewType) {
                  _.isNil(result.byViewType[viewType]) && (result.byViewType[viewType] = { total: 0, overdue: 0 }),
                    statsOfList[viewType] &&
                      ((result.byViewType[viewType].total += statsOfList[viewType].total),
                      (result.byViewType[viewType].overdue += statsOfList[viewType].overdue))
                }),
                result
              )
            },
            { byListId: {}, byViewType: {} },
          )
        })
        .catch(function (err) {
          return console.error(err), Promise.reject(err)
        }))
    }),
      (globalEntriesLoader.loadDataForTodosAppWidget = function () {
        var VIEW_TYPES = _.pick(ZenkitControlsShared.userViewModi, [
            'USER_ALL',
            'USER_TODAY',
            'USER_AGENDA',
            'USER_ASSIGNMENTS',
            'USER_TAGS',
          ]),
          todosApp = ZenkitControlsShared.apps.todos
        return optimisticState.initialLoad
          .then(function () {
            var data = optimisticState.getData()
            return _.flatMap(resourceHandlers.WORKSPACES_WITH_LISTS.get(data, {}), 'lists')
          })
          .filter(function (list) {
            return (
              !list.isBuilding &&
              !1 !== _.some(list.resourceTags, ['appType', todosApp.type]) &&
              optimisticState.isListAvailableOffline({ listId: list.id })
            )
          })
          .tap(function (lists) {
            return Promise.map(lists, function (list) {
              return optimisticState.ensureListStateIsLoaded({ listId: list.id })
            })
          })
          .then(function (lists) {
            if (_.isEmpty(lists)) return {}
            var results = (function (lists) {
                var data = optimisticState.getData(),
                  currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
                  userTagAssignments = resourceHandlers.USER_TAG_ASSIGNMENTS.get(data, {}),
                  elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
                  smartListsVisibility = currentUser.settings.smartListsVisibility || {},
                  AGGREATE_VIEW = _.reduce(
                    VIEW_TYPES,
                    function (map, type) {
                      return (map[type] = 'hidden' !== smartListsVisibility[type]), map
                    },
                    {},
                  ),
                  views = {}
                return (
                  (views[VIEW_TYPES.USER_ALL] = []),
                  (views[VIEW_TYPES.USER_TODAY] = []),
                  (views[VIEW_TYPES.USER_AGENDA] = []),
                  (views[VIEW_TYPES.USER_ASSIGNMENTS] = []),
                  (views[VIEW_TYPES.USER_TAGS] = []),
                  _.reduce(
                    lists,
                    function (results, list) {
                      var listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: list.id }),
                        listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: list.id }),
                        listElements = _.values(listElementsByUuid),
                        taskData = utils.getTaskData({ list, listElements, elementcategories, appType: todosApp.type })
                      if (_.isNil(taskData))
                        return (
                          console.warn(
                            'globalEntriesLoader.loadDataForTodosAppWidget: Unexpected lack of task data.',
                            list.id,
                          ),
                          results
                        )
                      var dueDateElement = _.find(listElements, function (listElement) {
                          var tag = todosApp.resourceTags.listElements.dueDate
                          return _.some(listElement.resourceTags, { appType: todosApp.type, tag })
                        }),
                        assignmentsElement = _.find(listElements, function (listElement) {
                          var tag = todosApp.resourceTags.listElements.assignments
                          return _.some(listElement.resourceTags, { appType: todosApp.type, tag })
                        }),
                        filterBuilder = utils.makeFilterTreeBuilder({ listElements, elementcategories }),
                        doneTerm = filterBuilder.term({
                          elementId: taskData.listElement.id,
                          modus: ZenkitControlsShared.filterTermModi.EQUALS,
                          value: [taskData.done.id],
                        }),
                        assignedToMeTerm = filterBuilder.term({
                          elementId: assignmentsElement.id,
                          modus: ZenkitControlsShared.filterTermModi.CONTAINS,
                          value: [currentUser.id],
                        }),
                        overdueTerm = filterBuilder.dateTerm({
                          elementId: dueDateElement.id,
                          dateType: ZenkitControlsShared.dateTimeFilterModi.CUSTOM,
                          dateTo: moment().subtract(1, 'day').endOf('day'),
                        }),
                        dueTodayTerm = filterBuilder.dateTerm({
                          elementId: dueDateElement.id,
                          dateType: ZenkitControlsShared.dateTimeFilterModi.CUSTOM,
                          dateTo: moment().endOf('day'),
                        }),
                        dueThisWeekTerm = filterBuilder.dateTerm({
                          elementId: dueDateElement.id,
                          dateType: ZenkitControlsShared.dateTimeFilterModi.CUSTOM,
                          dateTo: moment().endOf('week'),
                        }),
                        userTagsTerm = {
                          type: 'userTags',
                          modus: ZenkitControlsShared.filterTermModi.EMPTY,
                          negated: !0,
                        },
                        doneFilterTree = filterBuilder.filterTree({ terms: [doneTerm] }),
                        overdueFilterTree = filterBuilder.filterTree({ terms: [overdueTerm] }),
                        isDueTodayFilterTree = filterBuilder.filterTree({ terms: [dueTodayTerm] }),
                        isDueThisWeekFilterTree = filterBuilder.filterTree({ terms: [dueThisWeekTerm] }),
                        assignedToMeFilterTree = filterBuilder.filterTree({ terms: [assignedToMeTerm] }),
                        hasUserTagsFilterTree = filterBuilder.filterTree({ terms: [userTagsTerm] }),
                        matchesFilter = function (listEntry, filter) {
                          var filtered = utils.filterListEntries({
                            listEntries: [listEntry],
                            filter,
                            listElementsByUuid,
                            elementcategories,
                            currentUser,
                            userTagAssignments,
                          })
                          return !1 === _.isEmpty(filtered)
                        },
                        tasks = []
                      return (
                        _.forEach(listEntriesByUuid, function (listEntry) {
                          if (!1 !== _.isNil(listEntry.deprecated_at) && !matchesFilter(listEntry, doneFilterTree)) {
                            var isOverdue = matchesFilter(listEntry, overdueFilterTree),
                              isStarred = matchesFilter(listEntry, hasUserTagsFilterTree),
                              task = {
                                listId: list.id,
                                listName: list.name,
                                isOverdue,
                                isStarred,
                                id: listEntry.id,
                                uuid: listEntry.uuid,
                                displayString: listEntry.displayString,
                                sortOrder: parseFloat(listEntry.sortOrder),
                                dueDate: {
                                  startDate: listEntry[dueDateElement.uuid + '_date'],
                                  endDate: listEntry[dueDateElement.uuid + '_endDate'],
                                  duration: listEntry[dueDateElement.uuid + '_duration'],
                                  hasTime: listEntry[dueDateElement.uuid + '_hasTime'],
                                },
                              }
                            tasks.push(task),
                              AGGREATE_VIEW[VIEW_TYPES.USER_ALL] && results.views[VIEW_TYPES.USER_ALL].push(task),
                              isStarred &&
                                AGGREATE_VIEW[VIEW_TYPES.USER_TAGS] &&
                                results.views[VIEW_TYPES.USER_TAGS].push(task),
                              AGGREATE_VIEW[VIEW_TYPES.USER_ASSIGNMENTS] &&
                                matchesFilter(listEntry, assignedToMeFilterTree) &&
                                results.views[VIEW_TYPES.USER_ASSIGNMENTS].push(task),
                              AGGREATE_VIEW[VIEW_TYPES.USER_TODAY] &&
                                matchesFilter(listEntry, isDueTodayFilterTree) &&
                                results.views[VIEW_TYPES.USER_TODAY].push(task),
                              AGGREATE_VIEW[VIEW_TYPES.USER_AGENDA] &&
                                matchesFilter(listEntry, isDueThisWeekFilterTree) &&
                                results.views[VIEW_TYPES.USER_AGENDA].push(task)
                          }
                        }),
                        (results.lists[list.id] = tasks),
                        results
                      )
                    },
                    { lists: {}, views },
                  )
                )
              })(lists),
              data = optimisticState.getData(),
              currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              sortedWorkspaceIds = currentUser.settings.sortedWorkspaceIds,
              workspaces = resourceHandlers.WORKSPACES_WITH_LISTS.get(data, {}),
              sortedWorkspaces = _.orderBy(workspaces, [
                function (workspace) {
                  var tag = todosApp.resourceTags.workspaces.defaultFolder,
                    isDefaultFolder = _.some(workspace.resourceTags, { appType: todosApp.type, tag })
                  return isDefaultFolder ? -1 : 1
                },
                function (workspace) {
                  var index = _.indexOf(sortedWorkspaceIds, workspace.id)
                  return -1 === index ? 1 / 0 : index
                },
                function (workspace) {
                  return _.toLower(workspace.name)
                },
              ]),
              sortedLists = _.orderBy(lists, [
                function (list) {
                  var tag = todosApp.resourceTags.lists.inbox,
                    isInbox = _.some(list.resourceTags, { appType: todosApp.type, tag })
                  return isInbox ? -1 : 1
                },
                function (list) {
                  var index = _.findIndex(sortedWorkspaces, ['id', list.workspaceId])
                  return -1 === index ? 1 / 0 : index
                },
                'sortOrder',
              ]),
              taskLists = _.map(sortedLists, function (list) {
                var sortedTasks = _.orderBy(results.lists[list.id], ['sortOrder', 'uuid'])
                return { key: 'list_' + list.id, name: list.name, tasks: _.take(sortedTasks, 100) }
              }),
              smartListsVisibility = currentUser.settings.smartListsVisibility || {},
              filteredViewTypes = _.filter(
                [
                  VIEW_TYPES.USER_ASSIGNMENTS,
                  VIEW_TYPES.USER_TAGS,
                  VIEW_TYPES.USER_TODAY,
                  VIEW_TYPES.USER_AGENDA,
                  VIEW_TYPES.USER_ALL,
                ],
                function (type) {
                  return 'visible' === smartListsVisibility[type] || !1 === _.isEmpty(results.views[type])
                },
              ),
              views = _.map(filteredViewTypes, function (type) {
                var orderBy = [
                  function (entry) {
                    var index = _.findIndex(sortedLists, ['id', entry.listId])
                    return -1 === index ? 1 / 0 : index
                  },
                  'sortOrder',
                  'uuid',
                ]
                _.includes([VIEW_TYPES.USER_TODAY, VIEW_TYPES.USER_AGENDA], type) &&
                  orderBy.unshift('dueDate.startDate')
                var sortedTasks = _.orderBy(results.views[type], orderBy)
                return { key: 'view_' + type, viewType: type, tasks: _.take(sortedTasks, 100) }
              }),
              inbox = _.defaults({ isInbox: !0 }, _.head(taskLists))
            return { lists: _.concat([inbox], views, _.tail(taskLists)) }
          })
          .catch(function (err) {
            return console.error(err), Promise.reject(err)
          })
      }),
      (globalEntriesLoader.loadStatisticsForHypernotesApp = function () {
        var hypernotesApp = ZenkitControlsShared.apps.hypernotes,
          hypernotesResourceTags = hypernotesApp.resourceTags
        return optimisticState.initialLoad
          .then(function () {
            var data = optimisticState.getData()
            return resourceHandlers.WORKSPACES_WITH_LISTS.get(data, {}) || []
          })
          .filter(function (workspace) {
            return _.some(workspace.resourceTags, { appType: hypernotesApp.type })
          })
          .filter(function (workspace) {
            return _.every(workspace.lists, function (list) {
              return optimisticState.isListAvailableOffline({ listId: list.id })
            })
          })
          .tap(function (workspaces) {
            return Promise.map(workspaces, function (workspace) {
              return optimisticState.ensureWorkspaceStateIsLoaded({ workspaceId: workspace.id }).then(function () {
                return Promise.each(workspace.lists, function (list) {
                  return optimisticState.ensureListStateIsLoaded({ listId: list.id })
                })
              })
            })
          })
          .then(function (workspaces) {
            return _.map(workspaces, function (workspace) {
              var data = optimisticState.getData(),
                elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
                notesList = utils.findByResourceTag(workspace.lists, {
                  appType: hypernotesApp.type,
                  tag: hypernotesResourceTags.lists.notes,
                }),
                tasksList = utils.findByResourceTag(workspace.lists, {
                  appType: hypernotesApp.type,
                  tag: hypernotesResourceTags.lists.tasks,
                })
              if (_.isEmpty(notesList) || _.isEmpty(tasksList)) return {}
              var maxPerList,
                taskData,
                parentsKey,
                notesListElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: notesList.id }),
                notesListEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: notesList.id }),
                notesListSubentriesElement = utils.findByResourceTag(notesListElementsByUuid, {
                  appType: hypernotesApp.type,
                  tag: hypernotesResourceTags.listElements.subpages,
                }),
                tasksListElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: tasksList.id }),
                tasksListEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: tasksList.id }),
                updatedInfoForWorkspace =
                  ((maxPerList = _.map(workspace.lists, function (list) {
                    var listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: list.id }),
                      listEntries = _.values(listEntriesByUuid)
                    return _.maxBy(listEntries, 'updated_at')
                  })),
                  _.chain(maxPerList)
                    .maxBy('updated_at')
                    .pick(['updated_at', 'updated_by_displayname'], workspace.created_at)
                    .value()),
                pagesPreview = _.chain(notesListEntriesByUuid)
                  .filter(function (listEntry) {
                    return _.isEmpty(listEntry[notesListSubentriesElement.uuid + '_parents'])
                  })
                  .orderBy(notesListSubentriesElement.uuid + '_path')
                  .reject('deprecated_at')
                  .take(15)
                  .map('displayString')
                  .join('\n')
                  .value()
              return {
                id: workspace.id,
                created: workspace.created_at,
                name: _.toLower(workspace.name),
                updated: updatedInfoForWorkspace.updated_at,
                numberOfPages:
                  ((parentsKey = notesListSubentriesElement.uuid + '_parents'),
                  _.chain(notesListEntriesByUuid)
                    .filter(function (entry) {
                      return (
                        !1 !== _.isNil(entry.deprecated_at) &&
                        _.isEmpty(entry[parentsKey]) &&
                        entry.listId === notesList.id
                      )
                    })
                    .size()
                    .value()),
                numberOfTasks: _.size(_.reject(tasksListEntriesByUuid, 'deprecated_at')),
                numberOfDoneTasks:
                  ((taskData = utils.getTaskData({
                    list: tasksList,
                    listElements: _.values(tasksListElementsByUuid),
                    elementcategories,
                    appType: hypernotesApp.type,
                  })),
                  _.isNil(taskData)
                    ? 0
                    : _.chain(tasksListEntriesByUuid)
                        .filter(function (entry) {
                          return (
                            !1 !== _.isNil(entry.deprecated_at) &&
                            _.includes(entry[taskData.listElementKey], taskData.done.id)
                          )
                        })
                        .size()
                        .value()),
                updatedBy: updatedInfoForWorkspace.updated_by_displayname,
                pagesPreview,
              }
            })
          })
          .then(function (workspaceStats) {
            return _.keyBy(workspaceStats, 'id')
          })
      })
    var projectsAppStatisticsCache = {},
      projectsAppStatisticsLatestRun = null
    return (
      (globalEntriesLoader.loadAggregationsForProjectsDashboard = function (identifiers, params) {
        var increaseAt = function (object, path, add) {
          var current = _.get(object, path)
          _.isNil(current) && (current = 0), _.setWith(object, path, current + add, Object)
        }
        return (projectsAppStatisticsLatestRun = (projectsAppStatisticsLatestRun || optimisticState.initialLoad)
          .then(function () {
            var listIds = _.map(params.sources, 'listId')
            return _.filter(
              _.flatMap(resourceHandlers.WORKSPACES_WITH_LISTS.get(optimisticState.getData(), {}), 'lists'),
              function (list) {
                return _.includes(listIds, list.id)
              },
            )
          })
          .tap(function (lists) {
            return Promise.map(lists, function (list) {
              return optimisticState.ensureListStateIsLoaded({ listId: list.id })
            })
          })
          .then(function (lists) {
            var data = optimisticState.getData(),
              elementcategories = resourceHandlers.ELEMENTCATEGORIES.get(data, {}),
              currentUser = resourceHandlers.CURRENT_USER.get(data, {}),
              aggregationsForAll = {
                total: 0,
                totalWorkload: 0,
                totalDone: 0,
                totalWorkloadDone: 0,
                today: { total: 0, totalWorkload: 0, totalDone: 0, totalWorkloadDone: 0 },
                week: { total: 0, totalWorkload: 0, totalDone: 0, totalWorkloadDone: 0 },
                assignedToMe: {
                  total: 0,
                  totalWorkload: 0,
                  totalDone: 0,
                  totalWorkloadDone: 0,
                  today: { total: 0, totalWorkload: 0, totalDone: 0, totalWorkloadDone: 0 },
                  week: { total: 0, totalWorkload: 0, totalDone: 0, totalWorkloadDone: 0 },
                },
              }
            return _objectSpread(
              {
                byListId: _.reduce(
                  lists,
                  function (aggregationsByListId, list) {
                    var projectsApp = ZenkitControlsShared.apps.projects,
                      listElementsByUuid = resourceHandlers.LIST_ELEMENTS.get(data, { listId: list.id }),
                      listEntriesByUuid = resourceHandlers.LIST_ENTRIES.get(data, { listId: list.id }),
                      listElementsByTag = utils.keyByResourceTag(listElementsByUuid, { appType: projectsApp.type }),
                      listElements = _.values(listElementsByUuid),
                      taskData = utils.getTaskData({ list, listElements, elementcategories, appType: projectsApp.type })
                    if (_.isNil(taskData))
                      return console.warn('unexpected lack of taskData for list', list.id), aggregationsByListId
                    var dueDateElement = utils.findByResourceTag(listElements, {
                        appType: projectsApp.type,
                        tag: projectsApp.resourceTags.listElements.dueDate,
                      }),
                      assignmentsElement = utils.findByResourceTag(listElements, {
                        appType: projectsApp.type,
                        tag: projectsApp.resourceTags.listElements.assignments,
                      }),
                      filterBuilder = utils.makeFilterTreeBuilder({ listElements, elementcategories }),
                      doneTerm = filterBuilder.term({
                        elementId: taskData.listElement.id,
                        modus: ZenkitControlsShared.filterTermModi.EQUALS,
                        value: [taskData.done.id],
                      }),
                      assignedToMeTerm = filterBuilder.term({
                        elementId: assignmentsElement.id,
                        modus: ZenkitControlsShared.filterTermModi.CONTAINS,
                        value: [currentUser.id],
                      }),
                      dueTodayTerm = filterBuilder.dateTerm({
                        elementId: dueDateElement.id,
                        dateType: ZenkitControlsShared.dateTimeFilterModi.CUSTOM,
                        dateFrom: void 0,
                        dateTo: moment().endOf('day'),
                      }),
                      dueThisWeekTerm = filterBuilder.dateTerm({
                        elementId: dueDateElement.id,
                        dateType: ZenkitControlsShared.dateTimeFilterModi.CUSTOM,
                        dateFrom: void 0,
                        dateTo: moment().add(6, 'days').endOf('day'),
                      }),
                      doneFilterTree = filterBuilder.filterTree({ terms: [doneTerm] }),
                      assignedToMeFilterTree = filterBuilder.filterTree({ terms: [assignedToMeTerm] }),
                      isDueTodayFilterTree = filterBuilder.filterTree({ terms: [dueTodayTerm] }),
                      isDueThisWeekFilterTree = filterBuilder.filterTree({ terms: [dueThisWeekTerm] }),
                      matchesFilter = function (listEntry, filter) {
                        return (
                          _.size(
                            utils.filterListEntries({
                              listEntries: [listEntry],
                              filter,
                              listElementsByUuid,
                              elementcategories,
                              currentUser,
                            }),
                          ) > 0
                        )
                      },
                      getFilterResults = function (listEntry) {
                        var path = [listEntry.listId, listEntry.uuid],
                          cached = _.get(projectsAppStatisticsCache, path)
                        if (cached && cached.updated_at === listEntry.updated_at) return cached
                        var result = (function (listEntry) {
                          var result = {
                            updated_at: listEntry.updated_at,
                            isDone: !1,
                            isAssignedToMe: !1,
                            isDueThisWeek: !1,
                            isDueToday: !1,
                          }
                          return (
                            (result.isDone = matchesFilter(listEntry, doneFilterTree)),
                            (result.isAssignedToMe = matchesFilter(listEntry, assignedToMeFilterTree)),
                            (result.isDueThisWeek = matchesFilter(listEntry, isDueThisWeekFilterTree)),
                            result.isDueThisWeek &&
                              (result.isDueToday = matchesFilter(listEntry, isDueTodayFilterTree)),
                            result
                          )
                        })(listEntry)
                        return _.setWith(projectsAppStatisticsCache, path, result, Object), result
                      },
                      aggregationsForList = {
                        total: 0,
                        totalWorkload: 0,
                        totalPerCategory: {},
                        totalWorkloadPerCategory: {},
                      }
                    if (listElementsByTag.stage && listElementsByTag.workload) {
                      var stageKey = listElementsByTag.stage.uuid + '_categories',
                        workloadKey = listElementsByTag.workload.uuid + '_number'
                      _.forEach(listEntriesByUuid, function (listEntry) {
                        if (!listEntry.deprecated_at) {
                          var workload = listEntry[workloadKey]
                          _.isNil(workload) && (workload = params.defaultWorkload || 0),
                            increaseAt(aggregationsForList, ['total'], 1),
                            increaseAt(aggregationsForList, ['totalWorkload'], workload),
                            increaseAt(aggregationsForAll, ['total'], 1),
                            increaseAt(aggregationsForAll, ['totalWorkload'], workload)
                          var categoryIds = listEntry[stageKey]
                          _.isEmpty(listEntry[stageKey]) && (categoryIds = [-1]),
                            _.forEach(categoryIds, function (categoryId) {
                              increaseAt(aggregationsForList, ['totalPerCategory', categoryId], 1),
                                increaseAt(aggregationsForList, ['totalWorkloadPerCategory', categoryId], workload)
                            })
                          var { isAssignedToMe, isDone, isDueThisWeek, isDueToday } = getFilterResults(listEntry)
                          isAssignedToMe &&
                            (increaseAt(aggregationsForAll, ['assignedToMe', 'total'], 1),
                            increaseAt(aggregationsForAll, ['assignedToMe', 'totalWorkload'], workload)),
                            isDueThisWeek &&
                              (increaseAt(aggregationsForAll, ['week', 'total'], 1),
                              increaseAt(aggregationsForAll, ['week', 'totalWorkload'], workload),
                              isAssignedToMe &&
                                (increaseAt(aggregationsForAll, ['assignedToMe', 'week', 'total'], 1),
                                increaseAt(aggregationsForAll, ['assignedToMe', 'week', 'totalWorkload'], workload))),
                            isDueToday &&
                              (increaseAt(aggregationsForAll, ['today', 'total'], 1),
                              increaseAt(aggregationsForAll, ['today', 'totalWorkload'], workload),
                              isAssignedToMe &&
                                (increaseAt(aggregationsForAll, ['assignedToMe', 'today', 'total'], 1),
                                increaseAt(aggregationsForAll, ['assignedToMe', 'today', 'totalWorkload'], workload))),
                            isDone &&
                              (increaseAt(aggregationsForAll, ['totalDone'], 1),
                              increaseAt(aggregationsForAll, ['totalWorkloadDone'], workload),
                              isAssignedToMe &&
                                (increaseAt(aggregationsForAll, ['assignedToMe', 'totalDone'], 1),
                                increaseAt(aggregationsForAll, ['assignedToMe', 'totalWorkloadDone'], workload)),
                              isDueThisWeek &&
                                (increaseAt(aggregationsForAll, ['week', 'totalDone'], 1),
                                increaseAt(aggregationsForAll, ['week', 'totalWorkloadDone'], workload),
                                isAssignedToMe &&
                                  (increaseAt(aggregationsForAll, ['assignedToMe', 'week', 'totalDone'], 1),
                                  increaseAt(
                                    aggregationsForAll,
                                    ['assignedToMe', 'week', 'totalWorkloadDone'],
                                    workload,
                                  ))),
                              isDueToday &&
                                (increaseAt(aggregationsForAll, ['today', 'totalDone'], 1),
                                increaseAt(aggregationsForAll, ['today', 'totalWorkloadDone'], workload),
                                isAssignedToMe &&
                                  (increaseAt(aggregationsForAll, ['assignedToMe', 'today', 'totalDone'], 1),
                                  increaseAt(
                                    aggregationsForAll,
                                    ['assignedToMe', 'today', 'totalWorkloadDone'],
                                    workload,
                                  ))))
                        }
                      })
                    }
                    return (aggregationsByListId[list.id] = aggregationsForList), aggregationsByListId
                  },
                  {},
                ),
              },
              aggregationsForAll,
            )
          }))
      }),
      (globalEntriesLoader.loadVirtualCategories = function (identifiers, params) {
        return optimisticState.initialLoad
          .then(function () {
            var listIds = _.map(params.sources, 'listId')
            return _.filter(
              _.flatMap(resourceHandlers.WORKSPACES_WITH_LISTS.get(optimisticState.getData(), {}), 'lists'),
              function (list) {
                return _.includes(listIds, list.id)
              },
            )
          })
          .tap(function (lists) {
            return Promise.map(lists, function (list) {
              return optimisticState.ensureListStateIsLoaded({ listId: list.id })
            })
          })
          .then(function (lists) {
            var sourcesByListId = _.keyBy(params.sources, 'listId'),
              data = optimisticState.getData()
            return _.chain(lists)
              .map(function (list) {
                var findParams,
                  source = sourcesByListId[list.id]
                if (source.categoryElementId) findParams = { id: source.categoryElementId }
                else {
                  if (!source.categoryElementResourceTag)
                    throw new Error('Either categoryElementId or categoryElementResourceTag should be set')
                  findParams = function (listElement) {
                    return _.some(listElement.resourceTags, source.categoryElementResourceTag)
                  }
                }
                return _.find(resourceHandlers.LIST_ELEMENTS.get(data, { listId: list.id }), findParams)
              })
              .compact()
              .flatMap('elementData.predefinedCategories')
              .groupBy('name')
              .map(group => _.maxBy(group, 'sortOrder'))
              .orderBy('sortOrder')
              .map(function (category) {
                return {
                  key: category.name,
                  name: category.name,
                  colorHex: category.colorHex,
                  sortOrder: category.sortOrder,
                  resourceTags: category.resourceTags,
                }
              })
              .value()
          })
      }),
      globalEntriesLoader
    )
  }),
  (self.makeCategorySortOrderLoader = function (dependencies) {
    var optimisticState = dependencies.optimisticState,
      zenkitFetch = dependencies.zenkitFetch,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      categorySortOrderLoader = {
        load: function (identifiers) {
          var url = zenkitFetch.buildUrl('lists/:listAllId/category-sort-orders', { listAllId: identifiers.listId })
          return zenkitFetch
            .post(url, {})
            .tap(function (categorySortOrders) {
              return optimisticState.onCategorySortOrdersArrived({ listId: identifiers.listId, categorySortOrders })
            })
            .then(function (categorySortOrder) {
              return _.find(categorySortOrder, { elementId: identifiers.elementId })
            })
            .tap(function (categorySortOrder) {
              if (_.isNil(categorySortOrder)) return Promise.reject(ZenkitErrorCodes.NOT_FOUND)
            })
        },
      }
    return categorySortOrderLoader
  }),
  (self.makeListLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      resourceHandlers = dependencies.resourceHandlers,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      utils = dependencies.utils,
      optimisticState = dependencies.optimisticState,
      moment = dependencies.moment,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      listLoader = {}
    ;(listLoader.load = function (identifiers) {
      return (function (identifiers) {
        return inMemoryDb.initialLoad.then(function () {
          var workspacesWithLists = resourceHandlers.WORKSPACES_WITH_LISTS.get(inMemoryDb.getData(), {}) || [],
            list = _.chain(workspacesWithLists).flatMap('lists').find({ id: identifiers.id }).value()
          return _.isNil(list) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : list
        })
      })(identifiers).catch(function () {
        return (function (identifiers) {
          var url = zenkitFetch.buildUrl('lists/:listAllId', { listAllId: identifiers.id })
          return zenkitFetch.get(url)
        })(identifiers)
      })
    }),
      (listLoader.loadStatistics = function (identifiers) {
        var url = zenkitFetch.buildUrl('lists/:listAllId/statistics', { listAllId: identifiers.id })
        return zenkitFetch.get(url)
      }),
      (listLoader.loadFormulaBuildingBlocks = function (identifiers) {
        var url = zenkitFetch.buildUrl('lists/:listAllId/formulaBuildingBlocks', { listAllId: identifiers.id })
        return zenkitFetch.get(url)
      }),
      (listLoader.loadCriticalPaths = function (identifiers, params) {
        var url = zenkitFetch.buildUrl(
          '/lists/:listAllId/dependencies/:dependencyElementAllId/dates/:dateElementAllId/critical-paths',
          {
            listAllId: identifiers.id,
            dependencyElementAllId: params.dependencyElementAllId,
            dateElementAllId: params.dateElementAllId,
          },
        )
        return zenkitFetch.get(url)
      })
    var loadActivitiesFromOfflineStorage = function (identifiers, params) {
      var CREATED_IN = ZenkitControlsShared.activityTypes.CREATED_IN,
        includeListActivities = _.isEmpty(params.created_in) || _.includes(params.created_in, CREATED_IN.LIST),
        includeListEntryActivities =
          _.isEmpty(params.created_in) || _.includes(params.created_in, CREATED_IN.LIST_ENTRY),
        query = _.toLower(params.query)
      return !1 === includeListActivities && !1 === includeListEntryActivities
        ? Promise.resolve([])
        : inMemoryDb.ensureListStateIsLoaded({ listId: identifiers.id }).then(function () {
            var activitiesByUUID = resourceHandlers.ACTIVITIES.get(optimisticState.getData(), {
              listId: identifiers.id,
            })
            if (_.isNil(activitiesByUUID)) return Promise.reject(ZenkitErrorCodes.NOT_FOUND)
            var sortedActivities = _.chain(activitiesByUUID)
                .filter(function (activity) {
                  return (
                    (!1 !== _.isEmpty(query) || !1 !== _.includes(_.toLower(activity.message), query)) &&
                    (params.filter !== ZenkitControlsShared.activityTypes.FILTER.COMMENTS ||
                      activity.type === ZenkitControlsShared.activityTypes.TYPE.COMMENT) &&
                    (params.filter !== ZenkitControlsShared.activityTypes.FILTER.SYSTEM_MESSAGES ||
                      activity.type !== ZenkitControlsShared.activityTypes.TYPE.COMMENT) &&
                    activity.listId === identifiers.id &&
                    (activity.created_in === CREATED_IN.LIST
                      ? includeListActivities
                      : activity.created_in === CREATED_IN.LIST_ENTRY && includeListEntryActivities)
                  )
                })
                .orderBy(
                  [
                    function (activity) {
                      var created_at = activity.origin_created_at || activity.created_at
                      return moment(created_at).valueOf()
                    },
                    'id',
                  ],
                  ['desc', 'desc'],
                )
                .value(),
              total = _.size(sortedActivities),
              activities = _.take(_.drop(sortedActivities, params.skip), params.limit),
              parentActivitiesByUuid = void 0
            if (params.includeParentActivities) {
              var activitiesByUuid = _.keyBy(sortedActivities, 'uuid')
              parentActivitiesByUuid = _.reduce(
                activities,
                (parentActivitiesByUuid, activity) => (
                  activity.parentUUID &&
                    (parentActivitiesByUuid[activity.parentUUID] = activitiesByUuid[activity.parentUUID]),
                  parentActivitiesByUuid
                ),
                {},
              )
            }
            return {
              activities,
              parentActivitiesByUuid,
              thereAreMoreResults: total - params.skip > params.limit,
              total,
            }
          })
    }
    return (
      (listLoader.loadActivities = function (identifiers, params) {
        return (
          (params = utils.validateParameters(
            params,
            _.defaults(
              {
                query: { type: ['string', 'undefined'] },
                created_in: { type: ['array', 'null'], default: null },
                includeParentActivities: { type: 'boolean', default: !1 },
              },
              utils.getValidationForActivityLoader(),
            ),
          )),
          optimisticState.initialLoad.then(function () {
            var resultIsCached = inMemoryDb.areListActivitiesAvailableOffline({
              listId: identifiers.id,
              activitiesFilter: params.filter,
            })
            return params.loadFromCache || resultIsCached
              ? loadActivitiesFromOfflineStorage(identifiers, params)
              : (function (identifiers, params) {
                  var url = zenkitFetch.buildUrl('lists/:listAllId/activities', { listAllId: identifiers.id })
                  return zenkitFetch
                    .get(url, {
                      query: {
                        filter: params.filter,
                        skip: params.skip,
                        limit: params.limit,
                        created_in: _.isEmpty(params.created_in) ? void 0 : params.created_in,
                      },
                    })
                    .tap(function (response) {
                      optimisticState.onListActivitiesArrived({
                        listId: identifiers.id,
                        listActivities: response.activities,
                        publishChanges: !1,
                      })
                    })
                })(identifiers, params).catch(function () {
                  return loadActivitiesFromOfflineStorage(identifiers, params)
                })
          })
        )
      }),
      listLoader
    )
  }),
  (self.makeUserViewsLoader = function (dependencies) {
    var optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      zenkitFetch = dependencies.zenkitFetch,
      _ = dependencies.lodash,
      userViewsLoader = {
        load: function () {
          return optimisticState.initialLoad.then(function () {
            return _.values(resourceHandlers.USER_VIEWS.get(optimisticState.getData(), {}))
          })
        },
        loadUsingAllId: function (identifiers, params) {
          return optimisticState.initialLoad
            .then(function () {
              var views = resourceHandlers.USER_VIEWS.get(optimisticState.getData(), {})
              return _.find(views, function (view) {
                return (
                  view.id === params.viewAllId || view.shortId === params.viewAllId || view.uuid === params.viewAllId
                )
              })
            })
            .then(function (userView) {
              if (userView) return userView
              var url = zenkitFetch.buildUrl('users/me/views/:viewAllId', { viewAllId: params.viewAllId })
              return zenkitFetch.get(url)
            })
        },
        loadPreferred: function (identifiers, params) {
          return userViewsLoader
            .load()
            .then(function (views) {
              return _.find(views, { type: params.viewType })
            })
            .then(function (userView) {
              if (userView) return userView
              var url = zenkitFetch.buildUrl('users/me/views/preferred')
              return zenkitFetch.get(url, { query: { viewType: params.viewType } })
            })
        },
      }
    return userViewsLoader
  }),
  (self.makeBackgroundsLoader = function (dependencies) {
    var zenkitFetch = dependencies.zenkitFetch,
      backgroundsLoader = {
        loadForMe: function () {
          return zenkitFetch.get('backgrounds/users/me')
        },
        loadForList: function (identifiers) {
          var url = zenkitFetch.buildUrl('backgrounds/lists/:listAllId', { listAllId: identifiers.id })
          return zenkitFetch.get(url)
        },
      }
    return backgroundsLoader
  }),
  (self.makeOrganizationLoader = function (dependencies) {
    var utils = dependencies.utils,
      zenkitFetch = dependencies.zenkitFetch,
      organizationLoader = {
        loadActivities: function (identifiers, params) {
          params = utils.validateParameters(params, utils.getValidationForActivityLoader())
          var url = zenkitFetch.buildUrl('organizations/:organizationId/activities', { organizationId: identifiers.id })
          return zenkitFetch.get(url, { query: { filter: params.filter, skip: params.skip, limit: params.limit } })
        },
        loadResources: function (identifiers) {
          var url = zenkitFetch.buildUrl('organizations/:organizationId/resources', { organizationId: identifiers.id })
          return zenkitFetch.get(url)
        },
      }
    return organizationLoader
  }),
  (self.makeWorkspaceLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      utils = dependencies.utils,
      moment = dependencies.moment,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      ZenkitControlsShared = dependencies.ZenkitControlsShared,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      workspaceLoader = {}
    workspaceLoader.load = function (identifiers) {
      return (function (identifiers) {
        return inMemoryDb.initialLoad.then(function () {
          var workspacesWithLists = resourceHandlers.WORKSPACES_WITH_LISTS.get(inMemoryDb.getData(), {}) || [],
            workspace = _.find(workspacesWithLists, { id: identifiers.id })
          return _.isNil(workspace) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : workspace
        })
      })(identifiers).catch(function () {
        return (function (identifiers) {
          var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId', { workspaceAllId: identifiers.id })
          return zenkitFetch.get(url)
        })(identifiers)
      })
    }
    var CREATED_IN = ZenkitControlsShared.activityTypes.CREATED_IN,
      loadWorkspaceActivitiesFromOfflineStorage = function (identifiers, params) {
        return !1 === (_.isEmpty(params.created_in) || _.includes(params.created_in, CREATED_IN.WORKSPACE))
          ? []
          : inMemoryDb.ensureWorkspaceStateIsLoaded({ workspaceId: identifiers.id }).then(function () {
              var data = optimisticState.getData(),
                workspaceActivities = resourceHandlers.ACTIVITIES_PER_WORKSPACE.get(data, {
                  workspaceId: identifiers.id,
                })
              return _.values(workspaceActivities)
            })
      },
      loadListActivitiesFromOfflineStorage = function (identifiers, params) {
        var includeListActivities = _.isEmpty(params.created_in) || _.includes(params.created_in, CREATED_IN.LIST),
          includeListEntryActivities =
            _.isEmpty(params.created_in) || _.includes(params.created_in, CREATED_IN.LIST_ENTRY)
        if (!1 === includeListActivities && !1 === includeListEntryActivities) return []
        var workspace = _.find(optimisticState.getData().workspacesWithLists, { id: identifiers.id }),
          lists = workspace && workspace.lists
        return _.isEmpty(lists)
          ? []
          : Promise.resolve(lists)
              .map(function (list) {
                return inMemoryDb.ensureListStateIsLoaded({ listId: list.id })
              })
              .then(function () {
                var data = optimisticState.getData(),
                  activities = _.flatMap(lists, function (list) {
                    return _.values(resourceHandlers.ACTIVITIES.get(data, { listId: list.id }))
                  })
                return includeListActivities && includeListEntryActivities
                  ? activities
                  : includeListActivities
                  ? _.filter(activities, ['created_in', CREATED_IN.LIST])
                  : includeListEntryActivities
                  ? _.filter(activities, ['created_in', CREATED_IN.LIST_ENTRY])
                  : []
              })
      },
      loadActivitiesFromOfflineStorage = function (identifiers, params) {
        var query = _.toLower(params.query)
        return Promise.all([
          loadWorkspaceActivitiesFromOfflineStorage(identifiers, params),
          loadListActivitiesFromOfflineStorage(identifiers, params),
        ]).then(function (results) {
          var sortedActivities = _.chain(results)
              .flatten()
              .filter(function (activity) {
                return (
                  (!1 !== _.isEmpty(query) || !1 !== _.includes(_.toLower(activity.message), query)) &&
                  (params.filter !== ZenkitControlsShared.activityTypes.FILTER.COMMENTS ||
                    activity.type === ZenkitControlsShared.activityTypes.TYPE.COMMENT) &&
                  (params.filter !== ZenkitControlsShared.activityTypes.FILTER.SYSTEM_MESSAGES ||
                    activity.type !== ZenkitControlsShared.activityTypes.TYPE.COMMENT)
                )
              })
              .orderBy(function (activity) {
                return moment(activity.created_at).valueOf()
              }, 'desc')
              .value(),
            total = _.size(sortedActivities),
            end = params.limit + params.skip,
            activities = _.slice(sortedActivities, params.skip, end),
            parentActivitiesByUuid = void 0
          if (params.includeParentActivities) {
            var activitiesByUuid = _.keyBy(sortedActivities, 'uuid')
            parentActivitiesByUuid = _.reduce(
              activities,
              (parentActivitiesByUuid, activity) => (
                activity.parentUUID &&
                  (parentActivitiesByUuid[activity.parentUUID] = activitiesByUuid[activity.parentUUID]),
                parentActivitiesByUuid
              ),
              {},
            )
          }
          return { activities, parentActivitiesByUuid, thereAreMoreResults: total > end, total }
        })
      }
    return (
      (workspaceLoader.loadActivities = function (identifiers, params) {
        return (
          (params = utils.validateParameters(
            params,
            _.defaults(
              {
                query: { type: ['string', 'undefined'] },
                created_in: { type: ['array', 'null'], default: null },
                includeParentActivities: { type: 'boolean', default: !1 },
              },
              utils.getValidationForActivityLoader(),
            ),
          )),
          optimisticState.initialLoad.then(function () {
            var resultIsCached = inMemoryDb.areWorkspaceActivitiesAvailableOffline({
              workspaceId: identifiers.id,
              activitiesFilter: params.filter,
            })
            return params.loadFromCache || resultIsCached
              ? loadActivitiesFromOfflineStorage(identifiers, params)
              : (function (identifiers, params) {
                  var url = zenkitFetch.buildUrl('workspaces/:workspaceAllId/activities', {
                    workspaceAllId: identifiers.id,
                  })
                  return zenkitFetch.get(url, {
                    query: {
                      filter: params.filter,
                      skip: params.skip,
                      limit: params.limit,
                      created_in: _.isEmpty(params.created_in) ? void 0 : params.created_in,
                    },
                  })
                })(identifiers, params).catch(function () {
                  return loadActivitiesFromOfflineStorage(identifiers, params)
                })
          })
        )
      }),
      workspaceLoader
    )
  }),
  (self.makeRecurrenceRuleLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      resources = dependencies.resources,
      loadFromOfflineStorage = function (identifiers) {
        return optimisticState.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
          var rule = resourceHandlers.RECURRENCE_RULE.get(optimisticState.getData(), identifiers)
          return _.isNil(rule) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : rule
        })
      },
      loadFromServer = function (identifiers) {
        var url = zenkitFetch.buildUrl('lists/:listId/recurrence/rules/:ruleId', {
          listId: identifiers.listId,
          ruleId: identifiers.id,
        })
        return zenkitFetch.get(url).then(function (rule) {
          return inMemoryDb.update(resources.RECURRENCE_RULE, identifiers, rule), rule
        })
      },
      recurrenceRuleLoader = {}
    return (
      (recurrenceRuleLoader.load = function (identifiers) {
        return optimisticState.initialLoad.then(function () {
          return optimisticState.isListAvailableOffline({ listId: identifiers.listId })
            ? (function (identifiers) {
                return loadFromOfflineStorage(identifiers).catch(function () {
                  return loadFromServer(identifiers)
                })
              })(identifiers)
            : (function (identifiers) {
                return loadFromServer(identifiers).catch(function () {
                  return loadFromOfflineStorage(identifiers)
                })
              })(identifiers)
        })
      }),
      recurrenceRuleLoader
    )
  }),
  (self.makeRecurrenceRulesLoader = function (dependencies) {
    var _ = dependencies.lodash,
      Promise = dependencies.Promise,
      ZenkitErrorCodes = dependencies.ZenkitErrorCodes,
      optimisticState = dependencies.optimisticState,
      resourceHandlers = dependencies.resourceHandlers,
      zenkitFetch = dependencies.zenkitFetch,
      inMemoryDb = dependencies.inMemoryDb,
      resources = dependencies.resources,
      loadFromOfflineStorage = function (identifiers) {
        return optimisticState.ensureListStateIsLoaded({ listId: identifiers.listId }).then(function () {
          var rulesById = resourceHandlers.RECURRENCE_RULES.get(optimisticState.getData(), identifiers)
          return _.isNil(rulesById)
            ? Promise.reject(ZenkitErrorCodes.NOT_FOUND)
            : _.filter(rulesById, function (rule) {
                return _.isNil(rule.deprecated_at)
              })
        })
      },
      loadFromServer = function (identifiers) {
        var url = zenkitFetch.buildUrl('lists/:listId/recurrence/rules', { listId: identifiers.listId })
        return zenkitFetch.get(url).then(function (rules) {
          return inMemoryDb.update(resources.RECURRENCE_RULES, identifiers, rules), rules
        })
      },
      recurrenceRulesLoader = {}
    return (
      (recurrenceRulesLoader.load = function (identifiers) {
        return optimisticState.initialLoad.then(function () {
          return optimisticState.isListAvailableOffline({ listId: identifiers.listId })
            ? (function (identifiers) {
                return loadFromOfflineStorage(identifiers).catch(function () {
                  return loadFromServer(identifiers)
                })
              })(identifiers)
            : (function (identifiers) {
                return loadFromServer(identifiers).catch(function () {
                  return loadFromOfflineStorage(identifiers)
                })
              })(identifiers)
        })
      }),
      recurrenceRulesLoader
    )
  }),
  (function () {
    var LANGUAGE,
      passedGlobals,
      _ = self._,
      bowser = self.bowser,
      Promise = self.Promise,
      moment = self.moment,
      produceState = self.immer.default,
      Primus = self.Primus,
      CompactJSON = self.CompactJSON,
      utils = _.assign({}, self.ZenkitSharedUtils, self.ZenkitSharedWorkerUtils),
      ZenkitControlsShared = self.ZenkitControlsShared,
      ZenkitErrorCodes = self.ZenkitErrorCodes,
      makeIndexedDB = self.makeIndexedDB,
      makeStorageHandlers = self.makeStorageHandlers,
      makeResources = self.makeResources,
      makeZenkitFetch = self.makeZenkitFetch,
      makeActionHandlers = self.makeActionHandlers,
      makeInMemoryDb = self.makeInMemoryDb,
      makeOptimisticState = self.makeOptimisticState,
      makeSynchronization = self.makeSynchronization,
      makeSocketService = self.makeSocketService,
      makeConnectionChecker = self.makeConnectionChecker,
      initSocketHandlers = self.initSocketHandlers,
      makeCommands = self.makeCommands,
      makeAccessesPerListLoader = self.makeAccessesPerListLoader,
      makeAccessesPerWorkspaceLoader = self.makeAccessesPerWorkspaceLoader,
      makeAccessesPerOrganizationLoader = self.makeAccessesPerOrganizationLoader,
      makeEntriesUtils = self.makeEntriesUtils,
      makeCurrentUserLoader = self.makeCurrentUserLoader,
      makeUserLoader = self.makeUserLoader,
      makeUsersLoader = self.makeUsersLoader,
      makeElementcategoriesLoader = self.makeElementcategoriesLoader,
      makeElementsLoader = self.makeElementsLoader,
      makeElementLoader = self.makeElementLoader,
      makeEntriesLoader = self.makeEntriesLoader,
      makeEntryLoader = self.makeEntryLoader,
      makeListViewsLoader = self.makeListViewsLoader,
      makeListFiltersLoader = self.makeListFiltersLoader,
      makeListFilterLoader = self.makeListFilterLoader,
      makeListFileLoader = self.makeListFileLoader,
      makeGlobalEntriesLoader = self.makeGlobalEntriesLoader,
      makeCategorySortOrderLoader = self.makeCategorySortOrderLoader,
      makeListLoader = self.makeListLoader,
      makeUserViewsLoader = self.makeUserViewsLoader,
      makeBackgroundsLoader = self.makeBackgroundsLoader,
      makeOrganizationLoader = self.makeOrganizationLoader,
      makeWorkspaceLoader = self.makeWorkspaceLoader,
      makeRecurrenceRuleLoader = self.makeRecurrenceRuleLoader,
      makeRecurrenceRulesLoader = self.makeRecurrenceRulesLoader,
      constants = self.zenkitSDKConstants,
      { messageTypes, resources, actions, workerErrors, events, actionPayloadMayContainFiles } = constants,
      isSharedWorker = 'undefined' != typeof SharedWorkerGlobalScope,
      isWorker = 'undefined' != typeof WorkerGlobalScope,
      languageService =
        ((LANGUAGE = null),
        {
          get: function () {
            return LANGUAGE
          },
          set: function (language) {
            return (LANGUAGE = language)
          },
        })
    if (!1 === _.isEmpty(location.search)) {
      var match = location.search.match(/[?&]globals=([^&]+)/i)
      match && (passedGlobals = JSON.parse(decodeURIComponent(match[1])))
    }
    self.globals = _.defaults({}, self.globals, passedGlobals)
    var globals = self.globals
    if (_.isNil(globals.environment)) throw new Error('Worker Error: Environment not set.')
    var openPorts = [],
      postMessage = function (port, message) {
        return port.zenkitPostMessage
          ? port.zenkitPostMessage(message)
          : !1 === isSharedWorker && !1 === isWorker
          ? port.postMessage(message, '*')
          : port.postMessage(message)
      },
      serializeError = function (error) {
        return _.pick(error, ['name', 'stack', 'message', 'code', 'description'])
      },
      emitEvent = function (params) {
        var message
        ;(message = { type: messageTypes.event, event: params }),
          _.forEach(openPorts, function (port) {
            postMessage(port, message)
          })
      },
      zenkitIndexedDB = makeIndexedDB({ lodash: _, Promise, bowser, utils }),
      storageHandlers = makeStorageHandlers({ lodash: _, Promise, zenkitIndexedDB }),
      publishTypes = {
        ADDED: 'ADDED',
        CHANGED: 'CHANGED',
        REMOVED: 'REMOVED',
        REORDERED: 'REORDERED',
        ACTIVATED: 'ACTIVATED',
        NONE: 'NONE',
      },
      publishTypeCounterparts = {}
    ;(publishTypeCounterparts[publishTypes.ADDED] = publishTypes.REMOVED),
      (publishTypeCounterparts[publishTypes.CHANGED] = publishTypes.CHANGED),
      (publishTypeCounterparts[publishTypes.REORDERED] = publishTypes.REORDERED),
      (publishTypeCounterparts[publishTypes.REMOVED] = publishTypes.ADDED),
      (publishTypeCounterparts[publishTypes.ACTIVATED] = publishTypes.NONE),
      (publishTypeCounterparts[publishTypes.NONE] = publishTypes.NONE)
    var optimisticState,
      base,
      resourceHandlers = makeResources({
        lodash: _,
        utils,
        emitResourceChanged: function (params) {
          emitEvent(_.defaults({ name: events.resourceChanged }, params))
        },
        resources,
        publishTypes,
      }),
      getAccessToken = function () {
        return optimisticState
          ? optimisticState.initialLoad.then(function () {
              var token = resourceHandlers.ACCESS_TOKEN.get(optimisticState.getData(), {})
              return _.isNil(token) ? null : token
            })
          : Promise.resolve(null)
      },
      getBearerToken = function () {
        return getAccessToken().then(function (accessToken) {
          return _.isNil(accessToken) ? '' : 'Bearer ' + accessToken
        })
      },
      urlUtils =
        ((base = globals.serverUrl),
        {
          getAbsolutePath: function (path) {
            return (path = path || ''), _.startsWith(path, base) ? path : base + '/' + _.trimStart(path, '/')
          },
          stringifyQueryParams: function (queryParams) {
            return _.reduce(
              queryParams,
              function (queryString, value, key) {
                if (void 0 === value) return queryString
                var keyValuePair,
                  seperator = _.isEmpty(queryString) ? '?' : '&'
                if (_.isArray(value)) {
                  if (_.isEmpty(value)) return queryString
                  keyValuePair = _.join(
                    _.map(value, function (v) {
                      return key + '=' + encodeURIComponent(v)
                    }),
                    '&',
                  )
                } else keyValuePair = key + '=' + encodeURIComponent(value)
                return queryString + seperator + keyValuePair
              },
              '',
            )
          },
        }),
      connectionChecker = makeConnectionChecker({ lodash: _, Promise, globals, utils, urlUtils, emitEvent, events }),
      SocketService = makeSocketService({
        lodash: _,
        Promise,
        getAccessToken,
        appType: globals.appType,
        Primus,
        utils,
        urlUtils,
        connectionChecker,
        globals,
      }),
      zenkitFetch = makeZenkitFetch({
        lodash: _,
        Promise,
        clientVersion: globals.version,
        appType: globals.appType,
        urlUtils,
        apiPrefix: 'api/v1',
        getDynamicDefaultHeaders: function () {
          return Promise.props({ authorization: getBearerToken(), 'accept-language': languageService.get() })
        },
        globals,
      }),
      zenkitFetchPreventSockets = makeZenkitFetch({
        lodash: _,
        Promise,
        clientVersion: globals.version,
        appType: globals.appType,
        urlUtils,
        apiPrefix: 'api/v1',
        getDynamicDefaultHeaders: function () {
          return Promise.props({
            authorization: getBearerToken(),
            'accept-language': languageService.get(),
            'zenkit-spark-id': SocketService.getSparkId(),
          })
        },
        globals,
      }),
      actionHandlers = makeActionHandlers({
        lodash: _,
        Promise,
        globals,
        utils,
        moment,
        ZenkitErrorCodes,
        ZenkitControlsShared,
        resources,
        resourceHandlers,
        actions,
        publishTypes,
        zenkitFetch,
        zenkitFetchPreventSockets,
      }),
      inMemoryDb = makeInMemoryDb({
        lodash: _,
        utils,
        Promise,
        produceState,
        zenkitFetch,
        ZenkitErrorCodes,
        resources,
        resourceHandlers,
        storageHandlers,
        zenkitIndexedDB,
        emitEvent,
        events,
        workerErrors,
        ZenkitControlsShared,
      })
    ;(optimisticState = makeOptimisticState({
      lodash: _,
      utils,
      Promise,
      produceState,
      ZenkitErrorCodes,
      ZenkitControlsShared,
      resources,
      resourceHandlers,
      publishTypes,
      publishTypeCounterparts,
      storageHandlers,
      actions,
      actionPayloadMayContainFiles,
      actionHandlers,
      zenkitIndexedDB,
      inMemoryDb,
      connectionChecker,
      isMobileApp: globals.isMobileApp,
      bowser,
    })).onQueueChange(function (queue) {
      emitEvent({ name: events.queueChanged, queue })
    })
    var synchronization = makeSynchronization({
      lodash: _,
      utils,
      Promise,
      moment,
      inMemoryDb,
      optimisticState,
      ZenkitControlsShared,
      ZenkitErrorCodes,
      zenkitFetch,
      resources,
      resourceHandlers,
      connectionChecker,
      globals,
    })
    synchronization.onSyncStatusChanged(function () {
      emitEvent({ name: events.syncStatusChanged, syncStatus: synchronization.getSyncStatus() })
    }),
      synchronization.onListSynchronizationChanged(function (data) {
        emitEvent(_.assign({ name: events.listSynchronizationChanged }, data))
      }),
      synchronization.onWorkspaceSynchronizationChanged(function (data) {
        emitEvent(_.assign({ name: events.workspaceSynchronizationChanged }, data))
      })
    var entriesUtils = makeEntriesUtils({ zenkitFetch, optimisticState, resourceHandlers }),
      currentUserLoader = makeCurrentUserLoader({
        Promise,
        ZenkitErrorCodes,
        ZenkitControlsShared,
        publishTypes,
        inMemoryDb,
        optimisticState,
        resourceHandlers,
        resources,
        zenkitFetch,
        utils,
        moment,
        zenkitIndexedDB,
      }),
      userLoader = makeUserLoader({ lodash: _, zenkitFetch, optimisticState, resourceHandlers }),
      usersLoader = makeUsersLoader({
        utils,
        inMemoryDb,
        zenkitFetch,
        optimisticState,
        resourceHandlers,
        resources,
        connectionChecker,
      }),
      elementcategoriesLoader = makeElementcategoriesLoader({
        lodash: _,
        Promise,
        ZenkitErrorCodes,
        optimisticState,
        resourceHandlers,
      }),
      accessesPerListLoader = makeAccessesPerListLoader({
        lodash: _,
        Promise,
        zenkitFetch,
        inMemoryDb,
        resources,
        resourceHandlers,
        optimisticState,
        ZenkitErrorCodes,
      }),
      accessesPerWorkspaceLoader = makeAccessesPerWorkspaceLoader({
        lodash: _,
        Promise,
        zenkitFetch,
        inMemoryDb,
        resources,
        resourceHandlers,
        optimisticState,
        ZenkitErrorCodes,
      }),
      accessesPerOrganizationLoader = makeAccessesPerOrganizationLoader({
        lodash: _,
        utils,
        Promise,
        zenkitFetch,
        inMemoryDb,
        resources,
        resourceHandlers,
        optimisticState,
        ZenkitControlsShared,
      }),
      elementsLoader = makeElementsLoader({
        lodash: _,
        Promise,
        ZenkitErrorCodes,
        optimisticState,
        resourceHandlers,
        SocketService,
        zenkitFetch,
        socketTimeoutMs: 3e5,
      }),
      elementLoader = makeElementLoader({ lodash: _, Promise, ZenkitErrorCodes, elementsLoader }),
      entryLoader = makeEntryLoader({
        lodash: _,
        Promise,
        ZenkitErrorCodes,
        optimisticState,
        resourceHandlers,
        entriesUtils,
        utils,
        moment,
        zenkitFetch,
        inMemoryDb,
        ZenkitControlsShared,
      }),
      entriesLoader = makeEntriesLoader({
        lodash: _,
        Promise,
        moment,
        utils,
        zenkitFetch,
        resourceHandlers,
        optimisticState,
        ZenkitErrorCodes,
        ZenkitControlsShared,
        entriesUtils,
        connectionChecker,
        entryLoader,
        inMemoryDb,
        resources,
      }),
      globalEntriesLoader = makeGlobalEntriesLoader({
        lodash: _,
        moment,
        utils,
        connectionChecker,
        Promise,
        ZenkitControlsShared,
        optimisticState,
        resourceHandlers,
        zenkitFetch,
        appType: globals.appType,
      }),
      listViewsLoader = makeListViewsLoader({
        lodash: _,
        Promise,
        utils,
        zenkitFetch,
        optimisticState,
        inMemoryDb,
        resourceHandlers,
        resources,
        ZenkitErrorCodes,
      }),
      userViewsLoader = makeUserViewsLoader({ lodash: _, zenkitFetch, optimisticState, resourceHandlers }),
      listFiltersLoader = makeListFiltersLoader({
        lodash: _,
        Promise,
        zenkitFetch,
        optimisticState,
        inMemoryDb,
        resourceHandlers,
        resources,
        ZenkitErrorCodes,
      }),
      listFilterLoader = makeListFilterLoader({
        lodash: _,
        Promise,
        ZenkitErrorCodes,
        optimisticState,
        resourceHandlers,
        resources,
        inMemoryDb,
        zenkitFetch,
      }),
      listFileLoader = makeListFileLoader({
        lodash: _,
        Promise,
        ZenkitErrorCodes,
        optimisticState,
        resourceHandlers,
        resources,
        inMemoryDb,
        zenkitFetch,
      }),
      categorySortOrderLoader = makeCategorySortOrderLoader({
        optimisticState,
        zenkitFetch,
        Promise,
        ZenkitErrorCodes,
      }),
      listLoader = makeListLoader({
        lodash: _,
        Promise,
        zenkitFetch,
        inMemoryDb,
        resourceHandlers,
        ZenkitErrorCodes,
        utils,
        optimisticState,
        moment,
        ZenkitControlsShared,
      }),
      backgroundsLoader = makeBackgroundsLoader({ zenkitFetch }),
      organizationLoader = makeOrganizationLoader({ zenkitFetch, utils }),
      workspaceLoader = makeWorkspaceLoader({
        lodash: _,
        Promise,
        optimisticState,
        resourceHandlers,
        utils,
        moment,
        zenkitFetch,
        inMemoryDb,
        ZenkitControlsShared,
        ZenkitErrorCodes,
      }),
      recurrenceRuleLoader = makeRecurrenceRuleLoader({
        lodash: _,
        Promise,
        ZenkitErrorCodes,
        optimisticState,
        resourceHandlers,
        resources,
        inMemoryDb,
        zenkitFetch,
      }),
      recurrenceRulesLoader = makeRecurrenceRulesLoader({
        lodash: _,
        Promise,
        ZenkitErrorCodes,
        optimisticState,
        resourceHandlers,
        resources,
        inMemoryDb,
        zenkitFetch,
      }),
      accessTokenLoader = {
        load: function () {
          return optimisticState.initialLoad.then(function () {
            return resourceHandlers.ACCESS_TOKEN.get(optimisticState.getData(), {})
          })
        },
      },
      accessesLoader = {
        load: function () {
          return optimisticState.initialLoad.then(function () {
            return resourceHandlers.ACCESSES.get(optimisticState.getData(), {})
          })
        },
      },
      groupsLoader = {
        load: function () {
          return optimisticState.initialLoad.then(function () {
            return resourceHandlers.GROUPS.get(optimisticState.getData(), {})
          })
        },
      },
      groupLoader = {
        load: function (identifiers) {
          return optimisticState.initialLoad.then(function () {
            var group = resourceHandlers.GROUP.get(optimisticState.getData(), identifiers)
            return _.isNil(group) ? Promise.reject(ZenkitErrorCodes.NOT_FOUND) : group
          })
        },
      },
      userTagsLoader = {
        load: function () {
          return optimisticState.initialLoad.then(function () {
            return resourceHandlers.USER_TAGS.get(optimisticState.getData(), {})
          })
        },
      },
      userTagAssignmentsLoader = {
        load: function () {
          return optimisticState.initialLoad.then(function () {
            return resourceHandlers.USER_TAG_ASSIGNMENTS.get(optimisticState.getData(), {})
          })
        },
      },
      minimalNewNotificationsLoader = {
        load: function () {
          return resourceHandlers.MINIMAL_NEW_NOTIFICATIONS.get(optimisticState.getData(), {}) || []
        },
      },
      loaders = {}
    ;(loaders[resources.ACCESSES] = accessesLoader),
      (loaders[resources.CURRENT_USER] = currentUserLoader),
      (loaders[resources.USER] = userLoader),
      (loaders[resources.USERS] = usersLoader),
      (loaders[resources.GROUP] = groupLoader),
      (loaders[resources.GROUPS] = groupsLoader),
      (loaders[resources.ELEMENTCATEGORIES] = elementcategoriesLoader),
      (loaders[resources.ACCESSES_PER_LIST] = accessesPerListLoader),
      (loaders[resources.ACCESSES_PER_WORKSPACE] = accessesPerWorkspaceLoader),
      (loaders[resources.ACCESSES_PER_ORGANIZATION] = accessesPerOrganizationLoader),
      (loaders[resources.LIST_ELEMENTS] = elementsLoader),
      (loaders[resources.LIST_ELEMENT] = elementLoader),
      (loaders[resources.LIST_ENTRY] = entryLoader),
      (loaders[resources.LIST_ENTRIES] = entriesLoader),
      (loaders[resources.GLOBAL_ENTRIES] = globalEntriesLoader),
      (loaders[resources.ACCESS_TOKEN] = accessTokenLoader),
      (loaders[resources.VIEWS] = listViewsLoader),
      (loaders[resources.LIST_FILTER] = listFilterLoader),
      (loaders[resources.LIST_FILE] = listFileLoader),
      (loaders[resources.LIST_FILTERS] = listFiltersLoader),
      (loaders[resources.CATEGORY_SORT_ORDER] = categorySortOrderLoader),
      (loaders[resources.LIST] = listLoader),
      (loaders[resources.USER_VIEWS] = userViewsLoader),
      (loaders[resources.USER_TAGS] = userTagsLoader),
      (loaders[resources.USER_TAG_ASSIGNMENTS] = userTagAssignmentsLoader),
      (loaders[resources.BACKGROUNDS] = backgroundsLoader),
      (loaders[resources.ORGANIZATION] = organizationLoader),
      (loaders[resources.WORKSPACE] = workspaceLoader),
      (loaders[resources.RECURRENCE_RULE] = recurrenceRuleLoader),
      (loaders[resources.RECURRENCE_RULES] = recurrenceRulesLoader),
      (loaders[resources.MINIMAL_NEW_NOTIFICATIONS] = minimalNewNotificationsLoader)
    var commands = makeCommands({
      lodash: _,
      utils,
      Promise,
      zenkitFetch,
      ZenkitErrorCodes,
      ZenkitControlsShared,
      connectionChecker,
      inMemoryDb,
      optimisticState,
      resources,
      resourceHandlers,
      SocketService,
      synchronization,
      publishTypes,
      moment,
      events,
      emitEvent,
      languageService,
      appType: globals.appType,
      zenkitIndexedDB,
    })
    initSocketHandlers({
      lodash: _,
      Promise,
      inMemoryDb,
      optimisticState,
      resources,
      resourceHandlers,
      publishTypes,
      SocketService,
      emitEvent,
      events,
      workerErrors,
      commands,
      CompactJSON,
      globals,
    }),
      SocketService.startup()
    var onConnected = function (port) {
      !(function (port) {
        _.includes(openPorts, port) || openPorts.push(port)
      })(port)
      var handleDisconnect = () =>
          (function (port) {
            var index = _.indexOf(openPorts, port)
            ;-1 !== index && openPorts.splice(index, 1)
          })(port),
        onMessage = function (event) {
          var data = event.data || {}
          return data.type === messageTypes.dispatchRequest
            ? (function (data) {
                if (!_.isNil(data.messageId))
                  return Promise.try(function () {
                    return optimisticState.dispatch(data.params)
                  })
                    .then(function (result) {
                      return (
                        postMessage(port, { type: messageTypes.dispatchResponse, messageId: data.messageId, result }),
                        result
                      )
                    })
                    .catch(function (err) {
                      console.error('Dispatch error', data, err),
                        postMessage(port, {
                          type: messageTypes.dispatchResponse,
                          messageId: data.messageId,
                          error: serializeError(err),
                        })
                    })
                console.error('Got dispatch request without messageId.')
              })(data)
            : data.type === messageTypes.loadRequest
            ? (function (data) {
                if (_.isNil(data.messageId)) console.error('Got load request without messageId.')
                else {
                  var fn = _.get(loaders, [data.resource, data.function])
                  if (!_.isNil(fn))
                    return Promise.try(function () {
                      return fn(data.identifiers, data.params)
                    })
                      .then(function (result) {
                        return (
                          postMessage(port, { type: messageTypes.loadResponse, messageId: data.messageId, result }),
                          result
                        )
                      })
                      .catch(function (err) {
                        console.error('Load error', data, err),
                          postMessage(port, {
                            type: messageTypes.loadResponse,
                            messageId: data.messageId,
                            error: serializeError(err),
                          })
                      })
                  postMessage(port, {
                    type: messageTypes.loadResponse,
                    messageId: data.messageId,
                    error: { message: 'This function does not exist: ' + data.function },
                  })
                }
              })(data)
            : data.type === messageTypes.commandRequest
            ? (function (data) {
                if (_.isNil(data.messageId)) console.error('Got command request without messageId.')
                else {
                  var fn = commands[data.function]
                  if (!_.isNil(fn))
                    return Promise.try(function () {
                      return fn(data.params)
                    })
                      .then(function (result) {
                        return (
                          postMessage(port, { type: messageTypes.commandResponse, messageId: data.messageId, result }),
                          result
                        )
                      })
                      .catch(function (err) {
                        console.error('Command error', data, err),
                          postMessage(port, {
                            type: messageTypes.commandResponse,
                            messageId: data.messageId,
                            error: serializeError(err),
                          })
                      })
                  postMessage(port, {
                    type: messageTypes.commandResponse,
                    messageId: data.messageId,
                    error: { message: 'This function does not exist: ' + data.function },
                  })
                }
              })(data)
            : data.type === messageTypes.broadcastRequest
            ? (function (data) {
                if (!_.isNil(data.messageId))
                  return Promise.try(function () {
                    var resourceToUrl = {}
                    ;(resourceToUrl[resources.WORKSPACE] = '/workspaces/:id/broadcast'),
                      (resourceToUrl[resources.LIST] = '/lists/:id/broadcast'),
                      (resourceToUrl[resources.LIST_ENTRY] = '/lists/:listId/entries/:uuid/broadcast')
                    var url = zenkitFetch.buildUrl(resourceToUrl[data.resource], data.identifiers)
                    return zenkitFetch.put(url, data.message)
                  })
                    .then(function (result) {
                      return (
                        postMessage(port, { type: messageTypes.broadcastResponse, messageId: data.messageId, result }),
                        result
                      )
                    })
                    .catch(function (err) {
                      console.error('broadcast error', data, err),
                        postMessage(port, {
                          type: messageTypes.broadcastResponse,
                          messageId: data.messageId,
                          error: serializeError(err),
                        })
                    })
                console.error('Got broadcast request without messageId.')
              })(data)
            : data.type === messageTypes.disconnect
            ? handleDisconnect()
            : void 0
        }
      port.zenkitOnPostMessage ? port.zenkitOnPostMessage(onMessage) : port.addEventListener('message', onMessage)
    }
    isSharedWorker
      ? (self.onconnect = function (e) {
          var port = e.ports[0]
          onConnected(port), port.start()
        })
      : isWorker
      ? onConnected(self)
      : (onConnected(self), (self.zenkitSdkIsRunningInMainThread = !0))
  })()
