/* 5e4efe053b0bc680fbfb224f24a27f5db44c4697
 * This file is automatically generated by graphql-let. */

import * as Apollo from '@apollo/client';
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    DateTime: any;
    JSON: any;
};
export declare type Anchor = {
    __typename?: 'Anchor';
    id: Scalars['ID'];
    userId: Scalars['String'];
    count: AnchorCount;
    cocardId?: Maybe<Scalars['Int']>;
    ocardId?: Maybe<Scalars['Int']>;
    selfcardId?: Maybe<Scalars['Int']>;
};
export declare type AnchorCount = {
    __typename?: 'AnchorCount';
    id: Scalars['ID'];
    nViews: Scalars['Int'];
    nUps: Scalars['Int'];
    nDowns: Scalars['Int'];
};
export declare type AnchorLike = {
    __typename?: 'AnchorLike';
    id: Scalars['ID'];
    anchorId: Scalars['Int'];
    choice: LikeChoice;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type AnchorLikeResonse = {
    __typename?: 'AnchorLikeResonse';
    like: AnchorLike;
    count: AnchorCount;
};
export declare type AuthPayload = {
    __typename?: 'AuthPayload';
    token: Scalars['String'];
    user: User;
};
export declare type CardBody = {
    __typename?: 'CardBody';
    id: Scalars['ID'];
    userId: Scalars['String'];
    meta: Scalars['JSON'];
    text: Scalars['String'];
    prevId?: Maybe<Scalars['Int']>;
};
export declare type CardBodyInput = {
    text: Scalars['String'];
};
export declare type CardIdInput = {
    id: Scalars['String'];
    type: Scalars['String'];
};
export declare type CardIdentifierInput = {
    symbolName: Scalars['String'];
    oauthorName?: Maybe<Scalars['String']>;
};
export declare enum CardTemplate {
    Ticker = "TICKER",
    Topic = "TOPIC",
    Webpage = "WEBPAGE"
}
export declare type Cocard = {
    __typename?: 'Cocard';
    id: Scalars['ID'];
    template: CardTemplate;
    meta: Scalars['JSON'];
    link: Link;
    body?: Maybe<CardBody>;
};
export declare type Comment = {
    __typename?: 'Comment';
    id: Scalars['ID'];
    userId: Scalars['String'];
    symbols?: Maybe<Array<Symbol>>;
    isTop?: Maybe<Scalars['Boolean']>;
    text?: Maybe<Scalars['String']>;
    count: CommentCount;
    createdAt: Scalars['DateTime'];
    poll?: Maybe<Poll>;
    meta?: Maybe<Scalars['JSON']>;
    cocardId?: Maybe<Scalars['Int']>;
    ocardId?: Maybe<Scalars['Int']>;
    selfcardId?: Maybe<Scalars['Int']>;
};
export declare enum CommentCat {
    Text = "TEXT",
    Poll = "POLL",
    Prop = "PROP"
}
export declare type CommentCount = {
    __typename?: 'CommentCount';
    id: Scalars['ID'];
    nViews: Scalars['Int'];
    nUps: Scalars['Int'];
    nDowns: Scalars['Int'];
};
export declare type CommentInput = {
    mark: Scalars['String'];
    src?: Maybe<Scalars['String']>;
    text: Scalars['String'];
    poll?: Maybe<PollInput>;
};
export declare type CommentLike = {
    __typename?: 'CommentLike';
    id: Scalars['ID'];
    commentId: Scalars['Int'];
    choice: LikeChoice;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type CommentLikeResonse = {
    __typename?: 'CommentLikeResonse';
    like: CommentLike;
    count: CommentCount;
};
export declare type CommentProps = {
    __typename?: 'CommentProps';
    validator?: Maybe<Scalars['String']>;
    showAs?: Maybe<Scalars['String']>;
    showReplyDir?: Maybe<Scalars['String']>;
    disableReply?: Maybe<Scalars['Boolean']>;
};
export declare enum CommentStatus {
    Active = "ACTIVE",
    Lock = "LOCK",
    Deleted = "DELETED",
    Reported = "REPORTED",
    Archived = "ARCHIVED"
}
export declare enum CommitAction {
    Create = "CREATE",
    Update = "UPDATE",
    Delete = "DELETE",
    Merge = "MERGE"
}
export declare enum CommitStatus {
    Review = "REVIEW",
    Pass = "PASS",
    Reject = "REJECT"
}
export declare type Follow = {
    __typename?: 'Follow';
    id: Scalars['ID'];
    symbolId: Scalars['Int'];
    followed: Scalars['Boolean'];
    updatedAt: Scalars['DateTime'];
};
export declare type FollowInput = {
    symbolId: Scalars['ID'];
    followed: Scalars['Boolean'];
};
export declare enum LikeChoice {
    Up = "UP",
    Down = "DOWN",
    Neutral = "NEUTRAL"
}
export declare type LikeInput = {
    choice: LikeChoice;
};
export declare type Linemeta = {
    __typename?: 'Linemeta';
    linenumber: Scalars['Int'];
    userId: Scalars['String'];
    anchorId: Scalars['Int'];
    stampId: Scalars['String'];
    src?: Maybe<Scalars['String']>;
    reply?: Maybe<Scalars['Boolean']>;
    poll?: Maybe<Scalars['Boolean']>;
    broken?: Maybe<Scalars['Boolean']>;
    nested?: Maybe<Scalars['Boolean']>;
    pollId?: Maybe<Scalars['Int']>;
    commentId?: Maybe<Scalars['Int']>;
};
export declare type LinemetaInput = {
    linenumber: Scalars['Int'];
    userId?: Maybe<Scalars['String']>;
    anchorId?: Maybe<Scalars['Int']>;
    stampId: Scalars['String'];
    src?: Maybe<Scalars['String']>;
    new?: Maybe<Scalars['Boolean']>;
    reply?: Maybe<Scalars['Boolean']>;
    poll?: Maybe<Scalars['Boolean']>;
    broken?: Maybe<Scalars['Boolean']>;
    nested?: Maybe<Scalars['Boolean']>;
    pollId?: Maybe<Scalars['Int']>;
    commentId?: Maybe<Scalars['Int']>;
    nestedCard?: Maybe<CardIdentifierInput>;
    marker?: Maybe<MarkerInput>;
};
export declare type Link = {
    __typename?: 'Link';
    id: Scalars['ID'];
    url: Scalars['String'];
    domain: Scalars['String'];
    srcType: Scalars['String'];
    srcId?: Maybe<Scalars['String']>;
    oauthorName?: Maybe<Scalars['String']>;
};
export declare type MarkerInput = {
    mark: Scalars['String'];
    value: Scalars['String'];
};
export declare type Mutation = {
    __typename?: 'Mutation';
    createWebCardBody: CardBody;
    createReply: Reply;
    createVote: Vote;
    createAnchorLike: AnchorLikeResonse;
    updateAnchorLike: AnchorLikeResonse;
    createCommentLike: CommentLikeResonse;
    updateCommentLike: CommentLikeResonse;
    createReplyLike: ReplyLikeResonse;
    updateReplyLike: ReplyLikeResonse;
};
export declare type MutationCreateWebCardBodyArgs = {
    cardId: Scalars['ID'];
    data: CardBodyInput;
};
export declare type MutationCreateReplyArgs = {
    commentId: Scalars['ID'];
    data: ReplyInput;
};
export declare type MutationCreateVoteArgs = {
    pollId: Scalars['ID'];
    choiceIdx: Scalars['Int'];
};
export declare type MutationCreateAnchorLikeArgs = {
    anchorId: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationUpdateAnchorLikeArgs = {
    id: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationCreateCommentLikeArgs = {
    commentId: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationUpdateCommentLikeArgs = {
    id: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationCreateReplyLikeArgs = {
    replyId: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationUpdateReplyLikeArgs = {
    id: Scalars['ID'];
    data: LikeInput;
};
export declare type Ocard = {
    __typename?: 'Ocard';
    id: Scalars['ID'];
    template: CardTemplate;
    symbol: Symbol;
    oauthorName: Scalars['String'];
    body: CardBody;
};
export declare type Poll = {
    __typename?: 'Poll';
    id: Scalars['ID'];
    commentId: Scalars['Int'];
    choices: Array<Scalars['String']>;
    count: PollCount;
    createdAt: Scalars['DateTime'];
};
export declare enum PollCat {
    Fixed = "FIXED",
    Add = "ADD",
    AddByPost = "ADD_BY_POST"
}
export declare type PollCount = {
    __typename?: 'PollCount';
    id: Scalars['ID'];
    nVotes: Array<Scalars['Int']>;
};
export declare type PollInput = {
    choices: Array<Scalars['String']>;
};
export declare type PollJudgment = {
    __typename?: 'PollJudgment';
    id: Scalars['ID'];
    pollId: Scalars['Int'];
    choice: Scalars['Int'];
    comment: Comment;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type PollJudgmentInput = {
    choice: Scalars['Int'];
};
export declare type PollLike = {
    __typename?: 'PollLike';
    id: Scalars['ID'];
    pollId: Scalars['Int'];
    choice: LikeChoice;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type PollLikeResonse = {
    __typename?: 'PollLikeResonse';
    like: PollLike;
    count: PollCount;
};
export declare enum PollStatus {
    Open = "OPEN",
    Judge = "JUDGE",
    CloseSuccess = "CLOSE_SUCCESS",
    CloseFail = "CLOSE_FAIL"
}
export declare enum PostCat {
    Link = "LINK",
    Reply = "REPLY"
}
export declare enum PostStatus {
    Active = "ACTIVE",
    Lock = "LOCK",
    Deleted = "DELETED",
    Reported = "REPORTED",
    Archived = "ARCHIVED"
}
export declare type Query = {
    __typename?: 'Query';
    searchAll: Array<Scalars['String']>;
    searchTopic: Array<Scalars['String']>;
    latestCards: Array<Cocard>;
    link?: Maybe<Link>;
    cocard: Cocard;
    ocard?: Maybe<Ocard>;
    selfcard?: Maybe<Selfcard>;
    mycard?: Maybe<Selfcard>;
    anchor?: Maybe<Anchor>;
    comment?: Maybe<Comment>;
    replies: Array<Reply>;
    me: User;
    myVotes: Array<Vote>;
    myAnchorLikes: Array<AnchorLike>;
    myCommentLikes: Array<CommentLike>;
    myReplyLikes: Array<ReplyLike>;
};
export declare type QuerySearchAllArgs = {
    term: Scalars['String'];
};
export declare type QuerySearchTopicArgs = {
    term: Scalars['String'];
};
export declare type QueryLatestCardsArgs = {
    afterId?: Maybe<Scalars['String']>;
};
export declare type QueryLinkArgs = {
    url: Scalars['String'];
};
export declare type QueryCocardArgs = {
    url?: Maybe<Scalars['String']>;
    symbol?: Maybe<Scalars['String']>;
};
export declare type QueryOcardArgs = {
    id?: Maybe<Scalars['ID']>;
    oauthorName?: Maybe<Scalars['String']>;
    symbolName?: Maybe<Scalars['String']>;
};
export declare type QuerySelfcardArgs = {
    id: Scalars['ID'];
};
export declare type QueryMycardArgs = {
    symbolName: Scalars['String'];
};
export declare type QueryAnchorArgs = {
    id: Scalars['ID'];
};
export declare type QueryCommentArgs = {
    id: Scalars['ID'];
};
export declare type QueryRepliesArgs = {
    commentId: Scalars['ID'];
    afterId?: Maybe<Scalars['ID']>;
};
export declare type QueryMyVotesArgs = {
    after?: Maybe<Scalars['String']>;
};
export declare type QueryMyAnchorLikesArgs = {
    after?: Maybe<Scalars['String']>;
};
export declare type QueryMyCommentLikesArgs = {
    after?: Maybe<Scalars['String']>;
};
export declare type QueryMyReplyLikesArgs = {
    after?: Maybe<Scalars['String']>;
};
export declare type Reply = {
    __typename?: 'Reply';
    id: Scalars['ID'];
    userId: Scalars['String'];
    isTop?: Maybe<Scalars['Boolean']>;
    text: Scalars['String'];
    count: ReplyCount;
    updatedAt: Scalars['DateTime'];
    props?: Maybe<ReplyProps>;
};
export declare type ReplyCount = {
    __typename?: 'ReplyCount';
    id: Scalars['ID'];
    nViews: Scalars['Int'];
    nUps: Scalars['Int'];
    nDowns: Scalars['Int'];
};
export declare type ReplyInput = {
    text: Scalars['String'];
};
export declare type ReplyLike = {
    __typename?: 'ReplyLike';
    id: Scalars['ID'];
    replyId: Scalars['Int'];
    choice: LikeChoice;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type ReplyLikeResonse = {
    __typename?: 'ReplyLikeResonse';
    like: ReplyLike;
    count: ReplyCount;
};
export declare type ReplyProps = {
    __typename?: 'ReplyProps';
    label?: Maybe<Scalars['String']>;
    disableUpndown?: Maybe<Scalars['Boolean']>;
};
export declare type Selfcard = {
    __typename?: 'Selfcard';
    id: Scalars['ID'];
    template: CardTemplate;
    symbol: Symbol;
    body: CardBody;
};
export declare type Symbol = {
    __typename?: 'Symbol';
    id: Scalars['ID'];
    name: Scalars['String'];
    cat: SymbolCat;
    status: SymbolStatus;
    body?: Maybe<Scalars['String']>;
    sys?: Maybe<Scalars['String']>;
    ticks: Array<Tick>;
};
export declare enum SymbolCat {
    Ticker = "TICKER",
    Topic = "TOPIC"
}
export declare enum SymbolStatus {
    Active = "ACTIVE",
    Reported = "REPORTED",
    Archived = "ARCHIVED",
    Duplicated = "DUPLICATED"
}
export declare type Tick = {
    __typename?: 'Tick';
    id: Scalars['ID'];
    symbolId: Scalars['Int'];
    value: Scalars['Float'];
    at: Scalars['DateTime'];
};
export declare type User = {
    __typename?: 'User';
    id: Scalars['ID'];
    email: Scalars['String'];
};
export declare type Vote = {
    __typename?: 'Vote';
    id: Scalars['ID'];
    pollId: Scalars['Int'];
    choiceIdx: Scalars['Int'];
};
export declare type VoteInput = {
    choiceId: Scalars['ID'];
};
export declare type VoteFragment = {
    __typename: 'Vote';
    id: string;
    pollId: number;
    choiceIdx: number;
};
export declare type PollFragment = {
    __typename: 'Poll';
    id: string;
    commentId: number;
    choices: Array<string>;
    createdAt: any;
    count: {
        __typename?: 'PollCount';
        id: string;
        nVotes: Array<number>;
    };
};
export declare type AnchorLikeFragment = {
    __typename: 'AnchorLike';
    id: string;
    anchorId: number;
    choice: LikeChoice;
    createdAt: any;
    updatedAt: any;
};
export declare type AnchorCountFragment = {
    __typename: 'AnchorCount';
    id: string;
    nViews: number;
    nUps: number;
    nDowns: number;
};
export declare type AnchorFragment = {
    __typename: 'Anchor';
    id: string;
    userId: string;
    cocardId?: Maybe<number>;
    ocardId?: Maybe<number>;
    selfcardId?: Maybe<number>;
    count: ({
        __typename?: 'AnchorCount';
    } & AnchorCountFragment);
};
export declare type ReplyCountFragment = {
    __typename: 'ReplyCount';
    id: string;
    nViews: number;
    nUps: number;
    nDowns: number;
};
export declare type CommentCountFragment = {
    __typename: 'CommentCount';
    id: string;
    nViews: number;
    nUps: number;
    nDowns: number;
};
export declare type ReplyFragment = {
    __typename: 'Reply';
    id: string;
    userId: string;
    isTop?: Maybe<boolean>;
    text: string;
    updatedAt: any;
    count: ({
        __typename?: 'ReplyCount';
    } & ReplyCountFragment);
};
export declare type CommentFragment = {
    __typename: 'Comment';
    id: string;
    userId: string;
    cocardId?: Maybe<number>;
    ocardId?: Maybe<number>;
    selfcardId?: Maybe<number>;
    isTop?: Maybe<boolean>;
    text?: Maybe<string>;
    createdAt: any;
    meta?: Maybe<any>;
    poll?: Maybe<({
        __typename?: 'Poll';
    } & PollFragment)>;
    count: ({
        __typename?: 'CommentCount';
    } & CommentCountFragment);
};
export declare type CommentLikeFragment = {
    __typename: 'CommentLike';
    id: string;
    commentId: number;
    choice: LikeChoice;
    updatedAt: any;
};
export declare type ReplyLikeFragment = {
    __typename: 'ReplyLike';
    id: string;
    replyId: number;
    choice: LikeChoice;
    updatedAt: any;
};
export declare type LinkFragment = {
    __typename: 'Link';
    id: string;
    url: string;
    domain: string;
    srcType: string;
    srcId?: Maybe<string>;
    oauthorName?: Maybe<string>;
};
export declare type CardBodyFragment = {
    __typename: 'CardBody';
    id: string;
    userId: string;
    meta: any;
    text: string;
    prevId?: Maybe<number>;
};
export declare type CocardFragment = {
    __typename: 'Cocard';
    id: string;
    template: CardTemplate;
    meta: any;
    body?: Maybe<({
        __typename?: 'CardBody';
    } & CardBodyFragment)>;
    link: ({
        __typename?: 'Link';
    } & LinkFragment);
};
export declare type OcardFragment = {
    __typename: 'Ocard';
    id: string;
    template: CardTemplate;
    oauthorName: string;
    body: ({
        __typename?: 'CardBody';
    } & CardBodyFragment);
    symbol: {
        __typename?: 'Symbol';
        name: string;
        cat: SymbolCat;
    };
};
export declare type SelfcardFragment = {
    __typename: 'Selfcard';
    id: string;
    template: CardTemplate;
    body: ({
        __typename?: 'CardBody';
    } & CardBodyFragment);
    symbol: {
        __typename?: 'Symbol';
        name: string;
        cat: SymbolCat;
    };
};
export declare type LatestCardsQueryVariables = Exact<{
    afterId?: Maybe<Scalars['String']>;
}>;
export declare type LatestCardsQuery = {
    __typename?: 'Query';
    latestCards: Array<({
        __typename?: 'Cocard';
    } & CocardFragment)>;
};
export declare type LinkQueryVariables = Exact<{
    url: Scalars['String'];
}>;
export declare type LinkQuery = {
    __typename?: 'Query';
    link?: Maybe<({
        __typename?: 'Link';
    } & LinkFragment)>;
};
export declare type CocardQueryVariables = Exact<{
    url?: Maybe<Scalars['String']>;
    symbol?: Maybe<Scalars['String']>;
}>;
export declare type CocardQuery = {
    __typename?: 'Query';
    cocard: ({
        __typename?: 'Cocard';
    } & CocardFragment);
};
export declare type OcardQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
    oauthorName?: Maybe<Scalars['String']>;
    symbolName?: Maybe<Scalars['String']>;
}>;
export declare type OcardQuery = {
    __typename?: 'Query';
    ocard?: Maybe<({
        __typename?: 'Ocard';
    } & OcardFragment)>;
};
export declare type SelfcardQueryVariables = Exact<{
    id: Scalars['ID'];
}>;
export declare type SelfcardQuery = {
    __typename?: 'Query';
    selfcard?: Maybe<({
        __typename?: 'Selfcard';
    } & SelfcardFragment)>;
};
export declare type MycardQueryVariables = Exact<{
    symbolName: Scalars['String'];
}>;
export declare type MycardQuery = {
    __typename?: 'Query';
    mycard?: Maybe<({
        __typename?: 'Selfcard';
    } & SelfcardFragment)>;
};
export declare type AnchorQueryVariables = Exact<{
    id: Scalars['ID'];
}>;
export declare type AnchorQuery = {
    __typename?: 'Query';
    anchor?: Maybe<({
        __typename?: 'Anchor';
    } & AnchorFragment)>;
};
export declare type CommentQueryVariables = Exact<{
    id: Scalars['ID'];
}>;
export declare type CommentQuery = {
    __typename?: 'Query';
    comment?: Maybe<({
        __typename?: 'Comment';
    } & CommentFragment)>;
};
export declare type RepliesQueryVariables = Exact<{
    commentId: Scalars['ID'];
    afterId?: Maybe<Scalars['ID']>;
}>;
export declare type RepliesQuery = {
    __typename?: 'Query';
    replies: Array<({
        __typename?: 'Reply';
    } & ReplyFragment)>;
};
export declare type MyAnchorLikesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type MyAnchorLikesQuery = {
    __typename?: 'Query';
    myAnchorLikes: Array<({
        __typename?: 'AnchorLike';
    } & AnchorLikeFragment)>;
};
export declare type MyCommentLikesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type MyCommentLikesQuery = {
    __typename?: 'Query';
    myCommentLikes: Array<({
        __typename?: 'CommentLike';
    } & CommentLikeFragment)>;
};
export declare type MyReplyLikesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type MyReplyLikesQuery = {
    __typename?: 'Query';
    myReplyLikes: Array<({
        __typename?: 'ReplyLike';
    } & ReplyLikeFragment)>;
};
export declare type MyVotesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type MyVotesQuery = {
    __typename?: 'Query';
    myVotes: Array<({
        __typename?: 'Vote';
    } & VoteFragment)>;
};
export declare type MeQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type MeQuery = {
    __typename?: 'Query';
    me: {
        __typename?: 'User';
        id: string;
    };
};
export declare type SearchAllQueryVariables = Exact<{
    term: Scalars['String'];
}>;
export declare type SearchAllQuery = {
    __typename?: 'Query';
    searchAll: Array<string>;
};
export declare type CreateWebCardBodyMutationVariables = Exact<{
    cardId: Scalars['ID'];
    data: CardBodyInput;
}>;
export declare type CreateWebCardBodyMutation = {
    __typename?: 'Mutation';
    createWebCardBody: ({
        __typename?: 'CardBody';
    } & CardBodyFragment);
};
export declare type CreateReplyMutationVariables = Exact<{
    commentId: Scalars['ID'];
    data: ReplyInput;
}>;
export declare type CreateReplyMutation = {
    __typename?: 'Mutation';
    createReply: ({
        __typename?: 'Reply';
    } & ReplyFragment);
};
export declare type CreateVoteMutationVariables = Exact<{
    pollId: Scalars['ID'];
    choiceIdx: Scalars['Int'];
}>;
export declare type CreateVoteMutation = {
    __typename?: 'Mutation';
    createVote: ({
        __typename?: 'Vote';
    } & VoteFragment);
};
export declare type CreateAnchorLikeMutationVariables = Exact<{
    anchorId: Scalars['ID'];
    data: LikeInput;
}>;
export declare type CreateAnchorLikeMutation = {
    __typename?: 'Mutation';
    createAnchorLike: {
        __typename?: 'AnchorLikeResonse';
        like: ({
            __typename?: 'AnchorLike';
        } & AnchorLikeFragment);
        count: ({
            __typename?: 'AnchorCount';
        } & AnchorCountFragment);
    };
};
export declare type UpdateAnchorLikeMutationVariables = Exact<{
    id: Scalars['ID'];
    data: LikeInput;
}>;
export declare type UpdateAnchorLikeMutation = {
    __typename?: 'Mutation';
    updateAnchorLike: {
        __typename?: 'AnchorLikeResonse';
        like: ({
            __typename?: 'AnchorLike';
        } & AnchorLikeFragment);
        count: ({
            __typename?: 'AnchorCount';
        } & AnchorCountFragment);
    };
};
export declare type CreateCommentLikeMutationVariables = Exact<{
    commentId: Scalars['ID'];
    data: LikeInput;
}>;
export declare type CreateCommentLikeMutation = {
    __typename?: 'Mutation';
    createCommentLike: {
        __typename?: 'CommentLikeResonse';
        like: ({
            __typename?: 'CommentLike';
        } & CommentLikeFragment);
        count: ({
            __typename?: 'CommentCount';
        } & CommentCountFragment);
    };
};
export declare type UpdateCommentLikeMutationVariables = Exact<{
    id: Scalars['ID'];
    data: LikeInput;
}>;
export declare type UpdateCommentLikeMutation = {
    __typename?: 'Mutation';
    updateCommentLike: {
        __typename?: 'CommentLikeResonse';
        like: ({
            __typename?: 'CommentLike';
        } & CommentLikeFragment);
        count: ({
            __typename?: 'CommentCount';
        } & CommentCountFragment);
    };
};
export declare type CreateReplyLikeMutationVariables = Exact<{
    replyId: Scalars['ID'];
    data: LikeInput;
}>;
export declare type CreateReplyLikeMutation = {
    __typename?: 'Mutation';
    createReplyLike: {
        __typename?: 'ReplyLikeResonse';
        like: ({
            __typename?: 'ReplyLike';
        } & ReplyLikeFragment);
        count: ({
            __typename?: 'ReplyCount';
        } & ReplyCountFragment);
    };
};
export declare type UpdateReplyLikeMutationVariables = Exact<{
    id: Scalars['ID'];
    data: LikeInput;
}>;
export declare type UpdateReplyLikeMutation = {
    __typename?: 'Mutation';
    updateReplyLike: {
        __typename?: 'ReplyLikeResonse';
        like: ({
            __typename?: 'ReplyLike';
        } & ReplyLikeFragment);
        count: ({
            __typename?: 'ReplyCount';
        } & ReplyCountFragment);
    };
};
export declare const VoteFragmentDoc: Apollo.DocumentNode;
export declare const AnchorLikeFragmentDoc: Apollo.DocumentNode;
export declare const AnchorCountFragmentDoc: Apollo.DocumentNode;
export declare const AnchorFragmentDoc: Apollo.DocumentNode;
export declare const ReplyCountFragmentDoc: Apollo.DocumentNode;
export declare const ReplyFragmentDoc: Apollo.DocumentNode;
export declare const PollFragmentDoc: Apollo.DocumentNode;
export declare const CommentCountFragmentDoc: Apollo.DocumentNode;
export declare const CommentFragmentDoc: Apollo.DocumentNode;
export declare const CommentLikeFragmentDoc: Apollo.DocumentNode;
export declare const ReplyLikeFragmentDoc: Apollo.DocumentNode;
export declare const CardBodyFragmentDoc: Apollo.DocumentNode;
export declare const LinkFragmentDoc: Apollo.DocumentNode;
export declare const CocardFragmentDoc: Apollo.DocumentNode;
export declare const OcardFragmentDoc: Apollo.DocumentNode;
export declare const SelfcardFragmentDoc: Apollo.DocumentNode;
export declare const LatestCardsDocument: Apollo.DocumentNode;
/**
 * __useLatestCardsQuery__
 *
 * To run a query within a React component, call `useLatestCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useLatestCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLatestCardsQuery({
 *   variables: {
 *      afterId: // value for 'afterId'
 *   },
 * });
 */
export declare function useLatestCardsQuery(baseOptions?: Apollo.QueryHookOptions<LatestCardsQuery, LatestCardsQueryVariables>): Apollo.QueryResult<LatestCardsQuery, Exact<{
    afterId?: Maybe<string> | undefined;
}>>;
export declare function useLatestCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LatestCardsQuery, LatestCardsQueryVariables>): Apollo.QueryTuple<LatestCardsQuery, Exact<{
    afterId?: Maybe<string> | undefined;
}>>;
export declare type LatestCardsQueryHookResult = ReturnType<typeof useLatestCardsQuery>;
export declare type LatestCardsLazyQueryHookResult = ReturnType<typeof useLatestCardsLazyQuery>;
export declare type LatestCardsQueryResult = Apollo.QueryResult<LatestCardsQuery, LatestCardsQueryVariables>;
export declare const LinkDocument: Apollo.DocumentNode;
/**
 * __useLinkQuery__
 *
 * To run a query within a React component, call `useLinkQuery` and pass it any options that fit your needs.
 * When your component renders, `useLinkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLinkQuery({
 *   variables: {
 *      url: // value for 'url'
 *   },
 * });
 */
export declare function useLinkQuery(baseOptions: Apollo.QueryHookOptions<LinkQuery, LinkQueryVariables>): Apollo.QueryResult<LinkQuery, Exact<{
    url: string;
}>>;
export declare function useLinkLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LinkQuery, LinkQueryVariables>): Apollo.QueryTuple<LinkQuery, Exact<{
    url: string;
}>>;
export declare type LinkQueryHookResult = ReturnType<typeof useLinkQuery>;
export declare type LinkLazyQueryHookResult = ReturnType<typeof useLinkLazyQuery>;
export declare type LinkQueryResult = Apollo.QueryResult<LinkQuery, LinkQueryVariables>;
export declare const CocardDocument: Apollo.DocumentNode;
/**
 * __useCocardQuery__
 *
 * To run a query within a React component, call `useCocardQuery` and pass it any options that fit your needs.
 * When your component renders, `useCocardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCocardQuery({
 *   variables: {
 *      url: // value for 'url'
 *      symbol: // value for 'symbol'
 *   },
 * });
 */
export declare function useCocardQuery(baseOptions?: Apollo.QueryHookOptions<CocardQuery, CocardQueryVariables>): Apollo.QueryResult<CocardQuery, Exact<{
    url?: Maybe<string> | undefined;
    symbol?: Maybe<string> | undefined;
}>>;
export declare function useCocardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CocardQuery, CocardQueryVariables>): Apollo.QueryTuple<CocardQuery, Exact<{
    url?: Maybe<string> | undefined;
    symbol?: Maybe<string> | undefined;
}>>;
export declare type CocardQueryHookResult = ReturnType<typeof useCocardQuery>;
export declare type CocardLazyQueryHookResult = ReturnType<typeof useCocardLazyQuery>;
export declare type CocardQueryResult = Apollo.QueryResult<CocardQuery, CocardQueryVariables>;
export declare const OcardDocument: Apollo.DocumentNode;
/**
 * __useOcardQuery__
 *
 * To run a query within a React component, call `useOcardQuery` and pass it any options that fit your needs.
 * When your component renders, `useOcardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOcardQuery({
 *   variables: {
 *      id: // value for 'id'
 *      oauthorName: // value for 'oauthorName'
 *      symbolName: // value for 'symbolName'
 *   },
 * });
 */
export declare function useOcardQuery(baseOptions?: Apollo.QueryHookOptions<OcardQuery, OcardQueryVariables>): Apollo.QueryResult<OcardQuery, Exact<{
    id?: Maybe<string> | undefined;
    oauthorName?: Maybe<string> | undefined;
    symbolName?: Maybe<string> | undefined;
}>>;
export declare function useOcardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OcardQuery, OcardQueryVariables>): Apollo.QueryTuple<OcardQuery, Exact<{
    id?: Maybe<string> | undefined;
    oauthorName?: Maybe<string> | undefined;
    symbolName?: Maybe<string> | undefined;
}>>;
export declare type OcardQueryHookResult = ReturnType<typeof useOcardQuery>;
export declare type OcardLazyQueryHookResult = ReturnType<typeof useOcardLazyQuery>;
export declare type OcardQueryResult = Apollo.QueryResult<OcardQuery, OcardQueryVariables>;
export declare const SelfcardDocument: Apollo.DocumentNode;
/**
 * __useSelfcardQuery__
 *
 * To run a query within a React component, call `useSelfcardQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelfcardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelfcardQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useSelfcardQuery(baseOptions: Apollo.QueryHookOptions<SelfcardQuery, SelfcardQueryVariables>): Apollo.QueryResult<SelfcardQuery, Exact<{
    id: string;
}>>;
export declare function useSelfcardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelfcardQuery, SelfcardQueryVariables>): Apollo.QueryTuple<SelfcardQuery, Exact<{
    id: string;
}>>;
export declare type SelfcardQueryHookResult = ReturnType<typeof useSelfcardQuery>;
export declare type SelfcardLazyQueryHookResult = ReturnType<typeof useSelfcardLazyQuery>;
export declare type SelfcardQueryResult = Apollo.QueryResult<SelfcardQuery, SelfcardQueryVariables>;
export declare const MycardDocument: Apollo.DocumentNode;
/**
 * __useMycardQuery__
 *
 * To run a query within a React component, call `useMycardQuery` and pass it any options that fit your needs.
 * When your component renders, `useMycardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMycardQuery({
 *   variables: {
 *      symbolName: // value for 'symbolName'
 *   },
 * });
 */
export declare function useMycardQuery(baseOptions: Apollo.QueryHookOptions<MycardQuery, MycardQueryVariables>): Apollo.QueryResult<MycardQuery, Exact<{
    symbolName: string;
}>>;
export declare function useMycardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MycardQuery, MycardQueryVariables>): Apollo.QueryTuple<MycardQuery, Exact<{
    symbolName: string;
}>>;
export declare type MycardQueryHookResult = ReturnType<typeof useMycardQuery>;
export declare type MycardLazyQueryHookResult = ReturnType<typeof useMycardLazyQuery>;
export declare type MycardQueryResult = Apollo.QueryResult<MycardQuery, MycardQueryVariables>;
export declare const AnchorDocument: Apollo.DocumentNode;
/**
 * __useAnchorQuery__
 *
 * To run a query within a React component, call `useAnchorQuery` and pass it any options that fit your needs.
 * When your component renders, `useAnchorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAnchorQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useAnchorQuery(baseOptions: Apollo.QueryHookOptions<AnchorQuery, AnchorQueryVariables>): Apollo.QueryResult<AnchorQuery, Exact<{
    id: string;
}>>;
export declare function useAnchorLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AnchorQuery, AnchorQueryVariables>): Apollo.QueryTuple<AnchorQuery, Exact<{
    id: string;
}>>;
export declare type AnchorQueryHookResult = ReturnType<typeof useAnchorQuery>;
export declare type AnchorLazyQueryHookResult = ReturnType<typeof useAnchorLazyQuery>;
export declare type AnchorQueryResult = Apollo.QueryResult<AnchorQuery, AnchorQueryVariables>;
export declare const CommentDocument: Apollo.DocumentNode;
/**
 * __useCommentQuery__
 *
 * To run a query within a React component, call `useCommentQuery` and pass it any options that fit your needs.
 * When your component renders, `useCommentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCommentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useCommentQuery(baseOptions: Apollo.QueryHookOptions<CommentQuery, CommentQueryVariables>): Apollo.QueryResult<CommentQuery, Exact<{
    id: string;
}>>;
export declare function useCommentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CommentQuery, CommentQueryVariables>): Apollo.QueryTuple<CommentQuery, Exact<{
    id: string;
}>>;
export declare type CommentQueryHookResult = ReturnType<typeof useCommentQuery>;
export declare type CommentLazyQueryHookResult = ReturnType<typeof useCommentLazyQuery>;
export declare type CommentQueryResult = Apollo.QueryResult<CommentQuery, CommentQueryVariables>;
export declare const RepliesDocument: Apollo.DocumentNode;
/**
 * __useRepliesQuery__
 *
 * To run a query within a React component, call `useRepliesQuery` and pass it any options that fit your needs.
 * When your component renders, `useRepliesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRepliesQuery({
 *   variables: {
 *      commentId: // value for 'commentId'
 *      afterId: // value for 'afterId'
 *   },
 * });
 */
export declare function useRepliesQuery(baseOptions: Apollo.QueryHookOptions<RepliesQuery, RepliesQueryVariables>): Apollo.QueryResult<RepliesQuery, Exact<{
    commentId: string;
    afterId?: Maybe<string> | undefined;
}>>;
export declare function useRepliesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RepliesQuery, RepliesQueryVariables>): Apollo.QueryTuple<RepliesQuery, Exact<{
    commentId: string;
    afterId?: Maybe<string> | undefined;
}>>;
export declare type RepliesQueryHookResult = ReturnType<typeof useRepliesQuery>;
export declare type RepliesLazyQueryHookResult = ReturnType<typeof useRepliesLazyQuery>;
export declare type RepliesQueryResult = Apollo.QueryResult<RepliesQuery, RepliesQueryVariables>;
export declare const MyAnchorLikesDocument: Apollo.DocumentNode;
/**
 * __useMyAnchorLikesQuery__
 *
 * To run a query within a React component, call `useMyAnchorLikesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyAnchorLikesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyAnchorLikesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useMyAnchorLikesQuery(baseOptions?: Apollo.QueryHookOptions<MyAnchorLikesQuery, MyAnchorLikesQueryVariables>): Apollo.QueryResult<MyAnchorLikesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useMyAnchorLikesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyAnchorLikesQuery, MyAnchorLikesQueryVariables>): Apollo.QueryTuple<MyAnchorLikesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type MyAnchorLikesQueryHookResult = ReturnType<typeof useMyAnchorLikesQuery>;
export declare type MyAnchorLikesLazyQueryHookResult = ReturnType<typeof useMyAnchorLikesLazyQuery>;
export declare type MyAnchorLikesQueryResult = Apollo.QueryResult<MyAnchorLikesQuery, MyAnchorLikesQueryVariables>;
export declare const MyCommentLikesDocument: Apollo.DocumentNode;
/**
 * __useMyCommentLikesQuery__
 *
 * To run a query within a React component, call `useMyCommentLikesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyCommentLikesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyCommentLikesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useMyCommentLikesQuery(baseOptions?: Apollo.QueryHookOptions<MyCommentLikesQuery, MyCommentLikesQueryVariables>): Apollo.QueryResult<MyCommentLikesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useMyCommentLikesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyCommentLikesQuery, MyCommentLikesQueryVariables>): Apollo.QueryTuple<MyCommentLikesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type MyCommentLikesQueryHookResult = ReturnType<typeof useMyCommentLikesQuery>;
export declare type MyCommentLikesLazyQueryHookResult = ReturnType<typeof useMyCommentLikesLazyQuery>;
export declare type MyCommentLikesQueryResult = Apollo.QueryResult<MyCommentLikesQuery, MyCommentLikesQueryVariables>;
export declare const MyReplyLikesDocument: Apollo.DocumentNode;
/**
 * __useMyReplyLikesQuery__
 *
 * To run a query within a React component, call `useMyReplyLikesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyReplyLikesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyReplyLikesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useMyReplyLikesQuery(baseOptions?: Apollo.QueryHookOptions<MyReplyLikesQuery, MyReplyLikesQueryVariables>): Apollo.QueryResult<MyReplyLikesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useMyReplyLikesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyReplyLikesQuery, MyReplyLikesQueryVariables>): Apollo.QueryTuple<MyReplyLikesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type MyReplyLikesQueryHookResult = ReturnType<typeof useMyReplyLikesQuery>;
export declare type MyReplyLikesLazyQueryHookResult = ReturnType<typeof useMyReplyLikesLazyQuery>;
export declare type MyReplyLikesQueryResult = Apollo.QueryResult<MyReplyLikesQuery, MyReplyLikesQueryVariables>;
export declare const MyVotesDocument: Apollo.DocumentNode;
/**
 * __useMyVotesQuery__
 *
 * To run a query within a React component, call `useMyVotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyVotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyVotesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useMyVotesQuery(baseOptions?: Apollo.QueryHookOptions<MyVotesQuery, MyVotesQueryVariables>): Apollo.QueryResult<MyVotesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useMyVotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyVotesQuery, MyVotesQueryVariables>): Apollo.QueryTuple<MyVotesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type MyVotesQueryHookResult = ReturnType<typeof useMyVotesQuery>;
export declare type MyVotesLazyQueryHookResult = ReturnType<typeof useMyVotesLazyQuery>;
export declare type MyVotesQueryResult = Apollo.QueryResult<MyVotesQuery, MyVotesQueryVariables>;
export declare const MeDocument: Apollo.DocumentNode;
/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>): Apollo.QueryResult<MeQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>): Apollo.QueryTuple<MeQuery, Exact<{
    [key: string]: never;
}>>;
export declare type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export declare type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export declare type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export declare const SearchAllDocument: Apollo.DocumentNode;
/**
 * __useSearchAllQuery__
 *
 * To run a query within a React component, call `useSearchAllQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchAllQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchAllQuery({
 *   variables: {
 *      term: // value for 'term'
 *   },
 * });
 */
export declare function useSearchAllQuery(baseOptions: Apollo.QueryHookOptions<SearchAllQuery, SearchAllQueryVariables>): Apollo.QueryResult<SearchAllQuery, Exact<{
    term: string;
}>>;
export declare function useSearchAllLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchAllQuery, SearchAllQueryVariables>): Apollo.QueryTuple<SearchAllQuery, Exact<{
    term: string;
}>>;
export declare type SearchAllQueryHookResult = ReturnType<typeof useSearchAllQuery>;
export declare type SearchAllLazyQueryHookResult = ReturnType<typeof useSearchAllLazyQuery>;
export declare type SearchAllQueryResult = Apollo.QueryResult<SearchAllQuery, SearchAllQueryVariables>;
export declare const CreateWebCardBodyDocument: Apollo.DocumentNode;
export declare type CreateWebCardBodyMutationFn = Apollo.MutationFunction<CreateWebCardBodyMutation, CreateWebCardBodyMutationVariables>;
/**
 * __useCreateWebCardBodyMutation__
 *
 * To run a mutation, you first call `useCreateWebCardBodyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateWebCardBodyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createWebCardBodyMutation, { data, loading, error }] = useCreateWebCardBodyMutation({
 *   variables: {
 *      cardId: // value for 'cardId'
 *      data: // value for 'data'
 *   },
 * });
 */
export declare function useCreateWebCardBodyMutation(baseOptions?: Apollo.MutationHookOptions<CreateWebCardBodyMutation, CreateWebCardBodyMutationVariables>): Apollo.MutationTuple<CreateWebCardBodyMutation, Exact<{
    cardId: string;
    data: CardBodyInput;
}>>;
export declare type CreateWebCardBodyMutationHookResult = ReturnType<typeof useCreateWebCardBodyMutation>;
export declare type CreateWebCardBodyMutationResult = Apollo.MutationResult<CreateWebCardBodyMutation>;
export declare type CreateWebCardBodyMutationOptions = Apollo.BaseMutationOptions<CreateWebCardBodyMutation, CreateWebCardBodyMutationVariables>;
export declare const CreateReplyDocument: Apollo.DocumentNode;
export declare type CreateReplyMutationFn = Apollo.MutationFunction<CreateReplyMutation, CreateReplyMutationVariables>;
/**
 * __useCreateReplyMutation__
 *
 * To run a mutation, you first call `useCreateReplyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateReplyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createReplyMutation, { data, loading, error }] = useCreateReplyMutation({
 *   variables: {
 *      commentId: // value for 'commentId'
 *      data: // value for 'data'
 *   },
 * });
 */
export declare function useCreateReplyMutation(baseOptions?: Apollo.MutationHookOptions<CreateReplyMutation, CreateReplyMutationVariables>): Apollo.MutationTuple<CreateReplyMutation, Exact<{
    commentId: string;
    data: ReplyInput;
}>>;
export declare type CreateReplyMutationHookResult = ReturnType<typeof useCreateReplyMutation>;
export declare type CreateReplyMutationResult = Apollo.MutationResult<CreateReplyMutation>;
export declare type CreateReplyMutationOptions = Apollo.BaseMutationOptions<CreateReplyMutation, CreateReplyMutationVariables>;
export declare const CreateVoteDocument: Apollo.DocumentNode;
export declare type CreateVoteMutationFn = Apollo.MutationFunction<CreateVoteMutation, CreateVoteMutationVariables>;
/**
 * __useCreateVoteMutation__
 *
 * To run a mutation, you first call `useCreateVoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateVoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createVoteMutation, { data, loading, error }] = useCreateVoteMutation({
 *   variables: {
 *      pollId: // value for 'pollId'
 *      choiceIdx: // value for 'choiceIdx'
 *   },
 * });
 */
export declare function useCreateVoteMutation(baseOptions?: Apollo.MutationHookOptions<CreateVoteMutation, CreateVoteMutationVariables>): Apollo.MutationTuple<CreateVoteMutation, Exact<{
    pollId: string;
    choiceIdx: number;
}>>;
export declare type CreateVoteMutationHookResult = ReturnType<typeof useCreateVoteMutation>;
export declare type CreateVoteMutationResult = Apollo.MutationResult<CreateVoteMutation>;
export declare type CreateVoteMutationOptions = Apollo.BaseMutationOptions<CreateVoteMutation, CreateVoteMutationVariables>;
export declare const CreateAnchorLikeDocument: Apollo.DocumentNode;
export declare type CreateAnchorLikeMutationFn = Apollo.MutationFunction<CreateAnchorLikeMutation, CreateAnchorLikeMutationVariables>;
/**
 * __useCreateAnchorLikeMutation__
 *
 * To run a mutation, you first call `useCreateAnchorLikeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnchorLikeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnchorLikeMutation, { data, loading, error }] = useCreateAnchorLikeMutation({
 *   variables: {
 *      anchorId: // value for 'anchorId'
 *      data: // value for 'data'
 *   },
 * });
 */
export declare function useCreateAnchorLikeMutation(baseOptions?: Apollo.MutationHookOptions<CreateAnchorLikeMutation, CreateAnchorLikeMutationVariables>): Apollo.MutationTuple<CreateAnchorLikeMutation, Exact<{
    anchorId: string;
    data: LikeInput;
}>>;
export declare type CreateAnchorLikeMutationHookResult = ReturnType<typeof useCreateAnchorLikeMutation>;
export declare type CreateAnchorLikeMutationResult = Apollo.MutationResult<CreateAnchorLikeMutation>;
export declare type CreateAnchorLikeMutationOptions = Apollo.BaseMutationOptions<CreateAnchorLikeMutation, CreateAnchorLikeMutationVariables>;
export declare const UpdateAnchorLikeDocument: Apollo.DocumentNode;
export declare type UpdateAnchorLikeMutationFn = Apollo.MutationFunction<UpdateAnchorLikeMutation, UpdateAnchorLikeMutationVariables>;
/**
 * __useUpdateAnchorLikeMutation__
 *
 * To run a mutation, you first call `useUpdateAnchorLikeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAnchorLikeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAnchorLikeMutation, { data, loading, error }] = useUpdateAnchorLikeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export declare function useUpdateAnchorLikeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAnchorLikeMutation, UpdateAnchorLikeMutationVariables>): Apollo.MutationTuple<UpdateAnchorLikeMutation, Exact<{
    id: string;
    data: LikeInput;
}>>;
export declare type UpdateAnchorLikeMutationHookResult = ReturnType<typeof useUpdateAnchorLikeMutation>;
export declare type UpdateAnchorLikeMutationResult = Apollo.MutationResult<UpdateAnchorLikeMutation>;
export declare type UpdateAnchorLikeMutationOptions = Apollo.BaseMutationOptions<UpdateAnchorLikeMutation, UpdateAnchorLikeMutationVariables>;
export declare const CreateCommentLikeDocument: Apollo.DocumentNode;
export declare type CreateCommentLikeMutationFn = Apollo.MutationFunction<CreateCommentLikeMutation, CreateCommentLikeMutationVariables>;
/**
 * __useCreateCommentLikeMutation__
 *
 * To run a mutation, you first call `useCreateCommentLikeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCommentLikeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCommentLikeMutation, { data, loading, error }] = useCreateCommentLikeMutation({
 *   variables: {
 *      commentId: // value for 'commentId'
 *      data: // value for 'data'
 *   },
 * });
 */
export declare function useCreateCommentLikeMutation(baseOptions?: Apollo.MutationHookOptions<CreateCommentLikeMutation, CreateCommentLikeMutationVariables>): Apollo.MutationTuple<CreateCommentLikeMutation, Exact<{
    commentId: string;
    data: LikeInput;
}>>;
export declare type CreateCommentLikeMutationHookResult = ReturnType<typeof useCreateCommentLikeMutation>;
export declare type CreateCommentLikeMutationResult = Apollo.MutationResult<CreateCommentLikeMutation>;
export declare type CreateCommentLikeMutationOptions = Apollo.BaseMutationOptions<CreateCommentLikeMutation, CreateCommentLikeMutationVariables>;
export declare const UpdateCommentLikeDocument: Apollo.DocumentNode;
export declare type UpdateCommentLikeMutationFn = Apollo.MutationFunction<UpdateCommentLikeMutation, UpdateCommentLikeMutationVariables>;
/**
 * __useUpdateCommentLikeMutation__
 *
 * To run a mutation, you first call `useUpdateCommentLikeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCommentLikeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCommentLikeMutation, { data, loading, error }] = useUpdateCommentLikeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export declare function useUpdateCommentLikeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCommentLikeMutation, UpdateCommentLikeMutationVariables>): Apollo.MutationTuple<UpdateCommentLikeMutation, Exact<{
    id: string;
    data: LikeInput;
}>>;
export declare type UpdateCommentLikeMutationHookResult = ReturnType<typeof useUpdateCommentLikeMutation>;
export declare type UpdateCommentLikeMutationResult = Apollo.MutationResult<UpdateCommentLikeMutation>;
export declare type UpdateCommentLikeMutationOptions = Apollo.BaseMutationOptions<UpdateCommentLikeMutation, UpdateCommentLikeMutationVariables>;
export declare const CreateReplyLikeDocument: Apollo.DocumentNode;
export declare type CreateReplyLikeMutationFn = Apollo.MutationFunction<CreateReplyLikeMutation, CreateReplyLikeMutationVariables>;
/**
 * __useCreateReplyLikeMutation__
 *
 * To run a mutation, you first call `useCreateReplyLikeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateReplyLikeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createReplyLikeMutation, { data, loading, error }] = useCreateReplyLikeMutation({
 *   variables: {
 *      replyId: // value for 'replyId'
 *      data: // value for 'data'
 *   },
 * });
 */
export declare function useCreateReplyLikeMutation(baseOptions?: Apollo.MutationHookOptions<CreateReplyLikeMutation, CreateReplyLikeMutationVariables>): Apollo.MutationTuple<CreateReplyLikeMutation, Exact<{
    replyId: string;
    data: LikeInput;
}>>;
export declare type CreateReplyLikeMutationHookResult = ReturnType<typeof useCreateReplyLikeMutation>;
export declare type CreateReplyLikeMutationResult = Apollo.MutationResult<CreateReplyLikeMutation>;
export declare type CreateReplyLikeMutationOptions = Apollo.BaseMutationOptions<CreateReplyLikeMutation, CreateReplyLikeMutationVariables>;
export declare const UpdateReplyLikeDocument: Apollo.DocumentNode;
export declare type UpdateReplyLikeMutationFn = Apollo.MutationFunction<UpdateReplyLikeMutation, UpdateReplyLikeMutationVariables>;
/**
 * __useUpdateReplyLikeMutation__
 *
 * To run a mutation, you first call `useUpdateReplyLikeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateReplyLikeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateReplyLikeMutation, { data, loading, error }] = useUpdateReplyLikeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export declare function useUpdateReplyLikeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateReplyLikeMutation, UpdateReplyLikeMutationVariables>): Apollo.MutationTuple<UpdateReplyLikeMutation, Exact<{
    id: string;
    data: LikeInput;
}>>;
export declare type UpdateReplyLikeMutationHookResult = ReturnType<typeof useUpdateReplyLikeMutation>;
export declare type UpdateReplyLikeMutationResult = Apollo.MutationResult<UpdateReplyLikeMutation>;
export declare type UpdateReplyLikeMutationOptions = Apollo.BaseMutationOptions<UpdateReplyLikeMutation, UpdateReplyLikeMutationVariables>;
