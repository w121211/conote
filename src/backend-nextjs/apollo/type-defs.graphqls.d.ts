/* fd29fdad7987e5802e89e8648de335d50e556987
 * This file is automatically generated by graphql-let. */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export declare type RequireFields<T, K extends keyof T> = {
    [X in Exclude<keyof T, K>]?: T[X];
} & {
    [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    DateTime: any;
    JSON: any;
};
export declare type Anchor = {
    __typename?: 'Anchor';
    id: Scalars['ID'];
    userId: Scalars['String'];
    count: AnchorCount;
    cocardId?: Maybe<Scalars['Int']>;
    ocardId?: Maybe<Scalars['Int']>;
    selfcardId?: Maybe<Scalars['Int']>;
};
export declare type AnchorCount = {
    __typename?: 'AnchorCount';
    id: Scalars['ID'];
    nViews: Scalars['Int'];
    nUps: Scalars['Int'];
    nDowns: Scalars['Int'];
};
export declare type AnchorLike = {
    __typename?: 'AnchorLike';
    id: Scalars['ID'];
    anchorId: Scalars['Int'];
    choice: LikeChoice;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type AnchorLikeResonse = {
    __typename?: 'AnchorLikeResonse';
    like: AnchorLike;
    count: AnchorCount;
};
export declare type AuthPayload = {
    __typename?: 'AuthPayload';
    token: Scalars['String'];
    user: User;
};
export declare type CardBody = {
    __typename?: 'CardBody';
    id: Scalars['ID'];
    userId: Scalars['String'];
    meta: Scalars['JSON'];
    text: Scalars['String'];
    prevId?: Maybe<Scalars['Int']>;
};
export declare type CardBodyInput = {
    text: Scalars['String'];
};
export declare type CardIdInput = {
    id: Scalars['String'];
    type: Scalars['String'];
};
export declare type CardIdentifierInput = {
    symbolName: Scalars['String'];
    oauthorName?: Maybe<Scalars['String']>;
};
export declare enum CardTemplate {
    Ticker = "TICKER",
    Topic = "TOPIC",
    Webpage = "WEBPAGE"
}
export declare type Cocard = {
    __typename?: 'Cocard';
    id: Scalars['ID'];
    template: CardTemplate;
    meta: Scalars['JSON'];
    link: Link;
    body?: Maybe<CardBody>;
};
export declare type Comment = {
    __typename?: 'Comment';
    id: Scalars['ID'];
    userId: Scalars['String'];
    symbols?: Maybe<Array<Symbol>>;
    isTop?: Maybe<Scalars['Boolean']>;
    text?: Maybe<Scalars['String']>;
    count: CommentCount;
    createdAt: Scalars['DateTime'];
    poll?: Maybe<Poll>;
    meta?: Maybe<Scalars['JSON']>;
    cocardId?: Maybe<Scalars['Int']>;
    ocardId?: Maybe<Scalars['Int']>;
    selfcardId?: Maybe<Scalars['Int']>;
};
export declare enum CommentCat {
    Text = "TEXT",
    Poll = "POLL",
    Prop = "PROP"
}
export declare type CommentCount = {
    __typename?: 'CommentCount';
    id: Scalars['ID'];
    nViews: Scalars['Int'];
    nUps: Scalars['Int'];
    nDowns: Scalars['Int'];
};
export declare type CommentInput = {
    mark: Scalars['String'];
    src?: Maybe<Scalars['String']>;
    text: Scalars['String'];
    poll?: Maybe<PollInput>;
};
export declare type CommentLike = {
    __typename?: 'CommentLike';
    id: Scalars['ID'];
    commentId: Scalars['Int'];
    choice: LikeChoice;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type CommentLikeResonse = {
    __typename?: 'CommentLikeResonse';
    like: CommentLike;
    count: CommentCount;
};
export declare type CommentProps = {
    __typename?: 'CommentProps';
    validator?: Maybe<Scalars['String']>;
    showAs?: Maybe<Scalars['String']>;
    showReplyDir?: Maybe<Scalars['String']>;
    disableReply?: Maybe<Scalars['Boolean']>;
};
export declare enum CommentStatus {
    Active = "ACTIVE",
    Lock = "LOCK",
    Deleted = "DELETED",
    Reported = "REPORTED",
    Archived = "ARCHIVED"
}
export declare enum CommitAction {
    Create = "CREATE",
    Update = "UPDATE",
    Delete = "DELETE",
    Merge = "MERGE"
}
export declare enum CommitStatus {
    Review = "REVIEW",
    Pass = "PASS",
    Reject = "REJECT"
}
export declare type Follow = {
    __typename?: 'Follow';
    id: Scalars['ID'];
    symbolId: Scalars['Int'];
    followed: Scalars['Boolean'];
    updatedAt: Scalars['DateTime'];
};
export declare type FollowInput = {
    symbolId: Scalars['ID'];
    followed: Scalars['Boolean'];
};
export declare enum LikeChoice {
    Up = "UP",
    Down = "DOWN",
    Neutral = "NEUTRAL"
}
export declare type LikeInput = {
    choice: LikeChoice;
};
export declare type Linemeta = {
    __typename?: 'Linemeta';
    linenumber: Scalars['Int'];
    userId: Scalars['String'];
    anchorId: Scalars['Int'];
    stampId: Scalars['String'];
    src?: Maybe<Scalars['String']>;
    reply?: Maybe<Scalars['Boolean']>;
    poll?: Maybe<Scalars['Boolean']>;
    broken?: Maybe<Scalars['Boolean']>;
    nested?: Maybe<Scalars['Boolean']>;
    pollId?: Maybe<Scalars['Int']>;
    commentId?: Maybe<Scalars['Int']>;
};
export declare type LinemetaInput = {
    linenumber: Scalars['Int'];
    userId?: Maybe<Scalars['String']>;
    anchorId?: Maybe<Scalars['Int']>;
    stampId: Scalars['String'];
    src?: Maybe<Scalars['String']>;
    new?: Maybe<Scalars['Boolean']>;
    reply?: Maybe<Scalars['Boolean']>;
    poll?: Maybe<Scalars['Boolean']>;
    broken?: Maybe<Scalars['Boolean']>;
    nested?: Maybe<Scalars['Boolean']>;
    pollId?: Maybe<Scalars['Int']>;
    commentId?: Maybe<Scalars['Int']>;
    nestedCard?: Maybe<CardIdentifierInput>;
    marker?: Maybe<MarkerInput>;
};
export declare type Link = {
    __typename?: 'Link';
    id: Scalars['ID'];
    url: Scalars['String'];
    domain: Scalars['String'];
    srcType: Scalars['String'];
    srcId?: Maybe<Scalars['String']>;
    oauthorName?: Maybe<Scalars['String']>;
};
export declare type MarkerInput = {
    mark: Scalars['String'];
    value: Scalars['String'];
};
export declare type Mutation = {
    __typename?: 'Mutation';
    createWebCardBody: CardBody;
    createReply: Reply;
    createVote: Vote;
    createAnchorLike: AnchorLikeResonse;
    updateAnchorLike: AnchorLikeResonse;
    createCommentLike: CommentLikeResonse;
    updateCommentLike: CommentLikeResonse;
    createReplyLike: ReplyLikeResonse;
    updateReplyLike: ReplyLikeResonse;
};
export declare type MutationCreateWebCardBodyArgs = {
    cardId: Scalars['ID'];
    data: CardBodyInput;
};
export declare type MutationCreateReplyArgs = {
    commentId: Scalars['ID'];
    data: ReplyInput;
};
export declare type MutationCreateVoteArgs = {
    pollId: Scalars['ID'];
    choiceIdx: Scalars['Int'];
};
export declare type MutationCreateAnchorLikeArgs = {
    anchorId: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationUpdateAnchorLikeArgs = {
    id: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationCreateCommentLikeArgs = {
    commentId: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationUpdateCommentLikeArgs = {
    id: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationCreateReplyLikeArgs = {
    replyId: Scalars['ID'];
    data: LikeInput;
};
export declare type MutationUpdateReplyLikeArgs = {
    id: Scalars['ID'];
    data: LikeInput;
};
export declare type Ocard = {
    __typename?: 'Ocard';
    id: Scalars['ID'];
    template: CardTemplate;
    symbol: Symbol;
    oauthorName: Scalars['String'];
    body: CardBody;
};
export declare type Poll = {
    __typename?: 'Poll';
    id: Scalars['ID'];
    commentId: Scalars['Int'];
    choices: Array<Scalars['String']>;
    count: PollCount;
    createdAt: Scalars['DateTime'];
};
export declare enum PollCat {
    Fixed = "FIXED",
    Add = "ADD",
    AddByPost = "ADD_BY_POST"
}
export declare type PollCount = {
    __typename?: 'PollCount';
    id: Scalars['ID'];
    nVotes: Array<Scalars['Int']>;
};
export declare type PollInput = {
    choices: Array<Scalars['String']>;
};
export declare type PollJudgment = {
    __typename?: 'PollJudgment';
    id: Scalars['ID'];
    pollId: Scalars['Int'];
    choice: Scalars['Int'];
    comment: Comment;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type PollJudgmentInput = {
    choice: Scalars['Int'];
};
export declare type PollLike = {
    __typename?: 'PollLike';
    id: Scalars['ID'];
    pollId: Scalars['Int'];
    choice: LikeChoice;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type PollLikeResonse = {
    __typename?: 'PollLikeResonse';
    like: PollLike;
    count: PollCount;
};
export declare enum PollStatus {
    Open = "OPEN",
    Judge = "JUDGE",
    CloseSuccess = "CLOSE_SUCCESS",
    CloseFail = "CLOSE_FAIL"
}
export declare enum PostCat {
    Link = "LINK",
    Reply = "REPLY"
}
export declare enum PostStatus {
    Active = "ACTIVE",
    Lock = "LOCK",
    Deleted = "DELETED",
    Reported = "REPORTED",
    Archived = "ARCHIVED"
}
export declare type Query = {
    __typename?: 'Query';
    searchAll: Array<Scalars['String']>;
    searchTopic: Array<Scalars['String']>;
    latestCards: Array<Cocard>;
    link?: Maybe<Link>;
    cocard: Cocard;
    ocard?: Maybe<Ocard>;
    selfcard?: Maybe<Selfcard>;
    mycard?: Maybe<Selfcard>;
    anchor?: Maybe<Anchor>;
    comment?: Maybe<Comment>;
    replies: Array<Reply>;
    me: User;
    myVotes: Array<Vote>;
    myAnchorLikes: Array<AnchorLike>;
    myCommentLikes: Array<CommentLike>;
    myReplyLikes: Array<ReplyLike>;
};
export declare type QuerySearchAllArgs = {
    term: Scalars['String'];
};
export declare type QuerySearchTopicArgs = {
    term: Scalars['String'];
};
export declare type QueryLatestCardsArgs = {
    afterId?: Maybe<Scalars['String']>;
};
export declare type QueryLinkArgs = {
    url: Scalars['String'];
};
export declare type QueryCocardArgs = {
    url?: Maybe<Scalars['String']>;
    symbol?: Maybe<Scalars['String']>;
};
export declare type QueryOcardArgs = {
    id?: Maybe<Scalars['ID']>;
    oauthorName?: Maybe<Scalars['String']>;
    symbolName?: Maybe<Scalars['String']>;
};
export declare type QuerySelfcardArgs = {
    id: Scalars['ID'];
};
export declare type QueryMycardArgs = {
    symbolName: Scalars['String'];
};
export declare type QueryAnchorArgs = {
    id: Scalars['ID'];
};
export declare type QueryCommentArgs = {
    id: Scalars['ID'];
};
export declare type QueryRepliesArgs = {
    commentId: Scalars['ID'];
    afterId?: Maybe<Scalars['ID']>;
};
export declare type QueryMyVotesArgs = {
    after?: Maybe<Scalars['String']>;
};
export declare type QueryMyAnchorLikesArgs = {
    after?: Maybe<Scalars['String']>;
};
export declare type QueryMyCommentLikesArgs = {
    after?: Maybe<Scalars['String']>;
};
export declare type QueryMyReplyLikesArgs = {
    after?: Maybe<Scalars['String']>;
};
export declare type Reply = {
    __typename?: 'Reply';
    id: Scalars['ID'];
    userId: Scalars['String'];
    isTop?: Maybe<Scalars['Boolean']>;
    text: Scalars['String'];
    count: ReplyCount;
    updatedAt: Scalars['DateTime'];
    props?: Maybe<ReplyProps>;
};
export declare type ReplyCount = {
    __typename?: 'ReplyCount';
    id: Scalars['ID'];
    nViews: Scalars['Int'];
    nUps: Scalars['Int'];
    nDowns: Scalars['Int'];
};
export declare type ReplyInput = {
    text: Scalars['String'];
};
export declare type ReplyLike = {
    __typename?: 'ReplyLike';
    id: Scalars['ID'];
    replyId: Scalars['Int'];
    choice: LikeChoice;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type ReplyLikeResonse = {
    __typename?: 'ReplyLikeResonse';
    like: ReplyLike;
    count: ReplyCount;
};
export declare type ReplyProps = {
    __typename?: 'ReplyProps';
    label?: Maybe<Scalars['String']>;
    disableUpndown?: Maybe<Scalars['Boolean']>;
};
export declare type Selfcard = {
    __typename?: 'Selfcard';
    id: Scalars['ID'];
    template: CardTemplate;
    symbol: Symbol;
    body: CardBody;
};
export declare type Symbol = {
    __typename?: 'Symbol';
    id: Scalars['ID'];
    name: Scalars['String'];
    cat: SymbolCat;
    status: SymbolStatus;
    body?: Maybe<Scalars['String']>;
    sys?: Maybe<Scalars['String']>;
    ticks: Array<Tick>;
};
export declare enum SymbolCat {
    Ticker = "TICKER",
    Topic = "TOPIC"
}
export declare enum SymbolStatus {
    Active = "ACTIVE",
    Reported = "REPORTED",
    Archived = "ARCHIVED",
    Duplicated = "DUPLICATED"
}
export declare type Tick = {
    __typename?: 'Tick';
    id: Scalars['ID'];
    symbolId: Scalars['Int'];
    value: Scalars['Float'];
    at: Scalars['DateTime'];
};
export declare type User = {
    __typename?: 'User';
    id: Scalars['ID'];
    email: Scalars['String'];
};
export declare type Vote = {
    __typename?: 'Vote';
    id: Scalars['ID'];
    pollId: Scalars['Int'];
    choiceIdx: Scalars['Int'];
};
export declare type VoteInput = {
    choiceId: Scalars['ID'];
};
export declare type ResolverTypeWrapper<T> = Promise<T> | T;
export declare type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export declare type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
    selectionSet: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export declare type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export declare type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | StitchingResolver<TResult, TParent, TContext, TArgs>;
export declare type ResolverFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult;
export declare type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;
export declare type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<{
        [key in TKey]: TResult;
    }, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, {
        [key in TKey]: TResult;
    }, TContext, TArgs>;
}
export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}
export declare type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> = SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs> | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;
export declare type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> = ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>) | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;
export declare type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (parent: TParent, context: TContext, info: GraphQLResolveInfo) => Maybe<TTypes> | Promise<Maybe<TTypes>>;
export declare type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;
export declare type NextResolverFn<T> = () => Promise<T>;
export declare type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (next: NextResolverFn<TResult>, parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
/** Mapping between all available schema types and the resolvers types */
export declare type ResolversTypes = {
    Anchor: ResolverTypeWrapper<Anchor>;
    ID: ResolverTypeWrapper<Scalars['ID']>;
    String: ResolverTypeWrapper<Scalars['String']>;
    Int: ResolverTypeWrapper<Scalars['Int']>;
    AnchorCount: ResolverTypeWrapper<AnchorCount>;
    AnchorLike: ResolverTypeWrapper<AnchorLike>;
    AnchorLikeResonse: ResolverTypeWrapper<AnchorLikeResonse>;
    AuthPayload: ResolverTypeWrapper<AuthPayload>;
    CardBody: ResolverTypeWrapper<CardBody>;
    CardBodyInput: CardBodyInput;
    CardIdInput: CardIdInput;
    CardIdentifierInput: CardIdentifierInput;
    CardTemplate: CardTemplate;
    Cocard: ResolverTypeWrapper<Cocard>;
    Comment: ResolverTypeWrapper<Comment>;
    Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
    CommentCat: CommentCat;
    CommentCount: ResolverTypeWrapper<CommentCount>;
    CommentInput: CommentInput;
    CommentLike: ResolverTypeWrapper<CommentLike>;
    CommentLikeResonse: ResolverTypeWrapper<CommentLikeResonse>;
    CommentProps: ResolverTypeWrapper<CommentProps>;
    CommentStatus: CommentStatus;
    CommitAction: CommitAction;
    CommitStatus: CommitStatus;
    DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
    Follow: ResolverTypeWrapper<Follow>;
    FollowInput: FollowInput;
    JSON: ResolverTypeWrapper<Scalars['JSON']>;
    LikeChoice: LikeChoice;
    LikeInput: LikeInput;
    Linemeta: ResolverTypeWrapper<Linemeta>;
    LinemetaInput: LinemetaInput;
    Link: ResolverTypeWrapper<Link>;
    MarkerInput: MarkerInput;
    Mutation: ResolverTypeWrapper<{}>;
    Ocard: ResolverTypeWrapper<Ocard>;
    Poll: ResolverTypeWrapper<Poll>;
    PollCat: PollCat;
    PollCount: ResolverTypeWrapper<PollCount>;
    PollInput: PollInput;
    PollJudgment: ResolverTypeWrapper<PollJudgment>;
    PollJudgmentInput: PollJudgmentInput;
    PollLike: ResolverTypeWrapper<PollLike>;
    PollLikeResonse: ResolverTypeWrapper<PollLikeResonse>;
    PollStatus: PollStatus;
    PostCat: PostCat;
    PostStatus: PostStatus;
    Query: ResolverTypeWrapper<{}>;
    Reply: ResolverTypeWrapper<Reply>;
    ReplyCount: ResolverTypeWrapper<ReplyCount>;
    ReplyInput: ReplyInput;
    ReplyLike: ResolverTypeWrapper<ReplyLike>;
    ReplyLikeResonse: ResolverTypeWrapper<ReplyLikeResonse>;
    ReplyProps: ResolverTypeWrapper<ReplyProps>;
    Selfcard: ResolverTypeWrapper<Selfcard>;
    Symbol: ResolverTypeWrapper<Symbol>;
    SymbolCat: SymbolCat;
    SymbolStatus: SymbolStatus;
    Tick: ResolverTypeWrapper<Tick>;
    Float: ResolverTypeWrapper<Scalars['Float']>;
    User: ResolverTypeWrapper<User>;
    Vote: ResolverTypeWrapper<Vote>;
    VoteInput: VoteInput;
};
/** Mapping between all available schema types and the resolvers parents */
export declare type ResolversParentTypes = {
    Anchor: Anchor;
    ID: Scalars['ID'];
    String: Scalars['String'];
    Int: Scalars['Int'];
    AnchorCount: AnchorCount;
    AnchorLike: AnchorLike;
    AnchorLikeResonse: AnchorLikeResonse;
    AuthPayload: AuthPayload;
    CardBody: CardBody;
    CardBodyInput: CardBodyInput;
    CardIdInput: CardIdInput;
    CardIdentifierInput: CardIdentifierInput;
    Cocard: Cocard;
    Comment: Comment;
    Boolean: Scalars['Boolean'];
    CommentCount: CommentCount;
    CommentInput: CommentInput;
    CommentLike: CommentLike;
    CommentLikeResonse: CommentLikeResonse;
    CommentProps: CommentProps;
    DateTime: Scalars['DateTime'];
    Follow: Follow;
    FollowInput: FollowInput;
    JSON: Scalars['JSON'];
    LikeInput: LikeInput;
    Linemeta: Linemeta;
    LinemetaInput: LinemetaInput;
    Link: Link;
    MarkerInput: MarkerInput;
    Mutation: {};
    Ocard: Ocard;
    Poll: Poll;
    PollCount: PollCount;
    PollInput: PollInput;
    PollJudgment: PollJudgment;
    PollJudgmentInput: PollJudgmentInput;
    PollLike: PollLike;
    PollLikeResonse: PollLikeResonse;
    Query: {};
    Reply: Reply;
    ReplyCount: ReplyCount;
    ReplyInput: ReplyInput;
    ReplyLike: ReplyLike;
    ReplyLikeResonse: ReplyLikeResonse;
    ReplyProps: ReplyProps;
    Selfcard: Selfcard;
    Symbol: Symbol;
    Tick: Tick;
    Float: Scalars['Float'];
    User: User;
    Vote: Vote;
    VoteInput: VoteInput;
};
export declare type AnchorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Anchor'] = ResolversParentTypes['Anchor']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    count?: Resolver<ResolversTypes['AnchorCount'], ParentType, ContextType>;
    cocardId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    ocardId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    selfcardId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type AnchorCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnchorCount'] = ResolversParentTypes['AnchorCount']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    nViews?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    nUps?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    nDowns?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type AnchorLikeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnchorLike'] = ResolversParentTypes['AnchorLike']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    anchorId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    choice?: Resolver<ResolversTypes['LikeChoice'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type AnchorLikeResonseResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnchorLikeResonse'] = ResolversParentTypes['AnchorLikeResonse']> = {
    like?: Resolver<ResolversTypes['AnchorLike'], ParentType, ContextType>;
    count?: Resolver<ResolversTypes['AnchorCount'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type AuthPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthPayload'] = ResolversParentTypes['AuthPayload']> = {
    token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type CardBodyResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardBody'] = ResolversParentTypes['CardBody']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    meta?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
    text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    prevId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type CocardResolvers<ContextType = any, ParentType extends ResolversParentTypes['Cocard'] = ResolversParentTypes['Cocard']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    template?: Resolver<ResolversTypes['CardTemplate'], ParentType, ContextType>;
    meta?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
    link?: Resolver<ResolversTypes['Link'], ParentType, ContextType>;
    body?: Resolver<Maybe<ResolversTypes['CardBody']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type CommentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Comment'] = ResolversParentTypes['Comment']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    symbols?: Resolver<Maybe<Array<ResolversTypes['Symbol']>>, ParentType, ContextType>;
    isTop?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    count?: Resolver<ResolversTypes['CommentCount'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    poll?: Resolver<Maybe<ResolversTypes['Poll']>, ParentType, ContextType>;
    meta?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
    cocardId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    ocardId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    selfcardId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type CommentCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommentCount'] = ResolversParentTypes['CommentCount']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    nViews?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    nUps?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    nDowns?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type CommentLikeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommentLike'] = ResolversParentTypes['CommentLike']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    commentId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    choice?: Resolver<ResolversTypes['LikeChoice'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type CommentLikeResonseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommentLikeResonse'] = ResolversParentTypes['CommentLikeResonse']> = {
    like?: Resolver<ResolversTypes['CommentLike'], ParentType, ContextType>;
    count?: Resolver<ResolversTypes['CommentCount'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type CommentPropsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommentProps'] = ResolversParentTypes['CommentProps']> = {
    validator?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    showAs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    showReplyDir?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    disableReply?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    name: 'DateTime';
}
export declare type FollowResolvers<ContextType = any, ParentType extends ResolversParentTypes['Follow'] = ResolversParentTypes['Follow']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    symbolId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    followed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}
export declare type LinemetaResolvers<ContextType = any, ParentType extends ResolversParentTypes['Linemeta'] = ResolversParentTypes['Linemeta']> = {
    linenumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    anchorId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    stampId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    src?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    reply?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    poll?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    broken?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    nested?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    pollId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    commentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type LinkResolvers<ContextType = any, ParentType extends ResolversParentTypes['Link'] = ResolversParentTypes['Link']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    domain?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    srcType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    srcId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    oauthorName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
    createWebCardBody?: Resolver<ResolversTypes['CardBody'], ParentType, ContextType, RequireFields<MutationCreateWebCardBodyArgs, 'cardId' | 'data'>>;
    createReply?: Resolver<ResolversTypes['Reply'], ParentType, ContextType, RequireFields<MutationCreateReplyArgs, 'commentId' | 'data'>>;
    createVote?: Resolver<ResolversTypes['Vote'], ParentType, ContextType, RequireFields<MutationCreateVoteArgs, 'pollId' | 'choiceIdx'>>;
    createAnchorLike?: Resolver<ResolversTypes['AnchorLikeResonse'], ParentType, ContextType, RequireFields<MutationCreateAnchorLikeArgs, 'anchorId' | 'data'>>;
    updateAnchorLike?: Resolver<ResolversTypes['AnchorLikeResonse'], ParentType, ContextType, RequireFields<MutationUpdateAnchorLikeArgs, 'id' | 'data'>>;
    createCommentLike?: Resolver<ResolversTypes['CommentLikeResonse'], ParentType, ContextType, RequireFields<MutationCreateCommentLikeArgs, 'commentId' | 'data'>>;
    updateCommentLike?: Resolver<ResolversTypes['CommentLikeResonse'], ParentType, ContextType, RequireFields<MutationUpdateCommentLikeArgs, 'id' | 'data'>>;
    createReplyLike?: Resolver<ResolversTypes['ReplyLikeResonse'], ParentType, ContextType, RequireFields<MutationCreateReplyLikeArgs, 'replyId' | 'data'>>;
    updateReplyLike?: Resolver<ResolversTypes['ReplyLikeResonse'], ParentType, ContextType, RequireFields<MutationUpdateReplyLikeArgs, 'id' | 'data'>>;
};
export declare type OcardResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ocard'] = ResolversParentTypes['Ocard']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    template?: Resolver<ResolversTypes['CardTemplate'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['Symbol'], ParentType, ContextType>;
    oauthorName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    body?: Resolver<ResolversTypes['CardBody'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type PollResolvers<ContextType = any, ParentType extends ResolversParentTypes['Poll'] = ResolversParentTypes['Poll']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    commentId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    choices?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    count?: Resolver<ResolversTypes['PollCount'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type PollCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['PollCount'] = ResolversParentTypes['PollCount']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    nVotes?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type PollJudgmentResolvers<ContextType = any, ParentType extends ResolversParentTypes['PollJudgment'] = ResolversParentTypes['PollJudgment']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    pollId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    choice?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    comment?: Resolver<ResolversTypes['Comment'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type PollLikeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PollLike'] = ResolversParentTypes['PollLike']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    pollId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    choice?: Resolver<ResolversTypes['LikeChoice'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type PollLikeResonseResolvers<ContextType = any, ParentType extends ResolversParentTypes['PollLikeResonse'] = ResolversParentTypes['PollLikeResonse']> = {
    like?: Resolver<ResolversTypes['PollLike'], ParentType, ContextType>;
    count?: Resolver<ResolversTypes['PollCount'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
    searchAll?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QuerySearchAllArgs, 'term'>>;
    searchTopic?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QuerySearchTopicArgs, 'term'>>;
    latestCards?: Resolver<Array<ResolversTypes['Cocard']>, ParentType, ContextType, RequireFields<QueryLatestCardsArgs, never>>;
    link?: Resolver<Maybe<ResolversTypes['Link']>, ParentType, ContextType, RequireFields<QueryLinkArgs, 'url'>>;
    cocard?: Resolver<ResolversTypes['Cocard'], ParentType, ContextType, RequireFields<QueryCocardArgs, never>>;
    ocard?: Resolver<Maybe<ResolversTypes['Ocard']>, ParentType, ContextType, RequireFields<QueryOcardArgs, never>>;
    selfcard?: Resolver<Maybe<ResolversTypes['Selfcard']>, ParentType, ContextType, RequireFields<QuerySelfcardArgs, 'id'>>;
    mycard?: Resolver<Maybe<ResolversTypes['Selfcard']>, ParentType, ContextType, RequireFields<QueryMycardArgs, 'symbolName'>>;
    anchor?: Resolver<Maybe<ResolversTypes['Anchor']>, ParentType, ContextType, RequireFields<QueryAnchorArgs, 'id'>>;
    comment?: Resolver<Maybe<ResolversTypes['Comment']>, ParentType, ContextType, RequireFields<QueryCommentArgs, 'id'>>;
    replies?: Resolver<Array<ResolversTypes['Reply']>, ParentType, ContextType, RequireFields<QueryRepliesArgs, 'commentId'>>;
    me?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    myVotes?: Resolver<Array<ResolversTypes['Vote']>, ParentType, ContextType, RequireFields<QueryMyVotesArgs, never>>;
    myAnchorLikes?: Resolver<Array<ResolversTypes['AnchorLike']>, ParentType, ContextType, RequireFields<QueryMyAnchorLikesArgs, never>>;
    myCommentLikes?: Resolver<Array<ResolversTypes['CommentLike']>, ParentType, ContextType, RequireFields<QueryMyCommentLikesArgs, never>>;
    myReplyLikes?: Resolver<Array<ResolversTypes['ReplyLike']>, ParentType, ContextType, RequireFields<QueryMyReplyLikesArgs, never>>;
};
export declare type ReplyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Reply'] = ResolversParentTypes['Reply']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    isTop?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    count?: Resolver<ResolversTypes['ReplyCount'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    props?: Resolver<Maybe<ResolversTypes['ReplyProps']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type ReplyCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReplyCount'] = ResolversParentTypes['ReplyCount']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    nViews?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    nUps?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    nDowns?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type ReplyLikeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReplyLike'] = ResolversParentTypes['ReplyLike']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    replyId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    choice?: Resolver<ResolversTypes['LikeChoice'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type ReplyLikeResonseResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReplyLikeResonse'] = ResolversParentTypes['ReplyLikeResonse']> = {
    like?: Resolver<ResolversTypes['ReplyLike'], ParentType, ContextType>;
    count?: Resolver<ResolversTypes['ReplyCount'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type ReplyPropsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReplyProps'] = ResolversParentTypes['ReplyProps']> = {
    label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    disableUpndown?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type SelfcardResolvers<ContextType = any, ParentType extends ResolversParentTypes['Selfcard'] = ResolversParentTypes['Selfcard']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    template?: Resolver<ResolversTypes['CardTemplate'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['Symbol'], ParentType, ContextType>;
    body?: Resolver<ResolversTypes['CardBody'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type SymbolResolvers<ContextType = any, ParentType extends ResolversParentTypes['Symbol'] = ResolversParentTypes['Symbol']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    cat?: Resolver<ResolversTypes['SymbolCat'], ParentType, ContextType>;
    status?: Resolver<ResolversTypes['SymbolStatus'], ParentType, ContextType>;
    body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    sys?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    ticks?: Resolver<Array<ResolversTypes['Tick']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type TickResolvers<ContextType = any, ParentType extends ResolversParentTypes['Tick'] = ResolversParentTypes['Tick']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    symbolId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    value?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type VoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['Vote'] = ResolversParentTypes['Vote']> = {
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    pollId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    choiceIdx?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};
export declare type Resolvers<ContextType = any> = {
    Anchor?: AnchorResolvers<ContextType>;
    AnchorCount?: AnchorCountResolvers<ContextType>;
    AnchorLike?: AnchorLikeResolvers<ContextType>;
    AnchorLikeResonse?: AnchorLikeResonseResolvers<ContextType>;
    AuthPayload?: AuthPayloadResolvers<ContextType>;
    CardBody?: CardBodyResolvers<ContextType>;
    Cocard?: CocardResolvers<ContextType>;
    Comment?: CommentResolvers<ContextType>;
    CommentCount?: CommentCountResolvers<ContextType>;
    CommentLike?: CommentLikeResolvers<ContextType>;
    CommentLikeResonse?: CommentLikeResonseResolvers<ContextType>;
    CommentProps?: CommentPropsResolvers<ContextType>;
    DateTime?: GraphQLScalarType;
    Follow?: FollowResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    Linemeta?: LinemetaResolvers<ContextType>;
    Link?: LinkResolvers<ContextType>;
    Mutation?: MutationResolvers<ContextType>;
    Ocard?: OcardResolvers<ContextType>;
    Poll?: PollResolvers<ContextType>;
    PollCount?: PollCountResolvers<ContextType>;
    PollJudgment?: PollJudgmentResolvers<ContextType>;
    PollLike?: PollLikeResolvers<ContextType>;
    PollLikeResonse?: PollLikeResonseResolvers<ContextType>;
    Query?: QueryResolvers<ContextType>;
    Reply?: ReplyResolvers<ContextType>;
    ReplyCount?: ReplyCountResolvers<ContextType>;
    ReplyLike?: ReplyLikeResolvers<ContextType>;
    ReplyLikeResonse?: ReplyLikeResonseResolvers<ContextType>;
    ReplyProps?: ReplyPropsResolvers<ContextType>;
    Selfcard?: SelfcardResolvers<ContextType>;
    Symbol?: SymbolResolvers<ContextType>;
    Tick?: TickResolvers<ContextType>;
    User?: UserResolvers<ContextType>;
    Vote?: VoteResolvers<ContextType>;
};
/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export declare type IResolvers<ContextType = any> = Resolvers<ContextType>;

 
// This is an extra code in addition to what graphql-codegen makes.
// Users are likely to use 'graphql-tag/loader' with 'graphql-tag/schema/loader'
// in webpack. This code enables the result to be typed.
import { DocumentNode } from 'graphql'
export default DocumentNode
